{
    "paper_title": "s1: Simple test-time scaling",
    "authors": [
        "Niklas Muennighoff",
        "Zitong Yang",
        "Weijia Shi",
        "Xiang Lisa Li",
        "Li Fei-Fei",
        "Hannaneh Hajishirzi",
        "Luke Zettlemoyer",
        "Percy Liang",
        "Emmanuel CandÃ¨s",
        "Tatsunori Hashimoto"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Test-time scaling is a promising new approach to language modeling that uses extra test-time compute to improve performance. Recently, OpenAI's o1 model showed this capability but did not publicly share its methodology, leading to many replication efforts. We seek the simplest approach to achieve test-time scaling and strong reasoning performance. First, we curate a small dataset s1K of 1,000 questions paired with reasoning traces relying on three criteria we validate through ablations: difficulty, diversity, and quality. Second, we develop budget forcing to control test-time compute by forcefully terminating the model's thinking process or lengthening it by appending \"Wait\" multiple times to the model's generation when it tries to end. This can lead the model to double-check its answer, often fixing incorrect reasoning steps. After supervised finetuning the Qwen2.5-32B-Instruct language model on s1K and equipping it with budget forcing, our model s1 exceeds o1-preview on competition math questions by up to 27% (MATH and AIME24). Further, scaling s1 with budget forcing allows extrapolating beyond its performance without test-time intervention: from 50% to 57% on AIME24. Our model, data, and code are open-source at https://github.com/simplescaling/s1."
        },
        {
            "title": "Start",
            "content": "s1: Simple test-time scaling Niklas Muennighoff * 1 3 4 Zitong Yang * 1 Weijia Shi * 2 Xiang Lisa Li * 1 Li Fei-Fei 1 Hannaneh Hajishirzi 2 3 Luke Zettlemoyer 2 Percy Liang 1 Emmanuel CandÃ¨s 1 Tatsunori Hashimoto 1 5 2 0 2 1 3 ] . [ 1 3 9 3 9 1 . 1 0 5 2 : r Abstract Test-time scaling is promising new approach to language modeling that uses extra test-time compute to improve performance. Recently, OpenAIs o1 model showed this capability but did not publicly share its methodology, leading to many replication efforts. We seek the simplest approach to achieve test-time scaling and strong reasoning performance. First, we curate small dataset s1K of 1,000 questions paired with reasoning traces relying on three criteria we validate through ablations: difficulty, diversity, and quality. Second, we develop budget forcing to control test-time compute by forcefully terminating the models thinking process or lengthening it by appending Wait multiple times to the models generation when it tries to end. This can lead the model to doublecheck its answer, often fixing incorrect reasoning steps. After supervised finetuning the Qwen2.532B-Instruct language model on s1K and equipping it with budget forcing, our model s1-32B exceeds o1-preview on competition math questions by up to 27% (MATH and AIME24). Further, scaling s1-32B with budget forcing allows extrapolating beyond its performance without test-time intervention: from 50% to 57% on AIME24. Our model, data, and code are open-source at https: //github.com/simplescaling/s1. 1. Introduction Performance improvements of language models (LMs) over the past years have largely relied on scaling up train-time compute using large-scale self-supervised pretraining (Kaplan et al., 2020; Hoffmann et al., 2022). The creation of these powerful models has set the stage for new scaling paradigm built on top of them: test-time scaling. The aim *Equal contribution. ZY and NM started the project. WS, NM and ZY collected the prompts, XL, ZY and NM, built the data pipeline, LZ and WS proposed using 1K subset and ZY and NM built budget forcing. 1 Stanford University. 2 University of Washington, Seattle. 3 Allen Institute for AI. 4 Contextual AI. Figure 1. Test-time scaling with s1-32B. We benchmark s1-32B on reasoning-intensive tasks and vary test-time compute. of this approach is to increase the compute at test time to get better results. There has been much work exploring this idea (Snell et al., 2024; Wu et al., 2024b; Welleck et al., 2024), and the viability of this paradigm was recently validated by OpenAI o1 (OpenAI, 2024). o1 has demonstrated strong reasoning performance with consistent gains from scaling test-time compute. OpenAI describes their approach as using large-scale reinforcement learning (RL) implying the use of sizable amounts of data (OpenAI, 2024). This has led to various attempts to replicate their models relying on techniques like Monte Carlo Tree Search (Gao et al., 2024b; Zhang et al., 2024a), multi-agent approaches (Huang et al., 2024b), and others (Huang et al., 2024b; Gao et al., 2024b; Zhang et al., 2024a; Wang et al., 2024a). Among these approaches, DeepSeek R1 (DeepSeek-AI et al., 2025) has successfully replicated o1-level performance, also employing reinforcement learning via millions of samples and multiple training stages. However, despite the large number of o1 replication attempts, none have openly replicated clear test-time scaling behavior. Thus, we ask: what is the simplest approach to achieve both test-time scaling and strong reasoning performance? We show that training on only 1,000 samples with next-token prediction and controlling thinking duration via simple test-time technique we refer to as budget forcing leads to strong reasoning model that scales in performance with more test-time compute. Specifically, we construct s1K, which consists of 1,000 carefully curated questions paired with reasoning traces and answers distilled from Gemini Thinking Experimental (Google, 2024). We perform super1 s1: Simple test-time scaling vised fine-tuning (SFT) of an off-the-shelf pretrained model on our small dataset requiring just 26 minutes of training on 16 H100 GPUs. After training, we control the amount of test-time compute our model spends using budget forcing: (I) If the model generates more thinking tokens than desired limit, we forcefully end the thinking process by appending an end-of-thinking token delimiter. Ending the thinking this way makes the model transition to generating its answer. (II) If we want the model to spend more test-time compute on problem, we suppress the generation of the end-of-thinking token delimiter and instead append Wait to the models current reasoning trace to encourage more exploration. Equipped with this simple recipe SFT on 1,000 samples and test-time budget forcing our model s132B exhibits test-time scaling (Figure 1). Further, s1-32B is the most sample-efficient reasoning model and outperforms closed-source models like OpenAIs o1-preview (Figure 2). We conduct extensive ablation experiments targeting (a) our selection of 1,000 (1K) reasoning samples and (b) our testtime scaling. For (a), we find that jointly incorporating difficulty, diversity, and quality measures into our selection algorithm is important. Random selection, selecting samples with the longest reasoning traces, or only selecting maximally diverse samples all lead to significantly worse performance (around 30% on AIME24 on average). Training on our full data pool of 59K examples, superset of s1K, does not offer substantial gains over our 1K selection. This highlights the importance of careful data selection and echoes prior findings for instruction tuning (Zhou et al., 2023). For (b), we define desiderata for test-time scaling methods to compare different approaches. Budget forcing leads to the best scaling as it has perfect controllability with clear positive slope leading to strong performance. In summary, our contributions are: We develop simple methods for creating sample-efficient reasoning dataset (2) and test-time scaling (3); Based on these we build s1-32B which is competitive with o1-preview (4); We ablate subtleties of data (5.1) and test-time scaling (5.2). We end with discussion to motivate future work on simple reasoning (6). Our code, model, and data will be open-source. 2. Reasoning data curation to create s1K In this section, we describe our process for creating large dataset first in 2.1 and then filtering it down to s1K in 2.2. 2.1. Initial collection of 59K samples We collect an initial 59,029 questions from 16 diverse sources following three guiding principles. Quality: Datasets should be of high quality; we always inspect samples and ignore datasets with, e.g., poor formatting; Difficulty: Datasets should be challenging and require significant reasoning effort; Diversity: Datasets should stem from different fields to cover different reasoning tasks. We collect datasets of two categories: Curation of existing datasets Our largest source is NuminaMATH (LI et al., 2024) with 30,660 mathematical problems from online websites. We also include historical AIME problems (1983-2021). To enhance diversity, we add OlympicArena (Huang et al., 2024a) with 4,250 questions spanning Astronomy, Biology, Chemistry, Computer Science, Geography, Mathematics, and Physics from various Olympiads. OmniMath (Gao et al., 2024a) adds 4,238 competition-level mathematics problems. We also include 2,385 problems from AGIEval (Zhong et al., 2023), which features questions from standardized tests like SAT and LSAT, covering English, Law, and Logic. We refer to Table 6 in for our other sources. New datasets in quantitative reasoning To complement these existing datasets, we create two original datasets. s1-prob consists of 182 questions from the probability section of Stanford Universitys Statistics Departments PhD Qualifying Exams (https://statistics. stanford.edu), accompanied by handwritten solutions that cover difficult proofs. The probability qualifying exam is held yearly and requires professional-level mathematical problem-solving. s1-teasers comprises 23 challenging brain-teasers commonly used in interview questions for quantitative trading positions. Each sample consists of problem and solution taken from PuzzledQuant (https: //www.puzzledquant.com/). We only take examples with the highest difficulty level (\"Hard\"). For each question, we generate reasoning trace and solution using the Google Gemini Flash Thinking API (Google, 2024) extracting its reasoning trace and response. This yields 59K triplets of question, generated reasoning trace, and generated solution. Examples from our dataset are in C.2. We decontaminate all samples against our evaluation questions (MATH500, GPQA Diamond, AIME24; B.5) using 8-grams and deduplicate the data. 2.2. Final selection of 1K samples We could directly train on our pool of 59K questions, however, our goal is to find the simplest approach with minimal resources. Thus, we go through three stages of filtering to arrive at minimal set of 1,000 samples relying on our three guiding data principles: Quality, Difficulty, and Diversity. Quality We first remove any questions where we ran into any API errors reducing our dataset to 54,116 samples. Next, we filter out low-quality examples by checking if they contain any string patterns with formatting issues, such as ASCII art diagrams, non-existent image references, or inconsistent 2 s1: Simple test-time scaling Figure 2. s1K and s1-32B. (left) s1K is dataset of 1,000 high-quality, diverse, and difficult questions with reasoning traces. (right) s1-32B, 32B parameter model finetuned on s1K is on the sample-efficiency frontier. See Table 1 for details on other models. question numbering reducing our dataset to 51,581 examples. From this pool, we identify 384 samples for our final 1,000 samples from datasets that we perceive as high-quality and not in need of further filtering (see B.4 for details). Difficulty For difficulty, we use two indicators: model performance and reasoning trace length. We evaluate two models on each question: Qwen2.5-7B-Instruct and Qwen2.532B-Instruct (Qwen et al., 2024), with correctness assessed by Claude 3.5 Sonnet comparing each attempt against the reference solution (see B.3 for the grading protocol). We measure the token length of each reasoning trace to indicate problem difficulty using the Qwen2.5 tokenizer. This relies on the assumption that more difficult problems require more thinking tokens. Based on the grading, we remove questions that either Qwen2.5-7B-Instruct or Qwen2.5-32B-Instruct can solve correctly and thus may be too easy. By using two models we reduce the likelihood of an easy sample slipping through our filtering due to rare mistake on an easy question of one of the models. This brings our total samples down to 24,496, setting the stage for the next round of subsampling based on diversity. While filtering with these two models may be optimized for our setup as we will also use Qwen2.5-32B-Instruct as our model to finetune, the idea of model-based filtering generalizes to other setups. Diversity To quantify diversity we classify each question into specific domains using Claude 3.5 Sonnet based on the Mathematics Subject Classification (MSC) system (e.g., geometry, dynamic systems, real analysis, etc.) from the American Mathematical Society.1 The taxonomy focuses 1https://mathscinet.ams.org/mathscinet/ msc/msc2020.html on topics in mathematics but also includes other sciences such as biology, physics, and economics. To select our final examples from the pool of 24,496 questions, we first choose one domain uniformly at random. Then, we sample one problem from this domain according to distribution that favors longer reasoning traces (see B.4 for details) as motivated in Difficulty. We repeat this process until we have 1,000 total samples. This three-stage process yields dataset spanning 50 different domains (see Table 5). In 5.1, we will show that using our three criteria in combination is important, as only relying on quality, diversity, or difficulty in isolation leads to worse datasets. Examples from our dataset are in C.2. 3. Test-time scaling 3.1. Method We classify test-time scaling methods into 1) Sequential, where later computations depend on earlier ones (e.g., long reasoning trace), and 2) Parallel, where computations run independently (e.g., majority voting) (Snell et al., 2024; Brown et al., 2024). We focus on sequential scaling as intuitively we believe it should scale better, since later computations can build on intermediate results, allowing for deeper reasoning and iterative refinement. We propose new sequential scaling methods and ways to benchmark them. Budget forcing We propose simple decoding-time intervention by forcing maximum and/or minimum number of thinking tokens at test time. Specifically, we enforce maximum token count by simply appending the end-of-thinking token delimiter and Final Answer: to early exit the 3 s1: Simple test-time scaling three metrics: Control = 1 ğ‘ ğ•€(ğ‘min ğ‘ ğ‘max) (1) where ğ‘min, ğ‘max refer to pre-specified minimum and maximum amount of test-time compute; in our case thinking tokens. We usually only constrain ğ‘max. As tokens generated correspond to the amount of test-time compute spent, this metric measures the extent to which method allows controllability over the use of that test-time compute. We report it as percentage with 100% being perfect control. Scaling = 1 2 ( ) ğ‘,ğ‘ ğ‘>ğ‘ ğ‘“ (ğ‘) ğ‘“ (ğ‘) ğ‘ ğ‘ (2) Scaling is the average slope of the piece-wise linear function. It must be positive for useful methods and larger is better. Performance = max ğ‘ ğ‘“ (ğ‘) (3) Performance is simply the maximum performance the method achieves on the benchmark. method with monotonically increasing scaling achieves 100% performance on any benchmark in the limit. However, the methods we investigate eventually flatten out or further scaling fails due to control or context window limitations. 4. Results 4.1. Setup Training We perform supervised finetuning on Qwen2.532B-Instruct using s1K to obtain our model s1-32B using basic hyperparameters outlined in C. Finetuning took 26 minutes on 16 NVIDIA H100 GPUs with PyTorch FSDP. Evaluation We select three representative reasoning benchmarks widely used in the field: AIME24 (of America, 2024) consists of 30 problems that were used in the 2024 American Invitational Mathematics Examination (AIME) held from Wednesday, January 31 Thursday, February 1, 2024. AIME tests mathematical problem-solving with arithmetic, algebra, counting, geometry, number theory, probability, and other secondary school math topics. High-scoring high school students in the test are invited to participate in the United States of America Mathematics Olympiad (USAMO). All AIME answers are integers ranging from 000 to 999, inclusive. Some AIME problems rely on figures that we provide to our model using the vector graphics language Asymptote as it cannot take image inputs. MATH500 (Hendrycks et al., 2021) is benchmark of competition math problems of varying difficulty. We evaluate on the same 500 samples selected by OpenAI in prior work (Lightman et al., 2023). GPQA Diamond (Rein et al., 2023) consists of 198 Figure 3. Budget forcing with s1-32B. The model tries to stop after ...is 2., but we suppress the end-of-thinking token delimiter instead appending Wait leading s1-32B to self-correct its answer. thinking stage and make the model provide its current best answer. To enforce minimum, we suppress the generation of the end-of-thinking token delimiter and optionally append the string Wait to the models current reasoning trace to encourage the model to reflect on its current generation. Figure 3 contains an example of how this simple approach can lead the model to arrive at better answer. Baselines We benchmark budget forcing with: (I) Conditional length-control methods, which rely on telling the model in the prompt how long it should generate for. We group them by granularity into (a) Token-conditional control: We specify an upper bound of thinking tokens in the prompt; (b) Step-conditional control: We specify an upper bound of thinking steps, where each step is around 100 tokens; (c) Class-conditional control: We write two generic prompts that tell the model to either think for short or long amount of time (see D.1 for details). (II) Rejection sampling, which samples until generation fits predetermined compute budget. This oracle captures the posterior over responses conditioned on its length. 3.2. Metrics We establish set of desiderata as evaluation metrics to measure test-time scaling across methods. Importantly, we do not only care about the accuracy method can achieve but also its controllability and test-time scaling slope. For each method we consider, we run set of evaluations ğ‘ varying test-time compute on fixed benchmark, e.g. AIME24. This produces piece-wise linear function ğ‘“ with compute as the x-axis measured in thinking tokens and accuracy as the y-axis (see Figure 1, where the rightmost dot for AIME24 corresponds to ğ‘“ (7320) = 57%). We measure 4 s1: Simple test-time scaling (a) Sequential scaling via budget forcing (b) Parallel scaling via majority voting Figure 4. Sequential and parallel test-time scaling. (a): Budget forcing shows clear scaling trends and extrapolates to some extent. For the three rightmost dots, we prevent the model from stopping its thinking 2/4/6 times, each time appending Wait to its current reasoning trace. (b): For Qwen2.5-32B-Instruct we perform 64 evaluations for each sample and visualize the performance when majority voting across 2, 4, 8, 16, 32, and 64 of these. PhD-level science questions from Biology, Chemistry and Physics. Experts with PhDs in the corresponding domains only achieved 69.7% on GPQA Diamond (OpenAI, 2024). When we write GPQA in the context of evaluation in this work, we always refer to the Diamond subset. We build on the lm-evaluation-harness framework (Gao et al., 2021; Biderman et al., 2024). Other models We benchmark s1-32B against: OpenAI o1 series (OpenAI, 2024), which are closed-source models that popularized the idea of test-time scaling; DeepSeek r1 series (Team, 2024a), which are open-weight reasoning models with up to o1-level performance, concurrently released to ours; Qwens QwQ-32B-preview (Team, 2024b), 32B open-weight reasoning model without disclosed methodology; Sky-T1-32B-Preview, which is an open-weight and open reasoning data model distilled from QwQ-32Bpreview; Google Gemini 2.0 Flash Thinking Experimental, the API that we are distilling from. As there are no official evaluation scores, we use the Gemini API to benchmark it ourselves. However, the recitation error associated with the Gemini API makes evaluation challenging.2 We circumvent this, by manually inserting all 30 AIME24 questions in its web interface where the error does not appear. However, we leave out MATH500 (500 questions) and GPQA Diamond (198 questions), thus they are N.A. in Table 1. Our model, s1-32B, is fully open including weights, reasoning data, and code. 2https://github.com/google/ generative-ai-docs/issues/ Table 1. s1-32B is an open and sample-efficient reasoning model. We evaluate s1-32B, Qwen, and Gemini (some entries are unknown (N.A.), see 4). Other results are from the respective reports (Qwen et al., 2024; Team, 2024b; OpenAI, 2024; DeepSeek-AI et al., 2025; Labs, 2025; Team, 2025). # ex. = number examples used for reasoning finetuning; BF = budget forcing. Model # ex. AIME 2024 MATH500 GPQA Diamond o1-preview o1-mini o1 Gemini 2.0 Flash Think. Qwen2.532B-Instruct QwQ-32B r1 r1-distill API only 44.6 70.0 74.4 N.A. N.A. N.A. N.A. 60. Open Weights N.A. N.A. 800K 800K 26.7 50.0 79.8 72.6 85.5 90.0 94. N.A. 84.0 90.6 97.3 94.3 17K 17K Open Weights and Open Data 82.4 93.0 92.6 93.0 43.3 63.3 50.0 56. 1K 1K Sky-T1 Bespoke-32B s1 w/o BF s1-32B 5 73.3 60.0 77.3 N.A. 49.0 65.2 71.5 62.1 56.8 58.1 56.6 59.6 s1: Simple test-time scaling 4.2. Performance Test-time scaling Figure 1 shows the performance of s132B with budget forcing scales with more test-time compute. In Figure 4 (left), we expand the plot from Figure 1 (middle) showing that while we can improve AIME24 performance using our budget forcing technique (3) and more test-time compute it does eventually flatten out at six times. Suppressing the end-of-thinking token delimiter too often can lead the model into repetitive loops instead of continued reasoning. In Figure 4 (right), we show that after training Qwen2.532B-Instruct on our 1,000 samples to produce s1-32B and equipping it with the simple budget forcing technique, it operates in different scaling paradigm. Scaling test-time compute on the base model via majority voting cannot catch up with the performance of s1-32B which validates our intuition from 3 that sequential scaling is more effective than parallel. We provide example generations of s1-32B in Figure 5. Sample-efficiency In Figure 2 (right) and Table 1 we compare s1-32B with other models. We find that s132B is the most sample-efficient open data reasoning model. It performs significantly better than our base model (Qwen2.5-32B-Instruct) despite just training it on an additional 1,000 samples. The concurrently released r1-32B shows stronger performance than s1-32B while also only using SFT (DeepSeek-AI et al., 2025). However, it is trained on 800 more reasoning samples. It is an open question whether one can achieve their performance with just 1,000 samples. Finally, our model nearly matches Gemini 2.0 Thinking on AIME24, as s1-32B is distilled from Gemini 2.0, this shows that our distillation procedure was likely effective. 5. Ablations 5.1. Data Quantity, Diversity, and Difficulty Table 2. s1K data ablations. We budget force (BF) maximum of 32,000 thinking tokens for scores in this table. This performs slightly better than the scores without BF  (Table 1)  as it allows the model to finish with best guess when stuck in an infinite loop. We report 95% Wilson confidence intervals with . AIME 2024 GPQA Diamond MATH500 Model 1K-random 36.7 14.8 26.7 12.5 1K-diverse 33.3 14.0 1K-longest 53.3 16.8 59K-full 50.0 16.8 s1K 90.6 2.3 91.2 2.2 90.4 2.3 92.8 2.0 93.0 1.9 52.0 6.9 54.6 6.8 59.6 6.6 58.1 6.9 57.6 6.7 In 2 we outlined our three guiding principles in curating 6 s1K: Quality, Difficulty, and Diversity. Here we test the importance of combining them and the overall efficacy of our selection. Only Quality (1K-random): After obtaining our high-quality reasoning chains from Gemini, we select 1,000 samples at random; not relying on our difficulty and diversity filtering at all. Table 2 shows this approach performs much worse than s1K across all benchmarks. Only Diversity (1K-diverse): For this dataset, we sample uniformly across domains to maximize diversity disregarding any notion of difficulty. This approach also leads to poor performance similar to 1K-random. Only Difficulty (1K-longest): Here we rely on one of our difficulty indicators introduced in 2 by selecting the 1,000 samples with the longest reasoning traces. This approach significantly boosts GPQA performance but overall still falls short of using s1K. Maximize Quantity: Finally, we compare with just training on all of our 59K samples, superset of all the 1K-sample versions. This leads to strong model but uses much more resources. To finetune on 59K samples, we use 394 H100 GPU hours while s1-32B only required 7 H100 GPU hours. Moreover, relying only on s1K is extremely competitive as shown in 2. Overall, combining all three criteria Quality, Difficulty, Diversity via our methodology in 2 is key for sampleefficient reasoning training. 5.2. Test-time scaling methods Table 3. Ablations on methods to scale test-time compute on refers to the number of evaluation runs used to AIME24. estimate the properties; thus higher value indicates more robustness. Bold indicates our chosen method and the best values. BF = budget forcing, TCC/SCC/CCC = token/step/class-conditional control, RS = rejection sampling. Method Control Scaling Performance BF TCC TCC + BF SCC SCC + BF CCC RS 100% 40% 100% 60% 100% 50% 100% 15 -24 13 3 6 25 -35 56.7 40.0 40.0 36.7 36.7 36.7 40. 5 5 5 5 5 2 5 In Table 3 we compare the test-time scalBudget forcing ing methods we have introduced in 3. Overall, we find that budget forcing provides perfect control, good scaling, and leads to our best AIME24 score. Thus, this is the method we use for s1-32B in Figure 1 and in 4. In Table 4, we compare different strings for extrapolating performance. We find that Wait generally gives the best performance. Class-conditional control We provide benchmark scores for this method in D.1 and summarize three findings here: [AIME24] [MATH] [GPQA] s1: Simple test-time scaling Alice and Bob play the following game. stack of ğ‘› tokens lies before them. The players take turns with Alice going first. On each turn, the player removes either 1 token or 4 tokens from the stack. Whoever removes the last token wins. Find the number of positive integers ğ‘› less than or equal to 2024 for which there exists strategy for Bob that guarantees that Bob will win the game regardless of Alices play. The problem asks for the number of positive integers ğ‘› 2024 such that Bob has winning strategy. This is typical impartial game that can be analyzed using the Sprague-Grundy theorem or by directly finding the winning and losing positions. Let ğ‘Š be the set of winning positions (number of tokens ğ‘› such that the player whose turn it is can force win) and ğ¿ be the set of losing positions. [...] Let ğ‘ƒ (ğ‘›) be the statement \"the player whose turn it is when there are ğ‘› tokens has winning strategy. ğ‘ƒ (0) is false (the player whose turn it is and faces 0 tokens has already lost). Consider the small values of ğ‘›: ğ‘› = 1: The player whose turn it is can take 1 token and win. So ğ‘ƒ (1) is true. 1 ğ‘Š . ğ‘› = 2: The player whose turn it is can take 1 token, leaving 1 token for the opponent. Since 1 ğ‘Š , the opponent wins. So ğ‘ƒ (2) is false. 2 ğ¿. ğ‘› = 3: The player whose turn it is can take 1 token, leaving 2 tokens for the opponent. Since 2 ğ¿, the player whose turn it is wins. So ğ‘ƒ (3) is true. 3 ğ‘Š .[...] We are looking for the number of positive integers ğ‘› 2024 for which Bob has winning strategy. This means that if the game starts with ğ‘› tokens, and Alice goes first, Bob can win. This happens if and only if ğ‘› is losing position (because if ğ‘› ğ¿, then Alices first move must lead to winning position for Bob). [...] Lets try to find pattern in the losing positions ğ¿ = {0, 2, 5, 7, 10, 12, 15, 17, 20, 22, ...}. Differences between consecutive terms: 2, 3, 2, 3, 2, 3, 2, 3, 2, ... The pattern of differences is alternating 2, 3. [...] The losing positions are of the form 5ğ‘š or 5ğ‘š + 2, where ğ‘š 0. We need to find the number of positive integers ğ‘› 2024 that are in the set of losing positions ğ¿. [...] Case 1: ğ‘› = 5ğ‘š, where ğ‘š 1. 1 5ğ‘š 2024 15 ğ‘š 20245 = 404.8 Since ğ‘š is an integer, 1 ğ‘š 404. The number of values of ğ‘š is 404. Case 2: ğ‘› = 5ğ‘š + 2, where ğ‘š 0. 5ğ‘š + 2 2024 5ğ‘š 2022 ğ‘š 20225 = 404.4 Since ğ‘š is an integer, 0 ğ‘š 404. The number of values of ğ‘š is 404 0 + 1 = 405. The total number of positive integers ğ‘› 2024 that are losing positions is 404 + 405 = 809 . ) Find the projection of ğ‘ onto ğ‘ = (2 6 3 if ğ‘ ğ‘ = 8. The projection of vector ğš onto vector ğ› is given by the formula: proj ğ›ğš = ğ› ğš ğ› ğ›2 ) (2 6 3 We are given ğ› = and ğš ğ› = 8. First, we need to find the magnitude squared of ğ›, which is 2. ğ› quantum mechanical particle of mass ğ‘š moves in two dimensions in the following potential, as function of the polar coordinates (ğ‘Ÿ, ğœƒ): ğ‘‰ (ğ‘Ÿ, ğœƒ) = ğ‘˜ğ‘Ÿ2 + 1 2 3 2 ğ‘˜ğ‘Ÿ2 cos2(ğœƒ) Find the energy spectrum. Hint: Write the potential in Cartesian coordinates. The problem asks for the energy spectrum of particle in given 2D potential. The potential is given in polar coordinates (ğ‘Ÿ, ğœƒ): ğ‘‰ (ğ‘Ÿ, ğœƒ) = ğ‘˜ğ‘Ÿ2 + 1 2 3 2 ğ‘˜ğ‘Ÿ2 cos2(ğœƒ). ğ› 2 = ğ›ğ› = 22+62+32 = 4+36+9 = 49. We can rewrite the potential as: Now we can plug the values into the projection formula: ğ‘‰ (ğ‘Ÿ, ğœƒ) = 1 2 ğ‘˜ğ‘Ÿ2(1 + 3 cos2(ğœƒ)). proj ğ›ğš = 8 49 ğ› Substitute the vector ğ›: proj ğ›ğš = ) (2 6 3 8 49 Multiply the scalar by each component of the vector: proj ğ›ğš = 8 49 8 49 8 2 6 3 = 16 49 48 49 24 49 Final Answer: The final answer is 16 49 48 49 24 49 The Hamiltonian for particle in 2D is given by: ğ» = ( â„2 2ğ‘š 2 ğ‘¥2 + 2 ğ‘¦ ) + ğ‘‰ (ğ‘¥, ğ‘¦). In polar coordinates (ğ‘Ÿ, ğœƒ), the Laplacian operator is: 2 = ) 1 ğ‘Ÿ ğ‘Ÿ ( ğ‘Ÿ ğ‘Ÿ + 1 ğ‘Ÿ2 2 ğœƒ . So the Hamiltonian in polar coordinates is: ğ» = [ â„2 2ğ‘š ) 1 ğ‘Ÿ ğ‘Ÿ ( ğ‘Ÿ ğ‘Ÿ + 1 ğ‘Ÿ 2 ğœƒ2 ] +ğ‘‰ (ğ‘Ÿ, ğœƒ). The time-independent SchrÃ¶dinger equation is ğ»ğœ“ = ğ¸ğœ“. We can try to separate variables by assuming solution of the form ğœ“(ğ‘Ÿ, ğœƒ) = ğ‘…(ğ‘Ÿ)Î˜(ğœƒ). [...] This confirms the energy spectrum is: ğ¸ = â„ ( 2ğ‘›ğ‘¥ + ğ‘›ğ‘¦ + ğ‘˜ ğ‘š ) . 3 2 Final ğ‘˜ â„ ğ‘š ( Answer: 2ğ‘›ğ‘¥ + ğ‘›ğ‘¦ + 3 2 ) . ğ¸ = Figure 5. Example model outputs. We pick question from AIME24 (left), MATH (middle), and GPQA (right), where our model generates the correct answer. The black text is the prompt, the light blue text is the reasoning trace, and the blue text is the answer of s1-32B. The gray ellipsis [...] indicates that the text was trimmed to fit this page, but the generated text is actually longer. 7 s1: Simple test-time scaling (1) Token-conditional control fails without budget forcing, as our model cannot reliably count tokens - even when trained to do so. (2) Under step-conditional control, the model generates similar total number of tokens when given different step targets, as the model goes from few steps with many tokens per step, to many steps with few tokens in each step. Thus, the model learns to hack its way around the compute constraint making the controllability of this method mediocre. (3) Class-conditional control can work - telling model to simply think longer can increase its test-time compute and performance, which leads good scaling in Table 3. Table 4. Budget forcing extrapolation ablations. We compare ignoring the end-of-thinking delimiter twice and appending none or various strings. Model AIME 2024 MATH -500 GPQA Diamond No extrapolation 2x without string 2x Alternatively 2x Hmm 2x Wait 50.0 50.0 50.0 50.0 53.3 93.0 90.2 92.2 93.0 93.0 57.6 55.1 59.6 59.6 59.6 Rejection sampling Surprisingly, we find that simply sampling until the generation fits specific length leads to an inverse scaling trend as depicted in Figure 6. In D.2 we inspect question, which was answered correctly by the model when rejection sampling for 4000, but not for the 8000 token setting. In the 4000 setting the model directly jumps to the correct approach, while for the 8000 setting it backtracks lot. We hypothesize that there is correlation such that shorter generations tend to be the ones where the model was on the right track from the start, whereas longer ones tend to be ones where the model made mistakes and thus backtracks or questions itself. This leads to longer samples Figure 6. Rejection sampling on AIME24 with s1-32B. We sample with temperature of 1 until all generations have less than (from left to right) 3500, 4000, 5000, 8000, and 16000 thinking tokens requiring an average of 655, 97, 8, 3, 2, and 1 tries per sample. 8 often being wrong when rejection sampling and thus the inverse scaling trend. 6. Discussion and related work 6.1. Sample-efficient reasoning Models There are number of concurrent efforts to build models that replicate the performance of o1 (OpenAI, 2024). For example, DeepSeek-r1 and k1.5 (DeepSeek-AI et al., 2025; Team et al., 2025) are built with reinforcement learning methods, while others rely on SFT using tens of thousands of distilled examples (Team, 2025; Xu et al., 2025; Labs, 2025). We show that SFT on only 1,000 examples suffices to build competitive reasoning model matching o1-preview and produces model that lies on the pareto frontier (Figure 2). Further, we introduce budget forcing which combined with our reasoning model leads to the first reproduction of OpenAIs test-time scaling curves (OpenAI, 2024). Why does supervised finetuning on just 1,000 samples lead to such performance gains? We hypothesize that the model is already exposed to large amounts of reasoning data during pretraining which spans trillions of tokens. Thus, the ability to perform reasoning is already present in our model. Our sample-efficient finetuning stage just activates it and we scale it further at test time with budget forcing. This is similar to the \"Superficial Alignment Hypothesis\" presented in LIMA (Zhou et al., 2023), where the authors find that 1,000 examples can be sufficient to align model to adhere to user preferences. Benchmarks and methods To evaluate and push the limits of these models, increasingly challenging benchmarks have been introduced, such as Olympiad-level science competitions (He et al., 2024a; Jain et al., 2024a; Zhong et al., 2023) and others (Srivastava et al., 2023; Glazer et al., 2024; Su et al., 2024; Kim et al., 2024; Phan et al., 2025). To enhance models performance on reasoning-related tasks, researchers have pursued several strategies: Prior works have explored continuing training language models on specialized corpora related to mathematics and science (Azerbayev et al., 2023; Yang et al., 2024), sometimes even synthetically generated data (Yu et al., 2024). Others have developed training methodologies specifically aimed at reasoning performance (Zelikman et al., 2022; 2024; Luo et al., 2025; Yuan et al., 2025). Another significant line of work focuses on prompting-based methods to elicit and improve reasoning abilities, including methods like Chain-of-Thought prompting (Wei et al., 2023; Yao et al., 2023a;b; Bi et al., 2023; Fu et al., 2023; Zhang et al., 2024b; Hu et al., 2024). These combined efforts aim to advance the reasoning ability of language models, enabling them to handle more complex and abstract tasks effectively. s1: Simple test-time scaling 6.2. Test-time scaling Methods As we introduce in 3, we differentiate two methods to scale test-time compute: parallel and sequential. The former relies on multiple solution attempts generated in parallel and selecting the best outcome via specific criteria. These criteria include choosing the most frequent response for majority voting or the best response based on an external reward for Best-of-N (Brown et al., 2024; Irvine et al., 2023; Snell et al., 2024). Unlike repeated sampling, previous sequential scaling methods let the model generate solution attempts sequentially based on previous attempts, allowing it to refine each attempt based on previous outcomes (Snell et al., 2024; Hou et al., 2025; Lee et al., 2025). Tree-based search methods (Gandhi et al., 2024; Wu et al., 2024a) offer hybrid approach between sequential and parallel scaling, such as Monte-Carlo Tree Search (MCTS) (Liu et al., 2024; Zhang et al., 2023; Zhou et al., 2024; Choi et al., 2023) and guided beam search (Xie et al., 2023). REBASE (Wu et al., 2024a) employs process reward model to balance exploitation and pruning during tree search. Empirically, REBASE has been shown to outperform sampling-based methods and MCTS (Wu et al., 2024a). Reward models (Lightman et al., 2023; Wang et al., 2024b;c) play key role in these methods. They come in two variants: outcome reward models and process reward models. Outcome reward models (Xin et al., 2024; Ankner et al., 2024) assign score to complete solutions and are particularly useful in Best-of-N selection, while process reward models (Lightman et al., 2023; Wang et al., 2024b; Wu et al., 2024a) assess individual reasoning steps and are effective in guiding tree-based search methods. Limits to further test-time scaling We have shown that budget forcing allows extrapolating test-time compute in 4, e.g., improving AIME24 performance from 50% to 57%. However, it has two key limitations when scaling further: it eventually flattens out (Figure 4), and the context window of the underlying language model constrains it. Despite these constraints, our work shows test-time scaling across wide range of accuracies (Figure 1), partly because scaling down test-time compute behaves predictably and does not suffer from these constraints. Continuing test-time scaling will require approaches that can further extrapolate test-time compute. How can we get such extrapolation? There may be improvements to budget forcing such as rotating through different strings, not only Wait, or combining it with frequency penalties or higher temperature to avoid repetitive loops. An exciting direction for future work is also researching whether applying budget forcing to reasoning model trained with reinforcement learning yields better extrapolation; or if RL allows for new ways of test-time scaling beyond budget forcing. Our work defines the right metrics (3.2) Control, Scaling, and Performance to enable future research and progress on Figure 7. Scaling further with parallel scaling methods. All metrics averaged over the 30 questions in AIME24. Average thinking tokens for REBASE do not account for the additional compute from the reward model. For sequential scaling, we prompt the model to use up to (from left to right) 32, 64, 256, and 512 steps. For REBASE and majority voting we generate 16 parallel trajectories to aggregate across. extrapolating test-time compute. Parallel scaling as solution Parallel scaling offers one solution to the limits of sequential scaling, thus we augment our sequentially scaled model with two methods: (I) Majority voting: After generating ğ‘˜ solutions, the final solution is the most frequent one across generations; (II) Tree search via REBASE: We use the REBASE process reward model, which is initialized from LLaMA-34B and further finetuned on synthetic process reward modeling dataset (Wu et al., 2024a). We then aggregate the solutions generated by REBASE via majority voting. As shown in Figure 7, augmenting our model with REBASE scales better than majority voting, and even sequential scaling in this scenario. However, REBASE requires an additional forward pass at each step for the reward model adding some computation overhead. For sequential scaling, when prompted to use up to 512 steps, for 12 out of the 30 evaluation questions the model generates response that exceeds the context window leading to large performance drop. Overall, we find that these parallel scaling methods complement sequential scaling thus they offer an avenue for scaling test-time compute even further; beyond fixed context windows."
        },
        {
            "title": "Impact Statement",
            "content": "Language models with strong reasoning capabilities have the potential to greatly enhance human productivity, from assisting in complex decision-making to driving scientific breakthroughs. However, recent advances in reasoning, such as OpenAIs o1 and DeepSeeks r1, lack transparency, limiting broader research progress. Our work aims to push the frontier of reasoning in fully open manner, fostering innovation and collaboration to accelerate advancements that ultimately benefit society. 9 s1: Simple test-time scaling"
        },
        {
            "title": "Acknowledgements",
            "content": "This work was partly conducted using the Stanford Marlowe GPU cluster (Kapfer et al., 2025) made possible by financial support from Stanford University. We thank Alexander M. Rush, Andrew Ilyas, Banghua Zhu, Chenglei Si, Chunting Zhou, John Yang, Ludwig Schmidt, Samy Jelassi, Tengyu Ma, Xuechen Li, Yu Sun and Yue Zhang for very constructive discussions. References Ankner, Z., Paul, M., Cui, B., Chang, J. D., and Ammanabrolu, P. Critique-out-loud reward models, 2024. URL https://arxiv.org/abs/2408.11791. Arora, D., Singh, H. G., and Mausam. Have llms advanced enough? challenging problem solving benchmark for large language models, 2023. URL https://arxiv. org/abs/2305.15074. Azerbayev, Z., Schoelkopf, H., Paster, K., Santos, M. D., McAleer, S., Jiang, A. Q., Deng, J., Biderman, S., and Welleck, S. Llemma: An open language model for mathematics, 2023. Bi, Z., Zhang, N., Jiang, Y., Deng, S., Zheng, G., and Chen, H. When do program-of-thoughts work for reasoning?, 2023. URL https://arxiv.org/abs/2308. 15452. Biderman, S., Schoelkopf, H., Sutawika, L., Gao, L., Tow, J., Abbasi, B., Aji, A. F., Ammanamanchi, P. S., Black, S., Clive, J., DiPofi, A., Etxaniz, J., Fattori, B., Forde, J. Z., Foster, C., Hsu, J., Jaiswal, M., Lee, W. Y., Li, H., Lovering, C., Muennighoff, N., Pavlick, E., Phang, J., Skowron, A., Tan, S., Tang, X., Wang, K. A., Winata, G. I., Yvon, F., and Zou, A. Lessons from the trenches on reproducible evaluation of language models, 2024. Brown, B., Juravsky, J., Ehrlich, R., Clark, R., Le, Q. V., RÃ©, C., and Mirhoseini, A. Large language monkeys: Scaling inference compute with repeated sampling, 2024. URL https://arxiv.org/abs/2407.21787. Chen, W., Yin, M., Ku, M., Lu, P., Wan, Y., Ma, X., Xu, J., Wang, X., and Xia, T. Theoremqa: theoremdriven question answering dataset, 2023. URL https: //arxiv.org/abs/2305.12524. Choi, S., Fang, T., Wang, Z., and Song, Y. Kcts: Knowledgeconstrained tree search decoding with token-level hallucination detection, 2023. URL https://arxiv.org/ abs/2310.09044. DeepSeek-AI, Guo, D., Yang, D., Zhang, H., Song, J., Zhang, R., Xu, R., Zhu, Q., Ma, S., Wang, P., Bi, X., Zhang, X., Yu, X., Wu, Y., Wu, Z. F., Gou, Z., Shao, Z., Li, Z., Gao, Z., Liu, A., Xue, B., Wang, B., Wu, B., Feng, B., Lu, C., Zhao, C., Deng, C., Zhang, C., Ruan, C., Dai, D., Chen, D., Ji, D., Li, E., Lin, F., Dai, F., Luo, F., Hao, G., Chen, G., Li, G., Zhang, H., Bao, H., Xu, H., Wang, H., Ding, H., Xin, H., Gao, H., Qu, H., Li, H., Guo, J., Li, J., Wang, J., Chen, J., Yuan, J., Qiu, J., Li, J., Cai, J. L., Ni, J., Liang, J., Chen, J., Dong, K., Hu, K., Gao, K., Guan, K., Huang, K., Yu, K., Wang, L., Zhang, L., Zhao, L., Wang, L., Zhang, L., Xu, L., Xia, L., Zhang, M., Zhang, M., Tang, M., Li, M., Wang, M., Li, M., Tian, N., Huang, P., Zhang, P., Wang, Q., Chen, Q., Du, Q., Ge, R., Zhang, R., Pan, R., Wang, R., Chen, R. J., Jin, R. L., Chen, R., Lu, S., Zhou, S., Chen, S., Ye, S., Wang, S., Yu, S., Zhou, S., Pan, S., Li, S. S., Zhou, S., Wu, S., Ye, S., Yun, T., Pei, T., Sun, T., Wang, T., Zeng, W., Zhao, W., Liu, W., Liang, W., Gao, W., Yu, W., Zhang, W., Xiao, W. L., An, W., Liu, X., Wang, X., Chen, X., Nie, X., Cheng, X., Liu, X., Xie, X., Liu, X., Yang, X., Li, X., Su, X., Lin, X., Li, X. Q., Jin, X., Shen, X., Chen, X., Sun, X., Wang, X., Song, X., Zhou, X., Wang, X., Shan, X., Li, Y. K., Wang, Y. Q., Wei, Y. X., Zhang, Y., Xu, Y., Li, Y., Zhao, Y., Sun, Y., Wang, Y., Yu, Y., Zhang, Y., Shi, Y., Xiong, Y., He, Y., Piao, Y., Wang, Y., Tan, Y., Ma, Y., Liu, Y., Guo, Y., Ou, Y., Wang, Y., Gong, Y., Zou, Y., He, Y., Xiong, Y., Luo, Y., You, Y., Liu, Y., Zhou, Y., Zhu, Y. X., Xu, Y., Huang, Y., Li, Y., Zheng, Y., Zhu, Y., Ma, Y., Tang, Y., Zha, Y., Yan, Y., Ren, Z. Z., Ren, Z., Sha, Z., Fu, Z., Xu, Z., Xie, Z., Zhang, Z., Hao, Z., Ma, Z., Yan, Z., Wu, Z., Gu, Z., Zhu, Z., Liu, Z., Li, Z., Xie, Z., Song, Z., Pan, Z., Huang, Z., Xu, Z., Zhang, Z., and Zhang, Z. Deepseek-r1: Incentivizing reasoning capability in llms via reinforcement learning, 2025. URL https://arxiv.org/abs/2501.12948. Fu, Y., Peng, H., Sabharwal, A., Clark, P., and Khot, T. Complexity-based prompting for multi-step reasoning, 2023. URL https://arxiv.org/abs/2210. 00720. Gandhi, K., Lee, D., Grand, G., Liu, M., Cheng, W., Sharma, A., and Goodman, N. D. Stream of search (sos): Learning to search in language, 2024. URL https://arxiv. org/abs/2404.03683. Gao, B., Song, F., Yang, Z., Cai, Z., Miao, Y., Dong, Q., Li, L., Ma, C., Chen, L., Xu, R., Tang, Z., Wang, B., Zan, D., Quan, S., Zhang, G., Sha, L., Zhang, Y., Ren, X., Liu, T., and Chang, B. Omni-math: universal olympiad level mathematic benchmark for large language models, 2024a. URL https://arxiv.org/abs/2410.07985. Gao, L., Tow, J., Biderman, S., Black, S., DiPofi, A., Foster, C., Golding, L., Hsu, J., McDonell, K., Muennighoff, N., Phang, J., Reynolds, L., Tang, E., Thite, A., Wang, B., Wang, K., and Zou, A. framework for few-shot language 10 s1: Simple test-time scaling model evaluation, September 2021. URL https:// doi.org/10.5281/zenodo.5371628. Gao, Z., Niu, B., He, X., Xu, H., Liu, H., Liu, A., Hu, X., and Wen, L. Interpretable contrastive monte carlo tree search reasoning, 2024b. URL https://arxiv.org/abs/ 2410.01707. Glazer, E., Erdil, E., Besiroglu, T., Chicharro, D., Chen, E., Gunning, A., Olsson, C. F., Denain, J.-S., Ho, A., de Oliveira Santos, E., JÃ¤rviniemi, O., Barnett, M., Sandler, R., Vrzala, M., Sevilla, J., Ren, Q., Pratt, E., Levine, L., Barkley, G., Stewart, N., Grechuk, B., Grechuk, T., Enugandla, S. V., and Wildon, M. Frontiermath: benchmark for evaluating advanced mathematical reasoning in ai, 2024. URL https://arxiv.org/abs/2411. 04872. Google. Gemini 2.0 flash thinking mode (gemini-2.0URL flash-thinking-exp-1219), December 2024. https://cloud.google.com/vertex-ai/ generative-ai/docs/thinking-mode. He, C., Luo, R., Bai, Y., Hu, S., Thai, Z. L., Shen, J., Hu, J., Han, X., Huang, Y., Zhang, Y., Liu, J., Qi, L., Liu, Z., and Sun, M. Olympiadbench: challenging benchmark for promoting agi with olympiad-level bilingual multimodal scientific problems, 2024a. URL https://arxiv.org/abs/2402.14008. He, C., Luo, R., Bai, Y., Hu, S., Thai, Z. L., Shen, J., Hu, J., Han, X., Huang, Y., Zhang, Y., Liu, J., Qi, L., Liu, Z., and Sun, M. Olympiadbench: challenging benchmark for promoting agi with olympiad-level bilingual multimodal scientific problems, 2024b. URL https://arxiv. org/abs/2402.14008. Hendrycks, D., Burns, C., Kadavath, S., Arora, A., Basart, S., Tang, E., Song, D., and Steinhardt, J. Measuring mathematical problem solving with the math dataset, 2021. URL https://arxiv.org/abs/2103.03874. Hoffmann, J., Borgeaud, S., Mensch, A., Buchatskaya, E., Cai, T., Rutherford, E., de Las Casas, D., Hendricks, L. A., Welbl, J., Clark, A., Hennigan, T., Noland, E., Millican, K., van den Driessche, G., Damoc, B., Guy, A., Osindero, S., Simonyan, K., Elsen, E., Rae, J. W., Vinyals, O., and Sifre, L. Training compute-optimal large language models, 2022. URL https://arxiv.org/abs/2203. 15556. Hou, Z., Lv, X., Lu, R., Zhang, J., Li, Y., Yao, Z., Li, J., Tang, J., and Dong, Y. Advancing language model reasoning through reinforcement learning and inference scaling, 2025. URL https://arxiv.org/abs/2501. 11651. Hu, Y., Shi, W., Fu, X., Roth, D., Ostendorf, M., Zettlemoyer, L., Smith, N. A., and Krishna, R. Visual sketchpad: Sketching as visual chain of thought for multimodal language models, 2024. URL https://arxiv.org/ abs/2406.09403. Huang, Z., Wang, Z., Xia, S., Li, X., Zou, H., Xu, R., Fan, R.-Z., Ye, L., Chern, E., Ye, Y., Zhang, Y., Yang, Y., Wu, T., Wang, B., Sun, S., Xiao, Y., Li, Y., Zhou, F., Chern, S., Qin, Y., Ma, Y., Su, J., Liu, Y., Zheng, Y., Zhang, S., Lin, D., Qiao, Y., and Liu, P. Olympicarena: Benchmarking multi-discipline cognitive reasoning for superintelligent ai, 2024a. URL https://arxiv.org/abs/2406. 12753. Huang, Z., Zou, H., Li, X., Liu, Y., Zheng, Y., Chern, E., Xia, S., Qin, Y., Yuan, W., and Liu, P. O1 replication journey part 2: Surpassing o1-preview through simple distillation, big progress or bitter lesson?, 2024b. URL https://arxiv.org/abs/2411.16489. Irvine, R., Boubert, D., Raina, V., Liusie, A., Zhu, Z., Mudupalli, V., Korshuk, A., Liu, Z., Cremer, F., Assassi, V., Beauchamp, C.-C., Lu, X., Rialan, T., and Beauchamp, W. Rewarding chatbots for real-world engagement with millions of users, 2023. URL https: //arxiv.org/abs/2303.06135. Jain, N., Han, K., Gu, A., Li, W.-D., Yan, F., Zhang, T., Wang, S., Solar-Lezama, A., Sen, K., and Stoica, I. Livecodebench: Holistic and contamination free evaluation of large language models for code, 2024a. URL https://arxiv.org/abs/2403.07974. Jain, N., Han, K., Gu, A., Li, W.-D., Yan, F., Zhang, T., Wang, S., Solar-Lezama, A., Sen, K., and Stoica, I. Livecodebench: Holistic and contamination free evaluation of large language models for code, 2024b. URL https://arxiv.org/abs/2403.07974. Kapfer, C., Stine, K., Narasimhan, B., Mentzel, C., and Candes, E. Marlowe: Stanfords gpu-based computational instrument, January 2025. URL https://doi.org/ 10.5281/zenodo.14751899. Kaplan, J., McCandlish, S., Henighan, T., Brown, T. B., Chess, B., Child, R., Gray, S., Radford, A., Wu, J., and Amodei, D. Scaling laws for neural language models, 2020. URL https://arxiv.org/abs/2001. 08361. Kim, E., Suk, J., Kim, S., Muennighoff, N., Kim, D., and Oh, A. Llm-as-an-interviewer: Beyond static testing through dynamic llm evaluation, 2024. URL https://arxiv. org/abs/2412.10424. 11 s1: Simple test-time scaling Kwon, W., Li, Z., Zhuang, S., Sheng, Y., Zheng, L., Yu, C. H., Gonzalez, J. E., Zhang, H., and Stoica, I. Efficient memory management for large language model serving with pagedattention, 2023. URL https://arxiv. org/abs/2309.06180. Labs, B. Bespoke-stratos: The unreasonable effectiveness of reasoning distillation, 2025. URL https://hf. co/bespokelabs/Bespoke-Stratos-32B. Accessed: 2025-01-22. Lee, K.-H., Fischer, I., Wu, Y.-H., Marwood, D., Baluja, S., Schuurmans, D., and Chen, X. Evolving deeper llm thinking, 2025. URL https://arxiv.org/abs/ 2501.09891. LI, J., Beeching, E., Tunstall, L., Lipkin, B., Soletskyi, R., Huang, S. C., Rasul, K., Yu, L., Jiang, A., Shen, Z., Qin, Z., Dong, B., Zhou, L., Fleureau, Y., Lample, G., and Polu, S. Numinamath, 2024. URL https://github.com/project-numina/ aimo-progress-prize/blob/main/report/ numina_dataset.pdf. Lightman, H., Kosaraju, V., Burda, Y., Edwards, H., Baker, B., Lee, T., Leike, J., Schulman, J., Sutskever, I., and Cobbe, K. Lets verify step by step, 2023. URL https: //arxiv.org/abs/2305.20050. Ling, W., Yogatama, D., Dyer, C., and Blunsom, P. Program induction by rationale generation : Learning to solve and explain algebraic word problems, 2017. URL https: //arxiv.org/abs/1705.04146. Liu, J., Cui, L., Liu, H., Huang, D., Wang, Y., and Zhang, Y. Logiqa: challenge dataset for machine reading comprehension with logical reasoning, 2020. URL https: //arxiv.org/abs/2007.08124. Liu, J., Cohen, A., Pasunuru, R., Choi, Y., Hajishirzi, H., and Celikyilmaz, A. Dont throw away your value model! generating more preferable text with value-guided monte-carlo tree search decoding, 2024. URL https: //arxiv.org/abs/2309.15028. Loshchilov, I. and Hutter, F. Decoupled weight decay regularization, 2019. Luo, H., Sun, Q., Xu, C., Zhao, P., Lou, J., Tao, C., Geng, X., Lin, Q., Chen, S., Tang, Y., and Zhang, D. Wizardmath: Empowering mathematical reasoning for large language models via reinforced evol-instruct, 2025. URL https: //arxiv.org/abs/2308.09583. of America, M. A. Aime, February 2024. URL https: //artofproblemsolving.com/wiki/index. php/AIME_Problems_and_Solutions/. OpenAI. Learning to reason with llms, September 2024. URL https://openai.com/index/ learning-to-reason-with-llms/. Phan, L., Gatti, A., Han, Z., Li, N., Hu, J., Zhang, H., Shi, S., Choi, M., Agrawal, A., Chopra, A., Khoja, A., Kim, R., Hausenloy, J., Zhang, O., Mazeika, M., Anderson, D., Nguyen, T., Mahmood, M., Feng, F., Feng, S. Y., Zhao, H., Yu, M., Gangal, V., Zou, C., Wang, Z., Wang, J. P., Kumar, P., Pokutnyi, O., Gerbicz, R., Popov, S., Levin, J.-C., Kazakov, M., Schmitt, J., Galgon, G., Sanchez, A., Lee, Y., Yeadon, W., Sauers, S., Roth, M., Agu, C., Riis, S., Giska, F., Utpala, S., Giboney, Z., Goshu, G. M., of Arc Xavier, J., Crowson, S.-J., Naiya, M. M., Burns, N., Finke, L., Cheng, Z., Park, H., Fournier-Facio, F., Wydallis, J., Nandor, M., Singh, A., Gehrunger, T., Cai, J., McCarty, B., Duclosel, D., Nam, J., Zampese, J., Hoerr, R. G., Bacho, A., Loume, G. A., Galal, A., Cao, H., Garretson, A. C., Sileo, D., Ren, Q., Cojoc, D., Arkhipov, P., Qazi, U., Li, L., Motwani, S., de Witt, C. S., Taylor, E., Veith, J., Singer, E., Hartman, T. D., Rissone, P., Jin, J., Shi, J. W. L., Willcocks, C. G., Robinson, J., Mikov, A., Prabhu, A., Tang, L., Alapont, X., Uro, J. L., Zhou, K., de Oliveira Santos, E., Maksimov, A. P., Vendrow, E., Zenitani, K., Guillod, J., Li, Y., Vendrow, J., Kuchkin, V., Ze-An, N., Marion, P., Efremov, D., Lynch, J., Liang, K., Gritsevskiy, A., Martinez, D., Pageler, B., Crispino, N., Zvonkine, D., Fraga, N. W., Soori, S., Press, O., Tang, H., Salazar, J., Green, S. R., BrÃ¼ssel, L., Twayana, M., Dieuleveut, A., Rogers, T. R., Zhang, W., Li, B., Yang, J., Rao, A., Loiseau, G., Kalinin, M., Lukas, M., Manolescu, C., Mishra, S., Kamdoum, A. G. K., Kreiman, T., Hogg, T., Jin, A., Bosio, C., Sun, G., Coppola, B. P., Tarver, T., Heidinger, H., Sayous, R., Ivanov, S., Cavanagh, J. M., Shen, J., Imperial, J. M., Schwaller, P., Senthilkuma, S., Bran, A. M., Dehghan, A., Algaba, A., Verbeken, B., Noever, D., V, R. P., Schut, L., Sucholutsky, I., Zheltonozhskii, E., Lim, D., Stanley, R., Sivarajan, S., Yang, T., Maar, J., Wykowski, J., Oller, M., Sandlin, J., Sahu, A., Hu, Y., Fish, S., Heydari, N., Apronti, A., Rawal, K., Vilchis, T. G., Zu, Y., Lackner, M., Koppel, J., Nguyen, J., Antonenko, D. S., Chern, S., Zhao, B., Arsene, P., Goldfarb, A., Ivanov, S., PoÅ›wiata, R., Wang, C., Li, D., Crisostomi, D., Achilleos, A., Myklebust, B., Sen, A., Perrella, D., Kaparov, N., Inlow, M. H., Zang, A., Thornley, E., Orel, D., Poritski, V., Ben-David, S., Berger, Z., Whitfill, P., Foster, M., Munro, D., Ho, L., Hava, D. B., Kuchkin, A., Lauff, R., Holmes, D., Sommerhage, F., Schneider, K., Kazibwe, Z., Stambaugh, N., Singh, M., Magoulas, I., Clarke, D., Kim, D. H., Dias, F. M., Elser, V., Agarwal, K. P., Vilchis, V. E. G., Klose, I., Demian, C., Anantheswaran, U., Zweiger, A., Albani, G., Li, J., Daans, N., Radionov, M., RozhoÅˆ, V., Ma, Z., Stump, C., Berkani, M., Platnick, J., Nevirkovets, V., Basler, L., Piccardo, M., Jeanplong, F., s1: Simple test-time scaling Cohen, N., Tkadlec, J., Rosu, P., Padlewski, P., Barzowski, S., Montgomery, K., Menezes, A., Patel, A., Wang, Z., Tucker-Foltz, J., Stade, J., Goertzen, T., Kazemi, F., Milbauer, J., Ambay, J. A., Shukla, A., Labrador, Y. C. L., GivrÃ©, A., Wolff, H., Rossbach, V., Aziz, M. F., Kaddar, Y., Chen, Y., Zhang, R., Pan, J., Terpin, A., Muennighoff, N., Schoelkopf, H., Zheng, E., Carmi, A., Jones, A., Shah, J., Brown, E. D. L., Zhu, K., Bartolo, M., Wheeler, R., Ho, A., Barkan, S., Wang, J., Stehberger, M., Kretov, E., Sridhar, K., EL-Wasif, Z., Zhang, A., Pyda, D., Tam, J., Cunningham, D. M., Goryachev, V., Patramanis, D., Krause, M., Redenti, A., Bugas, D., Aldous, D., Lai, J., Coleman, S., Bahaloo, M., Xu, J., Lee, S., Zhao, S., Tang, N., Cohen, M. K., Carroll, M., Paradise, O., Kirchner, J. H., Steinerberger, S., Ovchynnikov, M., Matos, J. O., Shenoy, A., de Oliveira Junior, B. A., Wang, M., Nie, Y., Giordano, P., Petersen, P., Sztyber-Betley, A., Shukla, P., Crozier, J., Pinto, A., Verma, S., Joshi, P., Yong, Z.-X., Tee, A., AndrÃ©oletti, J., Weller, O., Singhal, R., Zhang, G., Ivanov, A., Khoury, S., Mostaghimi, H., Thaman, K., Chen, Q., KhÃ¡nh, T. Q., Loader, J., Cavalleri, S., Szlyk, H., Brown, Z., Roberts, J., Alley, W., Sun, K., Stendall, R., Lamparth, M., Reuel, A., Wang, T., Xu, H., Raparthi, S. G., HernÃ¡ndez-CÃ¡mara, P., Martin, F., Malishev, D., Preu, T., Korbak, T., Abramovitch, M., Williamson, D., Chen, Z., BÃ¡lint, B., Bari, M. S., Kassani, P., Wang, Z., Ansarinejad, B., Goswami, L. P., Sun, Y., Elgnainy, H., Tordera, D., Balabanian, G., Anderson, E., Kvistad, L., Moyano, A. J., Maheshwari, R., Sakor, A., Eron, M., McAlister, I. C., Gimenez, J., Enyekwe, I., O., A. F. D., Shah, S., Zhou, X., Kamalov, F., Clark, R., Abdoli, S., Santens, T., Meer, K., Wang, H. K., Ramakrishnan, K., Chen, E., Tomasiello, A., Luca, G. B. D., Looi, S.-Z., Le, V.-K., Kolt, N., MÃ¼ndler, N., Semler, A., Rodman, E., Drori, J., Fossum, C. J., Jagota, M., Pradeep, R., Fan, H., Shah, T., Eicher, J., Chen, M., Thaman, K., Merrill, W., Harris, C., Gross, J., Gusev, I., Sharma, A., Agnihotri, S., Zhelnov, P., Usawasutsakorn, S., Mofayezi, M., Bogdanov, S., Piperski, A., Carauleanu, M., Zhang, D. K., Ler, D., Leventov, R., Soroko, I., Jansen, T., Lauer, P., Duersch, J., Taamazyan, V., Morak, W., Ma, W., Held, W., Ãuc Huy, T., Xian, R., Zebaze, A. R., Mohamed, M., Leser, J. N., Yuan, M. X., Yacar, L., Lengler, J., Shahrtash, H., Oliveira, E., Jackson, J. W., Gonzalez, D. E., Zou, A., Chidambaram, M., Manik, T., Haffenden, H., Stander, D., Dasouqi, A., Shen, A., Duc, E., Golshani, B., Stap, D., Uzhou, M., Zhidkovskaya, A. B., Lewark, L., Vincze, M., Wehr, D., Tang, C., Hossain, Z., Phillips, S., Muzhen, J., EkstrÃ¶m, F., Hammon, A., Patel, O., Remy, N., Farhidi, F., Medley, G., Mohammadzadeh, F., PeÃ±aflor, M., Kassahun, H., Friedrich, A., Sparrow, C., Sakal, T., Dhamane, O., Mirabadi, A. K., Hallman, E., Battaglia, M., Maghsoudimehrabani, M., Hoang, H., Amit, A., Hulbert, D., Pereira, R., Weber, S., Mensah, S., Andre, N., Peristyy, A., Harjadi, C., Gupta, H., Malina, S., Albanie, S., Cai, W., Mehkary, M., Reidegeld, F., Dick, A.-K., Friday, C., Sidhu, J., Kim, W., Costa, M., Gurdogan, H., Weber, B., Kumar, H., Jiang, T., Agarwal, A., Ceconello, C., Vaz, W. S., Zhuang, C., Park, H., Tawfeek, A. R., Aggarwal, D., Kirchhof, M., Dai, L., Kim, E., Ferret, J., Wang, Y., Yan, M., Burdzy, K., Zhang, L., Franca, A., Pham, D. T., Loh, K. Y., Robinson, J., Gul, S., Chhablani, G., Du, Z., Cosma, A., White, C., Riblet, R., Saxena, P., Votava, J., Vinnikov, V., Delaney, E., Halasyamani, S., Shahid, S. M., Mourrat, J.-C., Vetoshkin, L., Bacho, R., Ginis, V., Maksapetyan, A., de la Rosa, F., Li, X., Malod, G., Lang, L., Laurendeau, J., Adesanya, F., Portier, J., Hollom, L., Souza, V., Zhou, Y. A., YalÄ±n, Y., Obikoya, G. D., Arnaboldi, L., Rai, Bigi, F., Bacho, K., Clavier, P., Recchia, G., Popescu, M., Shulga, N., Tanwie, N. M., Lux, T. C. H., Rank, B., Ni, C., Yakimchyk, A., Huanxu, Liu, HÃ¤ggstrÃ¶m, O., Verkama, E., Narayan, H., Gundlach, H., Brito-Santana, L., Amaro, B., Vajipey, V., Grover, R., Fan, Y., Silva, G. P. R., Xin, L., Kratish, Y., Åucki, J., Li, W.-D., Xu, J., Scaria, K. J., Vargus, F., Habibi, F., Long, Lian, RodolÃ , E., Robins, J., Cheng, V., Grabb, D., Bosio, I., Fruhauff, T., Akov, I., Lo, E. J. Y., Qi, H., Jiang, X., Segev, B., Fan, J., Martinson, S., Wang, E. Y., Hausknecht, K., Brenner, M. P., Mao, M., Jiang, Y., Zhang, X., Avagian, D., Scipio, E. J., Siddiqi, M. R., Ragoler, A., Tan, J., Patil, D., Plecnik, R., Kirtland, A., Montecillo, R. G., Durand, S., Bodur, O. F., Adoul, Z., Zekry, M., Douville, G., Karakoc, A., Santos, T. C. B., Shamseldeen, S., Karim, L., Liakhovitskaia, A., Resman, N., Farina, N., Gonzalez, J. C., Maayan, G., Hoback, S., Pena, R. D. O., Sherman, G., Mariji, H., Pouriamanesh, R., Wu, W., Demir, G., Mendoza, S., Alarab, I., Cole, J., Ferreira, D., Johnson, B., Milliron, H., Safdari, M., Dai, L., Arthornthurasuk, S., Pronin, A., Fan, J., Ramirez-Trinidad, A., Cartwright, A., Pottmaier, D., Taheri, O., Outevsky, D., Stepanic, S., Perry, S., Askew, L., RodrÃ­guez, R. A. H., Dendane, A., Ali, S., Lorena, R., Iyer, K., Salauddin, S. M., Islam, M., Gonzalez, J., Ducey, J., Campbell, R., Somrak, M., Mavroudis, V., Vergo, E., Qin, J., BorbÃ¡s, B., Chu, E., Lindsey, J., Radhakrishnan, A., Jallon, A., McInnis, I. M. J., Hoover, A., MÃ¶ller, S., Bian, S., Lai, J., Patwardhan, T., Yue, S., Wang, A., and Hendrycks, D. Humanitys last exam, 2025. URL https://arxiv.org/abs/2501.14249. Qwen, :, Yang, A., Yang, B., Zhang, B., Hui, B., Zheng, B., Yu, B., Li, C., Liu, D., Huang, F., Wei, H., Lin, H., Yang, J., Tu, J., Zhang, J., Yang, J., Yang, J., Zhou, J., Lin, J., Dang, K., Lu, K., Bao, K., Yang, K., Yu, L., Li, M., Xue, M., Zhang, P., Zhu, Q., Men, R., Lin, R., Li, T., Xia, T., Ren, X., Ren, X., Fan, Y., Su, Y., Zhang, Y., Wan, Y., Liu, Y., Cui, Z., Zhang, Z., and Qiu, Z. Qwen2.5 technical report, 2024. URL https://arxiv.org/ abs/2412.15115. 13 s1: Simple test-time scaling Rein, D., Hou, B. L., Stickland, A. C., Petty, J., Pang, R. Y., Dirani, J., Michael, J., and Bowman, S. R. Gpqa: graduate-level google-proof q&a benchmark, 2023. URL https://arxiv.org/abs/2311.12022. Shi, Q., Tang, M., Narasimhan, K., and Yao, S. Can language models solve olympiad programming?, 2024. URL https://arxiv.org/abs/2404.10952. Team, Q. Qwq: Reflect deeply on the boundaries of the unknown, November 2024b. URL https://qwenlm. github.io/blog/qwq-32b-preview/. Wang, J., Meng, F., Liang, Y., and Zhou, J. Drt-o1: Optimized deep reasoning translation via long chain-ofthought, 2024a. URL https://arxiv.org/abs/ 2412.17498. Snell, C., Lee, J., Xu, K., and Kumar, A. Scaling llm testtime compute optimally can be more effective than scaling model parameters, 2024. URL https://arxiv. org/abs/2408.03314. Wang, P., Li, L., Shao, Z., Xu, R. X., Dai, D., Li, Y., Chen, D., Wu, Y., and Sui, Z. Math-shepherd: Verify and reinforce llms step-by-step without human annotations, 2024b. URL https://arxiv.org/abs/2312.08935. Srivastava, A., Rastogi, A., Rao, A., Shoeb, A. A. M., Abid, A., Fisch, A., Brown, A. R., Santoro, A., Gupta, A., Garriga-Alonso, A., et al. Beyond the imitation game: Quantifying and extrapolating the capabilities of language models, 2023. Su, H., Yen, H., Xia, M., Shi, W., Muennighoff, N., yu Wang, H., Liu, H., Shi, Q., Siegel, Z. S., Tang, M., Sun, R., Yoon, J., Arik, S. O., Chen, D., and Yu, T. Bright: realistic and challenging benchmark for reasoning-intensive retrieval, 2024. URL https://arxiv.org/abs/ 2407.12883. Sun, L., Han, Y., Zhao, Z., Ma, D., Shen, Z., Chen, B., Chen, L., and Yu, K. Scieval: multi-level large language model evaluation benchmark for scientific research, 2024. URL https://arxiv.org/abs/2308.13149. Team, D. Deepseek r1, November 2024a. URL https://x.com/deepseek_ai/status/ 1859200141355536422. Team, K., Du, A., Gao, B., Xing, B., Jiang, C., Chen, C., Li, C., Xiao, C., Du, C., Liao, C., Tang, C., Wang, C., Zhang, D., Yuan, E., Lu, E., Tang, F., Sung, F., Wei, G., Lai, G., Guo, H., Zhu, H., Ding, H., Hu, H., Yang, H., Zhang, H., Yao, H., Zhao, H., Lu, H., Li, H., Yu, H., Gao, H., Zheng, H., Yuan, H., Chen, J., Guo, J., Su, J., Wang, J., Zhao, J., Zhang, J., Liu, J., Yan, J., Wu, J., Shi, L., Ye, L., Yu, L., Dong, M., Zhang, N., Ma, N., Pan, Q., Gong, Q., Liu, S., Ma, S., Wei, S., Cao, S., Huang, S., Jiang, T., Gao, W., Xiong, W., He, W., Huang, W., Wu, W., He, W., Wei, X., Jia, X., Wu, X., Xu, X., Zu, X., Zhou, X., Pan, X., Charles, Y., Li, Y., Hu, Y., Liu, Y., Chen, Y., Wang, Y., Liu, Y., Qin, Y., Liu, Y., Yang, Y., Bao, Y., Du, Y., Wu, Y., Wang, Y., Zhou, Z., Wang, Z., Li, Z., Zhu, Z., Zhang, Z., Wang, Z., Yang, Z., Huang, Z., Huang, Z., Xu, Z., and Yang, Z. Kimi k1.5: Scaling reinforcement learning with llms, 2025. URL https://arxiv.org/abs/2501.12599. Team, N. Sky-t1: Fully open-source reasoning model with o1-preview performance in $450 budget, 2025. URL https://novasky-ai.github.io/ posts/sky-t1. Accessed: 2025-01-09. Wang, S., Liu, Z., Zhong, W., Zhou, M., Wei, Z., Chen, Z., and Duan, N. From lsat: The progress and challenges of complex reasoning, 2021. URL https://arxiv. org/abs/2108.00648. Wang, Z., Dong, Y., Delalleau, O., Zeng, J., Shen, G., Egert, D., Zhang, J. J., Sreedhar, M. N., and Kuchaiev, O. Helpsteer2: Open-source dataset for training top-performing reward models, 2024c. URL https://arxiv.org/ abs/2406.08673. Wei, J., Wang, X., Schuurmans, D., Bosma, M., Ichter, B., Xia, F., Chi, E., Le, Q., and Zhou, D. Chain-ofthought prompting elicits reasoning in large language models, 2023. URL https://arxiv.org/abs/ 2201.11903. Welleck, S., Bertsch, A., Finlayson, M., Schoelkopf, H., Xie, A., Neubig, G., Kulikov, I., and Harchaoui, Z. From decoding to meta-generation: Inference-time algorithms for large language models, 2024. URL https://arxiv. org/abs/2406.16838. Wu, Y., Sun, Z., Li, S., Welleck, S., and Yang, Y. Inference scaling laws: An empirical analysis of computeoptimal inference for problem-solving with language models, 2024a. URL https://arxiv.org/abs/2408. 00724. Wu, Y., Sun, Z., Li, S., Welleck, S., and Yang, Y. Inference scaling laws: An empirical analysis of computeoptimal inference for problem-solving with language models, 2024b. URL https://arxiv.org/abs/2408. 00724. Xie, Y., Kawaguchi, K., Zhao, Y., Zhao, X., Kan, M.-Y., He, J., and Xie, Q. Self-evaluation guided beam search for reasoning, 2023. URL https://arxiv.org/abs/ 2305.00633. Xin, H., Guo, D., Shao, Z., Ren, Z., Zhu, Q., Liu, B., Ruan, C., Li, W., and Liang, X. Deepseek-prover: Advancing theorem proving in llms through large-scale synthetic data, 2024. URL https://arxiv.org/abs/2405. 14333. 14 s1: Simple test-time scaling Zhong, H., Xiao, C., Tu, C., Zhang, T., Liu, Z., and Sun, M. Jec-qa: legal-domain question answering dataset, 2019. URL https://arxiv.org/abs/1911.12011. Zhong, W., Cui, R., Guo, Y., Liang, Y., Lu, S., Wang, Y., Saied, A., Chen, W., and Duan, N. Agieval: human-centric benchmark for evaluating foundation models, 2023. URL https://arxiv.org/abs/2304. 06364. Zhou, A., Yan, K., Shlapentokh-Rothman, M., Wang, H., and Wang, Y.-X. Language agent tree search unifies reasoning acting and planning in language models, 2024. URL https://arxiv.org/abs/2310.04406. Zhou, C., Liu, P., Xu, P., Iyer, S., Sun, J., Mao, Y., Ma, X., Efrat, A., Yu, P., Yu, L., Zhang, S., Ghosh, G., Lewis, M., Zettlemoyer, L., and Levy, O. Lima: Less is more for alignment, 2023. Xu, H., Wu, X., Wang, W., Li, Z., Zheng, D., Chen, B., Hu, Y., Kang, S., Ji, J., Zhang, Y., Guo, Z., Yang, Y., Zhang, M., and Zhang, D. Redstar: Does scaling long-cot data unlock better slow-reasoning systems?, 2025. URL https://arxiv.org/abs/2501.11284. Yang, Z., Band, N., Li, S., CandÃ¨s, E., and Hashimoto, T. Synthetic continued pretraining, 2024. URL https: //arxiv.org/abs/2409.07431. Yao, S., Yu, D., Zhao, J., Shafran, I., Griffiths, T. L., Cao, Y., and Narasimhan, K. Tree of thoughts: Deliberate problem solving with large language models, 2023a. URL https://arxiv.org/abs/2305.10601. Yao, S., Zhao, J., Yu, D., Du, N., Shafran, I., Narasimhan, K., and Cao, Y. React: Synergizing reasoning and acting in language models, 2023b. URL https://arxiv. org/abs/2210.03629. Yu, L., Jiang, W., Shi, H., Yu, J., Liu, Z., Zhang, Y., Kwok, J. T., Li, Z., Weller, A., and Liu, W. Metamath: Bootstrap your own mathematical questions for large language models, 2024. URL https://arxiv.org/abs/2309. 12284. Yuan, S., Chen, Z., Xi, Z., Ye, J., Du, Z., and Chen, J. Agent-r: Training language model agents to reflect via iterative self-training, 2025. URL https://arxiv. org/abs/2501.11425. Zelikman, E., Wu, Y., Mu, J., and Goodman, N. D. Star: Bootstrapping reasoning with reasoning, 2022. URL https://arxiv.org/abs/2203.14465. Zelikman, E., Harik, G., Shao, Y., Jayasiri, V., Haber, N., and Goodman, N. D. Quiet-star: Language models can teach themselves to think before speaking, 2024. URL https://arxiv.org/abs/2403.09629. Zhang, H. and Chen, C. Test-time compute scaling laws, 2024. URL https://github.com/hughbzhang/ o1_inference_scaling_laws. Zhang, S., Chen, Z., Shen, Y., Ding, M., Tenenbaum, J. B., and Gan, C. Planning with large language models for code generation, 2023. URL https://arxiv.org/ abs/2303.05510. Zhang, Y., Wu, S., Yang, Y., Shu, J., Xiao, J., Kong, C., and Sang, J. o1-coder: an o1 replication for coding, 2024a. URL https://arxiv.org/abs/2412.00154. Zhang, Y., Yang, J., Yuan, Y., and Yao, A. C.-C. Cumulative reasoning with large language models, 2024b. URL https://arxiv.org/abs/2308.04371. 15 s1: Simple test-time scaling"
        },
        {
            "title": "Contents",
            "content": "1 Introduction 2 Reasoning data curation to create s1K Initial collection of 59K samples . 2.1 2.2 Final selection of 1K samples . . . 3 Test-time scaling . 3.1 Method . . . 3.2 Metrics . . 4 Results 4.1 Setup . . . . 4.2 Performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 Ablations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.1 Data Quantity, Diversity, and Difficulty . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2 Test-time scaling methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 Discussion and related work 6.1 Sample-efficient reasoning . 6.2 Test-time scaling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Evaluation determinism s1K details B.1 s1K summary . B.2 Dataset composition for full 59K questions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . B.3 s1K grading prompt . B.4 s1K diversity selection . . B.5 Decontamination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Training details C.1 Training Ablations: Sequence length . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . C.2 Training Samples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Test-time scaling details D.1 Sequential scaling ablations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D.2 Examples for rejection sampling ablation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 1 2 2 2 3 3 4 4 6 6 6 6 8 8 9 17 17 17 19 19 19 21 21 35 35 37 A. Evaluation determinism s1: Simple test-time scaling We run our evaluations using vLLM (Kwon et al., 2023) as it is faster than the alternatives we tried. However, we find that even when using the same random seeds and greedy sampling, evaluation scores can change significantly across runs: Different batch sizes causing different results see https://github.com/vllm-project/vllm/issues/ 5898 Continuing generations causing different results see https://github.com/vllm-project/vllm/issues/ 11783 Changes in tensor parallelism causing different results As our model generates long reasoning traces prior to its answer, small numeric changes can snowball into large differences. We encounter many generations that are exactly the same for thousands of tokens and then suddenly differ in one token eventually ending up with an entirely different answer. To partly counter this issue we generally run our final evaluations using full precision unless otherwise indicated. B. s1K details B.1. s1K summary Table 5. Summary of our dataset s1K. Token count measured by the Qwen-2.5 tokenizer. We prompt Claude to produce keywords given several questions from the domain. Domain #questions Total token count Keywords Geometry Number theory Combinatorics Real functions Biology Complex functions Quantum theory Field theory Calculus of variations Difference equations Electromagnetic theory Group theory Linear algebra Probability theory Algebraic systems Mechanics Thermodynamics Differential equations Computer science Numerical analysis Calculus Algebraic structures Astronomy Remaining 27 domains 109 98 75 43 41 32 32 28 28 24 23 22 22 20 19 19 19 18 18 18 17 17 16 242 All domains (51) 1000 B.2. Dataset composition for full 59K questions 560.2K 522.5K 384.7K 234.8K 120.9K 170.2K 127.9K 150.1K 155.5K 132.5K 95.8K 100.0K 128.3K 114.6K 109.9K 103.6K 74.2K 89.6K 34.2K 76.5K 96.3K 90.4K 37.7K 982.2K 4.7M 17 Area, Triangle, Distance Sequences, Divisibility Permutations, Counting Trigonometry, Calculus Organic reactions Complex roots Particles, Wave functions Polynomials, Roots Optimization, Control Recurrence, Recursion Optics, Waves, Diffraction Groups, Automorphisms Matrices, Determinants Random walk, Expectation Functional equations Forces, Motion, Energy Heat engines, Entropy Substitution, Existence Complexity theory, Algorithms Error analysis, Stability Convergence, Summation Inequalities, Sets Stellar populations, Orbits Domains with 16 questions s1K s1: Simple test-time scaling Table 6. Composition of full 59K questions. Thinking and response lengths are measured in tokens using the Qwen2.5-32B-Instruct tokenizer (Qwen et al., 2024). In addition to excluding our evaluation benchmark, AIME24, we also exclude AIME questions from 2022-2023 as we use these 90 questions during our development stage of s1-32B. Source Description #Samples Avg. NuminaMATH (LI et al., 2024) MATH (Hendrycks et al., 2021) Math problems from competitions OlympicArena (Huang et al., 2024a) Math problems from online websites OmniMath (Gao et al., 2024a) AGIEval (Zhong et al., 2023; Ling et al., 2017; Hendrycks et al., 2021; Liu et al., 2020; Zhong et al., 2019; Wang et al., 2021) xword OlympiadBench (He et al., 2024b) AIME (1983-2021) TheoremQA (Chen et al., 2023) USACO (Shi et al., 2024) JEEBench (Arora et al., 2023) GPQA (Rein et al., 2023) SciEval (Sun et al., 2024) s1-prob LiveCodeBench (Jain et al., 2024b) s1-teasers 30660 11999 4250 4238 Astronomy, Biology, Chemistry, Computer Science, Geography, Math, and Physics olympiad questions Math problems from competitions English, Law, Logic and Math problems from the SAT, LSAT and other exams Crossword puzzles Math and Physics olympiad questions American Invitational Mathematics Examination Computer Science, Finance, Math, and Physics university-level questions relating to theorems Code problems from the USA Computing Olympiad Chemistry, Math, and Physics problems used in the university entrance examination of the Indian Institute of Technology PhD-Level Science Questions Biology, Chemistry, and Physics problems from various sources Stanford statistics qualifying exams Code problems from coding websites (LeetCode, AtCoder, and CodeForces) Math brain-teasers crawled from the Internet 999 896 890 519 515 348 227 182 151 23 thinking length 4.1K 2.9K 3.2K 4.4K 1.2K 0.7K 3.9K 4.7K 2.1K 3.6K 2.9K 2.9K 0.7K 4.0K 3.5K 4.1K All 59K questions Composite of the above datasets with reasoning traces and solutions 59029 3.6K 18 B.3. s1K grading prompt To grade whether an example is correct for our dataset selection in 2, we use the prompt in Figure 8. s1: Simple test-time scaling You are an AI assistant for grading science problem. The user will provide you with the question itself, an attempt made by student and the correct answer to the problem. Your job is to judge whether the attempt is correct by comparing it with the correct answer. If the expected solution concludes with number or choice, there should be no ambiguity. If the expected solution involves going through the entire reasoning process, you should judge the attempt based on whether the reasoning process is correct with correct answer if helpful. The user will provide the attempt and the correct answer in the following format: # Problem {problem} ## Attempt {attempt} ## Correct answer {solution} Explain your reasoning, and end your response on new line with only \"Yes\" or \"No\" (without quotes). Figure 8. Grading prompt. B.4. s1K diversity selection Algorithm 1 provides our algorithm for selecting data in our diversity selection stage. As mentioned in 2, we also include samples from some specific benchmarks we perceive as high-quality. None of the samples overlap with our final evaluation. B.5. Decontamination We filter all samples by checking for an 8-gram overlap between the selected examples and the evaluation benchmarks: MATH500, GPTQA Diamond, and AIME24. We exclude questions with more than an 8-gram overlap. if IsGeminiCorrect(ğ‘) and (IsAIME(ğ‘) or IsGPQA(ğ‘)) then else if IsGeminiCorrect(ğ‘) and IsMATH(ğ‘) and ThinkingLength(ğ‘) > 5600 then Select all correct AIME/GPQA solutions Initialize the output set (only tracks unique elements) s1: Simple test-time scaling {ğ‘} {ğ‘} < 1000 do ğ‘‘ RandomChoice() Algorithm 1 Two-stage sampling for s1K 1: Input: := Set of 24,496 questions with features 2: Output: := Set of 1,000 selected questions 3: 4: for ğ‘ do 5: 6: 7: 8: 9: 10: 11: end if 12: end for 13: All available domains 14: 15: while 16: 17: 18: ğ‘„ğ‘‘ Questions in domain ğ‘‘ 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: ğ‘„ğ‘‘ ğ‘„ğ‘‘ {ğ‘} 29: if ğ‘„ğ‘‘ = then {ğ‘‘} 30: 31: 32: 33: end while ranks RankByThinkingLength(ğ‘„ğ‘‘ ğ‘ WeightedSample(ğ‘„ğ‘‘ weights 2ranks {ğ‘} , weights) end if ) Select correct MATH solutions with long chains Initialize domain pool Randomly select domain Get questions from this domain Rank by thinking length Apply power-law weighting Sample favoring longer chains Add selected question Remove exhausted domains 20 C. Training details s1: Simple test-time scaling We take model that has already been pretrained and instruction tuned and further finetune it for reasoning. Specifically, we use Qwen2.5-32B-Instruct (Qwen et al., 2024), which generally matches or outperforms the larger Qwen2.5-72B-Instruct on math tasks (Qwen et al., 2024). We use token delimiters to separate the thinking stage from the answering stage. We enclose the thinking stage with <im_start>think and <im_start>answer; both preceded and followed by newline. Samples from our dataset are in C.2. We use basic fine-tuning hyperparameters: we train for 5 epochs with batch size of 16 for total of 315 gradient steps. We train in bfloat16 precision with learning rate of 1ğ‘’ 5 warmed up linearly for 5% (16 steps) and then decayed to 0 over the rest of training (299 steps) following cosine schedule. We use the AdamW optimizer (Loshchilov & Hutter, 2019) with ğ›½1 = 0.9, ğ›½2 = 0.95 and weight decay of 1ğ‘’ 4. We do not compute loss on questions, only on reasoning traces and solutions. We ensure the sequence length is large enough to avoid cutting off any samples; setting we ablate in C.1. The training takes just 26 minutes on 16 NVIDIA H100 GPUs. Figure 9. Training dynamics of s1-32B on s1K. C.1. Training Ablations: Sequence length Table 7. Training sequence length ablation. We report accuracy / average thinking tokens per sample; the higher the accuracy and the fewer the thinking tokens (inference cost) the better. Model Training sequence length % training samples cutoff 4096 74% AIME24 MATH GPQA 30.0% / 20721 90.0% / 5324 52.5% / 6841 Model 32768 0% 50.0% / 6984 91.0% / 3268 53.0% / 3568 Besides our scaling ablations in 5.2, the main training hyperparameter we ablate is the sequence length used during training. We find that shorter training sequence length leads to longer reasoning traces at test time. This is because when training with shorter sequence length the answer section of the training sample is more commonly cut off. Inversely, when the training sequence length is longer, more samples appear in their entirety with the section where the model answers. Thus the model receives more gradient updates where it learns to generate an answer following its chain. This in turn leads to higher log probability of the answer section at any point during the generation and thus shorter reasoning traces at test time. Performance-wise, we find that there is no major difference when training with different sequence lengths, thus we opt for the longest training sequence length as it makes inference more efficient by leading to shorter reasoning traces. C.2. Training Samples Table 8, Table 9, Table 10 contain training samples from s1K. 21 s1: Simple test-time scaling Table 8. s1K sample stemming from s1-prob. The black text is the question and the yellow text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with Gemini, which we use for training. You are given integrable random variables ğ‘‹, ğ‘Œ0 , . For ğ‘˜ = 1, 2, ,, let and ğ‘ on the same probability space (Î©, , â„™), and two ğœ-algebras ğ‘Œğ‘˜ = ğ”¼[ğ‘‹ğœ(, ğ‘0, , ğ‘ğ‘˜1)], ğ‘ğ‘˜ = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, , ğ‘Œğ‘˜1)]. (a) Show that there exist integrable random variables ğ‘Œ ğ”¼[ğ‘ğ‘› ğ‘] 0. (b) Prove that almost surely ğ‘Œ = ğ‘. and ğ‘ such that as ğ‘› both ğ”¼[ğ‘Œğ‘› ğ‘Œ] 0 and 1. Introduce the notations, 0 = . 0 = , ğ‘› = ğœ(, ğ‘Œ0, , ğ‘Œğ‘›1), for all ğ‘› 1 and ğ‘› = ğœ(, ğ‘0, , ğ‘ğ‘›1) and } ], for all ğ‘› 0. Thus {ğ‘Œğ‘› [ğ‘‹ ] and ğ‘ğ‘› = ğ”¼ [ğ‘‹ (or ğ‘› ğ‘› ğ‘›0 } (or { } ) is Doobs Martingale with respect to filtration { ) and hence is U.I., ğ‘‹ being integrable. ğ‘› ğ‘›0 Clearly, both are filtrations and by definition, ğ‘Œğ‘› = ğ”¼ {ğ‘ğ‘› Now apply the fact that Martingale is U.I. if and only if it converges in ğ¿1 and conclude. ğ‘›0 ğ‘›0 } ğ‘› 2. We provide two different proofs. 1. Observe the following identity which follows from Tower Property. [ğ‘‹ [ğ‘Œğ‘› ğ‘› ğ‘› [ğ‘‹ ğ‘› ğ‘› = ğ”¼ = ğ”¼ ğ”¼ ğ”¼ ğ”¼ [ ] ] ] [ ] ] ğ‘› = ğ”¼ [ğ‘ğ‘› ğ‘› ] . (4) Note that ğ”¼ğ”¼ where and hence ğ”¼ Similarly, ğ”¼ ] [ğ‘Œğ‘› ğ‘› = ğœ ( ğ‘›0 [ğ‘Œ ] [ğ‘ğ‘› ğ‘› ] [ğ‘Œ ğ‘› = ğœ(, ğ‘Œ0, ğ‘Œ1 ). It is evident that ğ‘Œ ğ‘š ğ”¼ğ‘Œğ‘› ğ‘Œ = ğ‘œ(1) and by Levys Upward Theorem, ğ”¼ [ğ‘Œ [ğ‘Œ ğ‘› (since it is almost sure limit of ğ‘Œğ‘› ğ‘š ğ‘› ğ”¼ ], ) ] ğ¿1 ğ”¼ ) ğ‘› 2. Since ğ‘‹ is integrable, we have by Levys Upward Theorem, ğ‘Œ = limğ‘› ğ‘Œğ‘› = limğ‘› ğ”¼ almost surely. Combining the above observations we conclude that ğ”¼ = ğ‘Œ ] ğ¿1 ğ‘. Now invoke Equation (4), to conclude that ğ‘Œ = ğ‘ almost surely. [ğ‘‹ ] . On the otherhand, in first proof we have observed that ğ‘Œ ğ‘š ). This yields the following. Similarly, ğ‘ = ğ”¼ = ğ‘š ( ğ‘š ğ‘š [ğ‘‹ [ğ‘Œğ‘› ğ‘› ] ğ¿1 ğ‘Œ. = ğ”¼ ] . [ğ‘‹ ] ğ‘› and hence ğ‘Œ ğ‘Œ = ğ”¼ Similarly, ğ‘ = ğ”¼ [ğ‘‹ ] [ğ‘Œ = ğ”¼ ] . This proves that ğ‘Œ = ğ‘ [ğ‘‹ [ ğ”¼ ] ] = ğ”¼ [ğ‘‹ ] . almost surely. sequence: and ğ‘ğ‘˜ defined by conditional expectations. Lets analyze the problem. We are given two sequences of random variables ğ‘Œğ‘˜ We need to show that these sequences converge in ğ¿1 and that their limits are equal almost surely. Part (a): Convergence in ğ¿1. The sigma-algebras involved are increasing: ğ‘˜ = ğœ(, ğ‘0, , ğ‘ğ‘˜1) ğ‘˜ = ğœ(, ğ‘Œ0, , ğ‘Œğ‘˜1) For the ğ‘Œğ‘˜ ğ‘Œ1 = ğ”¼[ğ‘‹ğœ()] ğ‘Œ2 = ğ”¼[ğ‘‹ğœ(, ğ‘0)] ğ‘Œ3 = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1)] ... The sequence of sigma-algebras ğœ(, ğ‘0, , ğ‘ğ‘˜1) is increasing. By the Martingale Convergence Theorem (for conditional converges almost surely and in ğ¿1 to ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )]. Let expectations), since ğ‘‹ is integrable, the sequence ğ‘Œğ‘˜ ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )]. 22 s1: Simple test-time scaling . . . . is ]. ]). are given. sequence: and ğ‘ -measurable. -measurable and ğ‘ = ğœ(, ğ‘Œ0, ğ‘Œ1, ). , ğ‘Œ0, , ğ‘Œğ‘›1] = ğ‘ğ‘› , ğ‘0, , ğ‘ğ‘›1] = ğ‘Œğ‘› are measurable with respect to . = ğœ(, ğ‘0, ğ‘1, ) and = ğœ(, ğ‘0, ğ‘1, ) and , ğ‘0, , ğ‘ğ‘˜1] = ğ‘Œğ‘˜ . , ğ‘Œ0, , ğ‘Œğ‘˜1] = ğ‘ğ‘˜ is not defined, lets assume ğ‘Œ0 and ğ‘ğ‘– ], ğœ(, ğ‘0) = ğœ(, ğ”¼[ğ‘‹ and ğ‘0 . converges almost surely and in ğ¿1 to ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1, )]. Let ğ‘ = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1, )]. are measurable with respect to . Thus, ğ‘Œ , ğ‘0, , ğ‘ğ‘›1] = ğ”¼[ğ”¼[ğ‘‹ğœ(, ğ‘0, , ğ‘ğ‘›)] , ğ‘Œ0, , ğ‘Œğ‘›1] = ğ”¼[ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, , ğ‘Œğ‘›)] Similarly, for the ğ‘ğ‘˜ ğ‘1 = ğ”¼[ğ‘‹ğœ()] ğ‘2 = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0)] ğ‘3 = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1)] ... The sequence of sigma-algebras ğœ(, ğ‘Œ0, , ğ‘Œğ‘˜1) is increasing. By the Martingale Convergence Theorem, the sequence ğ‘ğ‘˜ Part (b): Prove that almost surely ğ‘Œ = ğ‘ We have ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )] and ğ‘ = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1, )]. Let ] and ğ‘ = ğ”¼[ğ‘‹ Then ğ‘Œ = ğ”¼[ğ‘‹ Consider ğ‘Œ1 = ğ”¼[ğ‘‹ ]. ]. ğ‘1 = ğ”¼[ğ‘‹ ğ‘Œ2 = ğ”¼[ğ‘‹ğœ(, ğ‘0)]. Since ğ‘0 = ğ”¼[ğ‘‹ ğ‘2 = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0)]. Since ğ‘Œ0 Lets consider the sigma-algebra generated by all the ğ‘Œğ‘– Let = ğœ(ğ‘Œ0, ğ‘0, ğ‘Œ1, ğ‘1, ). and ğ‘ğ‘˜ Both ğ‘Œğ‘˜ Consider ğ”¼[ğ‘Œğ‘›+1 Consider ğ”¼[ğ‘ğ‘›+1 Let = ğœ( ğœ(ğ‘Œ0, ğ‘0, ğ‘Œ1, ğ‘1, )). Consider ğ”¼[ğ‘‹ Consider ğ”¼[ğ‘‹ Lets consider the limit sigma-algebras We know that ğ‘Œ is Let = ğœ( ). ]. ğ‘1 = ğ”¼[ğ‘‹ ğ‘Œ1 = ğ”¼[ğ‘‹ ğ‘Œ2 = ğ”¼[ğ‘‹ğœ(, ğ‘0)] = ğ”¼[ğ‘‹ğœ(, ğ”¼[ğ‘‹ ğ‘2 = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0)] = ğ”¼[ğ‘‹ğœ(, ğ”¼[ğ‘‹ Consider the case when and are independent. Then ğ‘Œ1 = ğ”¼[ğ‘‹ ğ‘Œ2 = ğ”¼[ğ‘‹ğœ(, ğ”¼[ğ‘‹ Lets consider the sigma-algebra generated by all the information. Let -measurable. Then both ğ‘Œ We have ğ‘Œ = limğ‘› ğ‘Œğ‘› and ğ‘ = limğ‘› ğ‘ğ‘› Consider ğ”¼[ğ‘‹ Let Consider ğ”¼[ğ‘‹ Lets try to show that both ğ‘Œ Lets consider the definition of conditional expectation. For any set ğ´ , ğ”¼[ğ‘1ğµ] = ğ”¼[ğ‘‹1ğµ]. For any set ğµ where Consider ğ”¼[ğ‘Œğ‘˜+1 ğ‘˜] = ğ‘Œğ‘˜ Consider ğ”¼[ğ‘ğ‘˜+1 where ğ‘˜] = ğ‘ğ‘˜ Consider the sigma-algebra ğœ( ). Let ğ‘Š = ğ”¼[ğ‘‹ğœ( )]. We have ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )]. Since ğ‘ğ‘˜ depends on ğ‘Œğ‘˜1 Lets consider the case where ğ‘Œ0 = ğ”¼[ğ‘‹ ] = ğ‘Œ0 Then ğ‘Œ1 = ğ”¼[ğ‘‹ . ] = ğ‘0 ğ‘1 = ğ”¼[ğ‘‹ If this were the case, then ğ‘Œğ‘˜ = ğ‘Œ0 We need ğ‘Œ0 = ğ‘0 a.s., i.e., ğ”¼[ğ‘‹ Consider the sigma-algebra generated by all ğ‘Œğ‘– Then = ğœ(, ğ‘0, ğ‘1, ) ğœ(, . and ğ‘ = ğ‘0 ] a.s. This is not generally true. , denoted by are equal to ğ”¼[ğ‘‹ğœ( )]. This seems too simple. ğ‘˜ = ğœ(, ğ‘0, , ğ‘ğ‘˜1). ğ‘˜ = ğœ(, ğ‘Œ0, , ğ‘Œğ‘˜1). a.s. and in ğ¿1. , ğ‘Œ0, ğ‘Œ1, ] = ğ‘ = ğœ(, , ğ‘Œ0, ğ‘0, ğ‘Œ1, ğ‘1, ). etc., it is complex. ]. = ğœ( ). ]. = ğœ(ğ‘Œ0, ğ‘0, ğ‘Œ1, ğ‘1, ). which depends on ğ‘ğ‘˜2 , ğ”¼[ğ‘Œ1ğ´] = ğ”¼[ğ‘‹1ğ´]. = ğœ(, ğ‘Œ0, ğ‘Œ1, ). , ğ‘0, ğ‘1, ] = ğ‘Œ ] and ğ‘1 = ğ”¼[ğ‘‹ ] and ğ‘0 = ğ”¼[ğ‘‹ and ğ‘ğ‘˜ = ğ‘0 , so ğ‘Œ = ğ‘Œ0 ] = ğ”¼[ğ‘‹ and ğ”¼[ğ‘‹ ])]. ])]. and ğ‘ and ğ‘ and ğ‘ğ‘– ])]. are ). ]. ]. . . = ğœ(, ğ‘Œ0, ğ‘Œ1, ) ğœ(, ). 23 s1: Simple test-time scaling . This means for any ğ´ ğœ(, ğ‘0, ğ‘1, ), ğ”¼[ğ‘‹1ğ´] = ğ”¼[ğ‘Œ1ğ´]. . This means for any ğµ ğœ(, ğ‘Œ0, ğ‘Œ1, ), ğ”¼[ğ‘‹1ğµ] = ğ”¼[ğ‘1ğµ]. is ğœ(, ğ‘Œ0, ğ‘Œ1, )-measurable. . ]. ğ‘ ]. ] + ğ”¼[ğ‘2 , ğ‘Œ0, ğ‘Œ1, ]. ] = ğ”¼[ğ”¼[ğ‘‹ , ğ‘0, ğ‘1, ] , ğ‘0, ğ‘1, ] ] 2ğ”¼[ğ‘Œğ‘]. on set of positive measure. = ğœ( {ğ‘Œğ‘–, ğ‘ğ‘–}ğ‘–0). , ğ‘0, ğ‘1, ] = ğ‘Œ , ğ‘Œ0, ğ‘Œ1, ] = ğ‘ is measurable with respect to ğœ(, ğ‘0, ğ‘1, ), this does not simplify easily. and ğ‘ğ‘˜ , ğ‘0, , ğ‘ğ‘˜1] = ğ‘Œğ‘˜ . . , ğ‘Œ0, , ğ‘Œğ‘˜1] = ğ‘ğ‘˜ , ğ‘Œ0, ğ‘Œ1, ]. Consider ğ”¼[ğ‘‹ Consider ğ”¼[ğ‘‹ Let = ğœ(, ). ]. Consider ğ”¼[ğ‘‹ , ğ‘Œ0, ğ‘Œ1, ] = ğ”¼[ğ”¼[ğ‘‹ Consider ğ”¼[ğ‘Œ Lets use the fact that ğ‘Œ is ğœ(, ğ‘0, ğ‘1, )-measurable and ğ‘ Consider the smallest sigma-algebra containing both ğœ(, ğ‘0, ğ‘1, ) and ğœ(, ğ‘Œ0, ğ‘Œ1, ). This is ğœ( {ğ‘Œğ‘–}ğ‘–0 {ğ‘ğ‘–}ğ‘–0). Lets try to show that ğ”¼[(ğ‘Œ ğ‘)2] = 0. ğ”¼[(ğ‘Œ ğ‘)2] = ğ”¼[ğ‘Œ 2 Consider the definition of ğ‘Œğ‘˜ ğ”¼[ğ‘Œğ‘˜+1 ğ”¼[ğ‘ğ‘˜+1 Consider ğ”¼[ğ‘Œ Since ğ‘Œ Lets assume ğ‘Œ Consider the case where and are trivial. Then ğ‘Œğ‘˜ = ğ”¼[ğ‘‹ğœ(ğ‘0, , ğ‘ğ‘˜1)] and ğ‘ğ‘˜ = ğ”¼[ğ‘‹ğœ(ğ‘Œ0, , ğ‘Œğ‘˜1)]. Let Consider ğ”¼[ğ‘‹ ]. We have ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )]. By the properties of conditional expectation, ğ”¼[ğ‘Œ Consider the sigma-algebra generated by all the random variables involved. = ğœ( {ğ‘Œğ‘–}ğ‘–0 {ğ‘ğ‘–}ğ‘–0). Let ğ‘€ = ğ”¼[ğ‘‹ Consider the limits. As ğ‘› , ğœ(, ğ‘0, , ğ‘ğ‘›1) ğœ(, ğ‘0, ğ‘1, ). As ğ‘› , ğœ(, ğ‘Œ0, , ğ‘Œğ‘›1) ğœ(, ğ‘Œ0, ğ‘Œ1, ). = ğœ(, ğ‘Œ0, ğ‘Œ1, ). Let = ğœ(, ğ‘0, ğ‘1, ) and We have ğ‘Œ = ğ”¼[ğ‘‹ ]. ] and ğ‘ = ğ”¼[ğ‘‹ Consider ğ”¼[ğ‘Œ ğ‘]2 = ğ”¼[(ğ‘Œ ğ‘‹) + (ğ‘‹ ğ‘)]2 = ğ”¼[(ğ‘Œ ğ‘‹)2] + ğ”¼[(ğ‘‹ ğ‘)2] + 2ğ”¼[(ğ‘Œ ğ‘‹)(ğ‘‹ ğ‘)] ])2] + ğ”¼[(ğ‘‹ ğ”¼[ğ‘‹ = ğ”¼[(ğ‘‹ ğ”¼[ğ‘‹ ] + ğ”¼[ğ‘‹2] ğ”¼[ğ‘2 = ğ”¼[ğ‘‹2] ğ”¼[ğ‘Œ 2 ] + 2ğ”¼[ğ‘Œ 2 = ğ”¼[ğ‘Œ 2 = ğ”¼[ğ‘Œ 2 ] 2ğ”¼[ğ‘Œğ‘] Consider the sigma-algebra = ğœ( ). Let ğ‘Š = ğ”¼[ğ‘‹ Consider the limit sigma-algebra generated by all the information. Let Then and . We have ğ”¼[ğ‘‹ and ğ”¼[ğ‘‹ ] = ğ‘Œ ]. ] and ğ”¼[ğ‘ Consider ğ”¼[ğ‘Œ Let = ğœ( ). Consider ğ”¼[ğ‘‹ ]. Consider the sequence of pairs (ğ‘Œğ‘˜, ğ‘ğ‘˜). If the limits are the same, then for any bounded measurable function ğ‘“ , ğ”¼[ğ‘“ (ğ‘Œ)] = ğ”¼[ğ‘“ (ğ‘)]. Consider the sigma-algebra = ğœ( ğœ(ğ‘Œ0, ğ‘0, )). Then both ğ‘Œ Consider ğ”¼[(ğ‘Œğ‘› ğ‘ğ‘›)2]. Let = ğœ( ). Consider ğ‘Š = ğ”¼[ğ‘‹ Then ğ”¼[ğ‘Š ])2] + 2ğ”¼[ğ‘Œğ‘‹ ğ‘Œğ‘ ğ‘‹2 + ğ‘‹ğ‘] ] + 2ğ”¼[ğ‘Œğ‘‹] 2ğ”¼[ğ‘Œğ‘] 2ğ”¼[ğ‘‹2] + 2ğ”¼[ğ‘‹ğ‘] = ğœ(, , ğ‘Œ0, ğ‘0, ğ‘Œ1, ğ‘1, ). ] 2ğ”¼[ğ‘Œğ‘] + 2ğ”¼[ğ‘2 ] ] ğ”¼[ğ‘2 ] + ğ”¼[ğ‘2 are measurable with respect to . ]. ] = ğ”¼[ğ‘‹ ] and ğ”¼[ğ‘Š ] = ğ”¼[ğ‘‹ ] = ğ‘ and ğ‘ ]. ]. . 24 s1: Simple test-time scaling . ]. = ğœ(, ğ‘Œ0, ğ‘Œ1, ). ğ‘›]. ğ‘›] and ğ‘ = limğ‘› ğ”¼[ğ‘‹ = ğœ( ğœ(ğ‘Œ0, ğ‘0, )). , ğ‘0, ] = ğ‘Œğ‘›+1 . , ğ‘Œ0, ] = ğ‘ğ‘›+ , ğ‘0, ] = ğ”¼[ğ‘‹ , ğ‘Œ0, ] = ğ”¼[ğ‘‹ Consider the limit sigma-algebra = ğœ( ğœ(ğ‘Œ0, ğ‘0, )). We have ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )] and ğ‘ = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1, )]. Let = ğœ(, ğ‘0, ğ‘1, ) ğœ(, ğ‘Œ0, ğ‘Œ1, ). Consider ğ”¼[ğ‘‹ Consider the random variable ğ‘‹. Then ğ‘Œ = limğ‘› ğ”¼[ğ‘‹ Let Consider ğ¸ = {ğœ” ğ‘Œ(ğœ”) ğ‘(ğœ”)}. Suppose ğ‘ƒ (ğ¸) > 0. Consider the conditional expectation with respect to the join of the sigma-algebras. = ğœ(, , ğ‘Œ0, ğ‘0, ). Let Consider ğ”¼[ğ‘‹ ]. Then ğ”¼[ğ”¼[ğ‘‹ ] And ğ”¼[ğ”¼[ğ‘‹ ] So ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )] and ğ‘ = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1, )]. = ğœ(, ğ‘0, ğ‘1, ) and Let ]. Consider ğ”¼[ğ‘‹ . Then ğ”¼[ğ”¼[ğ‘‹ ] = ğ‘Œ ] = ğ”¼[ğ‘‹ ] . And ğ”¼[ğ”¼[ğ‘‹ ] = ğ‘ ] = ğ”¼[ğ‘‹ ] This means ğ‘Œ = ğ”¼[ğ‘‹ ] a.s. and ğ‘ = ğ”¼[ğ‘‹ Therefore, ğ‘Œ = ğ‘ a.s. Solution: ğ‘˜ = ğœ(, ğ‘0, , ğ‘ğ‘˜1) are increasing as ğ‘˜ increases. Since ğ‘‹ is integrable, by the (a) For the sequence ğ‘Œğ‘˜ ğ‘˜] converges almost surely and in Martingale Convergence Theorem for conditional expectations, the sequence ğ‘Œğ‘˜ = ğ”¼[ğ‘‹ ğ‘˜ = ğœ(, ğ‘Œ0, , ğ‘Œğ‘˜1) are increasing. ğ¿1 to ğ‘Œ = ğ”¼[ğ‘‹ğœ(, ğ‘0, ğ‘1, )]. Similarly, for the sequence ğ‘ğ‘˜ Since ğ‘‹ is integrable, by the Martingale Convergence Theorem, the sequence ğ‘ğ‘˜ = ğ”¼[ğ‘‹ ğ‘˜] converges almost surely and in ğ¿1 to ğ‘ = ğ”¼[ğ‘‹ğœ(, ğ‘Œ0, ğ‘Œ1, )]. (b) Let ğœ-algebra = We have Since ğ‘Š is -measurable, ğ”¼[ğ‘Š already However, we know that ğ”¼[ğ‘Œ Consider ğ”¼[ğ‘‹ ]. Then ğ”¼[ğ”¼[ğ‘‹ ] = ğ”¼[ğ‘‹ ] This implies that ğ”¼[ğ‘‹ ] = ğ‘Œ Similarly, ğ”¼[ğ”¼[ğ‘‹ ] = ğ”¼[ğ‘‹ ] This implies that ğ”¼[ğ‘‹ ] = ğ‘ Therefore, ğ‘Œ = ğ‘ almost surely. Final Answer: The final answer is ğ‘Œ = ğ‘ ] ] = ğ‘Œ ] = ğ”¼[ğ‘‹ is the conditional expectation of ğ‘Š given implies that ğ‘Œ -measurable, which is not necessarily true. ] = ğ‘Š if ğ‘Š is and ğ”¼[ğ‘ ] = ğ”¼[ğ”¼[ğ‘‹ ] = ğ‘Œ -measurable, we have ğ”¼[ğ‘Š ] = ğ‘Œ = ğœ(, ğ‘Œ0, ğ‘Œ1, ). We have ğ‘Œ = ğ”¼[ğ‘‹ ]. = ğœ(, , ğ‘Œ0, ğ‘0, ğ‘Œ1, ğ‘1, ). Consider ğ‘Š = ğ”¼[ğ‘‹ ] = ğ‘Œ almost surely. . ] = ğ‘ almost surely. ]. Consider the ] and ğ‘ = ğ”¼[ğ‘‹ , so ğ”¼[ğ‘Š = ğœ(, ğ‘0, ğ‘1, ) and , the ğœ-algebras , the ğœ-algebras . But since ğ‘Œ ] = ğ‘ ] a.s. is . . . 25 s1: Simple test-time scaling Table 9. s1K sample stemming from s1-teasers. The black text is the question and the yellow text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with Gemini, which we use for training. Alice and Bob each have coin and flip it until they get heads. If Bob flipped his coin more times than Alice, what is the expected number of times Alice flipped her coin? 4/3 . The problem asks for the expected number of times Alice flipped her coin, given that Bob flipped his coin more times than Alice. Let ğ‘‹ be the number of flips Alice makes until she gets head. Let ğ‘Œ be the number of flips Bob makes until he gets head. ğ‘‹ and ğ‘Œ are independent random variables following geometric distribution with parameter ğ‘ = 0.5 (probability of getting head). The probability mass function for geometric distribution is ğ‘ƒ (ğ¾ = ğ‘˜) = (1 ğ‘)ğ‘˜1ğ‘, for ğ‘˜ = 1, 2, . In this case, ğ‘ = 0.5, so ğ‘ƒ (ğ¾ = ğ‘˜) = (0.5)ğ‘˜1(0.5) = (0.5)ğ‘˜ = 1 2ğ‘˜ We are given the condition that Bob flipped his coin more times than Alice, which means ğ‘Œ > ğ‘‹. We want to find the expected value of ğ‘‹ given that ğ‘Œ > ğ‘‹, i.e., ğ¸[ğ‘‹ğ‘Œ > ğ‘‹]. The formula for conditional expectation is ğ¸[ğ‘‹ğ´] = Also, ğ‘ƒ (ğ‘‹ = ğ‘¥ğ´) = ğ‘ƒ (ğ‘‹=ğ‘¥ğ´) In our case, ğ´ is the event ğ‘Œ > ğ‘‹. We need to find ğ‘ƒ (ğ‘Œ > ğ‘‹). ğ‘ƒ (ğ‘Œ > ğ‘‹) = ğ‘¥=1 Since ğ‘‹ and ğ‘Œ are independent, ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ = ğ‘¦) = ğ‘ƒ (ğ‘‹ = ğ‘¥)ğ‘ƒ (ğ‘Œ = ğ‘¦) = 1 2ğ‘¥ ğ‘ƒ (ğ‘Œ > ğ‘‹) = 2ğ‘¥+ğ‘¦ = 1 ğ‘¥=1 ğ‘¥=1 2ğ‘¥ The inner sum is geometric series: ğ‘¦=ğ‘¥+1( 1 2 This is geometric series with first term ğ‘ = ( 1 2 ( 1 )ğ‘¥+1 2 = 1 1 2 So, ğ‘ƒ (ğ‘Œ > ğ‘‹) = 2ğ‘¥ ( 1 ğ‘¥=1 2 This is another geometric series with first term ğ‘ = 1 4 1 ğ‘¦=ğ‘¥+1 2ğ‘¦ )ğ‘¦ = ( 1 )ğ‘¥+1 + ( 1 2 2 )ğ‘¥+1 and common ratio ğ‘Ÿ = 1 2 and common ratio ğ‘Ÿ = 1 4 = ( 1 2 )ğ‘¥ = ğ‘¦=ğ‘¥+1 ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ = ğ‘¦) ğ‘¥ ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥ğ´). 2ğ‘¦ = 1 2ğ‘¥+ğ‘¦ )ğ‘¥+2 + The sum is ğ‘¥=1( )ğ‘¥+1 1 2 ğ‘ 1ğ‘Ÿ ğ‘¦=ğ‘¥+1 )ğ‘¥. )ğ‘¥. ğ‘ƒ (ğ´) ( 1 2 = 1 1 4 . . . . )ğ‘¥+2 + = ( 1 = 3( 1 4 )ğ‘¥. )ğ‘¥ = 3 ğ‘¥=1 ğ‘¥( 1 4 )ğ‘¥. )ğ‘¥. 1 4 1 1 4 1 4 3 4 . 2 2 = = ğ‘ 1ğ‘Ÿ The sum is ğ‘¦=ğ‘¥+1 )ğ‘¥. 2ğ‘¦ = ( 1 )ğ‘¥+1 + ( 1 2 ğ‘¦=ğ‘¥+1 ğ‘ƒ (ğ‘Œ = ğ‘¦) = )ğ‘¥ = ( 1 2ğ‘¥ ( 1 4 = 1 3 Now, we need to find ğ‘ƒ (ğ‘‹ = ğ‘¥ ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ > ğ‘¥). ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ > ğ‘¥) = ğ‘ƒ (ğ‘‹ = ğ‘¥)ğ‘ƒ (ğ‘Œ > ğ‘¥), due to independence. ğ‘ƒ (ğ‘Œ > ğ‘¥) = So, ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ > ğ‘¥) = 1 Now, we can find ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘‹=ğ‘¥ğ‘Œ >ğ‘‹) Finally, we can calculate the conditional expectation: ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = Consider the series ğ‘† = ğ‘† = ğ‘Ÿ + 2ğ‘Ÿ2 + 3ğ‘Ÿ3 + 4ğ‘Ÿ4 + ğ‘† = 1 + 2ğ‘Ÿ + 3ğ‘Ÿ2 + 4ğ‘Ÿ3 + ğ‘Ÿ Consider the geometric series ğº = 1 + ğ‘Ÿ + ğ‘Ÿ2 + ğ‘Ÿ3 + = 1 1ğ‘Ÿ Differentiating with respect to ğ‘Ÿ: ğ‘‘ğº ğ‘‘ğ‘Ÿ So, ğ‘† ğ‘Ÿ ğ‘¥=1 ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = ğ‘Ÿ < 1. ğ‘¥=1 ğ‘¥ğ‘Ÿğ‘¥, where ( 1 1ğ‘Ÿ , which means ğ‘† = ğ‘Ÿ = 1 + 2ğ‘Ÿ + 3ğ‘Ÿ2 + 4ğ‘Ÿ3 + = ğ‘‘ ğ‘‘ğ‘Ÿ ) = 1 . ğ‘¥=1 ğ‘¥ 3( 1 ( 1 )ğ‘¥ 4 1 3 ğ‘ƒ (ğ‘Œ >ğ‘‹) (1ğ‘Ÿ) (1ğ‘Ÿ)2 = 4 . . = 1 In our case, ğ‘Ÿ = 1 (1ğ‘Ÿ)2 . 26 s1: Simple test-time scaling . . . . 4 4 )2 = = = 1 4 3 4 1 4 9 16 )ğ‘˜ = )ğ‘¥ = = 1. = 1 3 = 2 3 = 4 9 ğ‘˜=1( 1 4 1 1 4 1 4 ( 3 )2 4 ğ‘˜=1( 1 ğ‘¥=1 ğ‘¥( 1 16 9 = 4 3 = 1 4 = 12 be Bobs first flip. 2ğ‘˜ )2 = . This confirms our previous calculation. ğ‘˜=1 ğ‘ƒ (ğ‘‹ = ğ‘˜, ğ‘Œ = ğ‘˜) = ğ‘˜=1 ğ‘ƒ (ğ‘‹ = ğ‘˜)ğ‘ƒ (ğ‘Œ = ğ‘˜) = 1 4 (1 1 4 Therefore, ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = 3 4 9 Alternative approach: Symmetry. Consider the events ğ‘Œ > ğ‘‹, ğ‘‹ > ğ‘Œ , and ğ‘‹ = ğ‘Œ . ğ‘ƒ (ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘‹ > ğ‘Œ ) due to symmetry. ğ‘ƒ (ğ‘‹ = ğ‘Œ ) = We have ğ‘ƒ (ğ‘Œ > ğ‘‹) + ğ‘ƒ (ğ‘‹ > ğ‘Œ ) + ğ‘ƒ (ğ‘‹ = ğ‘Œ ) = 1. ğ‘ƒ (ğ‘Œ > ğ‘‹) + ğ‘ƒ (ğ‘Œ > ğ‘‹) + 1 3 2ğ‘ƒ (ğ‘Œ > ğ‘‹) = 1 1 3 ğ‘ƒ (ğ‘Œ > ğ‘‹) = 1 3 Let ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = ğœ‡. We are looking for the expected number of flips Alice made, given Bob flipped more times. Consider the case where the first flip for both is tails. Then the process restarts, and the condition remains. Let ğ´1 be Alices first flip, ğµ1 ğ‘ƒ (ğ´1 = ğ») = 12, ğ‘ƒ (ğ´1 = ğ‘‡ ) = 12. ğ‘ƒ (ğµ1 = ğ») = 12, ğ‘ƒ (ğµ1 = ğ‘‡ ) = 12. Case 1: ğ´1 = ğ», ğµ1 = ğ». ğ‘‹ = 1, ğ‘Œ = 1, so ğ‘Œ > ğ‘‹ is false. Case 2: ğ´1 = ğ», ğµ1 = ğ‘‡ . Alice stops at 1, Bob continues. ğ‘Œ > 1. Case 3: ğ´1 = ğ‘‡ , ğµ1 = ğ». Bob stops at 1, Alice continues. Case 4: ğ´1 = ğ‘‡ , ğµ1 = ğ‘‡ . Both continue. Consider the conditional probabilities given ğ‘Œ > ğ‘‹. Let ğ¸ = ğ¸[ğ‘‹ğ‘Œ > ğ‘‹]. If the first flips are HH, the condition ğ‘Œ > ğ‘‹ is not met. If the first flips are HT, Alices number of flips is 1. If the first flips are TH, Bobs number of flips is 1, Alices is at least 2, so ğ‘Œ < ğ‘‹. If the first flips are TT, the problem restarts, and the expected number of additional flips for Alice is still ğ¸. Let ğ‘ğ´ We are given ğ‘ğµ > ğ‘ğ´ Consider the first flips: HH (prob 1/4): Condition not met. HT (prob 1/4): Alice flips 1 time. TH (prob 1/4): Bob flips 1 time, Alice > 1, so ğ‘ğ´ > ğ‘ğµ TT (prob 1/4): Both continue. Let ğ¸ be the expected number of Alices flips given Bob flipped more. If the first flips are HT, Alice flipped 1 time, and the condition is met. If the first flips are TT, the situation is the same as the beginning, so the expected number of additional flips for Alice is ğ¸. Consider the event ğ‘Œ > ğ‘‹. Conditioning on the first flips: ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ»ğ»]ğ‘ƒ (ğ»ğ»ğ‘Œ > ğ‘‹) + ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ»ğ‘‡ ]ğ‘ƒ (ğ»ğ‘‡ ğ‘Œ > ğ‘‹) + ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ‘‡ ğ»]ğ‘ƒ (ğ‘‡ ğ»ğ‘Œ > ğ‘‹) + ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ‘‡ ğ‘‡ ]ğ‘ƒ (ğ‘‡ ğ‘‡ ğ‘Œ > ğ‘‹) ğ‘ƒ (ğ‘Œ > ğ‘‹ğ»ğ») = 0. ğ‘ƒ (ğ‘Œ > ğ‘‹ğ»ğ‘‡ ) = 1. ğ‘ƒ (ğ‘Œ > ğ‘‹ğ‘‡ ğ») = 0. ğ‘ƒ (ğ‘Œ > ğ‘‹ğ‘‡ ğ‘‡ ) depends on the future flips. Lets use the definition of conditional expectation directly. ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = Consider the probabilities of the first flips given ğ‘Œ > ğ‘‹. ğ‘ƒ (ğ»ğ»ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘Œ >ğ‘‹ğ»ğ»)ğ‘ƒ (ğ»ğ») ğ‘ƒ (ğ»ğ‘‡ ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘Œ >ğ‘‹ğ»ğ‘‡ )ğ‘ƒ (ğ»ğ‘‡ ) be the number of flips Alice makes, ğ‘ğµ ğ‘¥=1 ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = be the number of flips Bob makes. ğ‘¥=1 ğ‘¥ ğ‘ƒ (ğ‘‹=ğ‘¥,ğ‘Œ >ğ‘¥) , condition not met. = 014 13 = 114 1 = 0. = 3 . 4 ğ‘ƒ (ğ‘Œ >ğ‘‹) ğ‘ƒ (ğ‘Œ >ğ‘‹) ğ‘ƒ (ğ‘Œ >ğ‘‹) . s1: Simple test-time scaling . 13 = 0. ğ‘ƒ (ğ‘Œ >ğ‘‹) ğ‘ƒ (ğ‘Œ >ğ‘‹) = 014 13 ğ‘ƒ (ğ‘‡ ğ»ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘Œ >ğ‘‹ğ‘‡ ğ»)ğ‘ƒ (ğ‘‡ ğ») ğ‘ƒ (ğ‘‡ ğ‘‡ ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘Œ >ğ‘‹ğ‘‡ ğ‘‡ )ğ‘ƒ (ğ‘‡ ğ‘‡ ) If the first flips are TT, the future behavior is the same, and the condition ğ‘Œ > ğ‘‹ holds if Bob takes more flips than Alice in the subsequent trials. ğ‘ƒ (ğ‘Œ > ğ‘‹ğ‘‡ ğ‘‡ ) = ğ‘ƒ (Bob needs more flips than Alice starting from scratch) = ğ‘ƒ (ğ‘Œ > ğ‘‹) = 13. ğ‘ƒ (ğ‘‡ ğ‘‡ ğ‘Œ > ğ‘‹) = (13)(14) = 1 4 Sum of conditional probabilities: 0 + 34 + 0 + 14 = 1. Now consider the conditional expectations of ğ‘‹: ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ»ğ»]: Not relevant since ğ‘ƒ (ğ»ğ»ğ‘Œ > ğ‘‹) = 0. ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ»ğ‘‡ ]: Given HT and ğ‘Œ > ğ‘‹, Alice flipped 1 time. ğ¸ = 1. ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ‘‡ ğ»]: Not relevant. ğ¸[ğ‘‹ğ‘Œ > ğ‘‹, ğ‘‡ ğ‘‡ ]: Given TT and ğ‘Œ > ğ‘‹, Alice has already flipped once, and the expected number of additional flips is ğ¸. So, the total number of flips is 1 + ğ¸. ğ¸ = 0 0 + 1 (34) + undefined 0 + (1 + ğ¸) (14) ğ¸ = 0 + 34 + 0 + 14 + ğ¸4 ğ¸ = 1 + ğ¸4 ğ¸ ğ¸4 = 1 3ğ¸4 = 1 ğ¸ = 43. This confirms the previous result. Lets think about the intuition. If we have the condition ğ‘Œ > ğ‘‹, it means Alice was \"lucky\" and got head early, or Bob was \"unlucky\". Consider the random variable ğ‘ = ğ‘Œ ğ‘‹. We are given ğ‘ > 0. We want ğ¸[ğ‘‹ğ‘ > 0]. Let ğ‘ = ğ‘ƒ (head) = 0.5. The number of tails before the first head follows geometric distribution with parameter ğ‘. ğ‘‹ 1 ğºğ‘’ğ‘œğ‘š(ğ‘), ğ‘Œ 1 ğºğ‘’ğ‘œğ‘š(ğ‘). ğ‘ƒ (ğ‘‹ 1 = ğ‘˜) = (1 ğ‘)ğ‘˜ğ‘. ğ‘ƒ (ğ‘‹ = ğ‘¥) = (1 ğ‘)ğ‘¥1ğ‘. Consider the joint distribution of ğ‘‹ and ğ‘Œ . ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ = ğ‘¦) = ğ‘2(1 ğ‘)ğ‘¥1(1 ğ‘)ğ‘¦1 Consider the event ğ‘Œ = ğ‘‹ + ğ‘˜, where ğ‘˜ 1. ğ‘ƒ (ğ‘Œ = ğ‘‹ + ğ‘˜) = = ğ‘2(1 ğ‘)ğ‘˜1 = ğ‘2(1 ğ‘)ğ‘˜1 = ğ‘(1ğ‘)ğ‘˜1 2ğ‘ If ğ‘ = 0.5, then 1 ğ‘ = 0.5, 2 ğ‘ = 1.5. ğ‘ƒ (ğ‘Œ = ğ‘‹ + ğ‘˜) = 0.5(0.5)ğ‘˜1 Check if = (0.5)ğ‘˜ 2ğ‘˜ 2 1.5 ğ‘˜=1 ğ‘ƒ (ğ‘Œ = ğ‘‹ + ğ‘˜) = ğ‘ƒ (ğ‘Œ > ğ‘‹) = 13. ğ‘¥=1((1 ğ‘)2)ğ‘¥1 = ğ‘2(1 ğ‘)ğ‘˜1 = ğ‘2(1 ğ‘)ğ‘˜1 1 1(1ğ‘)2 2ğ‘ğ‘2 = ğ‘2(1 ğ‘)ğ‘˜1 ğ‘¥=1 ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ = ğ‘¥ + ğ‘˜) = ğ‘¥=1 ğ‘2(1 ğ‘)ğ‘¥1(1 ğ‘)ğ‘¥+ğ‘˜1 1 1(12ğ‘+ğ‘2) = (12)ğ‘˜ 32 1 ğ‘(2ğ‘) = 1 = 32ğ‘˜1 1.5 1 3 . . = 1 3 2 = 2 3 . ğ‘˜=1 1 112 )ğ‘˜1 = 1 3 (1 + 12 + 14 + ) = 1 3 ğ‘¦=ğ‘¥+1(1 ğ‘)ğ‘¥1ğ‘(1 ğ‘)ğ‘¦1ğ‘ ğ‘¦=ğ‘¥+1(1 ğ‘)ğ‘¦1 ğ‘¥=1(1 ğ‘)ğ‘¥1 ğ‘˜=1( 1 32ğ‘˜1 = 1 2 Something is wrong here. Lets recalculate ğ‘ƒ (ğ‘Œ > ğ‘‹). ğ‘ƒ (ğ‘Œ > ğ‘‹) = ğ‘¥=1 = ğ‘2 Inner sum: (1 ğ‘)ğ‘¥ + (1 ğ‘)ğ‘¥+1 + = (1ğ‘)ğ‘¥ 1(1ğ‘) ğ‘ƒ (ğ‘Œ > ğ‘‹) = ğ‘2 = ğ‘(1 ğ‘) = ğ‘(1 ğ‘) If ğ‘ = 0.5, ğ‘ƒ (ğ‘Œ > ğ‘‹) = 0.5 1.5 ğ‘¥=1(1 ğ‘)ğ‘¥1 (1ğ‘)ğ‘¥ ğ‘¥=1((1 ğ‘)2)ğ‘¥1 = ğ‘(1 ğ‘) = ğ‘(1 ğ‘) = 1 3 = (1ğ‘)ğ‘¥ ğ‘ = ğ‘(1 ğ‘) ğ‘¥=1(1 ğ‘)2(ğ‘¥1) 1 1(1ğ‘)2 2ğ‘ğ‘2 = ğ‘(1 ğ‘) . Correct. 1 1(12ğ‘+ğ‘2) = 1ğ‘ 2ğ‘ 1 ğ‘(2ğ‘) 1 ğ‘ . . 28 s1: Simple test-time scaling ğ‘¦=ğ‘¥+1(1 ğ‘)ğ‘¦1ğ‘ = ğ‘[(1 ğ‘)ğ‘¥ + (1 ğ‘)ğ‘¥+1 + ] = ğ‘ (1ğ‘)ğ‘¥ 1(1ğ‘) = (1 ğ‘)ğ‘¥. ğ‘¥=1 ğ‘¥ ğ‘ƒ (ğ‘‹=ğ‘¥,ğ‘Œ >ğ‘¥) ğ‘ƒ (ğ‘Œ >ğ‘‹) . ğ‘¥=1 ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = Now, lets find ğ¸[ğ‘‹ğ‘Œ > ğ‘‹]. ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ > ğ‘¥) = ğ‘ƒ (ğ‘‹ = ğ‘¥)ğ‘ƒ (ğ‘Œ > ğ‘¥) (independence) ğ‘ƒ (ğ‘‹ = ğ‘¥) = (1 ğ‘)ğ‘¥1ğ‘. ğ‘ƒ (ğ‘Œ > ğ‘¥) = ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ > ğ‘¥) = (1 ğ‘)ğ‘¥1ğ‘(1 ğ‘)ğ‘¥ = ğ‘(1 ğ‘)2ğ‘¥1. ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = = 2ğ‘ 1ğ‘ ğ‘ƒ (ğ‘Œ > ğ‘¥) = (1ğ‘)ğ‘¥ 1(1ğ‘) ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = = ğ‘¥=1 ğ‘¥ğ‘(1 ğ‘)2ğ‘¥1 ğ‘¥=1 ğ‘¥((1 ğ‘)2)ğ‘¥ (error in power) ğ‘ = (1 ğ‘)ğ‘¥. 1 ğ‘ƒ (ğ‘Œ >ğ‘‹) ğ‘¥=1 ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥)ğ‘ƒ (ğ‘Œ > ğ‘¥) ğ‘(1 ğ‘)1 1 ğ‘ƒ (ğ‘Œ >ğ‘‹) 1 ğ‘ƒ (ğ‘Œ >ğ‘‹) ğ‘ ğ‘ƒ (ğ‘Œ >ğ‘‹) = ğ‘¥=1 ğ‘¥(1 ğ‘)ğ‘¥1ğ‘(1 ğ‘)ğ‘¥ ğ‘¥=1 ğ‘¥(1 ğ‘)2ğ‘¥1 (1 ğ‘)1 ğ‘¥=1 ğ‘¥((1 ğ‘)2)ğ‘¥. ğ‘ (1ğ‘)(2ğ‘) ğ‘¥=1 ğ‘¥((1 ğ‘)2)ğ‘¥ = = ğ‘ 2ğ‘ (1ğ‘)2 Let ğ‘Ÿ = (1 ğ‘)2. (1ğ‘Ÿ)2 1 ğ‘Ÿ = 1 (1 ğ‘)2 = 1 (1 2ğ‘ + ğ‘2) = 2ğ‘ ğ‘2 = ğ‘(2 ğ‘). (1 ğ‘Ÿ)2 = ğ‘2(2 ğ‘)2. ğ‘¥=1 ğ‘¥ğ‘Ÿğ‘¥ = ğ‘Ÿ . ğ‘¥=1 ğ‘¥((1 ğ‘)2)ğ‘¥ = (1ğ‘)2 ğ‘2(2ğ‘) ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = ğ‘ 2ğ‘ (1ğ‘)2 If ğ‘ = 0.5, ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = . (1ğ‘)2 ğ‘2(2ğ‘)2 = 1 ğ‘(2ğ‘) = 1 0.75 1 0.51.5 . = 1 34 = 43. ğ‘ƒ (ğ‘Œ >ğ‘‹) ğ‘¥=1 ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹). Solution: Let ğ‘‹ be the number of flips Alice makes until she gets head, and ğ‘Œ be the number of flips Bob makes until he gets head. ğ‘‹ and ğ‘Œ are independent geometric random variables with parameter ğ‘ = 0.5. The probability mass function is ğ‘ƒ (ğ¾ = ğ‘˜) = (1 ğ‘)ğ‘˜1ğ‘. We are interested in the expected number of times Alice flipped her coin, given that Bob flipped his coin more times than Alice, i.e., ğ¸[ğ‘‹ğ‘Œ > ğ‘‹]. Using the definition of conditional expectation, ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘‹=ğ‘¥,ğ‘Œ >ğ‘¥) . First, calculate ğ‘ƒ (ğ‘Œ > ğ‘‹). ğ‘ƒ (ğ‘Œ > ğ‘‹) = ğ‘¥=1 ğ‘ƒ (ğ‘‹ = ğ‘¥) = (0.5)ğ‘¥1(0.5) = (0.5)ğ‘¥ = 1 2ğ‘¥ ğ‘ƒ (ğ‘Œ > ğ‘¥) = ğ‘¦=ğ‘¥+1(0.5)ğ‘¦1(0.5) = (0.5)ğ‘¥. )ğ‘¥ = ğ‘ƒ (ğ‘Œ > ğ‘‹) = = 1 . ğ‘¥=1 3 Next, calculate ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ > ğ‘¥) = ğ‘ƒ (ğ‘‹ = ğ‘¥)ğ‘ƒ (ğ‘Œ > ğ‘¥) = 1 2ğ‘¥ ( 1 Now, find ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = ğ‘ƒ (ğ‘‹=ğ‘¥,ğ‘Œ >ğ‘¥) )ğ‘¥. Finally, calculate the conditional expectation: ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = Using the formula ğ‘¥=1 ğ‘¥ğ‘ƒ (ğ‘‹ = ğ‘¥ğ‘Œ > ğ‘‹) = ğ‘¥=1 ğ‘¥ğ‘Ÿğ‘¥ = ğ‘Ÿ ğ‘¦=ğ‘¥+1 ğ‘ƒ (ğ‘‹ = ğ‘¥, ğ‘Œ = ğ‘¦) = ğ‘¥=1 ğ‘ƒ (ğ‘‹ = ğ‘¥)ğ‘ƒ (ğ‘Œ > ğ‘¥). )ğ‘¥ = 14 114 ğ‘¥=1 ğ‘¥ 3( 1 )ğ‘¥ = 3 = (14)ğ‘¥ 13 )ğ‘¥ = ( 1 ğ‘¥=1 ğ‘¥( 1 = 3( 1 4 = 14 34 ğ‘¥=1( 1 2ğ‘¥ ( 1 ğ‘ƒ (ğ‘Œ >ğ‘‹) (1ğ‘Ÿ)2 )ğ‘¥. )ğ‘¥. 4 4 4 1 2 . with ğ‘Ÿ = 14: = 4 16 9 9 = 1 . 4 ğ‘¥=1 ğ‘¥( 1 )ğ‘¥ = 14 ğ¸[ğ‘‹ğ‘Œ > ğ‘‹] = 3 4 Final Answer: The final answer is 43 (34)2 = 14 (114)2 = 14 = 4 . 3 = 12 916 9 29 s1: Simple test-time scaling Table 10. s1K sample stemming from the astronomy subset of OlympicArena. The black text is the question and the blue text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with Gemini, which we use for training. An often-repeated fun fact is that humans produce more power per unit volume than stars. If the sun were the same size, but it produced the same amount of power per unit volume as human, what would its surface temperature be? Assume the \"average human\" produces 100 watts of power and has volume of 66400 cubic centimeters. A: 3500 B: 10000 C: 25000 D: 40000 E: 50000 Using the numbers from the problem, the average human produces ğ‘¢ = 100 66400 106 = 1506 Wm3 The volume of the sun is 4 3 ğœ‹ğ‘…3 , so its new power output would be ğ‘ƒ = 4 3 ğœ‹ğ‘…3 ğ‘¢. To find the equilibrium temperature, we use Solving for ğ‘‡ , we get ğ‘ƒ = ğœğ´ğ‘‡ 4 = 4ğœ‹ğœğ‘…2 ğ‘‡ 4 ğ‘…ğ‘¢ 3ğœ = 4 ğ‘‡ = 6.96 108) ( (1506) 5.67 108) = 49823 50000 K. ( The problem asks for the surface temperature of the sun if it had the same size but produced power per unit volume as human. First, lets find the power density of human. Power produced by human, ğ‘ƒâ„ğ‘¢ğ‘šğ‘ğ‘› = 100 Volume of human, ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› = 66400 cm3 Convert the volume to cubic meters: 1 = 100 cm 1 m3 = (100 cm)3 = 106 cm3 ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› = 66400 cm3 = 66400 106 m3 = 0.0664 m3 Power density of human, ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = ğ‘ƒâ„ğ‘¢ğ‘šğ‘ğ‘› ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = 1506.024 Wm3 Now, consider the sun with the same size as it currently is, but with power density equal to that of human. We need the radius of the sun to calculate its volume. The average radius of the sun is ğ‘…ğ‘ ğ‘¢ğ‘› = 6.95 108 m. Volume of the sun, ğ‘‰ğ‘ ğ‘¢ğ‘› = 4 3 ğ‘‰ğ‘ ğ‘¢ğ‘› = 4 3 ğ‘‰ğ‘ ğ‘¢ğ‘› = 1410.24 1024 ğœ‹ m3 ğ‘‰ğ‘ ğ‘¢ğ‘› = 4.4307 1027 m3 If the sun had the same power density as human, the total power produced by this modified sun would be: ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› ğ‘‰ğ‘ ğ‘¢ğ‘› ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 1506.024 Wm3 4.4307 1027 m3 ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 6.6726 1030 ğœ‹(337.159375 1024) m3 ğœ‹(6.95 108 m)3 = 100 0.0664 ğ‘ ğ‘¢ğ‘› = 4 ğœ‹ğ‘…3 3 30 s1: Simple test-time scaling . ğ‘ ğ‘¢ğ‘›ğœ: ğ‘ ğ‘¢ğ‘›ğœğ‘‡ 4 . The radius of the modified sun is the same as the actual sun, 3.441931011 = 1.9386 1019 ğ‘ ğ‘¢ğ‘› = (6.95 108)2 = 48.3025 1016 m2 ğ‘ ğ‘¢ğ‘› = 4ğœ‹ 48.3025 1016 = 607.08 1016 m2 ğ‘ ğ‘¢ğ‘›ğœ = 607.08 1016 m2 5.67 108 Wm2K4 ğ‘ ğ‘¢ğ‘›ğœ = 3441.93 108 WK4 = 3.44193 1011 WK The surface temperature of star is related to its luminosity (total power output) through the Stefan-Boltzmann law: ğ¿ = 4ğœ‹ğ‘…2ğœğ‘‡ 4 where ğ¿ is the luminosity (total power output), ğ‘… is the radius of the star, ğœ is the Stefan-Boltzmann constant, and ğ‘‡ is the surface temperature. In this case, the luminosity of the modified sun is ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› ğ‘…ğ‘ ğ‘¢ğ‘› The Stefan-Boltzmann constant, ğœ = 5.67 108 Wm2K4. ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 4ğœ‹ğ‘…2 6.6726 1030 = 4ğœ‹(6.95 108 m)2 5.67 108 Wm2K4 ğ‘‡ 4 Calculate the term 4ğœ‹ğ‘…2 ğ‘…2 4ğœ‹ğ‘…2 4ğœ‹ğ‘…2 4ğœ‹ğ‘…2 Now, substitute this back into the equation: 6.6726 1030 = 3.44193 1011 ğ‘‡ 4 Solve for ğ‘‡ 4: ğ‘‡ 4 = 6.67261030 Solve for ğ‘‡ : ğ‘‡ = (1.9386 1019)14 = (193.86 1017)14 ğ‘‡ = (1.9386)14 (1019)14 = (1.9386)0.25 104.75 Calculate (1.9386)0.25: Let ğ‘¦ = 1.93860.25, then ln ğ‘¦ = 0.25 ln(1.9386) ln(1.9386) 0.6619 ln ğ‘¦ = 0.25 0.6619 = 0.165475 ğ‘¦ = ğ‘’0.165475 1.1799 So, ğ‘‡ = 1.1799 104.75 = 1.1799 104 100.75 100.75 = 1034 = (103)14 = (1000)14 We know 54 = 625 and 64 = 1296, so (1000)14 is between 5 and 6. Alternatively, 100.75 = 100.5 100.25 = ğ‘‡ = 1.1799 104 5.62 = 6.63 104 = 66300 Lets double-check the calculations. Power density of human: ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = 1506.02 Wm3 Volume of sun: ğ‘‰ğ‘ ğ‘¢ğ‘› = 4.43 1027 m3 Power of modified sun: ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 1506.02 4.43 1027 = 6671.67 1027 = 6.67 1030 Stefan-Boltzmann law: ğ‘ƒ = 4ğœ‹ğ‘…2ğœğ‘‡ 4 ğ‘‡ 4 = ğ‘ƒ 4ğœ‹ğ‘…2 ğ‘‡ 4 = 6.671030 ğ‘‡ = (1.939 1019)14 = (193.9 1017)14 ğ‘‡ = (193.9)0.25 (1017)0.25 = (193.9)0.25 104.25 Calculate (193.9)0.25: Let ğ‘¦ = 193.90.25, then ln ğ‘¦ = 0.25 ln(193.9) ln(193.9) 5.267 ln ğ‘¦ = 0.25 5.267 = 1.31675 ğ‘¦ = ğ‘’1.31675 3.73 ğ‘‡ = 3.73 104.25 = 3.73 104 100.25 = 37300 1.778 = 66329 The result is around 66000 K. This is not among the options. Lets review the assumptions and calculations. Assumption: The sun radiates as black body, which is reasonable for estimating surface temperature. 4ğœ‹ğ‘…2ğœ ğ‘ ğ‘¢ğ‘›ğœ = 3.44 1011 3.441011 = 1.939 1019 10 100.25 3.16 1.778 = 5.62 31 s1: Simple test-time scaling Consider potential errors in calculations. Lets try simpler approach by setting up ratios. The power per unit volume of the modified sun is equal to that of human. ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› ğ‘‰ğ‘ ğ‘¢ğ‘› ğ‘ ğ‘¢ğ‘›ğœğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› . = ğ‘ƒâ„ğ‘¢ğ‘šğ‘ğ‘› ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› We also know ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 4ğœ‹ğ‘…2 4ğœ‹ğ‘…2 ğ‘ ğ‘¢ğ‘›ğœğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› 4 ğœ‹ğ‘…3 ğ‘ ğ‘¢ğ‘› = ğ‘ƒâ„ğ‘¢ğ‘šğ‘ğ‘› ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› 3ğœğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› ğ‘…ğ‘ ğ‘¢ğ‘› = ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘…ğ‘ ğ‘¢ğ‘› 3ğœ 35.67108 17.01108 = 1.04661012 1.701107 = 0.6153 1019 = 6.153 1018 ğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = Substitute the values: ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = 1506.02 Wm3 ğ‘…ğ‘ ğ‘¢ğ‘› = 6.95 108 ğœ = 5.67 108 Wm2K4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 1506.026.95108 ğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 10466.839108 ğ‘‡ 4 ğ‘‡ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = (6.153 1018)14 = (6153 1015)14 ğ‘‡ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = (6153)0.25 (1015)0.25 = (6153)0.25 103.75 Calculate (6153)0.25: Let ğ‘¦ = 61530.25, then ln ğ‘¦ = 0.25 ln(6153) ln(6153) 8.724 ln ğ‘¦ = 0.25 8.724 = 2.181 ğ‘¦ = ğ‘’2.181 8.85 ğ‘‡ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 8.85 103.75 = 8.85 103 100.75 = 8850 5.62 = 49737 This is close to option E: 50000 K. Lets re-check the units and calculations carefully. Power density of human: 100 0.0664 m3 = 1506.02 Wm3 ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘…ğ‘ ğ‘¢ğ‘› 3ğœ . = K4 m2 m2K4 Wm2K4 = 17.01108 = 0.061528 1020 = 6.1528 The formula derived was ğ‘‡ 4 = Units check: [ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘›] = Wm3 [ğ‘…ğ‘ ğ‘¢ğ‘›] = [ğœ] = Wm2K4 (Wm3)m Wm2K4 = Wm2 The units match for ğ‘‡ 4. Numerical calculation check: Numerator: 1506.02 6.95 108 = 10466.839 108 = 1.0466 1012 Denominator: 3 5.67 108 = 17.01 108 Ratio: 1.04661012 ğ‘‡ 4 = 6.1528 1018 ğ‘‡ = (6.1528 1018)14 = (6152.8 1015)14 ğ‘‡ = (6152.8)0.25 103.75 Lets use logarithms for precision. log10(6152.8) 3.789 0.25 3.789 = 0.94725 100.94725 8.856 ğ‘‡ = 8.856 103.75 = 8.856 103 100.75 = 8856 5.623 = 49806 This is very close to 50000 K. Possible sources of minor discrepancies: rounding errors, precision of constants. Lets verify the formula derivation. Power per unit volume = Total Power Volume 32 s1: Simple test-time scaling ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ = ğ¿ ğ‘‰ ğ¿ = 4ğœ‹ğ‘…2ğœğ‘‡ 4 ğ‘‰ = 4 ğœ‹ğ‘…3 3 ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ = 4ğœ‹ğ‘…2ğœğ‘‡ 4 ğœ‹ğ‘…3 If the modified sun has the power density of human: = 3ğœğ‘‡ 4 ğ‘… 4 3 3ğœğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› ğ‘…ğ‘ ğ‘¢ğ‘› ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘…ğ‘ ğ‘¢ğ‘› 3ğœ 18108 = 0.38 1019 = 3.8 ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = ğ‘‡ 4 ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = The formula derivation seems correct. Lets use approximate values to check the order of magnitude. ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› 103 Wm3 ğ‘…ğ‘ ğ‘¢ğ‘› 7 108 ğœ 6 108 Wm2K4 36108 = 71011 ğ‘‡ 4 1037108 ğ‘‡ (3.8 1018)14 = (3800 1015)14 ğ‘‡ (3800)0.25 103.75 (3800)0.25: 74 = 2401, 84 = 4096. So, between 7 and 8. 7.8 ğ‘‡ 7.8 103.75 = 7800 5.6 = 43680 The order of magnitude seems consistent with the detailed calculation. The problem statement is straightforward and doesnt seem to have any hidden complexities. The assumptions made are standard for such problems. Consider the precision of the given values. Power of human: 100 (exact) Volume of human: 66400 cm3 (exact) The result obtained is very close to option E. Given the nature of multiple-choice questions, the closest option is likely the intended answer. If there were any misinterpretations of the question, it would likely be in the setup. However, the phrase \"If the sun were the same size, but it produced the same amount of power per unit volume as human\" seems clear. The surface temperature is calculated using the Stefan-Boltzmann law, assuming black-body radiation. Double-check the provided options: A: 3500 B: 10000 C: 25000 D: 40000 E: 50000 Our calculated value is approximately 49800 K, which is closest to 50000 K. If we used more precise values for the constants, the result might be slightly different, but likely not enough to shift to another option. The fun fact mentioned in the question implies that the power density of human is higher than that of the sun. Lets verify this. Power output of the sun: 3.846 1026 Volume of the sun: 4.43 1027 m3 Power density of the sun: 3.8461026 Power density of human: 1506 Wm3 Indeed, the power density of human is significantly higher than that of the sun. Final check of the calculation steps and logic. The approach of equating the power density of the modified sun to that of human and then using the Stefan-Boltzmann law seems correct. 4.431027 = 0.868 Wm3 33 s1: Simple test-time scaling Solution: The power produced by an average human is ğ‘ƒâ„ğ‘¢ğ‘šğ‘ğ‘› = 100 W, and the volume of an average human is ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› = 66400 cm3 = 0.0664 m3. The power density of human is ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = ğ‘ƒâ„ğ‘¢ğ‘šğ‘ğ‘› = 100 ğ‘‰â„ğ‘¢ğ‘šğ‘ğ‘› If the sun were the same size but produced the same amount of power per unit volume as human, its power density would be ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› The radius of the sun is ğ‘…ğ‘ ğ‘¢ğ‘› = 6.95 108 m. The volume of the sun is ğ‘‰ğ‘ ğ‘¢ğ‘› = 4 ğœ‹ğ‘…3 3 The power density of the modified sun is given by ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = We also know that ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› = 4ğœ‹ğ‘…2 Equating the power density: ğ‘ ğ‘¢ğ‘›ğœğ‘‡ 4, where ğ‘‡ is the surface temperature of the modified sun. 0.0664 m3 1506.02 Wm3. ğ‘ƒğ‘šğ‘œğ‘‘ğ‘–ğ‘“ ğ‘–ğ‘’ğ‘‘_ğ‘ ğ‘¢ğ‘› ğ‘‰ğ‘ ğ‘¢ğ‘› ğ‘ ğ‘¢ğ‘› . . . 4ğœ‹ğ‘…2 4 3 ğ‘ ğ‘¢ğ‘›ğœğ‘‡ 4 ğœ‹ğ‘…3 = 3ğœğ‘‡ 4 ğ‘…ğ‘ ğ‘¢ğ‘› ğ‘ ğ‘¢ğ‘› ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘› = Solving for ğ‘‡ 4: ğœŒğ‘ğ‘œğ‘¤ğ‘’ğ‘Ÿ,â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘…ğ‘ ğ‘¢ğ‘› ğ‘‡ 4 = 3ğœ Substitute the values: ğ‘‡ 4 = 1506.02 Wm36.95108 35.67108 Wm2K4 ğ‘‡ 4 = 1.04661012 1.701107 = 6.1528 1018 K4 Solving for ğ‘‡ : ğ‘‡ = (6.1528 1018)14 = (6152.8)0.25 10184 = (6152.8)0.25 104.5 Using logarithms: log10(6152.8) 3.789 0.25 3.789 = 0.94725 (6152.8)0.25 = 100.94725 8.856 ğ‘‡ = 8.856 104.5 = 8.856 104 100.5 = 88560 Lets redo the exponent calculation: 184 = 4.5. ğ‘‡ = 8.856 104.5 = 8.856 104 100.5 - error in previous step. ğ‘‡ = (6.1528 1018)0.25 = 49806 The surface temperature would be approximately 49806 K, which is closest to 50000 K. Final Answer: The final answer is ğ¸ 10 88560 3.16 = 280000 34 s1: Simple test-time scaling D. Test-time scaling details D.1. Sequential scaling ablations <im_start>user What is the answer to Life, the Universe and Everything? Think for up to 2048 tokens. <im_start>assistant <im_start>think Let me break down this question into the three parts it is asking for: 1) Life 2) Universe 3) Everything Let me start with life... <im_start>answer The answer is... <im_start>user What is the answer to Life, the Universe and Everything? Think for up to 64 steps. <im_start>assistant <im_start>64 steps left Let me break down this question into the three parts it is asking for: 1) Life 2) Universe 3) Everything <im_start>63 steps left Let me start with life... <im_start>answer The answer is... Figure 10. Token and step instruction data formats for controlling test-time compute. We only train our model on the reasoning trace and the answer. Table 11. Scaling thinking time via tokens-conditional control. All metrics are averaged over the 30 questions in AIME24. Tokens instructed () 2048 4096 8192 16384 No intervention at test-time Thinking tokens Answer tokens AIME 7939 689 26.7 7158 669 30.0 8263 659 33.3 7108 722 33.3 Thinking tokens Answer tokens AIME24 Forcing end of thinking when token budget is reached 5664 722 33. 4031 142 33.3 2048 15 30.0 1024 15 3.3 7500 724 40.0 6330 691 40.0 Token-conditional control One general approach is to simply tell model in the prompt precisely how many tokens it should generate. Ideally, the model can keep track of its token count and adjust its generation to finish within the desired limits. We experiment with this approach by training model with token instructions using the format in Figure 10 (left). We bucket the lengths of the reasoning traces from our 1,000 training examples into powers of two (rounded upwards) and add corresponding instruction to the user prompt. For example, if the instruction says Think for up to 2048 tokens, then the reasoning trace has anywhere between 1024 and 2048 tokens. In Table 11, we show that after training the model hardly follows the token instruction. It does sometimes generate more tokens when given higher limit but often overshoots the limit. This may not be unique to our model as prior work suggests that OpenAI o1-mini can also not follow token instructions (Zhang & Chen, 2024). To prevent exceeding the limit, we test budget forcing the thinking to end once the limit is reached. This leads to perfect control (Table 11 (lower)). With budget forcing, the scaling trend is also clearer as the model can no longer overshoot the limit when given small thinking budget. This leads to better test-time scaling values for Token Prompting + budget forcing in Table 3. To compute Control reported in Table 3 for token-conditional control variants we divide the number of times the thinking tokens in Table 11 are less than the upper limit by the total evaluations (2/5 for without intervention; 5/5 for with intervention). Step-conditional control Token instructions fail as current models cannot count tokens. To accommodate this lack of capability, we experiment with making the counting more coarse-grained. We partition the reasoning traces into steps and ask the model to think for specific number of steps rather than tokens. We split our reasoning traces on double newlines into steps, which we find act as intuitive separators based on manual inspection of samples. We bucket our training samples into powers of 2 depending on their number of steps and add corresponding step instruction following the format in Figure 10 (right). This format is based on early experiments, where we found the model to be more likely to adhere to the step limit 35 s1: Simple test-time scaling Table 12. Scaling thinking time via step-conditional control. All metrics are averaged over the 30 samples in AIME24. Token counts ignore the thinking and step delimiters. Steps instructed () 32 64 128 256 Steps used Tokens per step Thinking tokens Answer tokens AIME24 No intervention at test-time 80 69 5396 735 33. 90 70 6277 653 23.3 123 60 7252 665 33.3 82 66 5552 777 36.7 Steps used Tokens per step Thinking tokens Answer tokens AIME24 Forcing end of thinking when 0 steps are reached 78 70 5409 794 36.7 59 80 4636 799 33. 32 94 2963 788 23.3 16 96 1517 1111 23.3 136 56 7551 754 33.3 136 56 7551 754 33.3 Table 13. Scaling thinking time via class-conditional control. We report accuracy / average thinking tokens per sample; the higher the accuracy and the fewer the thinking tokens (inference cost) the better. Prompt appended to the question after two newlines AIME24 MATH GPQA Answer after short amount of thinking. Do not spend excessive time double-checking your work. 30.0% / 8033 90.4% / 2537 56.6% / 4177 Answer after long amount of thinking. If you feel like you are finished early, spend the extra time trying to doublecheck your work until you are absolutely sure that you have the correct answer. Without generic prompt appending 36.7% / 9651 91.4% / 3875 51.0% / 4827 50.0% / 6109 93.0% / 3298 57.6% / 36 s1: Simple test-time scaling when counting down (3 steps left...2 steps left) rather than counting up (Step2...Step3...). This is likely because if counting down, the final step is always 1, which will act as strong prior to the model to finish its generation. If counting up, the final step before the answer varies, thus if the model does not remember the original step instruction, it may fail to stop. We conclude the following from our results in Table 12: (1) The model still struggles to adhere to the step limit. The model sometimes simply continues counting into negative steps, e.g. -1 steps left. To solve this issue, we automatically stop the thinking process once 0 steps are reached and then force the model to transition to answering mode by appending the answer token delimiter (3). This leads to perfect step adherence (lower half of Table 12), yet problems remain. (2) The model compensates for fewer steps by making each step longer. For example, when forced to use up to 16 steps vs 256 steps, the model generates an average of 96 tokens per step vs 56. Despite this issue, more steps still clearly correlate with more total thinking tokens in Table 12 and better performance leading to positive slope (3) Step instructions are more costly than other methods. The step delimiters require around 6 tokens each which for e.g. 64 steps adds up to total of around 380 tokens. When ignoring the step delimiters in token counts as in Table 12, the model still requires 7551 thinking tokens on average to achieve only 33.3% on AIME24. To compute Control reported in Table 3 for step-conditional control variants, we first decide that 100 tokens are an upper limit per step and then multiply this number by the steps instructed to arrive at proxy total token limit, e.g. 1600 for 16 steps instructed. We then check whether the thinking tokens in Table 12 fit within the respective limit for each evaluation run (3/5 for without intervention; 5/5 for with intervention). For the model in Figure 7, we use model with step-conditional control trained on an earlier version of our data and using an earlier version of our evaluation codebase. Class-conditional control OpenAI exposes test-time compute control to users via reasoning_effort API parameter with three possible settings: low, medium, and high.3 The OpenAI documentation also states that Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in response.\" suggesting that they are unable to control test-time compute with guarantees. Thus, maybe OpenAI simply adjusts the prompt or system instruction depending on the reasoning effort desired. In Table 13, we show that separate prompts for short and long thinking allow us to control thinking time to some extent: Prompting the model to think for longer leads to longer thinking. However, it does not reliably improve performance and control is not precise. The current adherence to control may suffice when we only have three classes, but it might not scale to finer-grained classes. To compute Control reported in Table 3 for this method, we assume that prompting the model to think for short time in Table 13 should produce fewer tokens than the default for AIME24, while the long prompt should produce more. As 8033 > 6109 and 9651 > 6109, one out of two follows our expected control thus Control is 50%. D.2. Examples for rejection sampling ablation 3https://github.com/openai/openai-python/blob/44d6210f101abedeb2dd68507fcffcb329df70ea/ src/openai/types/chat/completion_create_params.py#L172 37 s1: Simple test-time scaling Table 14. Answers generated by an earlier version of s1-32B when rejection sampling on AIME24. The black text is the question and the yellow text is the solution. Based solely on the question we generate the light blue reasoning trace and blue response with s1-32B using temperature of 1. We generate until the reasoning trace has less than 4000 tokens for the first and less than 8000 tokens for the second example. It required on average 199 (1) tries per example until thinking was 4000 ( 8000 tokens). 3 2 , 0), and ğµ(0, Let ğ‘‚(0, 0), ğ´( 1 ) be points in the coordinate plane. Let be the family of segments ğ‘ƒ ğ‘„ of unit length 2 lying in the first quadrant with ğ‘ƒ on the ğ‘¥-axis and ğ‘„ on the ğ‘¦-axis. There is unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that does not belong to any segment from other than ğ´ğµ. Then ğ‘‚ğ¶ 2 = ğ‘ , where ğ‘ and ğ‘ are relatively prime positive ğ‘ integers. Find ğ‘ + ğ‘. 23 [Correct generation with 3981 thinking tokens and 1055 answer tokens] The problem asks for point ğ¶ on the segment ğ´ğµ that is not contained in any other segment from the family , except for ğ´ğµ itself. The points ğ‘‚, ğ´, ğµ form triangle in the first quadrant. ğ‘‚ = (0, 0) ğ´ = ( 1 , 0) 2 3 ğµ = (0, 2 The segment ğ´ğµ connects ğ´( 1 , 0) and ğµ(0, 2 The equation of the line containing ğ´ğµ can be found using the two points: 3 2 ). ) Slope ğ‘š = 3 0 2 0 1 2 = 3(ğ‘¥ 1 2 3 2 Using the point-slope form ğ‘¦ ğ‘¦1 = ğ‘š(ğ‘¥ ğ‘¥1) with point ğ´( 1 2 ğ‘¦ 0 = ) , 0): ). 3ğ‘¥ + 3 2 ğ‘2 + ğ‘2 = 1. (ğ‘ 0)2 + (0 ğ‘)2 = ğ‘¦ = The segment ğ´ğµ lies in the first quadrant and connects ( 1 , 0) to (0, 2 The family consists of segments ğ‘ƒ ğ‘„ of unit length, where ğ‘ƒ is on the ğ‘¥-axis and ğ‘„ is on the ğ‘¦-axis. Let ğ‘ƒ = (ğ‘, 0) and ğ‘„ = (0, ğ‘). The length of ğ‘ƒ ğ‘„ is So ğ‘2 + ğ‘2 = 1. Since ğ‘ƒ is on the positive ğ‘¥-axis and ğ‘„ is on the positive ğ‘¦-axis, we have ğ‘ > 0 and ğ‘ > 0. The segment ğ‘ƒ ğ‘„ connects (ğ‘, 0) and (0, ğ‘). The equation of the line containing ğ‘ƒ ğ‘„ is ğ‘¥ ğ‘ The region covered by the family is the area bounded by the lines containing these segments. The endpoints (ğ‘, 0) and (0, ğ‘) vary such that ğ‘2 + ğ‘2 = 1. Consider the parametrization ğ‘ = cos ğœƒ, ğ‘ = sin ğœƒ, where 0 < ğœƒ < ğœ‹ 2 The segment ğ‘ƒ ğ‘„ connects (cos ğœƒ, 0) and (0, sin ğœƒ). The equation of the line is We are looking for unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that does not belong to any segment from other than ğ´ğµ. Let ğ¶ be point on ğ´ğµ. We can parametrize the points on ğ´ğµ as (1 ğ‘¡)ğ´ + ğ‘¡ğµ for 0 ğ‘¡ 1. 3 ğ¶ = (1 ğ‘¡)( 1 2 2 Since ğ¶ is distinct from ğ´ and ğµ, we have 0 < ğ‘¡ < 1. Suppose the point ğ¶ lies on some segment ğ‘ƒ ğ‘„ , where ğ‘ƒ = (cos ğœƒ, 0) and ğ‘„ = (0, sin ğœƒ). The point ğ¶ satisfies the equation ğ‘¥ cos ğœƒ + ğ‘¦ sin ğœƒ + ğ‘¦ sin ğœƒ ) = ( 1 2 , 0) + ğ‘¡(0, ğ‘¥ cos ğœƒ + ğ‘¦ ğ‘ 1 2 3 2 = 1. = 1. = 1. ğ‘¡). ğ‘¡, . 38 s1: Simple test-time scaling ğ‘¡ ğ‘¡ Plugging in the coordinates of ğ¶: 1 1 2 2 cos ğœƒ 3ğ‘¡ 1ğ‘¡ + 2 cos ğœƒ 2 sin ğœƒ Multiply by 2: 3 2 sin ğœƒ = 1 = 1 + + 3ğ‘¡ sin ğœƒ = 2 3ğ‘¡ cos ğœƒ = 2 sin ğœƒ cos ğœƒ 3ğ‘¡ cos ğœƒ = sin(2ğœƒ)2 1ğ‘¡ cos ğœƒ (1 ğ‘¡) sin ğœƒ + sin ğœƒ ğ‘¡ sin ğœƒ + We are looking for point ğ¶ on ğ´ğµ such that the only segment from containing ğ¶ is ğ´ğµ itself. The segment ğ´ğµ is part of the family . For ğ´ğµ, ğ‘ƒ = ğ´ = ( 1 , 0) and ğ‘„ = ğµ = (0, 2 3 Here ğ‘ = 1 . 2 2 3 ğ‘2 + ğ‘2 = ( 1 + 3 )2 + ( 4 2 2 The line segment ğ´ğµ connects ( 1 2 + ğ‘¦ The equation of the line is ğ‘¥ 12 = 1, which simplifies to 2ğ‘¥ + 2 3 ğ‘¦ = 1, or , 0) and (0, )2 = 1 4 3ğ‘¥ + ğ‘¦ = 3 3 2 3 2 , ğ‘ = = 1. 32 ). ). . + ğ‘¦ sin ğœƒ = 1. . = 3ğ‘¥ + ğ‘¥ cos ğœƒ 3 This matches the equation ğ‘¦ = 2 Consider the envelope of the family of lines Differentiating with respect to ğœƒ: + ğ‘¦ cos ğœƒ ğ‘¥ sin ğœƒ sin2 ğœƒ cos2 ğœƒ ğ‘¦ cos ğœƒ = ğ‘¥ sin ğœƒ sin2 ğœƒ cos2 ğœƒ ğ‘¦ cos3 ğœƒ = ğ‘¥ sin3 ğœƒ ğ‘¦ = tan3 ğœƒ ğ‘¥ tan ğœƒ = ( ğ‘¦ ğ‘¥ From the line equation: ğ‘¦ sin ğœƒ = sin ğœƒ cos ğœƒ ğ‘¥ sin ğœƒ ğ‘¦ = cos ğœƒ ğ‘¥ Substitute cos ğœƒ = )13 = 1 1+tan2 ğœƒ 1 1+(ğ‘¦ğ‘¥)23 ğ‘¥13 (ğ‘¥23+ğ‘¦23)12 cos ğœƒ = sin ğœƒ = tan ğœƒ cos ğœƒ = ( ğ‘¦ ğ‘¥ Substitute back into the line equation: ğ‘¥13 (ğ‘¥23+ğ‘¦23)12 = )13 ğ‘¦13 (ğ‘¥23+ğ‘¦23)12 = 1 + ğ‘¦ sin ğœƒ ğ‘¥ cos ğœƒ ğ‘¥(ğ‘¥23 + ğ‘¦23)12ğ‘¥13 + ğ‘¦(ğ‘¥23 + ğ‘¦23)12ğ‘¦13 = 1 ğ‘¥23(ğ‘¥23 + ğ‘¦23)12 + ğ‘¦23(ğ‘¥23 + ğ‘¦23)12 = 1 (ğ‘¥23 + ğ‘¦23)32 = 1 ğ‘¥23 + ğ‘¦23 = 1 The envelope of the family is the astroid ğ‘¥23 + ğ‘¦23 = 1. The segments from are tangent to this astroid. The point ğ¶ on ğ´ğµ that we are looking for is the point where ğ´ğµ is tangent to the astroid. The equation of ğ´ğµ is ğ‘¦ = 3ğ‘¥ + Substitute into the astroid equation: 3 2 3 . 3ğ‘¥ + )23 = 1 ğ‘¥23 + ( Let ğ‘¢ = ğ‘¥13 and ğ‘£ = ğ‘¦13. The astroid is ğ‘¢2 + ğ‘£2 = 1. The point ğ¶ lies on both the line ğ´ğµ and the astroid. Differentiating the astroid equation implicitly: ğ‘¥13 + 2 2 3 3 ğ‘¦ = ğ‘¦1 ğ‘¦13ğ‘¦ = 0 )13 ğ‘¥13 = ( ğ‘¦ ğ‘¥ 39 s1: Simple test-time scaling The slope of the tangent to the astroid at point (ğ‘¥, ğ‘¦) is 3 3. ğ‘¦ ğ‘¥ = 3. ğ‘¦ ğ‘¥ . 3 3 = The slope of the line ğ´ğµ is So, at the point of tangency, 3 ğ‘¦ ğ‘¥ = ( ğ‘¦ ğ‘¥ The point ğ¶ lies on the line ğ‘¦ = So ğ‘¦ = 3 Substitute into the line equation: 3)3 = 3ğ‘¥. 3 3ğ‘¥ + 3 2 and satisfies ğ‘¦ ğ‘¥ 3. = 3 3 2 . . . . 8 8 ğ‘¡). 8 ). 3 3 3ğ‘¥ + 3 2 ) = 3 3 , 3 1 ğ‘¡, 2 4 4ğ‘¡ = 1 3 = 4ğ‘¡ ğ‘¡ = 3 3ğ‘¥ = 3 3ğ‘¥ = ğ‘¥ + 1 2 4ğ‘¥ = 1 2 ğ‘¥ = 1 8 3( 1 Then ğ‘¦ = 3 8 The point ğ¶ is ( 1 8 We need to check if this point lies on the segment ğ´ğµ. The point ğ¶ is of the form ( 1 2 1 1 ğ‘¡ = 1 2 2 8 3 3 = 3 3 ğ‘¡ = 2 2 4 So ğ¶ lies on ğ´ğµ. We need to make sure 0 < ğ‘¡ < 1, which is true for ğ‘¡ = 3 4 Now, we need to check if this point ğ¶ does not belong to any other segment from . The point ğ¶ lies on the astroid. The segment ğ´ğµ is tangent to the astroid at ğ¶. Any other segment from that contains ğ¶ would have ğ¶ as an interior point, not tangent point. Consider the parametrization of the family . point (ğ‘¥, ğ‘¦) belongs to some segment in iff there exists ğœƒ such that For the point ğ¶ = ( 1 8 + 3 38 18 cos ğœƒ + 3 1 cos ğœƒ sin ğœƒ + 3 sin ğœƒ + 3 We know that ğ¶ lies on ğ´ğµ, which corresponds to some specific segment in . The problem statement assumes the existence and uniqueness of such point ğ¶. The unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that does not belong to any segment from other than ğ´ğµ. This means that if ğ¶ lies on another segment ğ‘ƒ ğ‘„ , then ğ‘ƒ ğ‘„ = ğ´ğµ. The point ğ¶ is the point of tangency of ğ´ğµ with the astroid. Now we need to find ğ‘‚ğ¶ 2. )2 + ( 3 )2 = 1 ğ‘‚ğ¶ 2 = ( 1 64 8 Here ğ‘ = 7 and ğ‘ = 16. ğ‘ and ğ‘ are relatively prime. ğ‘ + ğ‘ = 7 + 16 = 23. Final check of the reasoning: The family consists of unit-length segments with endpoints on the axes. The envelope of this family is the astroid ğ‘¥23 + ğ‘¦23 = 1. The segments from are tangent to the astroid. The segment ğ´ğµ is also member of the family . We are looking for point ğ¶ on ğ´ğµ that lies on the astroid. This point ğ¶ is the point of tangency of ğ´ğµ with the astroid. 3 cos ğœƒ = 8 sin ğœƒ cos ğœƒ 3 cos ğœƒ = 4 sin(2ğœƒ) sin ğœƒ 3 sin ğœƒ ), we have: + ğ‘¦ sin ğœƒ = 28 = 7 16 + 27 64 ğ‘¥ cos ğœƒ = 1. = 1 = 3 , 3 40 8 8 . s1: Simple test-time scaling 3. 3. and ğ¶ is the segment ğ´ğµ. is the segment ğ´ğµ. lies on ğ´ğµ, then the tangent to the astroid at ğ¶1 lies on ğ´ğµ, then the tangent to the astroid at ğ¶2 If point on ğ´ğµ lies on the astroid, it belongs to the tangent segment at that point. Since ğ´ğµ is the tangent segment, this point does not belong to any other segment from . Consider the case when the segment ğ´ğµ intersects the astroid at two points. If the segment ğ´ğµ is not tangent to the astroid, then there are two points of intersection. . Let the points of intersection be ğ¶1 If ğ¶1 If ğ¶2 The slope of ğ´ğµ is We found the point on the astroid with tangent slope The problem statement guarantees the uniqueness of such point ğ¶. The point ğ¶ must be interior to ğ´ğµ, so 0 < ğ‘¡ < 1. The parameter ğ‘¡ = 3 is in this range. 4 The point ğ¶ is distinct from ğ´ and ğµ. If ğ¶ = ğ´, then ğ‘¡ = 0, ğ¶ = ( 1 2 If ğ¶ = ğµ, then ğ‘¡ = 1, ğ¶ = (0, The point of tangency ğ¶ is the unique point on ğ´ğµ (excluding endpoints) that lies on the astroid. Solution: Let the family of segments be defined by segments ğ‘ƒ ğ‘„ of unit length with ğ‘ƒ on the positive ğ‘¥-axis and ğ‘„ on the positive ğ‘¦-axis. Let ğ‘ƒ = (ğ‘, 0) and ğ‘„ = (0, ğ‘). The length condition gives ğ‘2 + ğ‘2 = 1. The segment ğ‘ƒ ğ‘„ lies on the line ğ‘¥ = 1. ğ‘ Using the parametrization ğ‘ = cos ğœƒ, ğ‘ = sin ğœƒ with 0 < ğœƒ < ğœ‹ 2 The envelope of this family of lines is the astroid ğ‘¥23 + ğ‘¦23 = 1. The segments from are tangent to this astroid. The segment ğ´ğµ connects ğ´( 1 2 is part of the family . We are looking for unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that does not belong to any segment from other than ğ´ğµ. This means ğ¶ is the point where ğ´ğµ is tangent to the astroid. The slope of the tangent to the astroid at point (ğ‘¥, ğ‘¦) is 3 ğ‘¦ ğ‘¥ ). The equation of the line containing ğ´ğµ is ğ‘¦ = Setting the slopes equal: 3 . The slope of ğ´ğµ is , the equation of the line is , 0) and ğµ(0, . This segment , 0). 3 2 + ğ‘¦ sin ğœƒ ğ‘¦ ğ‘¥ ğ‘¥ cos ğœƒ + ğ‘¦ ğ‘ 3 2 3 2 = 1. 3ğ‘¥ + 3. ). = 3. = 3 3 ğ‘¦ ğ‘¥ 3 and satisfies ğ‘¦ = 3 2 3 4 2 3ğ‘¥ = 3ğ‘¥ + ğ‘¥ = 1 8 . 3ğ‘¥. The point ğ¶ lies on the line ğ‘¦ = 3 2 Substituting, 3 3ğ‘¥ + 3ğ‘¥ = ) = 3 3 3 , 3 . . ğ‘¡, 8 ). 3 2 1 2 1 2 3 2 ğ‘¡) for 0 ğ‘¡ 1. 3( 1 Then ğ‘¦ = 3 8 The point ğ¶ is ( 1 8 We need to check if ğ¶ lies on ğ´ğµ. The points on ğ´ğµ are ( 1 2 For ğ‘¥ = 1 ğ‘¡ = 1 ğ‘¡ = 3 , 1 8 2 8 4 3 ğ‘¡ = 3 3 For ğ‘¦ = 3 8 Since 0 < 3 4 The point ğ¶ is the unique point on ğ´ğµ (excluding endpoints) that lies on the astroid. The tangent to the astroid at ğ¶ is the segment ğ´ğµ. Thus, ğ¶ does not belong to any other segment from . )2 + ( 3 + 27 Finally, we calculate ğ‘‚ğ¶ 2 = ( 1 64 8 We have ğ‘ = 7 and ğ‘ = 16. These are relatively prime. ğ‘ + ğ‘ = 7 + 16 = 23. Final Answer: The final answer is 23 , < 1, ğ¶ is an interior point of ğ´ğµ. ğ‘¡ = 3 4 )2 = 1 64 = 7 16 = 28 3 8 8 . . s1: Simple test-time scaling [Incorrect generation with 5923 thinking tokens and 754 answer tokens] The problem asks for point ğ¶ on the segment ğ´ğµ such that ğ¶ is not on any other segment from the family , except ğ´ğµ itself. The family consists of segments ğ‘ƒ ğ‘„ of unit length, with ğ‘ƒ on the ğ‘¥-axis and ğ‘„ on the ğ‘¦-axis in the first quadrant. Let ğ‘ƒ = (ğ‘¥, 0) and ğ‘„ = (0, ğ‘¦), where ğ‘¥ > 0 and ğ‘¦ > 0. The length of the segment ğ‘ƒ ğ‘„ is 1, so the distance between ğ‘ƒ and ğ‘„ is 1. (ğ‘¥ 0)2 + (0 ğ‘¦)2 = 1 ğ‘¥2 + ğ‘¦2 = 1 ğ‘¥2 + ğ‘¦2 = 1 The segment ğ‘ƒ ğ‘„ lies in the first quadrant, so ğ‘¥ > 0 and ğ‘¦ > 0. The equation ğ‘¥2 + ğ‘¦2 = 1 represents the quarter circle in the first quadrant, with endpoints at (1, 0) and (0, 1). The points on the segment ğ‘ƒ ğ‘„ can be parameterized as (1 ğ‘¡)ğ‘¥ + ğ‘¡(0), (1 ğ‘¡)0 + ğ‘¡ğ‘¦) = (ğ‘¥(1 ğ‘¡), ğ‘¦ğ‘¡), where 0 ğ‘¡ 1. The segment ğ´ğµ connects ğ´( 1 , 0) and ğµ(0, 2 The equation of the line containing ğ´ğµ can be found using the two points: 3 2 ). Slope ğ‘š = 3 0 2 0 1 2 = 3 2 1 2 = 3. Using point-slope form with point ğ´( 1 2 , 0): ğ‘¦ 0 = ) 3(ğ‘¥ 1 2 3 2 . ğœ†, ğœ†). 3ğ‘¥ + 3 2 3 2 ) = ( 1 2 , 0) + ğœ†(0, ğ‘¦ = The segment ğ´ğµ lies in the first quadrant, between ğ‘¥ = 0 and ğ‘¥ = 1 2 Alternatively, we can parameterize the points on ğ´ğµ. Let ğ¶ be point on ğ´ğµ. Then ğ¶ = (1 ğœ†)ğ´ + ğœ†ğµ for some 0 ğœ† 1. ğ¶ = (1 ğœ†)( 1 1 2 2 We are looking for unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that does not belong to any segment from other than ğ´ğµ. Consider segment from , with endpoints ğ‘ƒ = (ğ‘¥, 0) and ğ‘„ = (0, ğ‘¦), where ğ‘¥2 + ğ‘¦2 = 1. point on this segment is of the form (ğ‘¥(1 ğ‘¡), ğ‘¦ğ‘¡), where 0 ğ‘¡ 1. We want to find point ğ¶ on ğ´ğµ, ğ¶ ğ´, ğµ, such that if ğ¶ lies on segment ğ‘ƒ ğ‘„ , then ğ‘ƒ ğ‘„ = ğ´ğµ. Let ğ¶ = ( 1 2 If ğ¶ lies on segment ğ‘ƒ ğ‘„ from , then there exist ğ‘¥, ğ‘¦ > 0 with ğ‘¥2 + ğ‘¦2 = 1, and ğ‘¡ [0, 1] such that: 1 1 2 2 3 2 From the first equation, 1 ğ‘¡ = ğœ†), where 0 < ğœ† < 1. ğœ† = ğ‘¥(1 ğ‘¡) ğœ† = ğ‘¦ğ‘¡ 1 2 3 2 ğœ†, 1 2 ğœ† . > 0, which implies 1 ğœ† > 0, or ğœ† < 1. This is consistent with the condition for point on ğ´ğµ. 1 2 ğ‘¥ ğœ† 3 2 ğ‘¦ = 1ğœ† 2ğ‘¥ . 3ğœ† 2ğ‘¦ From the second equation, ğ‘¡ = = Since ğ‘¡ [0, 1], we have 1 ğ‘¡ [0, 1]. Also, ğ‘¥ > 0, so 1ğœ† 2ğ‘¥ We have 1 ğ‘¡ = 1ğœ† 2ğ‘¥ 3ğœ† 2ğ‘¦ Adding these equations: 1 = 1ğœ† 2ğ‘¥ and ğ‘¡ = + . 3ğœ† 2ğ‘¦ 2ğ‘¥ğ‘¦ = (1 ğœ†)ğ‘¦ + 3ğœ†ğ‘¥ 42 s1: Simple test-time scaling . ). 3 2 and ğ‘¦ = , 0) to (0, We know ğ‘¥2 + ğ‘¦2 = 1. If the point ğ¶ belongs to the segment ğ´ğµ itself, then the endpoints of the segment are ğ´ and ğµ. So, the segment is from ( 1 2 3 Here, ğ‘¥ = 1 2 2 Check if ğ‘¥2 + ğ‘¦2 = 1: ( 1 = 1. So ğ´ğµ . 2 If ğ¶ belongs to another segment ğ‘ƒ ğ‘„ from , with endpoints ğ‘ƒ = (ğ‘¥, 0) and ğ‘„ = (0, ğ‘¦), where (ğ‘¥, ğ‘¦) ( 1 2 Consider the geometric interpretation. The family consists of segments of unit length with endpoints on the axes. The midpoints of these segments lie on the circle (ğ‘¥ 1 2 Let the point ğ¶ correspond to some ğœ†. If ğ¶ lies on ğ‘ƒ ğ‘„, then ğ¶ = (ğ‘¥(1 ğ‘¡), ğ‘¦ğ‘¡). So, 1 ğœ† = ğ‘¥(1 ğ‘¡) and )2 + (ğ‘¦ 1 2 )2 = 1 2 )2 = 1 4 ğœ† = ğ‘¦ğ‘¡. )2 + ( 1 2 + 3 4 3 2 3 2 3 2 ). . , and ğ‘¦ = 3 2 . . 3ğœ† 2ğ‘¦ and ğ‘¡ = We need to find ğœ† (0, 1) such that the only solution to these equations, with ğ‘¥2 + ğ‘¦2 = 1, ğ‘¥, ğ‘¦ > 0, is ğ‘¥ = 1 2 From the equations, 1 ğ‘¡ = 1ğœ† 2ğ‘¥ Substitute these into ğ‘¥2 + ğ‘¦2 = 1. Try different approach. Consider the tangents to the family of segments. The segments are formed by points (ğ‘¥, 0) and (0, ğ‘¦) with ğ‘¥2 + ğ‘¦2 = 1. The equation of the line containing the segment ğ‘ƒ ğ‘„ is ğ‘¥ = 1, or ğ‘¥ ğ‘¥ ğ‘¥ The equation of the line is ğ‘¥ = 1. ğ‘¥ Consider the equation of the segment in parametric form: (ğ‘¥(1 ğ‘¡), ğ‘¦ğ‘¡). If point ğ¶ lies on this segment, then ğ¶ = (ğ‘¥ğ‘, ğ‘¦ğ‘), where ğ‘¥ğ‘ = ğ‘¥(1 ğ‘¡) and ğ‘¦ğ‘ = ğ‘¦ğ‘¡. So, ğ‘¥ğ‘ ğ‘¥ + ğ‘¦ğ‘ ğ‘¥ğ‘ ğ‘¥ ğ‘¦ The segments from are parts of the lines ğ‘¥ ğ‘¥0 = 1 ğ‘¡ and ğ‘¦ğ‘ ğ‘¦ = 1 ğ‘¡ + ğ‘¡ = 1. 0 = 1, ğ‘¥0, ğ‘¦0 > 0. = 1, where ğ‘¥2 0 + ğ‘¦2 + ğ‘¦ ğ‘¦0 + ğ‘¦ ğ‘¦ + ğ‘¦ ğ‘¦ + ğ‘¦ ğ‘¦ = 1. = ğ‘¡. 3 Consider the point ğ¶ = ( 1 2 2 If ğ¶ lies on segment from with endpoints (ğ‘¥, 0) and (0, ğ‘¦), then: 1 2 ğœ†). ğœ†, 3 2 ğ‘¦ 3ğœ† 2ğ‘¦ ) ğœ† ğœ† 1 2 + + = 1 = 1 + 3 2 3ğœ† 3 and ğ‘¦ = into the equation: 1 2 ğ‘¥ 1ğœ† 2ğ‘¥ We need to find unique ğœ† (0, 1) such that the only solution (ğ‘¥, ğ‘¦) to this equation, with ğ‘¥2 + ğ‘¦2 = 1, ğ‘¥, ğ‘¦ > 0, is ( 1 2 Substitute ğ‘¥ = 1 2 1ğœ† = 1 2( 1 ) 2( 2 1 ğœ† + ğœ† = 1 1 = 1 This shows that any point on ğ´ğµ lies on the segment ğ´ğµ itself. Consider the line containing ğ´ğµ: ğ‘¦ = If point ğ¶ on ğ´ğµ also lies on another segment from with endpoints (ğ‘¥, 0) and (0, ğ‘¦), then: ğ‘¥ğ¶ ğ‘¥ Let the point ğ¶ divide ğ´ğµ in the ratio ğœ‡ (1 ğœ‡), where 0 < ğœ‡ < 1. ğ¶ = (1 ğœ‡)ğ´ + ğœ‡ğµ = (1 ğœ‡)( 1 ğœ‡, 2 If ğ¶ lies on segment with endpoints (ğ‘¥, 0) and (0, ğ‘¦), then: , 0) + ğœ‡(0, ) = ( 1 2 + ğ‘¦ğ¶ ğ‘¦ 1 2 3 2 3 2 3 2 = 1. 3ğ‘¥ + ğœ‡). . 3 2 ). , 1 2 1 2 ğ‘¥ ğœ‡ + 3 2 ğ‘¦ ğœ‡ = 1. We are looking for point ğ¶ such that the line passing through ğ¶ with the form ğ‘¥ ğ‘¥0 + ğ‘¦ ğ‘¦0 = 1, where ğ‘¥2 0 + ğ‘¦2 0 = 1, is unique. 43 s1: Simple test-time scaling Consider the tangents to the unit circle centered at the origin. The lines of the form ğ‘¥ ğ‘¥0 + ğ‘¦ ğ‘¦0 = 1 are tangents to the circle . 2 = 1. + ğ‘¦ ğ‘¦0 0 + ğ‘¦2 0 = 1. ğ‘¥2 + ğ‘¦2 = ğ‘Ÿ2. Consider the dual problem. The family of segments corresponds to points on the quarter circle ğ‘¥2 + ğ‘¦2 = 1 in the first quadrant. The lines containing the segments are ğ‘¥ ğ‘¥0 The envelope of these lines is the curve whose tangents are these lines. + ğ‘¦ The equation ğ‘¥ = 1, with the constraint ğ‘¥2 ğ‘¥0 ğ‘¦0 Let ğ‘¥0 = cos ğœƒ, ğ‘¦0 = sin ğœƒ, where 0 < ğœƒ < ğœ‹ The equations of the lines are ğ‘¥ cos ğœƒ + ğ‘¦ sin ğœƒ = 1. The envelope of the family of lines ğ‘¥ cos ğœƒ + ğ‘¦ sin ğœƒ = 1 is the circle ğ‘¥2 + ğ‘¦2 = 1. The segments from are parts of the tangents to the unit circle in the first quadrant. The point ğ¶ on ğ´ğµ that does not belong to any other segment from means that the tangent to the unit circle passing through ğ¶ is unique. Consider the point ğ¶ = ( 1 2 The tangents to the unit circle passing through ğ¶ have the form ğ‘¥ğ‘¥ğ¶ + ğ‘¦ğ‘¦ğ¶ = 1. If the tangent is unique, then ğ¶ lies on the unit circle. 1 ( 1 ğœ†)2 + ( 2 2 ( 1 1 ğœ† + 1 4 2 4 1 1 ğœ† + ğœ†2 = 1 4 2 4ğœ†2 2ğœ† + 1 = 4 4ğœ†2 2ğœ† 3 = 0 Solve for ğœ†: ğœ† = (2) We need 0 < ğœ† < 1. 3 2 ğœ†2) + 3 4 (2)24(4)(3) 2(4) = 22 8 ğœ†)2 = 1 4+48 8 ğœ†2 = = 2 = 2 = 1 1 2 3 2 ğœ†). ğœ†, 52 13 13 8 4 . ğœ†, ğœ†). 1 2 > 1. < 0. 1+3.6 4 13.6 4 Something is wrong. The point ğ¶ is inside the unit circle. Lets rephrase the condition. There is unique point ğ¶ on ğ´ğµ such that if ğ¶ lies on segment ğ‘ƒ ğ‘„ , then ğ‘ƒ ğ‘„ = ğ´ğµ. 3 Let the point ğ¶ on ğ´ğµ be ( 1 2 2 Consider segment from with endpoints (ğ‘¥, 0) and (0, ğ‘¦), ğ‘¥2 + ğ‘¦2 = 1. The parametric form of the segment is (ğ‘¥(1 ğ‘¡), ğ‘¦ğ‘¡). If ğ¶ is on this segment, then for some ğ‘¡ [0, 1]: 1 1 2 2 3 2 If the segment is unique, then the values of ğ‘¥ and ğ‘¦ are unique. 3ğœ† The only solution to 1ğœ† 2ğ‘¦ 2ğ‘¥ = 1, with ğ‘¥2 + ğ‘¦2 = 1, ğ‘¥, ğ‘¦ > 0, should be ğ‘¥ = 1 2 Consider the intersection of the line containing ğ´ğµ with the boundary of the region formed by the segments in . The boundaries are the ğ‘¥-axis, ğ‘¦-axis, and the quarter circle ğ‘¥2 + ğ‘¦2 = 1. Consider the dual problem again. The family of lines ğ‘¥ ğ‘¥0 0 = 1, ğ‘¥0, ğ‘¦0 > 0. = 1, where ğ‘¥2 ğœ† = ğ‘¥(1 ğ‘¡) 0 + ğ‘¦2 + ğ‘¦ ğ‘¦0 ğœ† = ğ‘¦ğ‘¡ 3 , ğ‘¦ = + . 13 3.6. = 4.6 4 = 2.6 4 The envelope of these lines is the circle ğ‘¥2 + ğ‘¦2 = 1. point belongs to unique segment from if it lies on the circle ğ‘¥2 + ğ‘¦2 = 1. The point ğ¶ on ğ´ğµ satisfies ğ¶ = ğ‘¡ğ´ + (1 ğ‘¡)ğµ. Lets consider the case where the segment is ğ´ğµ. Here ğ‘¥ = 1 2 The point ğ¶ can be represented as ( 1 (1 ğ‘ ), 2 We are looking for point ğ¶ on ğ´ğµ that does not lie on any other segment from . ğ‘ ) for 0 ğ‘  1. 3 2 3 2 , ğ‘¦ = . s1: Simple test-time scaling Consider the geometry. The family forms region bounded by the axes and the quarter circle. The segments are chords of circles centered on the line ğ‘¦ = ğ‘¥, tangent to the axes. Let the endpoints of segment be (cos ğœƒ, 0) and (0, sin ğœƒ). point on the segment is (cos ğœƒ(1 ğ‘¡), sin ğœƒğ‘¡). The point ğ¶ = ( 1 ğœ†, 2 1 2 3 2 ğœ†). If ğ¶ lies on such segment, then ğœ† 1 1 2 2 cos ğœƒ = 1 ğ‘¡ and ğœ† 3 2 sin ğœƒ = ğ‘¡. , , . . + + + + ). = = 1 = 1 2 cos ğœƒ 2 cos ğœƒ = 1. 3ğœ† 2 sin ğœƒ 3 2 3 2 3 4 ğœ† 3ğœ† 2 sin ğœƒ cos ğœƒ = sin(2ğœƒ) = ğœ‹ 2ğœƒ + 2ğœ‹ğ‘˜. , then ğ¶ = ( 1 4 ), which corresponds to ğœƒ = ğœ‹ 3 3 cos ğœƒ = 4 sin ğœƒ cos ğœƒ 3 cos ğœƒ = 2 sin(2ğœƒ) 3(12) 2 sin ğœƒ 3 4 sin ğœƒ 3 sin ğœƒ = 2ğœƒ + 2ğœ‹ğ‘˜, or ğœƒ + ğœ‹ 3 2ğœ‹ğ‘˜, so ğœƒ = ğœ‹ . 3 + 2ğœ‹ğ‘˜ = 2ğœ‹ 3 . 1ğœ† 2 cos ğœƒ We need unique ğœ† (0, 1) such that the only solution (cos ğœƒ, sin ğœƒ) is ( 1 2 Consider the function ğ‘“ (ğœƒ) = 1 We need ğ‘“ (ğœƒ) = 1. If ğœ† = 1 2 112 + 2 cos ğœƒ 1 4 cos ğœƒ 1 cos ğœƒ sin ğœƒ + sin ğœƒ + Divide by 2: 1 sin ğœƒ + 2 sin(ğœƒ + ğœ‹ ) = sin(2ğœƒ). 3 ğœƒ + ğœ‹ 3 ğœƒ = ğœ‹ 3 3ğœƒ = ğœ‹ ğœ‹ 3 ğœƒ = 2ğœ‹ + 2ğœ‹ğ‘˜ 3 9 If ğ‘˜ = 0, ğœƒ = 2ğœ‹ 9 If ğ‘˜ = 1, ğœƒ = 2ğœ‹ = 2ğœ‹+6ğœ‹ 9 9 3 If ğœ† = 1 , the point is ( 1 ). , 4 2 4 This point lies on segments corresponding to ğœƒ = ğœ‹ 3 The unique point ğ¶ means that for other values of ğœ†, there is more than one solution for (ğ‘¥, ğ‘¦). Consider the tangent to the unit circle passing through ğ¶. If the tangent is unique, ğ¶ is on the unit circle. This leads to ğœ† = 1 13 Consider the geometric interpretation of the family . The segments connect points on the axes such that the distance is 1. The locus of the centers of these segments is the circle (ğ‘¥ 1 2 If point ğ¶ lies on segment from , then ğ¶ is on line segment connecting (ğ‘¥, 0) and (0, ğ‘¦) with ğ‘¥2 + ğ‘¦2 = 1. The line containing the segment is ğ‘¥ = 1. ğ‘¥0 If ğ¶ belongs to unique segment, then there is unique line of this form passing through ğ¶. The point ğ¶ on ğ´ğµ is ( 1 2 , neither of which is in (0, 1). , in the first quadrant. and ğœƒ = 2ğœ‹ 9 )2 + (ğ‘¦ 1 2 . + 2ğœ‹ )2 = 1 2 + 2ğœ‹ğ‘˜. = 8ğœ‹ 9 + ğ‘¦ ğ‘¦0 ğœ†). 4 . . ğœ†, 1 2 3 2 We need unique (ğ‘¥0, ğ‘¦0) with ğ‘¥2 0 + ğ‘¦2 Let the point ğ¶ be such that the line passing through ğ¶ with the form ğ‘¥ ğ‘¥0 This line is tangent to the unit circle. The point ğ¶ lies on the intersection of the line containing ğ´ğµ and the unit circle. ( 1 2 We found no solution for ğœ† (0, 1). 0 = 1, ğ‘¥0, ğ‘¦0 > 0, such that 3 2 + ğ‘¦0 + ğ‘¦ ğ‘¦0 ğœ†)2 = 1. ğœ†)2 + ( 1 2 3 1 2 ğ‘¥0 1 2 ğœ† ğœ† = 1. = 1 is unique, subject to ğ‘¥2 0 + ğ‘¦ 0 = 1. 45 s1: Simple test-time scaling ğ‘¥ + ğ‘¦. The unique point ğ¶ means that if any other segment passes through ğ¶, it must be ğ´ğµ. Consider the slope of the line containing the segment connecting (ğ‘¥, 0) and (0, ğ‘¦). Slope is ğ‘¦ ğ‘¥ The equation is ğ‘¦ = ğ‘¦ ğ‘¥ If ğ¶ lies on the segment, then 1ğœ† 2ğ‘¥ Consider the geometric mean. Let the point ğ¶ have coordinates (ğ‘, ğ‘). The segment connecting (ğ‘¥, 0) and (0, ğ‘¦) passes through (ğ‘, ğ‘). ğ‘ ğ‘¥ If ğ¶ is on ğ´ğµ, then ğ‘ = ğ‘ = 1 2 The point ğ¶ is tangent to the envelope of the family of segments. ğœ†, ğ‘ = 1 2 + ğ‘ ğ‘¦ 3 2 3 2 = 1. = 1. 3ğ‘ + 3ğœ† 2ğ‘¦ ğœ†. + . . Solution: Let the family of segments be . The segments have endpoints ğ‘ƒ = (ğ‘¥, 0) and ğ‘„ = (0, ğ‘¦) with ğ‘¥2 + ğ‘¦2 = 1 and ğ‘¥, ğ‘¦ > 0. = 1. The segments lie on the lines ğ‘¥ The points on the segment ğ‘ƒ ğ‘„ satisfy ğ‘¥ 0 = 1, ğ‘¥0, ğ‘¦0 > 0. ğ‘¥0 ğ‘¥ . 3ğ‘¥ + ). The equation of the line containing ğ´ğµ is ğ‘¦ = = 1, where ğ‘¥2 0 + ğ‘¦2 + ğ‘¦ ğ‘¦0 + ğ‘¦ ğ‘¦ The segment ğ´ğµ has endpoints ğ´( 1 , 0) and ğµ(0, 2 point ğ¶ on ğ´ğµ can be parameterized as ğ¶ = ( 1 2 ğœ†), where 0 ğœ† 1. 3 2 1 2 ğœ†, 3 3 2 ğœ† 1 2 1 2 ğ‘¥ ğœ† 3 2 ğ‘¦ + = 1. If ğ¶ belongs to segment from with endpoints (ğ‘¥, 0) and (0, ğ‘¦), then We are looking for unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that does not belong to any segment from other than ğ´ğµ. This means that the only solution (ğ‘¥, ğ‘¦) to the equation with ğ‘¥2 + ğ‘¦2 = 1, ğ‘¥, ğ‘¦ > 0, is ( 1 2 The segments from are parts of the tangents to the unit circle. The point ğ¶ must be tangent to the envelope of the family of segments. The envelope is the unit circle itself. The unique point ğ¶ on ğ´ğµ, distinct from ğ´ and ğµ, that lies on the unit circle. We need to solve: 3 ( 1 1 ğœ†)2 + ( ğœ†)2 = 1 2 2 2 3 . The point ğ¶ = ( 1 ğœ† = 1 ). 4 2 4 )2 = 1 ğ‘‚ğ¶ 2 = ( 1 + 3 )2 + ( 16 16 4 = ğ‘ ğ‘‚ğ¶ 2 = 1 , so ğ‘ = 1, ğ‘ = 4. ğ‘ 4 ğ‘ and ğ‘ are relatively prime. ğ‘ + ğ‘ = 1 + 4 = 5. Final Answer: The final answer is 5 = 4 16 = 1 4 3 3 2 ). , , ."
        }
    ],
    "affiliations": [
        "Allen Institute for AI",
        "Contextual AI",
        "Stanford University",
        "University of Washington, Seattle"
    ]
}