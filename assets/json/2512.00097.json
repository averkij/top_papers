{
    "paper_title": "Gold-Medal-Level Olympiad Geometry Solving with Efficient Heuristic Auxiliary Constructions",
    "authors": [
        "Boyan Duan",
        "Xiao Liang",
        "Shuai Lu",
        "Yaoxiang Wang",
        "Yelong Shen",
        "Kai-Wei Chang",
        "Ying Nian Wu",
        "Mao Yang",
        "Weizhu Chen",
        "Yeyun Gong"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Automated theorem proving in Euclidean geometry, particularly for International Mathematical Olympiad (IMO) level problems, remains a major challenge and an important research focus in Artificial Intelligence. In this paper, we present a highly efficient method for geometry theorem proving that runs entirely on CPUs without relying on neural network-based inference. Our initial study shows that a simple random strategy for adding auxiliary points can achieve silver-medal level human performance on IMO. Building on this, we propose HAGeo, a Heuristic-based method for adding Auxiliary constructions in Geometric deduction that solves 28 of 30 problems on the IMO-30 benchmark, achieving gold-medal level performance and surpassing AlphaGeometry, a competitive neural network-based approach, by a notable margin. To evaluate our method and existing approaches more comprehensively, we further construct HAGeo-409, a benchmark consisting of 409 geometry problems with human-assessed difficulty levels. Compared with the widely used IMO-30, our benchmark poses greater challenges and provides a more precise evaluation, setting a higher bar for geometry theorem proving."
        },
        {
            "title": "Start",
            "content": "5 2 0 2 7 2 ] . [ 1 7 9 0 0 0 . 2 1 5 2 : r Gold-Medal-Level Olympiad Geometry Solving with Efficient Heuristic Auxiliary Constructions Boyan Duan , Xiao Liang , Shuai Lu Ying Nian Wu , Mao Yang , Yaoxiang Wang , Weizhu Chen , Yelong Shen , Yeyun Gong , Kai-Wei Chang , ETH Zurich, Microsoft, University of California, Los Angeles Work done during Boyan, Xiao, and Yaoxiangs intership at Microsoft, Corresponding authors. Automated theorem proving in Euclidean geometry, particularly for International Mathematical Olympiad (IMO) level problems, remains major challenge and an important research focus in Artificial Intelligence. In this paper, we present highly efficient method for geometry theorem proving that runs entirely on CPUs without relying on neural networkbased inference. Our initial study shows that simple random strategy for adding auxiliary points can achieve silver-medal level human performance on IMO. Building on this, we propose HAGeo, Heuristic-based method for adding Auxiliary constructions in Geometric deduction that solves 28 of 30 problems on the IMO-30 benchmark, achieving gold-medal level performance and surpassing AlphaGeometry, competitive neural networkbased approach, by notable margin. To evaluate our method and existing approaches more comprehensively, we further construct HAGeo-409, benchmark consisting of 409 geometry problems with human-assessed difficulty levels. Compared with the widely used IMO-30, our benchmark poses greater challenges and provides more precise evaluation, setting higher bar for geometry theorem proving. Date: December 2, 2025 Code: https://github.com/boduan1/HAGeo Benchmark: https://huggingface.co/datasets/HAGeo-409 Email: Xiao Liang (vitoliang0601@gmail.com); Yeyun Gong (yegong@microsoft.com)"
        },
        {
            "title": "1 Introduction",
            "content": "Automatic mathematical theorem proving is one of the fundamental goals of Artificial Intelligence (AI). As branch of mathematics studied for over two millennia, Euclidean geometry serves as one of the four primary problem categories in the International Mathematical Olympiad (IMO), the worlds leading high school mathematics competition. Given its enduring importance, automated theorem proving in Euclidean geometry has remained focus of research and has been extensively studied for decades (Gelernter, 1959; Gelernter et al., 1960; Reiter, 1972). As recent advance, AlphaGeometry (Trinh et al., 2024) demonstrates remarkable progress by utilizing deduction database and an algebraic reasoning (DDAR) engine. It employs neuralsymbolic system to exhaustively deduce new statements using symbolic engine and neural language model trained on hundreds of millions of synthetic data to add auxiliary points for Euclidean geometry problem solving. It achieves silver-medal performance on the IMO-30 benchmark, collection of 30 competition-level geometry problems from the International Mathematical Olympiad between 2000 and 2022, solving 24 of the 30 problems 1. More recently, by incorporating multiple Large Language Models (LLMs) instead of small neural network and introducing shared knowledge mechanism, AlphaGeometry2 (Chervonyi et al., 2025) successfully solves all problems in IMO-30. Meanwhile, TongGeometry (Zhang et al., 2024) achieves the same performance by employing neural models with guided tree search; however, its technical details remain unreported. Despite their effectiveness, common limitation of these methods is the reliance on neural models, particularly LLMs, which requires additional GPU resources for inference. In our initial study, we find that even simple 1We report that one of the 25 announced proofs by AlphaGeometry on IMO-30 is wrong in Appendix A. 1 random strategy for adding auxiliary points using only CPUs allows the system to reach AlphaGeometrys performance on IMO-30, solving 25 of 30 problems. These surprising results raise promising research question: Could the system achieve gold-medal performance by simply employing an efficient strategy for adding auxiliary points without relying on neural inference? To answer this, we propose HAGeo, heuristic method that relies solely on adding auxiliary constructions in deduction without using neural network, outperforming AlphaGeometry and achieving gold-medal performance on the IMO-30 benchmark. Specifically, HAGeo adds heuristic auxiliary points with favorable geometric properties, such as the intersections of circles and lines, which can be discovered through numerical calculations. Given that the deduction engine already assumes all numerical information is available, our method introduces no additional assumptions about numerical values. Moreover, we develop optimized deduction rules to lower time complexity without sacrificing deductive capability and optimize the implementation, yielding an approximately 20 speedup over AlphaGeometrys DDAR engine. These improvements enable faster and more scalable inference. For evaluation, while the IMO-30 benchmark is widely used, we find that it overlooks problem difficulty and most of its problems are relatively easy, as judged by professionals. Besides, it consists of only 30 problems, which could lead to high variance in evaluation. Therefore, this benchmark does not reliably reflect methods true capability. To address the limitations of IMO-30 and more comprehensively evaluate geometry problem solving, we construct HAGeo-409, benchmark consisting of 409 Olympiad-level geometry problems with human-assessed difficulty labels and generally more challenging than IMO-30. The problems have been systematically converted into geometry-specific language assisted by LLMs, numerically verified, and corrected through manual inspection, making them more rigorous for evaluation. In summary, our main contributions are as follows: We propose HAGeo, heuristic method for adding auxiliary points in automated theorem proving for Euclidean geometry, achieving gold-medal performance on CPUs and surpassing AlphaGeometrys neural networkbased approach. We implemented an improved DDAR engine that achieves roughly 20 inference speedup compared to AlphaGeometrys DDAR engine. We construct HAGeo-409, comprehensive benchmark comprising 409 IMO-level geometry problems with human-assessed difficulty scores that are generally more challenging than those in IMO-30. Experiments on both benchmarks demonstrate the effectiveness of our method."
        },
        {
            "title": "2.1 Automated Theorem Proving for Euclidean Geometry",
            "content": "Existing methods for automated theorem proving in Euclidean geometry can be broadly divided into algebraic and synthetic approaches. Algebraic methods typically transform geometry problem into system of polynomial equations, which can then be solved using Wus method (Wu, 1978; Chou, 1988) or the Gröbner basis method (Lazard, 1983). For synthetic methods, Chou et al. (1993) applied the area method and generated human-readable proofs for more than 400 geometry problems, while Chou et al. (2000) introduced deductive database (DD) based on set of geometric rules. Building on synthetic methods, remarkable progress has recently been made in the field. AlphaGeometry (Trinh et al., 2024) improves the DD method with an additional algebraic engine (DDAR) and employs neural network to add extra auxiliary points for geometry problems. It achieves silver-medal performance on the IMO-30 benchmark. When combined with Wus method (Sinha et al., 2024), which independently solves 15 of the 30 problems on IMO-30, AlphaGeometry can solve 27/30 problems. More recently, TongGeometry (Zhang et al., 2024) improved AlphaGeometrys DD engine and proposed tree-search-based method that solves 30/30 problems on IMO-30, but the technical details remain unavailable. AlphaGeometry2 (Chervonyi et al., 2025) introduces several improvements over AlphaGeometry, including enhancements to its geometric language, increased efficiency of the DDAR engine, and support for the double point feature in DDAR. It further extends the neural network with an ensemble of multiple language models and introduces shareable 2 Figure 1 Problem difficulity distribution of the IMO-30 benchmark and our new HAGeo-409 benchmark. knowledge across different searches, while also refining the synthetic dataset with more complex problems and better-balanced distribution."
        },
        {
            "title": "2.2 Geometry Problem Dataset",
            "content": "Prior work has collected multiple Olympiad-level mathematics datasets for theorem proving (Ying et al., 2024; Xin et al., 2024; Wei et al., 2024; De Moura et al., 2015; Zheng et al., 2021). However, these datasets primarily focus on algebra and number theory in Olympiad competitions, with only few of them dedicated to Olympiad-level geometry theorem proving. Furthermore, most of them are based on Lean (Moura and Ullrich, 2021), which is less effective for geometry problems. Recent work (Liang et al., 2025a; Li et al., 2025) shows even frontier LLMs exhibit weaker performance on geometry than on algebra, and data augmentation targeted at this challenging subdomain has shown promise in mitigating this issue (Liang et al., 2025b). Recently, AlphaGeometry generated large-scale synthetic dataset with 100 million problems to train neural network for adding auxiliary points. It randomly generates geometric configurations and uses the DDAR engine to deduce geometric facts, which are then considered as geometry problems. GeoGen (Bak et al., 2020) proposes adding few objects to triangle and quadrilateral configurations to extract geometry theorems, generating more than 100 turnaround problems. Using method similar to GeoGen, TongGeometry generates over 100 million geometric configurations and extracts 6 billion geometry problems. However, their further technical details are not provided."
        },
        {
            "title": "3 HAGeo-409 Benchmark Construction",
            "content": "Previous studies, such as AlphaGeometry, primarily employed two benchmarks to evaluate their Euclidean geometry theorem-proving systems: JGEX-231 (Sturm and Zengler, 2011) and IMO-30. The JGEX-231 benchmark consists of 231 relatively simple geometry problems, while IMO-30 includes only 30 problems drawn from International Mathematical Olympiads spanning 2000 to 2022. Furthermore, as in the IMO competition, problems 1 and 4, 2 and 5, and 3 and 6 typically differ substantially in difficulty; however, we observe that the IMO-30 benchmark predominantly contains problems that are not especially challenging. Since it is important to know the upper limit of problem difficulty that method could solve, in this work, we constructed more comprehensive benchmark from Mathematical Olympiad competitions, with each problem annotated with human-evaluated difficulty levels. We first collected more than 2000 geometry problems from the contest data collection of Art of Problem Solving website (Programs, 2025). Then, we converted these problems into our geometry-specific language, with an illustration provided in Appendix C. The successfully converted raw dataset contained more than 1,000 geometry problems, all of which were verified numerically, ensuring that each problems conclusion is numerically correct. However, not all problems in the raw dataset are paired with human-annotated difficulty score. We retain subset of problems, along with around 50 additional problems from the mathematical platform ShuZhiMi2. 2A Wechat mini program dedicated to Olympiad-level mathematical problems. 3 Figure 2 Overview of the HAGeo method. First, the DDAR engine deduces new statements in the problem. If the DDAR does not solve the problem, our heuristic-based strategy gives additional attempts for adds auxiliary constructions to help solve the problem and re-runs the DDAR. The difficulty level ranges from 1 to 7 (corresponding to easy to hard) and is defined as the average rating provided by ShuZhiMi users. The final benchmark contains over 400 problems with difficulty level annotations. We categorize the benchmark into difficulty ranges [1, 3), [3, 4), [4, 5), [5, 6), [6, 7] and present the statistics in Figure 1. Notably, compared with HAGeo-409, whose average difficulty is 3.47, the IMO-30 benchmark is relatively easy, with an average difficulty of only 2.85. We also report that the conversion process is non-trivial. We employ GPT-4o (Hurst et al., 2024) with few-shot prompt, as illustrated in Prompt 3, to convert geometry problems from natural language into our geometry-specific language. However, only around 50% of the problems could be converted into construction-based definition, and less than 20% could be automatically converted and numerically verified. We then manually revised the remaining problems that could be expressed in our geometric language and obtained the raw dataset. To evaluate AlphaGeometry on our HAGeo-409, we used GPT-4o with Prompt 2 to convert the problems into the AlphaGeometry format, and manually corrected errors in the converted problems. To ensure fair comparison with AlphaGeometry, we further refined HAGeo-409 to align with the its format as closely as possible. For example, if AlphaGeometry defines the circumcircle as = circumcenter c; = oncircle a; (which introduces the circumcenter), we also add this point in our setting."
        },
        {
            "title": "4.2 Geometry-Specific Languages\nUnlike theorem proving in other mathematical domains, such as algebra, which can be formally expressed\nin Lean, geometry lacks a standardized formal language for theorem proving. In HAGeo, we adopt the\ngeometry-specific language in GeoGebra (Team, 2025), which includes definitions of points, lines, and circles,\nalong with a fixed set of construction actions.",
            "content": "For example, consider problem that defines new points X, as the intersection of line AB and circle that is centered at and passes through point . Our geometric language first defines the line AB : = line B, then circle (O, OP ): ω = circle_center_point P, and then define the points X, : X, = intersection ω. When the problem involves more advanced constraints, we address them through curve intersections. For example, if the problem defines point that satisfies AXB = CDE and lies on line Q, we first define curve ω with the first condition, then set as the intersection of ω and line Q. 4 Figure 3 Pipeline for adding heuristic auxiliary points. Each complete auxiliary construction consists of up to rounds of auxiliary point generation. In each round, the system selects one valid auxiliary point from all possible candidates determined through algebraical computation. In contrast to AlphaGeometry, which employs point-based geometric language that considers only points, our definition better reflects the natural language of problem statements, encompassing diverse geometric objects. This design is also more consistent with the deduction engine that includes rules with multiple objects, such as lines and circles, rather than only points as in AlphaGeometry."
        },
        {
            "title": "4.3 Deduction",
            "content": "The symbolic deduction engine deduces new statements by brute-force searching over fixed set of deduction rules. Each deduction rule has the form P1(x1), . . . , Pk(xk) Q(x), where P1, ...Pk and are predicates, and x1, , xk and each represent set of geometric objects. Since defining the same point in different ways is an important technique, we extend the DD engine to support deductions involving identical points, whereas AlphaGeometrys engine restricts all points to be distinct. The deduction is represented as graph, where geometric objects and relations are represented as vertices and edges. Whenever new property is deduced, the deduction graph is updated accordinglyby adding vertices or edges, or by merging existing ones. To enhance scalability and inference speed, we develop deduction engine that operates with significantly higher efficiency, running approximately 20 times faster than AlphaGeometry. Specifically, we evaluate both methods on the same machine. The average solving time of AlphaGeometrys DDAR on IMO-30 is 42.77 seconds, whereas ours achieves an average of 1.75 seconds, representing 24 speed improvement. The improved inference efficiency stems from the modifications to the deduction rules and the optimizations in their implementation. We provide two examples in the following grey box. These updated rules reduce time complexity while preserving the same deductive capacity, thereby improving the efficiency of most time-consuming rules and significantly accelerating the speed of the deduction engine."
        },
        {
            "title": "4.4 Algebraic Reasoning",
            "content": "Building on the geometric properties deduced by the DD engine, we further adapt an AR engine to infer additional statements algebraically. The AR engine first converts all length, ratio, and angle relations into linear equations. For example, it converts (l1, l2) = (l3, l4) into dir(l1) + dir(l4) dir(l2) dir(l3) = 0, where dir(l) represents the direction of the line as the directed angle of with the axis mod π. It then aggregates all linear equations into coefficient matrix and derives new relations accordingly. Specifically, it 5 1. We replace (angle-chasing rule on lines li, mi): (l1, l2) = (m1, m2), (l1, l3) = (m1, m3) (l2, l3) = (m2, m3) (l1, l2) = (m1, m2) (l1, m1) = (l2, m2) (2) We replace (positive similar triangle rule on ABC, DEF ): (AB, BC) = (DE, EF ), (AC, BC) = (DF, EF ) ABC + DEF (AB, DE) = (AC, DF ) = (BC, EF ) + DEF ABC uses Gaussian Elimination 3 to identify the independent set of variables and express all variables as linear combinations of this set. It then expresses all xi xj as linear combinations of the independent variables and finds all equivalent xi1 xj1 = xi2 xj2. It is worth noting that our implementation is fully based on matrix manipulation. To reduce matrix size and improve computational efficiency, we merge all equivalent variables before constructing the matrix. For the final step, we use an equivalent alternative implementation that takes all xi + xj instead of xi xj and finds all xi1 + xj1 = xi2 + xj2, which halves the computation due to the symmetry."
        },
        {
            "title": "4.5 Heuristic for Auxiliary Points",
            "content": "Adding auxiliary constructions is an important strategy for solving geometry problems and can be regarded as selecting from the set of all valid auxiliary objects. However, while the number of valid constructions can be very large, only small set of them is useful. AlphaGeometry employs neural network to construct auxiliary points while reporting that its implemented heuristic approach solves only 18 out of 30 problems on the IMO-30 benchmark. However, in their implementation, the rule-based heuristic only uses fixed rules to add auxiliary points. For example, \"If is the midpoint of AB, and is the midpoint of CD, then add the midpoint of AD as an auxiliary point\". In geometry, we usually add auxiliary constructions with good geometric properties; for example, the intersection of multiple curves may yield promising auxiliary point. Guided by this principle, our heuristic designates constructed point as potential auxiliary point if it non-trivially lies on line or circle. Specifically, we employ numerically driven auxiliary-point heuristic that only includes basic auxiliary constructions, such as the midpoint, reflection, foot of the perpendicular, and intersection, since it is easy to verify whether the resulting relation is trivial. Importantly, the numerical calculations introduce no extra assumptions for assigning numerical values to all geometric objects. This is because the deduction step (as detailed in Section 4.3) already requires numerical checks, such as verifying that points A, B, are not collinear, which inherently assumes that numerical values for all geometric objects are available. We categorize auxiliary points into several categories, as detailed in Figure 4 and illustrated in the paired visualization in Figure 5, including previously mentioned points with favorable geometric properties such as intersections, midpoints, and reflections. The random auxiliary points are also incorporated to enhance the generalization of the procedure. Additionally, Figure 5 Illustration of heuristic auxiliary points. Geometry configuration: I, G, O, are the incenter, centroid, circumcenter, and orthocenter of ABC; L, M, are the midpoints of BC, CA, AB; and D, E, are the tangent points of the incircle (I) with sides BC, CA, AB. 3en.wikipedia.org/wiki/Gaussian_elimination"
        },
        {
            "title": "Heuristics for Auxiliary Points",
            "content": "1. The intersection of multiple lines. If multiple lines l1, . . . , ln intersect (n 3), then take the intersection of two of them as an auxiliary point. Eg.1: The lines AD, BE, CF intersects, and we can take = AD BE as an auxiliary point. 2. The intersection of multiple lines and circles. If multiple lines l1, . . . , ln and circles ω1, . . . , ωm intersect (m + 3, 1), then take the intersection of line and circle (m 1) or two circles (n 3) as an auxiliary point. Eg.2: The lines AI, OL and circle (ABC) intersects, and we can take , the intersection of AI and (ABC) as an auxiliary point. 3. midpoint non-trivially lies on lines or circles. If the midpoint of AB lies on line = AB or circle ω, then take it as an auxiliary point. Eg.3: The midpoint of AH, defined as , lies on circle (LM ), and we take as an auxiliary point. 4. Reflection of point with respect to another point non-trivially lies on lines or circles. If the reflection of point wrt another point lines on line = AB or circle ω, then take it as an auxiliary point. Eg.4: The reflection of wrt L, defined as X, lies on circle (ABC), and we take as an auxiliary point. 5. Foot of point lies on another line. If the foot of point on line (A / l) lies on another line (m = l, / m), then take it as an auxiliary point. Eg.5: The foot of point on line AI lies on line LN , defined as , and we take as an auxiliary point. 6. Random constructions. Randomly perform an action over random set of geometry objects corresponding to the action. Eg.6: Construct point such that ZHD is clockwise equilateral triangle. Figure 4 The heuristics proposed in HAGeo. The paired visualization is present in Figure 5. Each heuristic is exemplified using distinct color, which are aligned with the lines and points shown in Figure 5. we also provide special heuristic for identical points: if an existing point lies on multiple circles and lines, this point of intersection (which is identical to the existing one) is also selected as an auxiliary point. If the system fails to solve geometric problem in the initial DDAR, we add auxiliary points based on our heuristics to assist the DDAR engine for up to additional attempts. Specifically, during each auxiliary construction attempt, the system first calculates all potential auxiliary points from the aforementioned heuristic categories and then randomly selects one point(s) along with its corresponding construction. It repeats this process for rounds and obtains the final set of auxiliary constructions, which are integrated into the new DDAR runs. It is worth noting that both the DDAR and heuristic auxiliary construction procedures are fully executed on CPUs without neural inference. The experiments in Section 5.2 show that equipping DDAR with our proposed heuristic auxiliary adding approach yields high efficiency and effectiveness, surpassing both the random selection baseline and the neural-network-based strategy in AlphaGeometry."
        },
        {
            "title": "5.1 Settings",
            "content": ". In our proposed HAGeo, we set the number of auxiliary construction rounds to = 6 Parameters in each auxiliary attempt. In experiments on the IMO-30 dataset in Table 2, we use = 4096 auxiliary construction attempts, which is significantly fewer than the equivalent auxiliary and DDAR attempts used in AlphaGeometry. For comparison on HAGeo-409, we set the number of attempts = 2048 for both our heuristic methods and random baseline for adding auxiliary points, as this yields roughly comparable number of DDAR samples to those in the AlphaGeometry experiment. We also report the performance of our method and the random baseline at = 8192 to evaluate the upper bound of our approach."
        },
        {
            "title": "Level Count",
            "content": "AlphaGeometry 16-64-8 Random @2048 HAGeo @2048 Random @8192 HAGeo @8192 13 34 45 56"
        },
        {
            "title": "Total",
            "content": "161 112 71 43 22 409 118 (73.3%) 44 (39.3%) 13 (18.3%) 2 (4.7%) 0 (0.0%) 127 (78.9%) 62 (55.4%) 13 (18.3%) 2 (4.7%) 0 (0.0%) 141 (87.6%) 87 (77.7%) 29 (40.8%) 5 (11.6%) 1 (4.5%) 128 (79.5%) 69 (61.6%) 18 (25.4%) 3 (7.0%) 0 (0.0%) 149 (92.5%) 93 (83.0%) 36 (50.7%) 7 (16.3%) 2 (9.1%) 177 (43.3%) 204 (49.9%) 263 (64.3%) 218 (53.3%) 287 (70.2%) Table 1 Experimental results on the HAGeo-409 benchmark across different difficulty levels. We compare our HAGeo method with AlphaGeometry and the random baseline. In AlphaGeometry, we set the beam search parameter to be (beam, batch, depth) = (16, 64, 8). For both the random auxiliary point construction and the strategies in HAGeo, we set to 2,048 and 8,192 to ensure comprehensive evaluation."
        },
        {
            "title": "Method",
            "content": "IMO-30 DDAR AlphaGeometry Random Auxiliary points + DDAR HAGeo 15 24 25 28 Table 2 Comparison on the IMO-30 benchmark. indicates that we report AlphaGeometry as solving 24 problems instead of 25, as we found the proof for IMO-2020-P1 to be incorrect, details provided in Appendix A. Device and Time Constraints All experiments were conducted on 64-core CPU machine, with an additional 80 GB A100 GPU used for AlphaGeometrys language model (LM). Each DDAR run was given 60-second time limit per problem, with total of 1.5 hours allocated for experiments on the IMO-30 benchmark. We implemented parallel version of AlphaGeometrys DDAR code and separated its LM and DDAR inference. The LM was first executed for full beam search under 1.5-hour time limit, generating complete list of auxiliary proposals. For fair comparison, we then run their DDAR to solve the problems under another 1.5-hour time constraint. To perform all methods on 64-core machine under 1.5 hour time limit, we set AlphaGeometrys beam search parameter to (beam, batch, depth) = (16, 64, 8), which approximately reaches the maximum time limit setting on the 64-core CPU device."
        },
        {
            "title": "5.2 Results\nEvaluation on the IMO-30 Benchmark We compare the performance of HAGeo with AlphaGeometry\nand the random baseline on the IMO-30 benchmark, as shown in Table 2. Given the erroneous proofs\npotentially resulting from implementation mistakes in AlphaGeometry, we emphasize that manual verification\nis essential for the final evaluation. Therefore, we manually verified the proofs produced by our method on the\nIMO-30 benchmark, conducted by an IMO gold medalist. We find that even the random strategy for adding\nauxiliary points could solve 25 problems in the IMO-30 dataset, which is comparable to AlphaGeometry\nand reaches the “silver-medal” performance. Notably, our proposed HAGeo solves 28 out of 30 problems,\noutperforming AlphaGeometry by a notable margin and achieving “gold-medal” performance on IMO-30. We\nfurther evaluated our method on recent IMO problems from 2024 and 2025 (with difficulty scores of 2.5 and\n3.2, respectively), where it successfully solved them within 20 seconds each.",
            "content": "Evaluation on our HAGeo-409 benchmark . We also compare our method with AlphaGeometry and the random baseline on the HAGeo-409 benchmark, with the results reported in Table 1. Notably, all methods solve fewer problems as the difficulty increases, demonstrating the reliability of the difficulty annotations in HAGeo-409. Notably, our method performs effectively in the difficulty ranges [1,3) and [3,4) when is 8 Figure 6 Pass@K results of HAGeo and the random DDAR baseline on HAGeo-409 across different difficulty levels. Top row: [1, 3), [3, 4), and [4, 5); Bottom row: [5, 6), [6, 7], and the full benchmark. The red double arrow indicates the performance gap between the best results of the random baseline and our method. set to 8192, achieving solve rates of 92.5% and 83.0%, respectively, surpassing AlphaGeometry by 19.2% and 43.7%. Moreover, our method is capable of successfully solving two of the most challenging problems at the difficulty level [6, 7]. These results highlight both the robust generalization and the strong upper-bound performance of HAGeo in automated geometric theorem proving."
        },
        {
            "title": "6 Conclusion",
            "content": "In this work, we propose HAGeo, heuristic method based on numerical computation using only CPUs to add auxiliary points in DDAR for automated Euclidean geometry theorem proving. Our method solves 28 out of 30 problems on the IMO-30 benchmark, achieving gold-medal performance while being 20 times faster than AlphaGeometry. Furthermore, we develop more comprehensive benchmark, HAGeo-409, with human-evaluated difficulty annotations, featuring geometric problems that are generally more difficult than those in the IMO-30 benchmark. Experiments on this new benchmark also demonstrate both the scalability and effectiveness of our method."
        },
        {
            "title": "References",
            "content": "P Bak, RNDr Stanislav Krajči, and Mgr Michal Rolínek. Automated generation of planar geometry Olympiad problems. PhD thesis, Master Thesis, 2020. Yuri Chervonyi, Trieu Trinh, Miroslav Olšák, Xiaomeng Yang, Hoang Nguyen, Marcelo Menegali, Junehyuk Jung, Vikas Verma, Quoc Le, and Thang Luong. Gold-medalist performance in solving olympiad geometry with alphageometry2. arXiv preprint arXiv:2502.03544, 2025. Shang-Ching Chou. An introduction to wus method for mechanical theorem proving in geometry. Journal of Automated Reasoning, 4(3):237267, 1988. Shang-Ching Chou, Xiao-Shan Gao, and Jing-Zhong Zhang. Automated production of traditional proofs for theorems in euclidean geometry. In Proceedings of Eigth IEEE Symposium on Login in Computer Science, pages 4856, 1993. Shang-Ching Chou, Xiao-Shan Gao, and Jing-Zhong Zhang. deductive database approach to automated geometry theorem proving and discovering. Journal of Automated Reasoning, 25(3):219246, 2000. Leonardo De Moura, Soonho Kong, Jeremy Avigad, Floris Van Doorn, and Jakob von Raumer. The lean theorem prover (system description). In Automated Deduction-CADE-25: 25th International Conference on Automated Deduction, Berlin, Germany, August 1-7, 2015, Proceedings 25, pages 378388. Springer, 2015. Herbert Gelernter. Realization of geometry-theorem proving machine. In Proceedings of the International Conference on Information Processing, page 273282, 1959. Herbert Gelernter, James Hansen, and Donald Loveland. Empirical explorations of the geometry theorem machine. In Papers presented at the May 3-5, 1960, western joint IRE-AIEE-ACM computer conference, pages 143149, 1960. Aaron Hurst, Adam Lerer, Adam Goucher, Adam Perelman, Aditya Ramesh, Aidan Clark, AJ Ostrow, Akila Welihinda, Alan Hayes, Alec Radford, et al. Gpt-4o system card. arXiv preprint arXiv:2410.21276, 2024. Daniel Lazard. Gröbner bases, gaussian elimination and resolution of systems of algebraic equations. In European Conference on Computer Algebra, pages 146156. Springer, 1983. Zhong-Zhi Li, Duzhen Zhang, Ming-Liang Zhang, Jiaxin Zhang, Zengyan Liu, Yuxuan Yao, Haotian Xu, Junhao Zheng, Pei-Jie Wang, Xiuyi Chen, et al. From system 1 to system 2: survey of reasoning large language models. arXiv preprint arXiv:2502.17419, 2025. Xiao Liang, Zhong-Zhi Li, Yeyun Gong, Yang Wang, Hengyuan Zhang, Yelong Shen, Ying Nian Wu, and Weizhu Chen. Sws: Self-aware weakness-driven problem synthesis in reinforcement learning for llm reasoning. arXiv preprint arXiv:2506.08989, 2025a. Xiao Liang, Zhongzhi Li, Yeyun Gong, Yelong Shen, Ying Nian Wu, Zhijiang Guo, and Weizhu Chen. Beyond pass@ 1: Self-play with variational problem synthesis sustains rlvr. arXiv preprint arXiv:2508.14029, 2025b. Leonardo de Moura and Sebastian Ullrich. The lean 4 theorem prover and programming language. In International Conference on Automated Deduction, pages 625635. Springer, 2021. Aops Programs. Art of problem solving. https://artofproblemsolving.com/community/c13_contests, 2025. Accessed: 2025-06-24. Raymond Reiter. The use of models in automatic theorem-proving. University of British Columbia. Department of Computer Science, 1972. Shiven Sinha, Ameya Prabhu, Ponnurangam Kumaraguru, Siddharth Bhat, and Matthias Bethge. Wus method can boost symbolic ai to rival silver medalists and alphageometry to outperform gold medalists at imo geometry. arXiv preprint arXiv:2404.06405, 2024. Thomas Sturm and Christoph Zengler. Automated deduction in geometry: 7th international workshop, adg 2008, shanghai, china, september 22-24, 2008, revised papers, 04 2011. Geogebra Team. Geogebra. https://www.geogebra.org/, 2025. Accessed: 2025-06-24. Trieu Trinh, Yuhuai Wu, Quoc Le, He He, and Thang Luong. Solving olympiad geometry without human demonstrations. Nature, 625(7995):476482, 2024. 10 Chenrui Wei, Mengzhou Sun, and Wei Wang. Proving olympiad algebraic inequalities without human demonstrations. arXiv preprint arXiv:2406.14219, 2024. W-T Wu. On the decision problem and the mechanization of theorem proving in elementary geometry. Scientia Sinica, 21:157179, 1978. Huajian Xin, Daya Guo, Zhihong Shao, Zhizhou Ren, Qihao Zhu, Bo Liu, Chong Ruan, Wenda Li, and Xiaodan Liang. Deepseek-prover: Advancing theorem proving in llms through large-scale synthetic data. arXiv preprint arXiv:2405.14333, 2024. Huaiyuan Ying, Zijian Wu, Yihan Geng, Jiayu Wang, Dahua Lin, and Kai Chen. Lean workbook: large-scale lean problem set formalized from natural language math problems. arXiv preprint arXiv:2406.03847, 2024. Chi Zhang, Jiajun Song, Siyu Li, Yitao Liang, Yuxi Ma, Wei Wang, Yixin Zhu, and Song-Chun Zhu. Proposing and solving olympiad geometry with guided tree search. arXiv preprint arXiv:2412.10673, 2024. Kunhao Zheng, Jesse Michael Han, and Stanislas Polu. Minif2f: cross-system benchmark for formal olympiad-level mathematics. arXiv preprint arXiv:2109.00110, 2021."
        },
        {
            "title": "B Preliminary for DDAR",
            "content": "C Example of our Geometry-Specific Language Example in our HAGeo-409 Example Proof of Problem in IMO-30 Prompt to Convert Natural Language into AlphaGeometrys Geometric Language"
        },
        {
            "title": "G Prompt to Convert Natural Language into our Geometric language",
            "content": "13 13 14 14 15"
        },
        {
            "title": "A Fallacious Proof in AlphaGeometry",
            "content": "Here we present detailed illustration of the fallacious proof for IMO-2020-P1 produced by AlphaGeometry. AlphaGeometry releases their proof to the IMO-30 problems in their supplementary material. As shown in section 2.28, the step 9 of the proof for IMO-2020-P1 is wrong. In Step 9 of the proof, it states: P, A, are collinear, A, Z, are collinear, A, D, are collinear, OP = ON and ODE = ON (P O, AM ) = (DO, AZ). This statement is incorrect because it implicitly assumes that , , and are collinear, which is not proven."
        },
        {
            "title": "B Preliminary for DDAR",
            "content": "The Deductive Database and Algebraic Reasoning (DDAR) engine serves as the symbolic core of the existing generative automated geometry theorem-proving frameworks (Trinh et al., 2024; Zhang et al., 2024; Chervonyi et al., 2025). It combines rule-based deductive database (DD) inference with algebraic reasoning (AR), forming unified system that jointly explores geometric and numerical dependencies. Deductive Database Engine. The deductive component focuses on inferring new geometric properties from known premises using set of geometric rules that follow the paradigm If X, then Y. Each rule encodes logically valid transformation, such as deducing collinearity, parallelism, or equality of segments and angles. Inspired by AlphaGeometry (Trinh et al., 2024), we adopt structured deductive engine (Chou et al., 2000; Sturm and Zengler, 2011) that incrementally expands the deductive closure of all provable statements. This procedure is highly efficient, typically finishing in seconds on standard CPUs and requiring at most few minutes, while ensuring comprehensive coverage of symbolic inferences. specific example of our deduction process in the geometry-specific language is provided in Case 1. Algebraic Reasoning. The algebraic reasoning module complements the DD inference by handling arithmetic and ratio-based relations that cannot be captured symbolically. In AR, all geometric equalities are represented in canonical linear form, such as + = 0, enabling the use of Gaussian elimination to uncover hidden dependencies among variables. Variables may correspond to geometric quantities, including angles, distances, or ratios. As an example from AlphaGeometry, the angle equality ABC = XY can be represented as s(AB) s(BC) = s(XY ) s(Y Z), where s(AB) denotes the angle between segment AB and the x-axis, modulo π. Notably, the algebraic computations can be represented in coefficient matrix RM , where denotes the number of variables and the number of input equations. To ensure numerical completeness, constant terms such as π, 1 , and rational ratios are also included in the coefficient matrix. This algebraic 2 procedure efficiently generates new equivalences, such as quantitative relationships among existing angles or edges, thereby enhancing the symbolic reasoning process. Joint DeductiveAlgebraic Inference. The DDAR engine could alternate between deductive and algebraic reasoning to build consistent and exhaustive set of provable statements. After each round of symbolic deduction, the resulting statements could be passed to the algebraic module for further inference, and the new algebraic results are reintroduced into the deductive reasoning stage. This iterative interaction allows DDAR to reason across both geometric and numerical domains while maintaining logical soundness. In practice, the DDAR process converges rapidly, typically within few seconds and may take up to minutes, yielding compact yet complete closure of geometric knowledge for theorem proving. 13 Example of our Geometry-Specific Language Here we provide an example (IMO 2010 p2) illustrating how we convert geometric problem from its natural language description into our geometry-specific language. Problem in natural language: Given triangle ABC, with as its incenter and Γ as its circumcircle, AI intersects Γ again at D. Let be point on the BAC. If is the midpoint of IF , prove that arc BDC, and point on the segment BC, such that BAF = CAE < the meeting point of the lines EI and DG lies on Γ. 1 2 Problem in our geometry-specific language: = triangle; = circumcenter C; (O) = circumcircle C; = incenter C; AI = line I; = intersection AI (O); BC = line C; = on_line BC; = angle_equal1 A F; = intersection (O); = midpoint F; DG = line G; EI = line I; = intersection DG EI; Prove: cong K Example in our HAGeo-409 We also provide an example (ShuZhiMi 2023 MOST Mock p2) in our HAGeo-409 benchmark. Problem in natural language: Given two positively similar triangles A1A3A5 A4A6A2. For 1 6, define Xi as the intersection of AiAi+2 and Ai+1Ai1. For 1 6, let Oi be the circumcenter of AiXiAi+1 (A7 = A1). Prove that the three lines O1O4, O2O5, O3O6 are concurrent. Problem in our geometry-specific language: A1 A3 A5 = triangle; A4 = point; A6 = point; l1 = angle_equal1 A4 A6 A5 A1 A3; l2 = angle_equal1 A6 A4 A5 A3 A1; A2 = intersection l1 l2; A1A3 = line A1 A3; A2A6 = line A2 A6; X1 = intersection A1A3 A2A6; A2A4 = line A2 A4; X2 = intersection A1A3 A2A4; A3A5 = line A3 A5; X3 = intersection A2A4 A3A5; A4A6 = line A4 A6; X4 = intersection A3A5 A4A6; A1A5 = line A1 A5; X5 = intersection A1A5 A4A6; X6 = intersection A1A5 A2A6; O1 = circumcenter A1 X1 A2; O2 = circumcenter A2 X2 A3; O3 = circumcenter A3 X3 A4; O4 = circumcenter A4 X4 A5; O5 = circumcenter A5 X5 A6; O6 = circumcenter A6 X6 A1; O1O4 = line O1 O4; O2O5 = line O2 O5; = intersection O1O4 O2O5; Prove: collinear O3 14 Example Proof of Problem in IMO-30 Problem IMO-2008-p6 in Natual Language (Converted following AlphaGeometry): Let T1T2T3 be triangle. Define point as the circumcenter of triangle T1T2T3. Define circle (I) as the circle centered passing through T1. Let T4 be any point on circle (I). Define lines l1,l2,l3,l4 as the tangent lines at T1,T2,T3,T4 on circle (I). Define point as the intersection of l1, l2. Define point as the intersection of l2,l3. Define point as the intersection of l3,l4. Define point as the intersection of l4,l1. Define point I1 as incenter of triangle ABD. Define point I2 as the incenter of triangle BCD. Define point P1 as the foot of I1 on line BD. Define point P2 as the foot of I2 on line BD. Define (I1) as the circle centered I1 passing through P1. Define (I2) as the circle centered I2 passing through P2. Define lines m1, m2 be the excommon tangent of circle (I1), (I2). Define U1,U2 as the tangent points of m1, m2 with (I1). Define V1,V2 as the tangent points of m1, m2 with (I2). Define point as the intersection of lines m1, m2. Prove that IX = IT1. The original Problem: T1 T2 T3 = obtuse_triangle; = circumcenter T1 T2 T3; (I) = circle_center_point T1; T4 = on_circle (I); IT1 = line T1; IT2 = line T2 ; IT3 = line T3; IT4 = line T4; l1 = perpendicular_line T1 IT1; l2 = perpendicular_line T2 IT2; = intersection l1 l2; l3 = perpendicular_line T3 IT3; = intersection l2 l3; l4 = perpendicular_line T4 IT4; = intersection l3 l4; = intersection l1 l4; I1 = incenter D; I2 = incenter D; BD = line D; P1 = foot I1 BD; P2 = foot I2 BD; (I1) = circle_center_point I1 P1; (I2) = circle_center_point I2 P2; m1 m2 = ex_common_tangent (I1) (I2); U1 = intersection m1 (I1); U2 = intersection m2 (I1); V1 = intersection m1 (I2); V2 = intersection m2 (I2); = intersection m1 m2; Prove: cong T1 The problem with our Auxiliary constructions: T1 T2 T3 = obtuse_triangle; = circumcenter T1 T2 T3; (I) = circle_center_point T1; T4 = on_circle (I); IT1 = line T1; IT2 = line T2 ; IT3 = line T3; IT4 = line T4; l1 = perpendicular_line T1 IT1; l2 = perpendicular_line T2 IT2; = intersection l1 l2; l3 = perpendicular_line T3 IT3; = intersection l2 l3; l4 = perpendicular_line T4 IT4; = intersection l3 l4; = intersection l1 l4; I1 = incenter D; I2 = incenter D; BD = line D; P1 = foot I1 BD; P2 = foot I2 BD; (I1) = circle_center_point I1 P1; (I2) = circle_center_point I2 P2; m1 m2 = ex_common_tangent (I1) (I2); U1 = intersection m1 (I1); U2 = intersection m2 (I1); V1 = intersection m1 (I2); V2 = intersection m2 (I2); = intersection m1 m2; l5 = line I2; = foot l5; l6 = line C; = foot l6; Prove: cong T1 Proof: IT1=IT2, IT1=IT3, IT1=IT4 => T4 on circle (T1T2T3) <EI,l5>=<l6,BF>, on line l6, on line l5, on line l6, on line l5 => on circle (BEF) <l3,IT3>=<l4,IT4>, T3 on line l3, T4 on line l4, on line l3, on line l4 => T4 on circle (CIT3) is circumcenter of (T1T2T3), T4 on circle (T1T2T3), T4 on line l4, IT4l4 => l4 is tangent to (T1T2T3) is circumcenter of (T1T2T3), T3 on line l3, IT3l3 => l3 is tangent to (T1T2T3) <IT3,l3>=<l6,BF>, on line l6, T3 on line l3, on line l6, on line l3, on circle (BEF) => T3 on circle (BEF) <IT2,l2>=<l6,BF>, on line l6, T2 on line l2, on line l6, on line l2, on circle (BEF) => T2 on circle (BEF) is circumcenter of (T1T2T3), T2 on line l2, IT2l2 => l2 is tangent to (T1T2T3) T4 on circle (CIT3), on line l6, on line l6, T3 on line l3, on line l3, on line l4, T4 on line l4 => <IT3,l6>=<T3T4,l4> l4 is tangent to (T1T2T3), T4 on circle (T1T2T3), T4 on line l4 => <T1T3,T1T4>=<T3T4,l4> l3 is tangent to (T1T2T3), T3 on line l3, T4 on circle (T1T2T3) => <T1T3,T1T4>=<l3,T3T4> on circle (BEF), T3 on circle (BEF), on line l6, on line l6, T3 on line l3, on line l3 => <IT3,l6>=<l3,BF> on circle (BEF), T2 on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <IT3,l6>=<T2T3,FT2> l2 is tangent to (T1T2T3), T2 on line l2 => <T1T2,T1T3>=<l2,T2T3> T2 on circle (BEF), T3 on circle (BEF), T2 on line l2, on line l2, T3 on line l3, on line l3 => <BF,FT3>=<l2,T2T3> l3 is tangent to (T1T2T3), T3 on line l3 => <T1T2,T1T3>=<T2T3,l3> <IT3,l6>=<l3,BF>, <IT3,l6>=<T3T4,l4>, <T1T3,T1T4>=<T3T4,l4>, <T1T3,T1T4>=<l3,T3T4> => <l3,BF>=<l3,T3T4> <IT3,l6>=<T2T3,FT2>, <IT3,l6>=<T3T4,l4> => <T2T3,FT2>=<T3T4,l4> <BF,FT3>=<l2,T2T3>, <T1T2,T1T3>=<l2,T2T3>, <T1T2,T1T3>=<T2T3,l3> => <BF,FT3>=<T2T3,l3> <l3,BF>=<l3,T3T4> => BF//T3T4 on circle (BEF), T2 on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <FT2,l6>=<T2T3,IT3> on circle (BEF), T2 on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <IT2,T2T3>=<l6,FT3> IT2=IT3 => <IT2,T2T3>=<T2T3,IT3> <T2T3,FT2>=<T3T4,l4> => <T3T4,T2T3>=<l4,FT2> <BF,FT3>=<T2T3,l3> => <BF,T2T3>=<FT3,l3> BF//T3T4 => <BF,T2T3>=<T3T4,T2T3> <FT2,l6>=<T2T3,IT3>, <IT2,T2T3>=<T2T3,IT3>, <IT2,T2T3>=<l6,FT3> => <FT2,l6>=<l6,FT3> <BF,T2T3>=<FT3,l3>, <BF,T2T3>=<T3T4,T2T3>, <T3T4,T2T3>=<l4,FT2> => <FT3,l3>=<l4,FT2> T3 on circle (BEF), on line l5, on line l5, T3 on line l3, on line l3 => <BF,FT3>=<l5,ET3> T2 on circle (BEF), T3 on circle (BEF) => <FT3,EF>=<T2T3,ET2> T3 on circle (BEF), on line l5, on line l5, T3 on line l3, on line l3 => <FT3,EF>=<l3,l5> <FT2,l6>=<l6,FT3> => <FT2,l6>=<l6,FT3> <CI2,l4>=<l3,CI2> => <CI2,l3>=<l4,CI2> <FT3,l3>=<l4,FT2> => <FT2,l3>=<l4,FT3> <T1T2,T1T3>=<T2T3,l3>, <T1T2,T1T3>=<l2,T2T3>, <BF,FT3>=<l2,T2T3>, <BF,FT3>=<l5,ET3> => <T2T3,l3>=<l5,ET3> <FT3,EF>=<T2T3,ET2>, <FT3,EF>=<l3,l5>, <l3,l5>=<l5,BD> => <T2T3,ET2>=<l5,BD> <CI2,l3>=<l4,CI2>, <FT2,l3>=<l4,FT3>, <FT2,l6>=<l6,FT3> => <CI2,l6>=<l6,CI2> <T2T3,l3>=<l5,ET3> => <T2T3,l5>=<l3,ET3> T2 on circle (BEF), T2 on line l2, on line l2, on line l5, on line l5 => <BF,EF>=<l2,ET2> T3 on circle (BEF), on line l5, on line l5, T3 on line l3, on line l3 => <BF,EF>=<l3,ET3> <T2T3,ET2>=<l5,BD> => <ET2,BD>=<T2T3,l5> <CI2,l6>=<l6,CI2> => CI2//l6 <ET2,BD>=<T2T3,l5>, <T2T3,l5>=<l3,ET3>, <BF,EF>=<l3,ET3>, <BF,EF>=<l2,ET2> => <ET2,BD>=<l2,ET2> CI2//l6, on line l6 => line CI2l6 <BI1,BD>=<l2,BI1> => <BD,BI1>=<BI1,l2> <ET2,BD>=<l2,ET2> => <BD,ET2>=<ET2,l2> line CI2l6 => I2 on line l6 <BD,BI1>=<BI1,l2>, <BD,ET2>=<ET2,l2> => <BI1,ET2>=<ET2,BI1> on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <FT3,EF>=<IT3,EI> on circle (BEF), T3 on circle (BEF), on line l6, on line l6, T3 on line l3, on line l3 => <BF,FT3>=<BI,IT3> T2 on circle (BEF), T3 on circle (BEF), T2 on line l2, on line l2, T3 on line l3, on line l3 => <FT2,BF>=<T2T3,l3> T2 on circle (BEF), T2 on line l2, on line l2, on line l5, on line l5 => <ET2,l5>=<FT2,BF> <BD,I2P2>=<BF,l6>, P2 on line BD, on line l6, I2 on line l6 => P2 on circle (BFI2) <BI1,ET2>=<ET2,BI1> => BI1//ET2 <FT3,EF>=<IT3,EI>, <FT3,EF>=<l3,l5>, <l3,l5>=<l5,BD> => <IT3,EI>=<l5,BD> <BF,FT3>=<BI,IT3>, <BF,FT3>=<l2,T2T3>, <T1T2,T1T3>=<l2,T2T3>, <T1T2,T1T3>=<T2T3,l3>, <FT2,BF>=<T2T3,l3>, <ET2, l5>=<FT2,BF> => <BI,IT3>=<ET2,l5> P2 on circle (BFI2), on line l6, I2 on line l6, P2 on line BD, I2 on line l5, on line l5 => <FP2,BF>=<I2P2,l5> 15 <BD,I2P2>=<EI,l5> => <BD,EI>=<I2P2,l5> BI1//ET2 => <BI1,BI>=<ET2,BI> <IT3,EI>=<l5,BD> => <BD,EI>=<l5,IT3> <BI,IT3>=<ET2,l5> => <ET2,BI>=<l5,IT3> l2 is tangent to (T1T2T3), T2 on line l2, T4 on circle (T1T2T3) => <T2T4,T3T4>=<l2,T2T3> on circle (BEF), T2 on circle (BEF), on line l6, on line l6, T2 on line l2, on line l2 => <FT2,BF>=<IT2,BI> <BI1,BI>=<ET2,BI>, <ET2,BI>=<l5,IT3>, <BD,EI>=<l5,IT3>, <BD,EI>=<I2P2,l5>, <FP2,BF>=<I2P2,l5> => <BI1,BI>=<FP2,BF > <FT2,BF>=<IT2,BI>, <FT2,BF>=<T2T3,l3>, <T1T2,T1T3>=<T2T3,l3>, <T1T2,T1T3>=<l2,T2T3>, <T2T4,T3T4>=<l2,T2T3> => <IT2,BI>=<T2T4,T3T4> <BI1,BI>=<FP2,BF> => <BF,BI>=<FP2,BI1> <IT2,BI>=<T2T4,T3T4> => <T2T4,IT2>=<T3T4,BI> BF//T3T4 => <BF,BI>=<T3T4,BI> IT2=IT4 => <IT4,T2T4>=<T2T4,IT2> <BF,BI>=<FP2,BI1>, <BF,BI>=<T3T4,BI>, <T2T4,IT2>=<T3T4,BI>, <IT4,T2T4>=<T2T4,IT2> => <FP2,BI1>=<IT4,T2T4> <ET2,l5>=<FT2,BF>, <FT2,BF>=<T2T3,l3>, <T1T2,T1T3>=<T2T3,l3>, <T1T2,T1T3>=<l2,T2T3>, <T2T4,T3T4>=<l2,T2T3> => <ET2,l5>=<T2T4,T3T4> <FP2,BI1>=<IT4,T2T4> => <IT4,FP2>=<T2T4,BI1> BF//T3T4 => <BF,l5>=<T3T4,l5> <ET2,l5>=<T2T4,T3T4> => <T2T4,ET2>=<T3T4,l5> P2 on circle (BFI2), on line l6, I2 on line l6, P2 on line BD, I2 on line l5, on line l5 => <BF,l5>=<FP2,I2P2> BI1//ET2 => <T2T4,BI1>=<T2T4,ET2> <BF,l5>=<FP2,I2P2>, <BF,l5>=<T3T4,l5>, <T2T4,ET2>=<T3T4,l5>, <T2T4,BI1>=<T2T4,ET2>, <IT4,FP2>=<T2T4,BI1> => < FP2,I2P2>=<IT4,FP2> <BD,I2P2>=<IT4,l4> => <BD,I2P2>=<IT4,l4> <BD,DI2>=<DI2,l4> => <BD,DI2>=<DI2,l4> <FP2,I2P2>=<IT4,FP2> => <FP2,I2P2>=<IT4,FP2> m2 is tangent to (I1), I1 is circumcenter of (I1), U2 on circle (I1), U2 on line m2 => I1U2m2 m1 is tangent to (I1), I1 is circumcenter of (I1), U1 on circle (I1), U1 on line m1 => I1U1m1 m1 is tangent to (I2), I2 is circumcenter of (I2), V1 on circle (I2), V1 on line m1 => I2V1m1 m2 is tangent to (I2), I2 is circumcenter of (I2), V2 on circle (I2), V2 on line m2 => I2V2m2 <BD,DI2>=<DI2,l4>, <BD,I2P2>=<IT4,l4>, <FP2,I2P2>=<IT4,FP2> => <DI2,FP2>=<FP2,DI2> <l1,IT1>=<l2,IT2>, T2 on line l2, T1 on line l1, on line l2, on line l1 => T2 on circle (AIT1) <DI2,FP2>=<FP2,DI2> => DI2FP2 <IT3,l6>=<T3T4,l4>, <T1T3,T1T4>=<T3T4,l4>, <T1T3,T1T4>=<l3,T3T4> => <IT3,l6>=<l3,T3T4> T2 on circle (AIT1), T2 on line l2, on line l2, on line l1, T1 on line l1 => <T1T2,IT2>=<l1,AI> T2 on circle (AIT1), T2 on line l2, on line l2, on line l1, T1 on line l1 => <AI,l2>=<IT1,T1T2> IT1=IT2 => <IT1,T1T2>=<T1T2,IT2> <l1,IT1>=<l4,IT4>, T1 on line l1, T4 on line l4, on line l1, on line l4 => T4 on circle (DIT1) m1I1U1, m2I1U2 => <m1,I1U1>=<m2,I1U2> I2V1m1, I2V2m2 => <I2V1,m1>=<I2V2,m2> <IT3,l6>=<l3,T3T4> => <T3T4,l6>=<l3,IT3> <AI,l2>=<IT1,T1T2>, <IT1,T1T2>=<T1T2,IT2>, <T1T2,IT2>=<l1,AI> => <AI,l2>=<l1,AI> T4 on circle (DIT1), on line l1, T1 on line l1, on line l4, T4 on line l4 => <DI,IT1>=<l4,T1T4> l4 is tangent to (T1T2T3), T4 on circle (T1T2T3), T4 on line l4 => <T2T4,T1T2>=<l4,T1T4> <m1,I1U1>=<m2,I1U2> => <I1U1,I1U2>=<m1,m2> <I2V1,m1>=<I2V2,m2> => <I2V1,I2V2>=<m1,m2> m2I1U2, m2I2V2 => <m2,I1U2>=<m2,I2V2> DI2FP2, l3IT3, <T3T4,l6>=<l3,IT3> => <DI2,FP2>=<T3T4,l6> <AI1,l1>=<l2,AI1> => <AI1,l1>=<l2,AI1> <AI,l2>=<l1,AI> => <AI,l1>=<l2,AI> <DI,IT1>=<l4,T1T4>, <T2T4,T1T2>=<l4,T1T4> => <DI,IT1>=<T2T4,T1T2> I1U2=I1U1, I2V1=I2V2 => I1U2/I1U1=I2V1/I2V2 <I1U1,I1U2>=<m1,m2>, <I2V1,I2V2>=<m1,m2> => <I1U1,I1U2>=<I2V1,I2V2> <m2,I1U2>=<m2,I2V2> => I1U2//I2V2 FP2DI2, l3IT3, <T3T4,l6>=<l3,IT3> => <FP2,DI2>=<T3T4,l6> <BF,l5>=<FP2,I2P2>, <BF,l5>=<T3T4,l5> => <FP2,I2P2>=<T3T4,l5> P2 on circle (BFI2), on line l6, I2 on line l6, P2 on line BD, I2 on line l5, on line l5 => <BD,l5>=<FP2,l6> <DI2,FP2>=<T3T4,l6> => <DI2,T3T4>=<FP2,l6> T2 on circle (BEF), T3 on circle (BEF) => <EF,FT3>=<ET2,T2T3> BI1//ET2 => <BI1,T2T3>=<ET2,T2T3> T3 on circle (BEF), on line l5, on line l5, T3 on line l3, on line l3 => <EF,FT3>=<l5,l3> <AI,l1>=<l2,AI>, <AI1,l1>=<l2,AI1> => <AI,AI1>=<AI1,AI> <DI,IT1>=<T2T4,T1T2> => <DI,T2T4>=<IT1,T1T2> I1U2/I1U1=I2V1/I2V2, <I1U1,I1U2>=<I2V1,I2V2> => <I2V1,V1V2>=<U1U2,I1U2> I1U2//I2V2 => <V1V2,I1U2>=<V1V2,I2V2> I2V1=I2V2 => <I2V1,V1V2>=<V1V2,I2V2> I1U1=I1U2 => <I1U1,U1U2>=<U1U2,I1U2> I1U1m1, m2I1U2 => <I1U1,m1>=<m2,I1U2> <FP2,DI2>=<T3T4,l6> => <DI2,l6>=<FP2,T3T4> <FP2,I2P2>=<T3T4,l5> => <FP2,T3T4>=<I2P2,l5> <I1P1,BD>=<l5,EI> => <BD,EI>=<I1P1,l5> <BI1,T2T3>=<ET2,T2T3>, <EF,FT3>=<ET2,T2T3>, <EF,FT3>=<l5,l3>, <BD,l5>=<l5,l3>, <BD,l5>=<FP2,l6>, <DI2,T3T4>=< FP2,l6> => <BI1,T2T3>=<DI2,T3T4> <AI,AI1>=<AI1,AI> => AI//AI1 <AI,l2>=<IT1,T1T2>, <DI,T2T4>=<IT1,T1T2> => <AI,l2>=<DI,T2T4> <I2V1,m1>=<I2V2,m2>, V2 on line m2, V1 on line m1, on line m2, on line m1 => on circle (I2V1V2) <m1,I1U1>=<m2,I1U2>, U2 on line m2, U1 on line m1, on line m2, on line m1 => on circle (I1U1U2) m1 is tangent to (I2), V1 on circle (I2), V1 on line m1, V2 on circle (I2), P2 on circle (I2) => <P2V1,P2V2>=<m1,V1V2> m2 is tangent to (I2), V2 on circle (I2), V2 on line m2, V1 on circle (I2), P2 on circle (I2) => <P2V1,P2V2>=<V1V2,m2> <I1U1,U1U2>=<U1U2,I1U2>, <I2V1,V1V2>=<U1U2,I1U2>, <I2V1,V1V2>=<V1V2,I2V2>, <V1V2,I1U2>=<V1V2,I2V2> => <I1U1, U1U2>=<V1V2,I1U2> <I1U1,m1>=<m2,I1U2> => <I1U1,m2>=<m1,I1U2> <DI2,l6>=<FP2,T3T4>, <FP2,T3T4>=<I2P2,l5> => <DI2,l6>=<I2P2,l5> <BI1,BI>=<ET2,BI>, <ET2,BI>=<l5,IT3>, <BD,EI>=<l5,IT3>, <BD,EI>=<I1P1,l5> => <BI1,BI>=<I1P1,l5> <BI1,T2T3>=<DI2,T3T4> => <BI1,DI2>=<T2T3,T3T4> BF//T3T4 => <T2T3,BF>=<T2T3,T3T4> <BF,FT3>=<T2T3,l3> => <T2T3,BF>=<l3,FT3> on circle (BEF), T3 on circle (BEF), on line l6, on line l6, T3 on line l3, on line l3 => <BI,l6>=<l3,FT3> 16 AI//AI1 => line AIAI1 l2 is tangent to (T1T2T3), T2 on line l2, T4 on circle (T1T2T3) => <T2T3,T3T4>=<l2,T2T4> <AI,l2>=<DI,T2T4> => <AI,DI>=<l2,T2T4> on circle (I2V1V2), V1 on line m1, on line m1, V2 on line m2, on line m2 => <V1V2,I2V2>=<m1,I2X> on circle (I1U1U2), U2 on line m2, on line m2, on line m1, U1 on line m1 => <U1U2,I1U2>=<m1,I1X> <P2V1,P2V2>=<V1V2,m2>, <P2V1,P2V2>=<m1,V1V2> => <V1V2,m2>=<m1,V1V2> <I1U1,U1U2>=<V1V2,I1U2> => <I1U1,U1U2>=<V1V2,I1U2> <I1U1,m2>=<m1,I1U2> => <I1U1,m1>=<m2,I1U2> <DI2,l6>=<I2P2,l5>, <BD,EI>=<I2P2,l5>, P2 on line BD, I2 on line l5, on line l5, I2 on line l6, on line l6 => DP2/DI2=EI/II2 <BI1,BI>=<I1P1,l5>, <BD,EI>=<I1P1,l5>, P1 on line BD, on line l5, on line l5 => BE/BI=I1P1/BI1 <DI2,l6>=<I2P2,l5>, <BD,EI>=<I2P2,l5>, P2 on line BD, I2 on line l5, on line l5, I2 on line l6, on line l6 => DP2/I2P2=EI/EI2 <BI,l6>=<l3,FT3>, <T2T3,BF>=<l3,FT3>, <T2T3,BF>=<T2T3,T3T4>, <BI1,DI2>=<T2T3,T3T4> => <BI,l6>=<BI1,DI2> line AIAI1 => I1 on line AI <AI,DI>=<l2,T2T4>, <T2T3,T3T4>=<l2,T2T4>, <T2T3,BF>=<T2T3,T3T4>, <T2T3,BF>=<l3,FT3>, <BI,l6>=<l3,FT3> => <AI,DI >=<BI,l6> I1U1m1, I2V1m1 => <I1U1,m1>=<I2V1,m1> <U1U2,I1U2>=<m1,I1X>, <I2V1,V1V2>=<U1U2,I1U2>, <I2V1,V1V2>=<V1V2,I2V2>, <V1V2,I2V2>=<m1,I2X> => <m1,I1X>=<m1, I2X> <V1V2,m2>=<m1,V1V2> => <V1V2,m1>=<m2,V1V2> <I1U1,U1U2>=<V1V2,I1U2>, <I1U1,m1>=<m2,I1U2> => <U1U2,m1>=<m2,V1V2> I2V1=I2V2, I2V2=I2V1 => I2V1/I2V2=I2V2/I2V1 DP2/DI2=EI/II2 => EI/DP2=II2/DI2 BE/BI=I1P1/BI1 => BE/I1P1=BI/BI1 I1P1=I1U2 => BE/I1P1=BE/I1U2 DP2/I2P2=EI/EI2 => EI/DP2=EI2/I2P2 <BI,l6>=<BI1,DI2>, <AI,DI>=<BI,l6>, I1 on line AI, I2 on line l6, on line l6 => BI/BI1=II2/DI2 <I1U1,m1>=<I2V1,m1> => I1U1//I2V1 <m1,I1X>=<m1,I2X> => I1X//I2X <V1V2,m1>=<m2,V1V2>, on line m2, V2 on line m2, on line m1, V1 on line m1 => V1X/V1V2=V2X/V1V2 <U1U2,m1>=<m2,V1V2>, on line m2, U2 on line m2, on line m1, U1 on line m1, V1 on line m1, V2 on line m2 => U1X/U1U2=V2X/ V1V2 I2V1/I2V2=I2V2/I2V1 => V1V2/I2V1=V1V2/I2V2 I1U2/I1U1=I2V1/I2V2, <I1U1,I1U2>=<I2V1,I2V2> => U1U2/I1U1=V1V2/I2V2 BE/I1P1=BE/I1U2, BE/I1P1=BI/BI1, BI/BI1=II2/DI2, EI/DP2=II2/DI2, EI/DP2=EI2/I2P2 => BE/I1U2=EI2/I2P2 I1U1//I2V1, I1X//I2X, U1 on line m1, on line m1, V1 on line m1 => I1X/U1X=I2X/V1X I1P1=I1U2, I2V1=I2P2 => I1P1/I1U2=I2V1/I2P2 U1X/U1U2=V2X/V1V2, V1X/V1V2=V2X/V1V2 => U1X/U1U2=V1X/V1V2 I1U1=I1P1, I2P2=I2V1 => I1U1/I1P1=I2P2/I2V1 U1U2/I1U1=V1V2/I2V2, V1V2/I2V1=V1V2/I2V2 => U1U2/I1U1=V1V2/I2V1 I1U1=I1P1, I2P2=I2V2 => I1U1/I1P1=I2P2/I2V2 I1U1=I1P1, I2V1=I2V2 => I1U1/I1P1=I2V1/I2V2 I1X//I2X => line I1XI2X BE/I1U2=EI2/I2P2 => BE/EI2=I1U2/I2P2 I1X/U1X=I2X/V1X => I1X/I2X=U1X/V1X I1P1/I1U2=I2V1/I2P2 => I1P1/I2V1=I1U2/I2P2 U1X/U1U2=V1X/V1V2 => U1U2/V1V2=U1X/V1X I1U1/I1P1=I2P2/I2V1 => I1P1/I2V1=I1U1/I2P2 U1U2/I1U1=V1V2/I2V1 => I1U1/I2V1=U1U2/V1V2 I1U1/I1P1=I2P2/I2V2 => I1P1/I2V2=I1U1/I2P2 I1U1/I1P1=I2V1/I2V2 => I1P1/I2V2=I1U1/I2V1 line I1XI2X => I2 on line I1X BE/EI2=I1U2/I2P2, I1P1/I2V1=I1U2/I2P2, I1P1/I2V1=I1U1/I2P2, I1P1/I2V2=I1U1/I2P2, I1P1/I2V2=I1U1/I2V1, I1U1/I2V1=U1U2/V1V2, U1U2/V1V2=U1X/V1X, I1X/I2X=U1X/V1X => BE/EI2=I1X/I2X BE/EI2=I1X/I2X, I2 on line I1X, on line l5, on line l5, I2 on line l5, I1 I2 and I2 have same order => BE/BI2=I1X/I1I2 BE/BI2=I1X/I1I2 => I1I2/BI2=I1X/BE BE/EI2=I1X/I2X => I1X/BE=I2X/EI2 I1I2/BI2=I1X/BE, I1X/BE=I2X/EI2 => I1I2/BI2=I2X/EI2 FP2DI2, I1P1BD => <FP2,DI2>=<I1P1,BD> <FP2,BF>=<I2P2,l5>, <BD,EI>=<I2P2,l5>, <BD,EI>=<I1P1,l5> => <FP2,BF>=<I1P1,l5> I1I2/BI2=I2X/EI2, I2 on line I1X, I2 on line l5, on line l5, on line l5 => <l5,BI1>=<l5,EX> on circle (BEF), T2 on circle (BEF), on line l6, on line l6, T2 on line l2, on line l2 => <BF,FT2>=<BI,IT2> T2 on circle (BEF), T2 on line l2, on line l2, on line l5, on line l5 => <BF,FT2>=<l5,ET2> BI1//ET2 => <l5,BI1>=<l5,ET2> on circle (BEF), T2 on circle (BEF), on line l6, on line l6 => <FT2,EF>=<IT2,EI> T2 on circle (BEF), T2 on line l2, on line l2, on line l5, on line l5 => <FT2,EF>=<l2,l5> <FT3,EF>=<l3,l5>, <l3,l5>=<l5,BD> => <FT3,EF>=<l5,BD> on circle (BEF), on line l6, on line l6, on line l5, on line l5 => <BF,l5>=<l6,EI> <FP2,DI2>=<I1P1,BD> => <DI2,BD>=<FP2,I1P1> on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <FT3,ET3>=<l6,EI> <FP2,BF>=<I1P1,l5> => <BF,l5>=<FP2,I1P1> <BF,FT2>=<BI,IT2>, <BF,FT2>=<l5,ET2>, <l5,BI1>=<l5,ET2>, <l5,BI1>=<l5,EX> => <BI,IT2>=<l5,EX> <FT2,EF>=<IT2,EI>, <FT2,EF>=<l2,l5> => <IT2,EI>=<l2,l5> <FT3,EF>=<l5,BD> => <EF,BD>=<FT3,l5> <DI2,BD>=<FP2,I1P1>, <BF,l5>=<FP2,I1P1>, <BF,l5>=<l6,EI>, <FT3,ET3>=<l6,EI> => <DI2,BD>=<FT3,ET3> on circle (BEF), on line l6, on line l6, on line l5, on line l5 => <EF,l5>=<l6,BI> <BI,IT2>=<l5,EX> => <BI,IT2>=<l5,EX> <IT2,EI>=<l2,l5> => <EI,IT2>=<l5,l2> <EF,BD>=<FT3,l5> => <BD,EF>=<l5,FT3> <DI2,BD>=<FT3,ET3> => <BD,DI2>=<ET3,FT3> <BI,l6>=<BI1,DI2>, <AI,DI>=<BI,l6>, I1 on line AI, I2 on line l6, on line l6 => DI/DI2=II1/BI1 <EF,l5>=<l6,BI> => <BI,l5>=<l6,EF> <BI,l6>=<BI1,DI2>, <AI,DI>=<BI,l6>, I1 on line AI, I2 on line l6, on line l6 => BI/II1=II2/DI <BI,IT2>=<l5,EX>, <EI,IT2>=<l5,l2> => <BI,EI>=<l2,EX> <BD,DI2>=<ET3,FT3>, <BD,EF>=<l5,FT3> => <DI2,EF>=<l5,ET3> DI/DI2=II1/BI1 => DI/II1=DI2/BI1 <BI,l5>=<l6,EF>, I2 on line l6, on line l6, I2 on line l5, on line l5, on line l5, on line l6 => EI2/EF=II2/BI BI/II1=II2/DI => DI/II1=II2/BI IT2=IT3 => <IT3,T2T3>=<T2T3,IT2> on circle (BEF), T2 on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <IT3,T2T3>=<l6,FT2> 17 on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <ET3,EI>=<FT3,l6> on circle (BEF), T2 on circle (BEF), T3 on circle (BEF), on line l6, on line l6 => <FT3,l6>=<T2T3,IT2> <BI,EI>=<l2,EX> => <BI,l2>=<EI,EX> on circle (BEF), T2 on circle (BEF), on line l6, on line l6, T2 on line l2, on line l2 => <BI,l2>=<l6,FT2> <DI2,EF>=<l5,ET3>, <BD,EF>=<l5,FT3>, I2 on line l5, on line l5 => DI2/BI2=ET3/EF I1I2/BI2=I2X/EI2, I2 on line I1X, I2 on line l5, on line l5, on line l5 => BI2/BI1=EI2/EX DI/II1=DI2/BI1, DI/II1=II2/BI, EI2/EF=II2/BI => DI2/BI1=EI2/EF <BI,l2>=<EI,EX>, <BI,l2>=<l6,FT2>, <IT3,T2T3>=<l6,FT2>, <IT3,T2T3>=<T2T3,IT2>, <FT3,l6>=<T2T3,IT2>, <ET3,EI>=< FT3,l6> => <EI,EX>=<ET3,EI> BI2/BI1=EI2/EX, DI2/BI2=ET3/EF, DI2/BI1=EI2/EF => EI/ET3=EI/EX EI/ET3=EI/EX, <EI,EX>=<ET3,EI> => IT3/ET3=IX/EX BI2/BI1=EI2/EX, DI2/BI2=ET3/EF, DI2/BI1=EI2/EF, IT2=IT4, IT3=IT4 => IT2/EX=IT3/ET3 IT2/EX=IT3/ET3, IT3/ET3=IX/EX => IT2/EX=IX/EX IT2/EX=IX/EX => IT2=IX IT1=IT2, IT2=IX => IT1=IX IT1=IX => Goal Listing 1 Example geometric theorem proving from our HAGeo. We manually convert and improve the proof of HAGeometry to make it easier to understand. Proof: DP2 = BD+CDBC 2 = BD+DT4BT 2 = BD+DT1BT2 2 = BD+ABAD 2 = BP1. EI2I = 90 BDC 2 = P2I2D EII2 P2DI2. EBI = 90 ABD 2 = P1I1B BEI I1P1B EI2 = EI I2P2 DP2 BE = I2P2 EI2 P1P1 EX I1B = EI BP1 = BE I1P1 = XI2 XI1 EI2 BI2 = EX BI1 BI1I = 90 ADB 2 = I2DI, DI2I1 = 90 + DCB 2 = I1BI DII2 I1IB EF EI2 = BI II2 = BI1 DI2 ET3F = EII2 = I2DB, EF T3 = EBC = I2BD ET3F I2DB ET3 DI = EF BI2 EX = ET3 T3EI = T3BI = 90 I1BE = (EI, IB1) = IEX ET3I EXI IX = IT3 18 Prompt to Convert Natural Language into AlphaGeometrys Geometric"
        },
        {
            "title": "Language",
            "content": "Translate geometry problem from natural language into the following format: The geometric objects in the converted problem format only contain points. The naming conventions follows the following rule: Points are named using lower letters like a,b,c,...,x,y,z, or lower letters with subscripts numbers like a1, b1, a2, ... Convert the name if not in this convention, for example, convert I_A to i_1 The format is divided into two parts: 1. Problem Definition and 2. Conclusion to be Proved. Note that the definitions of points are separated by ; and definition and conclusion are separated by ? Problem Definition: The general structure starts by setting some initial structure and then adding one or more geometry objects each time. Initial or free structures can be point, segment, triangle, quadrilateral, pentagon, ... For example: \"Free point A\" convert to \"a = free\" \"Segment AB\" convert to \"a = segment\" \"Triangle ABC\" or \"Acute triangle ABC\" or \"Obtuse triangle ABC\" convert to \"a c= triangle\". \"Isosceles triangle ABC with AB=AC\" convert to \"a = iso_triangle\" \"Right triangle ABC with angle A=90\" convert to \"a = r_triangle\". \"Right Isosceles triangle ABC\" convert to \"a = risos\" \"Equilateral triangle ABC\" \"a = ieq_triangle\" \"Quadrilateral ABCD\" is converted to \"a = quadrangle\". \"Trapezoid ABCD with AB//CD\" convert to \"a = trapezoid\" \"Isosceles Trapezoid ABCD with AB//CD and AD=BC\" convert to \"a = eq_trapezoid\" \"Right trapezoid ABCD with A=90\" convert to \"a = r_trapezoid\" \"Rectangle ABCD\" convert to \"a = rectangle\" \"Pentagon ABCDE\" is converted to \"a e = pentagon\". Each time new point is constructed, using one or two constraints, The constraints could be: \"M is the midpoint of AB\" convert to \"m = midpoint b\". \"X is foot of on BC\" is converted to \"x = foot c\". \"X as the reflection of wrt point B\" convert to \"x = mirror b\". \"X as the reflection of wrt line BC\" convert to \"x = reflect c\". \"X are tangent points of the tangent lines from point to circle centered passing through B\" convert to \"x = tangent o b\" \"X satisfies AX is the diameter in (O)\" convert to \"x = mirror o\" \"The common tangent line l1, l2 of (O1,A) and (O2,B) tangent the two circles at X1,Y1, X2,Y2\" convert to \"x1 y1 x2 y2 = cc_tangent o1 o2 b\" \"O is circumcenter of ABC\" convert to \"o = circumcenter c\". \"I is incenter of ABC\" convert to \"i = incenter c\". \"H is orthocenter of ABC\" convert to \"h = orthocenter C\". \"I is the excenter of in ABC\" convert to \"i = excenter c\", 19 \"I as the excenter of in ABC\" convert to \"i = excenter a\", \"I is the excenter of in ABC\" convert to \"i = excenter b\". \"G is centroid of ABC\" convert to \"g = centroid c\" \"N is the nine-point center of ABC\" convert to \"n = ninepoints c\". \"X satisfies ABCX is parallelogram\" convert to \"x = parallelogram x\". \"X are points such that XYAB is square\" convert to \"x = square b\". \"X satisfies XBC is equilateral triangle\" convert to \"x = eq_triangle c\" \"X such that XA=BC\" convert to \"x = eqdistance c\" \"X on line BC\" convert to \"x = on_line c\". \"X on parallel line from to BC\" convert to \"x = on_pline c\" \"X on the perpendicular line from to BC\" convert to \"x = on_tline c\" \"X on perpendicular bisector of AB\" convert to \"x = on_bline b\" \"X on angle bisector of BAC\" convert to \"x = angle_bisector c\" \"X on circle with center pass through A\" convert to \"x = on_circle a\" \"X on circle passing through C\" convert to \"x = on_circum c\" \"X on circle with diameter AB\" convert to \"x = on_dia b\". \"X on tangent from point to circle centered passing through A\" convert to \"x = on_tline a\". \"X satisfies XAB=DEF\" convert to \"on_aline d f\" \"X satisfies AXB=DEF\" convert to \"eqangle3 e f\" If satisfies two constraints, separate the two constraints with \", \" For example, is the intersection of two conditions, it can be written as \"X = condition1, condition2\": \"X is the intersection of AB and CD\" convert to \"X = on_line b, on_line d\". \"X is the intersection of circles (O, A) and (P, B)\" convert to \"x = on_circle a, on_circle b\". \"X is the other intersection of line AB with circle (O, P)\" convert to \"X = on_line b, on_circle p\". Conclusion to be Proved: \"A are cyclic\" converted to \"? cyclic d\". \"A, B, and are collinear\" convert to \"? coll c\". \"AB perpendicular to CD\" convert to \"? perp d\". \"AB parallel to CD\" convert to \"? para d\". \"AB = CD\" convert to \"? cong d\", \"Angle ABC = DEF\" convert to \"? eqangle c f\". \"Ratio AB/CD = EF/GH\" convert to \"? eqratio d h\" \"M is the midpoint of AB\" convert to \"? midp b\". \"ABC DEF\" or \"ABC is similar to DEF\", convert to \"? simtri d f\". \"ABC = DEF\" or \"ABC is congruent to DEF\", convert to \"? contri d f\". Some conclusion need definition of new points: \"AB bisect CD\" or \"AB pass through the midpoint of CD\" convert to \"m = midpoint ? midp d\" \"AB, CD, EF are concurrent\" convert to \"x = on_line b, on_line ? coll f\". Note that each new point is separated by semicolon \";\", and the conclusion is separated by \" ? \". Note that newly added points must have different names from previously defined points. Some conversions require slight modifications: In triangle ABC, is that same as BAC. 20 The incircle or excircle (I) touching BC at point can be viewed as the foot on BC, hence convert to \"d = foot c\". The euler line is the line through orthocenter and circumcenter, on euler line of ABC convert to \"a = triangle; = circumcenter c; = orthocenter c; = on_line h\" The initial structure (O1),(O2) intersect in A, we can first define then define O1,O2 on perpendicular bisector \"a = segment; o1 = on_bline b; o2 = on_bline b\" The initial structure parallelogram ABCD, we need first define ABC then \"a = triangle; = parallelogram d;\" The initial structure cyclic ABCD, we need first define ABC then \"a = triangle; = on_circum c;\" Here are few examples: Problem 1: Let $ABCD$ be trapezoid with $ABparallel CD$ and $ Omega $ is circle passing through $A,B,C,D$. Let $ omega $ be the circle passing through $C,D$ and intersecting with $CA,CB$ at $A_1$, $B_1$ respectively. $A_2$ and $B_2$ are the points symmetric to $A_1$ and $B_1$ respectively, with respect to the midpoints of $CA$ and $CB$. Prove that the points $A,B,A_2,B_2$ are concyclic. Convert to: c = eq_trapezoid; = on_bline d; a1 = on_line c, on_circle c; b1 = on_line c, on_circle c; m1 = midpoint a; m2 = midpoint b; a2 = mirror a1 m1; b2 = mirror b1 m2 ? cyclic a2 b2 Problem 2: Given is an acute triangle $ABC$. Its heights $BB_1$ and $CC_1$ are extended past points $B_1$ and $C_1$. On these extensions, points $P$ and $Q$ are chosen, such that angle $PAQ$ is right. Let $AF$ be height of triangle $APQ$. Prove that angle $BFC$ is right angle. Convert to: = triangle; b1 = foot c; c1 = foot b; = on_line b1; = on_line c1, on_tline p; = foot ? perp c Problem 3: Let $ABC$ be triangle. Circle $Gamma$ passes through $A$, meets segments $AB$ and $AC$ again at points $D$ and $E$ respectively, and intersects segment $BC$ at $F$ and $G$ such that $F$ lies between $B$ and $G$. The tangent to circle $BDF$ at $F$ and the tangent to circle $CEG$ at $G$ meet at point $T$. Suppose that points $A$ and $T$ are distinct. Prove that line $AT$ is parallel to $BC$. Convert to: = triangle; = free; = on_line b, on_circle a; = on_line c, on_circle a; = on_line c, on_circle a; = on_line c, on_circle a; o1 = circumcenter f; o2 = circumcenter g; = on_tline o1 f, on_tline o2 ? para c Problem 4: Let $ABC$ be triangle with circumcentre $O$. The points $D,E,F$ lie in the interiors of the sides $BC,CA,AB$ respectively, such that $DE$ is perpendicular to $CO$ and $DF$ is perpendicular to $BO$. (By interior we mean, for example, that the point $D$ lies on the line $BC$ and $D$ is between $B$ and $C$ on that line.) Let $K$ be the circumcentre of triangle $AFE$. Prove that the lines $DK$ and $BC$ are perpendicular. Convert to: c = triangle; = circumcenter c; = on_line c; = on_line c, on_tline o; = on_line b, on_tline o; = circumcenter ? perp c Problem 5: In triangle $ABC$ with right angle at $C$, the angle bisector $AL$ (where $L$ is on segment $BC$) intersects the altitude $CH$ at point $K$. The bisector of angle $BCH$ intersects segment $AB$ at point $M$. Prove that $CK=ML$ Convert to: = r_triangle; = on_line c, angle_bisector c; = foot b; = on_line h, angle_bisector c; = on_line b, angle_bisector ? cong l Problem 6: Let $ABC$ be triangle with $angle BAC neq 90^{circ}.$ Let $O$ be the circumcenter of the triangle $ABC$ and $Gamma$ be the circumcircle of the triangle $BOC.$ Suppose that $Gamma$ intersects the line segment $AB$ at $P$ different from $B$, and the line segment $AC$ at $Q$ different from $C.$ Let $ON$ be the diameter of the circle $Gamma.$ Prove that the quadrilateral $APNQ$ is parallelogram. Convert to: = triangle; = circumcenter c; o1 = circumcenter c; = on_line b, on_circle o1 o; = on_line c, on_circle o1 o; = mirror o1 ? para q Problem 7: In an acute-angled triangle $ABC$ on the sides $AB$, $BC$, $AC$ the points $H$, $L$, $K$ so that $CH perp AB$, $HL parallel AC$, $HK parallel BC$. Let $P$ and $Q$ feet of altitudes of triangle $HBL$, drawn from the vertices $H$ and $B$ respectively. Prove that the feet of the altitudes of the triangle $AKH$, drawn from the vertices $A$ and $H$ lie on the line $PQ$. Convert to: = triangle; = foot b; = on_line c, on_pline c; = on_line c, on_pline c; = foot l; = foot l; = foot ; = foot ? coll Problem 8: Let $ABCD$ be parallelogram such that $AB > BC$. Let $O$ be point on the line $CD$ such that $OB = OD$. Let $omega$ be circle with center $O$ and radius $OC$. If $T$ is the second intersection of $omega$ and $CD$, prove that $AT, BO$ and $omega$ are concurrent. Convert to: c = triangle; = parallelogram d; = on_line d, on_bline d; = on_line d, on_circle c; = on_line t, on_line ? cong c Problem 9: As shown in the figure below, the in-circle of $ABC$ is tangent to sides $AB$ and $AC$ at $D$ and $E$ respectively, and $O$ is the circumcenter of $BCI$. Prove that $angle ODB = angle OEC$. Convert to: = triangle; = incenter c; = foot b; = foot c; = circumcenter ? eqangle b o Problem 10: In acute triangle $ABC,$ $AB<AC,$ $O$ is the circumcenter of the triangle. $M$ is the midpoint of segment $BC,$ $(AOM)$ intersects the line $AB$ again at $D$ and intersects the segment $AC$ at $E.$ Prove that $DM=EC.$ Convert to: = triangle; = circumcenter c; = midpoint c; o1 = circumcenter m; = on_line b, on_circle o1 a; = on_line c, on_circle o1 ? cong c Please follow these examples to convert the following problems: {INPUT_PROBLEM} Listing 2 An illustration of prompt converting natural language problem into AlphaGeometrys geometry specific language."
        },
        {
            "title": "G Prompt to Convert Natural Language into our Geometric language",
            "content": "Translate geometry problem from natural language into the following format: The geometric objects in the problem include points, lines, and circles. The naming conventions follows the following rule: Points are named using uppercase letters like A, B, C...X, Y, Z, or uppercase letters with subscripts (numbers or lowercase letters) like A1, B1, Ai, Bj, I_1,I_a... Convert the name if not in this convention, for example, convert I_A to I_a Lines are named using lowercase letters like l, m... or lowercase letters with numbers like l1, m2,... or by the names of two points on the line like AB, CD. Circles are named using the center of the circle of the circle (O), (P),... or diameter of the circle (AB),(CD),... or three points on the circle with parentheses or or (ABC), (DEF),... or the center and point on the circle separated by comma (O, A), (O, P)... or similar with lines with lower case letter c,c1,... or greek letter such as Γ,γ,Ω,ω... The format is divided into two parts: 1. Problem Definition and 2. Conclusion to be Proved. Problem Definition: The general structure starts by setting some initial structure and then adding one or more geometry objects each time. Initial structures can be triangle, acute_triangle, or right_triangle, quadrilateral, pentagon, ... or point line circle: \"Triangle ABC\" convert to \"A = triangle\". \"Acute triangle ABC\" convert to \"A = acute_triangle\". \"Right triangle ABC\" convert to \"A = right_triangle\". \"Obtuse triangle ABC\" convert to \"A = obtuse_triangle\". \"Isosceles triangle ABC with AB=BC\" convert to \"B = isos_triangle\" \"Equilateral triangle ABC\" \"A = equilateral_triangle\" \"Quadrilateral ABCD\" is converted to \"A = quadrilateral\". \"Cyclic quadrilateral ABCD\" is converted to \"A = cyclic_quadrilateral\". \"Tangential quadrilateral ABCD\" convert to \"A = tangential_quadrilateral\". \"Pentagon ABCDE\" is converted to \"A E = pentagon\". \"Hexagon ABCDEF\" is converted to \"A E = hexagon\". Each time new point or line or circle is constructed, the definition for each point is given using one or two constraints, The constraints could be: \"A on line BC\" convert to \"A = on_line BC\". \"A on circle (O)\" convert to \"A = on_circle (O)\". \"D is the foot of on BC\" is converted to \"D = foot BC\". \"M is the midpoint of AB\" convert to \"M = midpoint B\". \"M is the midpoint of arc ABC\" convert to \"M = midarc C\" \"M is the midpoint of arc AB without C\" convert to \"M = midarc_no C\" \"O is the circumcenter of ABC\" convert to \"O = circumcenter ABC\". \"H is the orthocenter of ABC\" convert to \"H = orthocenter C\". \"I is the incenter of ABC\" convert to \"I = incenter C\". \"N is the nine-point center of ABC\" convert to \"N = ninepointcenter C\". \"I1 is the excenter relative to in ABC\" convert to \"I1 = excenter C\", \"I2 as the excenter relative to in ABC\" convert to \"I2 = excenter A\", \"I3 is the excenter relative to in ABC\" convert to \"I3 = excenter B\". \"P is the isogonal conjugate of wrt ABC\" convert to \"P = isogonal_conjugate C\". \"X satisfies ABCX is parallelogram\" convert to \"X = parallelogram X\". \"X are points such that XYAB is square\" convert to \"X = square B\". \"X as the reflection of wrt line BC\" convert to \"X = reflect BC\". 23 \"X as the reflection of wrt point B\" convert to \"X = reflect B\". \"The radical axis of circles (A) and (B)\" convert to \"radical_axis (A) (B)\". \"Tangent from point to circle (O)\" convert to \"tangent_line (O)\". \"the tangent line from to (O) intersect (O) at X, Y\" convert to \"X = tangent_point (O)\" \"Euler line of triangle ABC\" convert to \"euler_line C\". \"perpendicular bisector of AB\" convert to \"perpendicular_bisector AB\". \"The angle bisector of angle ABC\" or \"The angle bisector of angle in triangle ABC\" convert to \"angle_bisector C\". \"The external angle bisector of angle ABC\" or \"The external angle bisector of angle in triangle ABC\" convert to \"angle_exbisector C\". \"line through parallel to BC\" convert to \"parallel_line BC\". \"perpendicular line through to BC\" convert to \"perpendicular_line BC\". \"circle with diameter AB\" convert to \"(AB)\". \"X satisfies AX=BC\" convert to \"length_equal C\" \"X satisfies <AXY=<PQR\" convert to \"angle_equal P R\" \"O is the circumcenter of triangle formed by lines l1,l2,l3\" convert to \"X = triangle l1 l2 l3; = circumcenter Z\" here should be new points with dfferent names \"AB is the diameter in (O)\" (where is already defined) convert to \"B = antipodal (O)\" \"l is line through A\" convert to \"l = line_through A\" \"ω is circle through B\" convert to \"ω = circle_through B\" If satisfies two constraints, separate the two constraints with \", \" For example, is the intersection point under two conditions, it can be written as \"X = condition1, condition2\" or \"X = intersection condition1, condition2\" . : \"X is the intersection of AB and CD\" convert to \"X = AB, CD\". \"X is the intersection of circles (O, OA) and (P, PB)\" convert to \"X = (O, OA), (P, PB)\". \"X is the other intersection of line AB with circle (O, OP)\" convert to \"X = AB, (O, OP)\". \"X as the other intersection of line PQ with circle (ABC)\" convert to \"X = PQ, (ABC)\". Note that there should always be \",\" between two conditions. Conclusion to be Proved: \"A are cyclic\" converted to \"concyclic D\". \"A, B, and are collinear\" convert to \"collinear C\". \"AB, CD, EF are concurrent\" convert to \"concurrent AB CD EF\". \"AB perpendicular to CD\" convert to \"perpendicular AB CD\". \"AB parallel to CD\" convert to \"parallel AB CD\". \"AB = CD\" convert to \"cong AB CD\", \"ABC = DEF\" convert to \"equal_angle ABC DEF\". \"M is the midpoint of AB\" convert to \"midpoint B\". \"ABC DEF\" or \"ABC is similar to DEF\", convert to \"similar ABC DEF\". \"ABC = DEF\" or \"ABC is congruent to DEF\", convert to \"contri ABC DEF\". \"ABCD is square\" convert to \"square D\". \"Circles (O1), (O2), and (O3) having common radical axis\" or \"(O1), (O2), (O3) are coaxal\" convert to \"coaxal (O1) (O2) (O3)\". \"AB bisect CD\" or \"AB pass through the midpoint of CD\" convert to \"bisect AB CD\" Note that each new point is separated by semicolon \";\", and the conclusion is separated by \"Prove: \". Note that newly added points must have different names from previously defined points. Some conversions require slight modifications: In triangle ABC, is that same as BAC. 24 The incircle or excircle (I) touching BC at point can be viewed as the foot on BC, hence convert to \"D = foot BC\" or directly \"D = (I), BC\". Note that AB represents line or segment without any space in between, such as in \"concurrent AB CD EF\" or \"foot AB\". Here are few examples: Problem 1: In cyclic hexagon ABCDEF, extend AB and CD to intersect at point G. Extend AF and DE to intersect at point H. Let and be the circumcenters of triangles BCG and EFH, respectively. Prove that lines BE, CF, and MN are concurrent. Convert to: D = cyclic_hexagon; = AB, CD; = AF, DE; = circumcenter G; = circumcenter H; Prove: concurrent BE CF MN Problem 2: Let be the orthocenter of triangle ABC, and be any point. The lines AP, BP, and CP intersect the circumcircle of triangle ABC at points A1, B1, and C1, respectively. Let A2, B2, and C2 be the reflections of A1, B1, and C1 over the sides BC, CA, and AB, respectively. Then, A1, B1, C1, and are concyclic. Convert to: = triangle; = orthocenter C; = point; A1 = AP, (ABC); B1 = BP, (ABC); C1 = CP, (ABC); A2 = reflect A1 BC; B2 = reflect B1 CA; C2 = reflect C1 AB; Prove: concyclic A1 B1 C1 Problem 3: In triangle ABC, the incircle (I) touches sides BC, CA, and AB at points D, E, and F, respectively. Prove that lines AD, BE, and CF are concurrent. Convert to: C = triangle; = incenter C; = foot BC; = foot CA; = foot AB; Prove: concurrent AD BE CF Problem 4: Let $ABC$ be triangle with $AC > BC,$ let $omega$ be the circumcircle of $triangle ABC,$ and let $r$ be its radius. Point $P$ is chosen on $overline{AC}$ such taht $BC=CP,$ and point $S$ is the foot of the perpendicular from $P$ to $overline{AB}$. Ray $BP$ mets $ omega$ again at $D$. Point $Q$ is chosen on line $SP$ such that $PQ = r$ and $S,P,Q$ lie on line in that order. Finally, let $E$ be point satisfying $overline{AE} perp overline{CQ}$ and $overline{BE} perp overline{DQ}$. Prove that $E$ lies on $omega$. Convert to: = triangle; = circumcenter C; = AC, (C,B); = foot AB; = intersection BP, (ABC); = SP, (P,OA); l1 = perpendicular_line CQ; l2 = perpendicular_line DQ; = intersection l1, l2; Prove: on_circle (ABC) Problem 5: Let $ABC$ be an acute, scalene triangle with orthocentre $H$. Let $ell_a$ be the line through the reflection of $B$ with respect to $CH$ and the reflection of $C$ with respect to $BH$. Lines $ell_b$ and $ell_c$ are defined similarly. Suppose lines $ell_a$, $ell_b$, and $ell_c$ determine triangle $mathcal T$. Prove that the orthocentre of $mathcal T$, the circumcentre of $mathcal T$, and $H$ are collinear. Convert to: = acute_triangle; = orthocenter C; B1 = reflect CH; C1 = reflect BH; la = line B1 C1; A1 = reflect BH; B2 = reflect AH; lb = line A1 B2; A2 = reflect CH; C2 = reflect AH; lc = line A2 C2; = lb, lc; = la, lc; = la, lb; H1 = orthocenter Z; O1 = circumcenter Z; Prove: collinear H1 O1 Problem 6: Let $ABCD$ be parallelogram with $AC=BC.$ point $P$ is chosen on the extension of ray $AB$ past $B.$ The circumcircle of $ACD$ meets the segment $PD$ again at $Q.$ The circumcircle of triangle $APQ$ meets the segment $PC$ at $R.$ Prove that lines $CD,AQ,BR$ are concurrent. Convert to: B = isos_triangle; = parallelogram D; = on_line AB; = intersection PD, (ACD); = intersection PC, (APQ); Prove: concurrent CD AQ BR Problem 7: Let $I$ be the incentre of acute triangle $ABC$ with $ABneq AC$. The incircle $omega$ of $ABC$ is tangent to sides $BC, CA$, and $AB$ at $D, E,$ and $F$, respectively. The line through $D$ perpendicular to $EF$ meets $omega$ at $R$. Line $AR$ meets $omega$ again at $P$. The circumcircles of triangle $PCE$ and $PBF$ meet again at $Q$. Prove that lines $DI$ and $PQ$ meet on the line through $A$ perpendicular to $AI$. Convert to: 25 = acute_triangle; = incenter C; = foot BC; = foot CA; = foot AB; = intersection perpendicular_line EF, (I); = intersection AR, (I); = intersection (PCE), (PBF); = DI, PQ; Prove: perpendicular AI AX Problem 8: Let $ABC$ be an acute triangle with circumcircle $Gamma$. Let $ell$ be tangent line to $Gamma$, and let $ell_a, ell_b$ and $ ell_c$ be the lines obtained by reflecting $ell$ in the lines $BC$, $CA$ and $AB$, respectively. Show that the circumcircle of the triangle determined by the lines $ell_a, ell_b$ and $ell_c$ is tangent to the circle $Gamma$. Convert to: = acute_triangle; ω= circumcircle C; = on_circle ω; = tangent ω; la = reflect BC; lb = reflect CA; lc = reflect AB; Ω= circumcircle la lb lc; Prove: tangent ωΩ Problem 9: Let $Omega$ and $O$ be the circumcircle and the circumcentre of an acute-angled triangle $ABC$ with $AB > BC$. The angle bisector of $ angle ABC$ intersects $Omega$ at $M ne B$. Let $Gamma$ be the circle with diameter $BM$. The angle bisectors of $angle AOB$ and $ angle BOC$ intersect $Gamma$ at points $P$ and $Q,$ respectively. The point $R$ is chosen on the line $P Q$ so that $BR = MR$. Prove that $BRparallel AC$. Convert to: = acute_triangle; = circumcenter C; = midarc_no B; Γ= circle (BM); = intersection perpendicular_line AB, Γ; = intersection perpendicular_line BC, Γ; = PQ, length_equal R; Prove: parallel BR AC Problem 10: Let $ABC$ be triangle with $angle > angle C$. Let $P$ and $Q$ be two different points on line $AC$ such that $angle PBA = angle QBA = angle ACB $ and $A$ is located between $P$ and $C$. Suppose that there exists an interior point $D$ of segment $BQ$ for which $PD=PB$. Let the ray $AD$ intersect the circle $ABC$ at $R neq A$. Prove that $QB = QR$. Convert to: = triangle; = AC, angle_equal B A; = AC, angle_equal A B; = BQ, length_equal B; = intersection AD, (ABC); Prove: cong R Please follow these examples to convert the following problem: {INPUT_PROBLEM} Listing 3 An illustration of prompt converting natural language problem into our geometry specific language."
        }
    ],
    "affiliations": [
        "ETH Zurich",
        "Microsoft",
        "University of California, Los Angeles"
    ]
}