{
    "paper_title": "Kimi Linear: An Expressive, Efficient Attention Architecture",
    "authors": [
        "Kimi Team",
        "Yu Zhang",
        "Zongyu Lin",
        "Xingcheng Yao",
        "Jiaxi Hu",
        "Fanqing Meng",
        "Chengyin Liu",
        "Xin Men",
        "Songlin Yang",
        "Zhiyuan Li",
        "Wentao Li",
        "Enzhe Lu",
        "Weizhou Liu",
        "Yanru Chen",
        "Weixin Xu",
        "Longhui Yu",
        "Yejie Wang",
        "Yu Fan",
        "Longguang Zhong",
        "Enming Yuan",
        "Dehao Zhang",
        "Yizhi Zhang",
        "T. Y. Liu",
        "Haiming Wang",
        "Shengjun Fang",
        "Weiran He",
        "Shaowei Liu",
        "Yiwei Li",
        "Jianlin Su",
        "Jiezhong Qiu",
        "Bo Pang",
        "Junjie Yan",
        "Zhejun Jiang",
        "Weixiao Huang",
        "Bohong Yin",
        "Jiacheng You",
        "Chu Wei",
        "Zhengtao Wang",
        "Chao Hong",
        "Yutian Chen",
        "Guanduo Chen",
        "Yucheng Wang",
        "Huabin Zheng",
        "Feng Wang",
        "Yibo Liu",
        "Mengnan Dong",
        "Zheng Zhang",
        "Siyuan Pan",
        "Wenhao Wu",
        "Yuhao Wu",
        "Longyu Guan",
        "Jiawen Tao",
        "Guohong Fu",
        "Xinran Xu",
        "Yuzhi Wang",
        "Guokun Lai",
        "Yuxin Wu",
        "Xinyu Zhou",
        "Zhilin Yang",
        "Yulun Du"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "We introduce Kimi Linear, a hybrid linear attention architecture that, for the first time, outperforms full attention under fair comparisons across various scenarios -- including short-context, long-context, and reinforcement learning (RL) scaling regimes. At its core lies Kimi Delta Attention (KDA), an expressive linear attention module that extends Gated DeltaNet with a finer-grained gating mechanism, enabling more effective use of limited finite-state RNN memory. Our bespoke chunkwise algorithm achieves high hardware efficiency through a specialized variant of the Diagonal-Plus-Low-Rank (DPLR) transition matrices, which substantially reduces computation compared to the general DPLR formulation while remaining more consistent with the classical delta rule. We pretrain a Kimi Linear model with 3B activated parameters and 48B total parameters, based on a layerwise hybrid of KDA and Multi-Head Latent Attention (MLA). Our experiments show that with an identical training recipe, Kimi Linear outperforms full MLA with a sizeable margin across all evaluated tasks, while reducing KV cache usage by up to 75% and achieving up to 6 times decoding throughput for a 1M context. These results demonstrate that Kimi Linear can be a drop-in replacement for full attention architectures with superior performance and efficiency, including tasks with longer input and output lengths. To support further research, we open-source the KDA kernel and vLLM implementations, and release the pre-trained and instruction-tuned model checkpoints."
        },
        {
            "title": "Start",
            "content": "5 2 0 2 0 3 ] . [ 1 2 9 6 6 2 . 0 1 5 2 : r AN EXPRESSIVE, EFFICIENT ATTENTION ARCHITECTURE KIMI LINEAR:"
        },
        {
            "title": "TECHNICAL REPORT OF KIMI LINEAR",
            "content": "Kimi Team (cid:135) https://github.com/MoonshotAI/Kimi-Linear"
        },
        {
            "title": "ABSTRACT",
            "content": "We introduce Kimi Linear, hybrid linear attention architecture that, for the first time, outperforms full attention under fair comparisons across various scenariosincluding short-context, long-context, and reinforcement learning (RL) scaling regimes. At its core lies Kimi Delta Attention (KDA), an expressive linear attention module that extends Gated DeltaNet [111] with finer-grained gating mechanism, enabling more effective use of limited finite-state RNN memory. Our bespoke chunkwise algorithm achieves high hardware efficiency through specialized variant of the Diagonal-Plus-LowRank (DPLR) transition matrices, which substantially reduces computation compared to the general DPLR formulation while remaining more consistent with the classical delta rule. We pretrain Kimi Linear model with 3B activated parameters and 48B total parameters, based on layerwise hybrid of KDA and Multi-Head Latent Attention (MLA). Our experiments show that with an identical training recipe, Kimi Linear outperforms full MLA with sizeable margin across all evaluated tasks, while reducing KV cache usage by up to 75% and achieving up to 6 decoding throughput for 1M context. These results demonstrate that Kimi Linear can be drop-in replacement for full attention architectures with superior performance and efficiency, including tasks with longer input and output lengths. To support further research, we open-source the KDA kernel and vLLM implementations 1, and release the pre-trained and instruction-tuned model checkpoints. 2 a f 60 45 MLA 81.3 Kimi Linear 84. GDN-H 80.5 Kimi Linear 51.0 GDN-H 47.9 MLA 47.2 RULER (128k) MMLU-Pro (4k) 1 2 3 4 Decoding Acceleration (a) 50 ) ( T 10 5 MLA GDN-H Kimi Linear 6.3 5.7 4.8 4K 128K 256K 512k 1M Decoding Length (b) Figure 1: (a) Performance vs. acceleration. With strict fair comparisons with 1.4T training tokens, on MMLU-Pro (4k context length, red stars), Kimi Linear leads performance (51.0) at similar speed. On RULER (128k context length, blue circles), it is Pareto-optimal, achieving top performance (84.3) and 3.98 acceleration. (b) Time per output token (TPOT) vs. decoding length. Kimi Linear (blue line) maintains low TPOT, matching GDN-H and outperforming MLA at long sequences. This enables larger batches, yielding 6.3 faster TPOT (1.84ms vs. 11.48ms) than MLA at 1M tokens. 1(cid:135) https://github.com/fla-org/flash-linear-attention/tree/main/fla/ops/kda 2 https://huggingface.co/moonshotai/Kimi-Linear-48B-A3B-Instruct Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT"
        },
        {
            "title": "Introduction",
            "content": "As large language models (LLMs) evolve into increasingly capable agents [50], the computational demands of inferenceparticularly in long-horizon and reinforcement learning (RL) settingsare becoming central bottleneck. This shift toward RL test-time scaling [95, 33, 80, 74, 53], where models must process extended trajectories, tool-use interactions, and complex decision spaces at inference time, exposes fundamental inefficiencies in standard attention mechanisms. In particular, the quadratic time complexity and the linearly growing keyvalue (KV) cache of softmax attention introduce substantial computational and memory overheads, hindering throughput, context-length scaling, and real-time interactivity. Linear attention [48] offers principled approach to reducing computational complexity but has historically underperformed softmax attention in language modelingeven for short sequencesdue to limited expressivity. Recent advances have significantly narrowed this gap, primarily through two innovations: gating or decay mechanisms [92, 16, 114] and the delta rule [84, 112, 111, 71]. Together, these developments have pushed linear attention closer to softmaxlevel quality on moderate-length sequences. Nevertheless, purely linear structure remain fundamentally constrained by the finite-state capacity, making long-sequence modeling and in-context retrieval theoretically challenging [104, 4, 45]. Hybrid architectures that combine softmax and linear attentionusing few global-attention layers alongside predominantly faster linear layershave thus emerged as practical compromise between quality and efficiency [57, 100, 66, 12, 32, 81]. However, previous hybrid models often operated at limited scale or lacked comprehensive evaluation across diverse benchmarks. The core challenge remains: to develop an attention architecture that matches or surpasses full attention in quality while achieving substantial efficiency gains in both speed and memoryan essential step toward enabling the next generation of agentic, decoding-heavy LLMs. In this work, we present Kimi Linear, hybrid linear attention architecture designed to meet the efficiency demands of agentic intelligence and test-time scaling without compromising quality. At its core lies Kimi Delta Attention (KDA), hardware-efficient linear attention module that extends Gated DeltaNet [111] with finer-grained gating mechanism. While GDN, similar to Mamba2 [16], employs coarse head-wise forget gate, KDA introduces channel-wise variant in which each feature dimension maintains an independent forgetting rate, akin to Gated Linear Attention (GLA) [114]. This fine-grained design enables more precise regulation of the finite-state RNN memory, unlocking the potential of RNN-style models within hybrid architectures. Crucially, KDA parameterizes its transition dynamics with specialized variant of the Diagonal-Plus-Low-Rank (DPLR) matrices [30, 71], enabling bespoke chunkwise-parallel algorithm that substantially reduces computation relative to general DPLR formulations while remaining consistent with the classical delta rule. Kimi Linear interleaves KDA with periodic full attention layers in uniform 3:1 ratio. This hybrid structure reduces memory and KV-cache usage by up to 75% during long-sequence generation while preserving global information flow via the full attention layers. Through matched-scale pretraining and evaluation, we show that Kimi Linear consistently matches or outperforms strong full-attention baselines across short-context, long-context, and RL-style post-training taskswhile achieving up to 6 higher decoding throughput at 1M context length. To facilitate further research, we release open-source KDA kernels with vLLM integration, as well as pre-trained and instruction-tuned checkpoints. These components are drop-in compatible with existing full-attention pipelines, requiring no modification to caching or scheduling interfaces, thereby facilitating research on hybrid architectures. Contributions Kimi Delta Attention (KDA): linear attention mechanism that refines the gated delta rule with improved recurrent memory management and hardware efficiency. The Kimi Linear architecture: hybrid design adopting 3:1 KDA-to-global attention ratio, reducing memory footprint while surpassing full-attention quality. Fair empirical validation at scale: through 1.4T token training runs, Kimi Linear outperforms full attention and other baselines in short/long context and RL-style evaluations, with full release of kernels, vLLM integration, and checkpoints."
        },
        {
            "title": "2 Preliminary",
            "content": "In this section, we introduce the technical background related to our proposed Kimi Delta Attention. 2 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT 2.1 Notation In this paper, we define Rdk or Rdv , s. t., {q, k, v, o, u, w} denotes t-th corresponding column vector, and St Rdkdv represents the matrix-form memory state. and denote lower-triangular masks with and without diagonal elements, respectively; for convenience, we also write them as Tril and StrictTril. Chunk-wise Formulation Suppose the sequence is split into L/C chunks where each chunk is of length C. We define [t] RCd for {Q, K, V, O, U, W} are matrices that stack the vectors within the t-th chunk, and [t] = tC+r is the r-th element of the chunk. Note that [0, L/C), [1, C]. State matrices are also re-indexed such that Si [t1], i.e., the initial state of chunk is the last state of the previous chunk. [t] = StC+i. Additionally, S[t] := S0 [t] = SC Decay Formulation We define the cumulative decay γij A[t] := Ai/j [t] RCC is the matrix with elements γi (cid:16) (cid:81)j [t]/γj (cid:17) k=i Diag αk [t] , and Γij [t] RCdk is the matrix stack from γi [t] to γj [t]. := (cid:81)j k=i αk [t], and abbreviate γ1r [t] [t]. Diag (αt) denotes the fine-grained decay, Diag [t]. Additionally, γij := [t] (cid:17) (cid:16) as γr [t] 2.2 Linear Attention and the Gated Delta Rule Linear Attention as Online Learning. Linear attention [48] maintains matrix-valued recurrent state that accumulates keyvalue associations: St = St1 + ktv , From the fast-weight perspective [84, 85], St serves as an associative memory storing transient mappings from keys to values. This update can be viewed as performing gradient descent on the unbounded correlation objective ot = t qt. Lt(S) = Skt, vt, which continually reinforces recent keyvalue pairs without any forgetting. However, such an objective provides no criterion for which memories to erase, and the accumulated state grows unbounded, leading to interference over long contexts. DeltaNet: Online Gradient Descent on Reconstruction Loss. DeltaNet [84] reinterprets this recurrence as online gradient descent on reconstruction objective: Taking gradient step with learning rate βt gives Lt(S) = 2 Skt vt2. St = St1 βtSLt(St1) = (I βtktk )St1 + βtktv . This rulethe classical delta ruletreats as learnable associative memory that continually corrects itself toward the mapping kt (cid:55) vt. The rank-1 update structure, equivalent to generalized Householder transformation, supports hardware-efficient chunkwise parallelization [11, 112]. Gated DeltaNet as Weight Decay. Although DeltaNet stabilizes learning, it still retains outdated associations indefinitely. Gated DeltaNet (GDN) [111] introduces scalar forget gate αt [0, 1], yielding St = αt(I βtktk )St1 + βtktv . Here, αt acts as form of weight decay on the fast weights [8], implementing forgetting mechanism analogous to data-dependent L2 regularization. This simple yet effective modification provides principled way to control memory lifespan and mitigate interference, improving both stability and long-context generalization while preserving DeltaNets parallelizable structure. From this perspective, we observe that GDN can be interpreted as form of multiplicative positional encoding where the transition matrix is data-dependent and learnable, relaxing the orthogonality constraint of RoPE [115].3 3When the state transformation matrix preserves its orthogonality, absolute positional encodings can also be applied independently to and to be converted into relative positional encodings during the attention computation [87]. Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT"
        },
        {
            "title": "3 Kimi Delta Attention: Improving Delta Rule with Fine-grained Gating",
            "content": "We propose Kimi Delta Attention (KDA), new gated linear attention variant that refines GDNs scalar decay by introducing fine-grained diagonalized gate Diag(αt) that enables fine-grained control over memory decay and positional awareness (as discussed in 6.1). We begin by introducing the chunkwise parallelization of KDA, showing how series of rank-1 matrix transformations can be compressed into dense representation while maintaining stability under diagonal gating. We then highlight the efficiency gains of KDA over the standard DPLR (Diagonal-Plus-LowRank) formulation [30, 71]. St = (cid:0)I βtktk (cid:1) Diag (αt)St1 + βtktv Rdkdv ; ot = t qt Rdv (1) = (cid:32) (cid:33) + = 3.1 Hardware-Efficient Chunkwise Algorithm By partially expanding the recurrence for Eq. 1 into chunk-wise formulation, we have: Sr [t] = (cid:32) (cid:89) (cid:16) i=1 (cid:124) βi [t]ki [t]ki [t] (cid:17) (cid:33) Diag(αi [t]) S0 [t] + (cid:123)(cid:122) :=Pr [t] (cid:125) (cid:88) i=1 (cid:124) (cid:89) (cid:16) βj [t]kj [t]kj [t] (cid:17) Diag(αj [t]) [t]ki [t]vi [t] βi j=i (cid:123)(cid:122) :=Hr [t] (cid:125) (2) WY Representation is typically employed to pack series rank-1 updates into single compact representation [11]. We follow the formulation of in Comba [40] to reduce the need for an additional matrix inversion in subsequent computations. Pr [t] = Diag(γr [t]) (cid:88) i=1 Diag(γir [t] )ki [t]wi [t] Hr [t] = (cid:88) i=1 Diag (cid:16) γir [t] (cid:17) [t]ui ki [t] where the auxiliary vector wt Rdk and ut Rdv are computed via the following recurrence relation: (cid:32) wr [t] = βr [t] Diag(γr [t])kr [t] (cid:16) wi [t] ki [t] Diag (cid:16) γir [t] (cid:17) kr [t] (cid:33) (cid:17) r1 (cid:88) i=1 (cid:32) [t] = βr ur [t] vr [t] r1 (cid:88) i=1 (cid:16) ui [t] ki [t] Diag (cid:16) γir [t] (cid:17) kr [t] (cid:33) (cid:17) (3) (4) (5) UT transform. We apply the UT transform [46] to reduce non-matmul FLOPs, which is crucial to enable better hardware utilization during training. M[t] = + StrictTril Diag (cid:0)β[t] (cid:1) (cid:16) Γ1C [t] K[t] (cid:32) (cid:17) K[t] Γ1C [t] (cid:33) 1 Diag (cid:0)β[t] (cid:1) W[t] = M[t] (cid:16) Γ1C [t] K[t] (cid:17) , U[t] = M[t]V[t] (6) (7) The inverse of lower triangular matrix can be efficiently computed through an iterative row-wise approach by forward substitution in Gaussian elimination [28]. Equivalently, in matrix form, we can update the state in chunk-wise: S[t+1] = Diag(γC [t])S[t] + (cid:16) ΓiC [t] K[t] (cid:17) (cid:0)U[t] W[t]S[t] (cid:1) Rdkdv (8) 4 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT = (cid:32) + (cid:33) During the output stage, we adopt an inter-block recurrent and intra-block parallel strategy to maximize matrix multiplication throughput, thereby fully utilizing the computational potential of Tensor Cores. O[t] = (cid:17) (cid:16) (cid:124) Γ1C [t] Q[t] (cid:123)(cid:122) inter chunk S[t] (cid:125) + Tril (cid:124) (cid:16) Γ1C [t] Q[t] (cid:32) (cid:17) K[t] Γ1C [t] (cid:33) (cid:123)(cid:122) intra chunk (cid:125) (cid:0)U[t] W[t]S[t] (cid:124) (cid:123)(cid:122) pseudo-value term (cid:1) (cid:125) RCdv (9) (cid:32) = (cid:33) (cid:34) (cid:35) + 3.2 Efficiency Analysis )St1 + ktv In terms of representational capacity, KDA aligns with the generalized DPLR formulation, i.e., St = (D atb , both exhibiting fine-grained decay behavior. However, such fine-grained decay introduces numerical precision issues during division operations (e.g., the intra-chunk computation in Eq. 9). To address this, prior work such as GLA [114] performs computations in the logarithmic domain and introduces secondary chunking in full precision. This approach, however, prevents full utilization of half-precision matrix multiplications and significantly reduces operator speed. By binding both variables and to k, KDA effectively alleviates this bottleneckreducing the number of second-level chunk matrix computations from four to two, and further eliminating three additional matrix multiplications. As result, the operator efficiency of KDA improves by roughly 100% compared to the DPLR formulation. detailed analysis is provided in 6.2."
        },
        {
            "title": "4 The Kimi Linear Model Architecture",
            "content": ") ( T t x 48 32 16 0 DPLR KDA (ours) 2K 4K 8K 16K Input length 32K 64K Figure 2: Execution time of kernels for varying input lengths, with uniform batch size of 1 and 16 heads. The main backbone of our model architecture follows Moonlight [62]. In addition to fine-grained gating, we also leverage several components to further improve the expressiveness of Kimi Linear. The overall Kimi Linear architecture is shown in Figure 3. Neural Parameterization Let xt Rd be the t-th token input representation, the input to KDA for each head is computed as follows = L2Norm(Swish(ShortConv(Wh , kh qh xt)) Rdv = Swish(ShortConv(Wh vh αxt) [0, 1]dk αW = (W αh βh = Sigmoid(Wh βxt) [0, 1] q/kxt))) Rdk where dk, dv represent the key and value head dimensions, which are set to 128 for all experiments. For q, k, v, we apply ShortConv followed by Swish activation, following [111]. The and representations are further normalized using L2Norm to ensure eigenvalues stability, as suggested by [112]. The per-channel decay αh is parameterized via low-rank projection (W α with rank equal to the head dimension) and decay function () similar to those α and Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT 1 MoE Norm MLA Norm MoE Norm KDA Norm Outputs Shared Expert Routed Expert 1 Ns 1 2 3 Nr Router Outputs Linear Norm Kimi Delta Attention σ σ σ L2 L2 Conv Conv Linear Linear Conv Linear Inputs Figure 3: Illustration of our Kimi Linear model architecture, which consists of stack of blocks containing token mixing layer followed by MoE channel-mixing layer. Specifically, we interleave KDA layers with one MLA layer for token mixing, where is set to 3 in our implementation. used in GDN and Mamba [111, 16]. Before the output projection through Wo Rdd, we use head-wise RMSNorm [122] and data-dependent gating mechanism [79] parameterized as: ot = Wo (cid:0)Sigmoid (cid:0)W gW gxt (cid:1) RMSNorm (KDA (qt, kt, vt, αt, βt))(cid:1) (10) Here, the output gate adopts low-rank parameterization similar to the forget gate, to ensure fair parameter comparison, while maintaining performance comparable to full-rank gating and alleviating the Attention Sink [79]. The choice of nonlinear activation function is further discussed in 5.2. Hybrid model architecture Long-context retrieval remains the primary bottleneck for pure linear attention, we therefore hybridize KDA with small number of full global-attention (Full MLA) layers [19]. For Kimi Linear, we chose layerwise approach (alternating entire layers) over headwise one (mixing heads within layers) for its superior infrastructure simplicity and training stability. Empirically, uniform 3:1 ratio, i.e., repeating 3 KDA layers to 1 full MLA layer, provided the best qualitythroughput trade-off. We discuss other hybridization strategies in 7.2. No Position Encoding (NoPE) for MLA Layers. In Kimi Linear, we apply NoPE to all full attention (MLA) layers. This design delegates the entire responsibility for encoding positional information and recency bias (see 6.1) to the KDA layers. KDA is thus established as the primary position-aware operator, fulfilling role analogous to, or arguably stronger than, auxiliary components like short convolutions [3] or SWA [76]. Our findings align with prior results [110, 7, 19], who similarly demonstrated that complementing global NoPE attention with dedicated position-aware mechanism yields competitive long-context performance. 6 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT 100 ) % ( r A 75 50 25 0 ) % ( r A 75 25 0 256 512 1024 Sequence length KDA GDN Mamba2 KDA GDN Mamba2 5K 10K 15K 20K Training steps 100 ) % ( r A 75 25 0 100 ) % ( a c 75 50 25 0 512 1024 Sequence length 2048 5K 10K 15K 20K Training steps 100 ) % ( r A 50 25 0 100 ) % ( r A 75 50 25 256 1024 512 Sequence length 2048 5K 10K 15K 20K Training steps (a) Palindrome (b) MQAR (c) Stack Figure 4: Results on synthetic tasks: palindrome, multi query associative recall, and the state tracking. We note that NoPE offers practical advantages, particularly for MLA. First, NoPE enables their conversion to the highly-efficient pure Multi-Query Attention (MQA) during inference. Second, it simplifies long-context training, as it obviates the need for RoPE parameter adjustments, such as frequency base tuning or methods like YaRN [72]."
        },
        {
            "title": "5 Experiments",
            "content": "5.1 Synthetic tests We start by evaluating KDA against other competing linear attention methods on three synthetic tasks, serving as benchmark tests for long-context performance. Across all experiments, we adopt consistent model configuration of 2 layers with 2 attention heads, each having head dimension of 128. For each task, we train the model for at most 20,000 steps with grid search over learning rates in {5 105, 1 104, 5 104, 1 103}. We then present the best-performing training accuracy curves. Specifically, we compare two scenarios: (1) the performance of different tasks as training length increases from 256 to 2,048 tokens, measuring the peak accuracy; and (2) the convergence speed of KDA, GDN, and Mamba2 with fixed context length of 1,024 tokens. Palindrome Palindrome requires the model to reproduce given sequence of random tokens in reverse order. As illustrated in Table 5.1, given an input like R E, the model must generate its exact reversal. Such copying tasks are known to be difficult for linear attention models [45], as they struggle to precisely retrieve the entire history from compressed, fixed-size memory state. Input S <sep> ϕ Output ϕ ϕ ϕ ϕ ϕ ϕ ϕ U O R ϕ Multi Query Associative Recall (MQAR) MQAR assesses the models ability to retrieve values associated with multiple queries that appear at various positions within the context. For instance, as shown in Table 5.1, the model is asked to recall 0 for the query and 5 for G. This task is known to be highly correlated with language modeling performance [5]. Input 1 3 0 8 5 ϕ Output ϕ ϕ ϕ ϕ ϕ ϕ ϕ ϕ ϕ ϕ 4 ϕ <sep> 5 ϕ 7 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Table 1: Ablation study on the hybrid ratio of KDA to MLA attention and other key components. We list the training and validation perplexities (lower is better) for comparison. The best-performing model, used in our final experiments, is highlighted in gray. Training PPL () Validation PPL () Hybrid ratio 3:1 0:1 1:1 7:1 15:1 w/o output gate w/ swish output gate w/o convolution layer 9.23 9.45 9.29 9.23 9.34 9.25 9.43 9.29 5.65 5.77 5.66 5.70 5. 5.67 5.81 5.70 Stack We assess the state tracking capabilities [27] of each candidate by simulating the standard LIFO (Last In First Out) stack operations. Our setup involves 64 independent stacks, each identified by unique ID. The model processes sequence of two operations: 1) PUSH: an action like <push> 1 adds the element to stack 1; 2) POP: an action like <pop> 0 requires the model to predict the element most recently pushed onto stack 0. The objective is to accurately track the states of all stacks and predict the correct element upon each pop request. Figure 4 shows the final results. Across all tasks, KDA consistently achieves the highest accuracy as the sequence length increases from 256 to 2,048 tokens. In particular, on the Palindrome and recall-intensive MQAR tasks, KDA converges significantly faster than GDN. This confirms the benefits of our fine-grained decay, which enables the model to selectively forget irrelevant information while preserving crucial memories more precisely. We also observe that Mamba2 [16], typical linear attention that uses only multiplicative decay and lacks delta rule, fails on all tasks in our model settings. 5.2 Ablation on Key Components of Kimi Linear We conducted series of ablation studies by directly comparing different models to the first-scale scaling law model, i.e., 16 heads, 16 layers. All models were trained with the same FLOPs budget and hyperparameters for fair comparison. We report the training and validation perplexities (PPLs) in Table 1. The validation PPL is calculated on highquality dataset whose distribution differs significantly from the pre-training corpus, emphasizing generalization under distribution shift, and thus the differences in training and validation perplexities. Output gate We compare our default Sigmoid output gate against two variants: one with no gating and another with swish gating. The results show that removing the gate degrades performance. Moreover, the swish gate adopted by [111] performs substantially worse than Sigmoid. Our observation is consistent with [79], who also conclude that Sigmoid gating offers superior performance. So we adopt Sigmoid across all of our experiments, including GDN-H. Convolution Layer Lightweight depthwise convolutions with small kernel size (e.g., 4) can be effective at capturing local token dependencies [3] and are widely adopted by many recent architectures [16, 5, 112]. We validate its efficacy in Table 1, demonstrating that convolutional layers continue to play non-negligible role in hybrid models. Hybrid ratio We performed an ablation study to determine the optimal hybrid ratio of KDA linear attention layers to MLA full attention layers. Among the configurations tested, the 3:1 ratio (3 KDA layers for every 1 MLA layer) yielded the best results, achieving the lowest training and validation losses. We observed clear trade-offs with other ratios: higher ratio (e.g., 7:1) produced comparable training loss but led to significantly worse validation performance, while lower ratio (e.g., 1:1) maintained similar validation loss but at the cost of increased inference overhead. Furthermore, the pure full-attention baseline (0:1) performed poorly. Thus, the 3:1 configuration offers the most effective balance between model performance and computational efficiency. NoPE vs. RoPE As shown in Table 5, the Kimi Linear consistently excels on long-context evaluations, whereas Kimi Linear (RoPE) attains similar scores on short-context tasks. We posit that this divergence arises from how positional bias is distributed across depth. In Kimi Linear (RoPE), the global attention layer carries strong, explicit relative positional signal, while the linear attention (e.g., GDN) contributes weaker, implicit positional inductive bias. This mismatch yields an overemphasis on short-range order in the global layer, which benefits short contexts but makes the model less flexible when adapting mid-training to extended contexts. By contrast, Kimi Linear induces more 8 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Table 2: Model configurations and hyperparameters for scaling law experiments. # Act. Params. Head Layer Hidden Tokens lr batch size 653M 878M 1.1B 1.4B 1.7B 16 18 20 22 24 16 18 20 22 24 1216 1376 1536 1632 1776 038.8B 059.8B 085.2B 102.5B 128.0B 2.006 103 1.790 103 1.617 103 1.486 103 1.371 103 336 432 512 576 640 Denotes the number of activated parameters in our MoE models, excluding embeddings. All models were trained with context length of 4,096. MLA: 2.3092 C0.0536 Kimi Linear: 2.2879 C0.0527 1.16 2. o 2.1 2.0 101 PFLOP/s-days Figure 5: The fitted scaling law curves for MLA and Kimi Linear. balanced positional bias across layers, which improves robustness and extrapolation at long ranges, leading to stronger long-context performance. Regarding long context performance, as shown in Table 5, Kimi Linear achieves the best average score across different long context benchmarks, which verifies the benefits we claim in the last section. 5.3 Scaling Law of Kimi Linear We conducted scaling law experiments on series of MoE models following the Moonlight [62] architecture. In all experiments, we activated 8 out of 64 experts and utilized the Muon optimizer [62]. Details and hyperparameters are listed in Table 2. For MLA, following the Chinchilla scaling law methodology [37], we trained five language models of different sizes, carefully tuning their hyperparameters through grid search to ensure optimal performance for each model. For KDA, we maintained the best hybrid ratio of 3:1 as ablated in Table 1. Except for this, we adhered strictly to the MLA training configuration without any modifications. As shown in Figure 5, Kimi Linear achieves 1.16 computational efficiency compared to the MLA baselines with compute optimal training. We expect that careful hyperparameter tuning will yield superior scaling curves for KDA. 5.4 Experimental Setup Kimi Linear and baselines settings We evaluate our Kimi Linear model against full-attention MLA baseline and hybrid Gated DeltaNet (GDN-H) baseline, all of which share the same architecture, parameter count, and training setup for fair comparisons. The model configuration is largely aligned with Moonlight [62], with the key distinction that MoE sparsity is increased to 32. Each model activates 8 out of 256 experts, including one shared expert, resulting in 48 billion total parameters and 3 billion active parameters per forward pass. The first layer is implemented as dense layer without MoE, ensuring stable training. To evaluate the effectiveness of NoPE in Kimi Linear, we also introduce hybrid KDA baseline using RoPE with the same model configuration, referred to as Kimi Linear (RoPE). 9 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Evaluation Benchmarks Our evaluation encompasses three primary categories of benchmarks, each designed to assess distinct capabilities of the model: Language Understanding and Reasoning: Hellaswag [121], ARC-Challenge [14], Winogrande [83], MMLU [36], TriviaQA [47], MMLU-Redux [26], MMLU-Pro [103], GPQA-Diamond [82], BBH [94], and [105]. Code Generation: LiveCodeBench v6 4[44], EvalPlus [60]. Math & Reasoning: AIME 2025, MATH 500, HMMT 2025, PolyMath-en. Long-context: MRCR 5 , RULER [38], Frames [52], HELMET-ICL [118], RepoQA [61], Long Code Arena [13] and LongBench v2 [6]. Chinese Language Understanding and Reasoning: C-Eval [43], and CMMLU [55]. Evaluation Configurations All models are evaluated using temperature 1.0. For benchmarks with high variance, we report the score of Avg@k. For base model, We employ perplexity-based evaluation for MMLU, MMLU-Redux, GPQA-Diamond, and C-Eval. Otherwise, generation-based evaluation is adopted. To mitigate the high variance inherent to GPQA-Diamond, we report the mean score across eight independent runs. All evaluations are conducted using our internal framework derived from LM-Harness-Evaluation [10], ensuring consistent settings across all models. 5.4.1 Pre-training recipe Pre-training recipe All models are pretrained using 4,096-token context window, the MuonClip optimizer, and the WSD learning rate schedule, processing shared total of 1.4 trillion tokens sampled from the K2 pretraining corpus [50]. The learning rate is set to 1.1 103, and the global batch size is fixed at 32 million tokens. They also adopt the same annealing schedule and long-context activation phase established in Kimi K2 [50]. Our final released Kimi Linear checkpoint is pretrained using the same procedure, but with an expanded total of 5.7 trillion tokens to match the pretraining tokens of Moonlight. In addition, the final checkpoint supports context length of up to 1 million tokens. We compare the performance of Kimi Linear@5.7T and Moonlight in Appendix 5.4.2 Post-training recipe SFT recipe The SFT dataset extends the Kimi K2 [50] SFT data by incorporating additional reasoning tasks, creating large-scale instruction-tuning dataset that spans diverse domains with heavy emphasis on math and coding. We employ multi-stage SFT approach, initially training the model on broad range of diverse SFT data for general instruction-following, followed by scheduled targeted training on reasoning-intensive data to enhance the models reasoning capabilities. RL recipe For the RL training prompt set, we primarily integrate three data sources: mathematics, code, and STEM. The main purpose of this enhancement is to boost the models reasoning ability. Before conducting RL, we pre-selected data that matches moderate difficulty level for the starting checkpoint. known risk of RL training is the potential degeneration of general capabilities. To mitigate this, we incorporate the PTX loss [70] during RL, following the practice of K2 [50]. This involves concurrent SFT on high-quality, distributionally diverse dataset in the RL progress. Our PTX dataset spans both reasoning and general-purpose tasks. All data mentioned above are subsets derived from the training recipe of the K2 model [50]. For the RL algorithm, we use the same algorithm as in K1.5 [95], while introducing several advanced tricks. We noticed that the precision mismatch between training and inference engines may lead to unstable RL learning. Therefore we introduce truncated importance sampling, method that effectively mitigates the policy mismatch between rollout and training [116]. We also dynamically adjust the KL penalty and the mini batch size (i.e., the number of updates per iteration) to make the RL training stable and avoid collapse of entropy [15]. 5.5 Main results 5.5.1 Kimi Linear@1.4T results Pretrain results We compared our Kimi Linear model against two baselines (MLA and hybrid GDN-H) using 1.4T pretraining corpus in Table 3. The evaluation focused on three areas: general knowledge, reasoning (math and code), and Chinese tasks. Kimi Linear consistently outperformed both baselines across almost all categories. 4Questions from 2024.8 to 2025.5 5https://huggingface.co/datasets/openai/mrcr 10 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT General Knowledge: Kimi Linear scores highest on all of the key benchmarks like BBH, MMLU and HellaSwag. Reasoning: It leads in math (GSM8K) and most code tasks (CRUXEval). However, it scores slightly lower on EvalPlus compared to GDN-H. Chinese Tasks: Kimi Linear achieves the top scores on CEval and CMMLU. In summary, Kimi Linear demonstrated the strongest performance, positioning it as strong alternative to full-attention architectures at short context pretraining. Table 3: Performance comparison of Kimi Linear with the full-attention MLA baseline and the hybrid GDN baseline, all after the same pretraining recipe. Kimi Linear consistently outperforms both MLA and GDN-H on short-context pretrain evaluations. Best per-column results are bolded. Type Base Trained Tokens HellaSwag ARC-challenge Winogrande BBH MMLU MMLU-Pro TriviaQA GSM8K MATH EvalPlus CRUXEval-I-cot CRUXEval-O-cot General Math & Code Chinese CEval CMMLU MLA 1.4T 81.7 64.6 78.1 71.6 71.6 47.2 68. 83.7 54.7 59.5 51.6 61.5 79.3 79.5 GDN-H Kimi Linear 1.4T 82.2 66.5 77.9 70.6 72.2 47.9 70. 81.7 54.1 63.1 56.0 58.1 79.1 80.7 1.4T 82.9 67.3 78.6 72.9 73.8 51.0 71.7 83.9 54.7 60.2 56.6 62.0 79.5 80. Table 4: Performance comparison of Kimi Linear with the full-attention MLA baseline and the hybrid GDN baseline, all using the same SFT recipe after pretraining. Kimi Linear consistently outperforms both MLA and GDN-H on short-context instruction-tuned benchmarks. Best per-column results are bolded. Type Instruct Trained Tokens BBH MMLU MMLU-Pro MMLU-Redux GPQA-Diamond (Avg@8) LiveBench (Pass@1) AIME 2025 (Avg@64) MATH500 (Acc.) HMMT 2025 (Avg@32) PolyMath-en (Avg@4) LiveCodeBench v6 (Pass@1) EvalPlus MLA 1.4T 68.2 75.7 65.7 79.2 57.1 45.7 20.6 80.8 11.3 41.3 25.1 62.6 GDN-H Kimi Linear 1.4T 68.5 75.6 64.8 78.7 58.6 46.4 21.1 83.0 11.3 41.5 25.4 62.5 1.4T 69.4 77.0 67.4 80.3 62.1 45.2 21.3 81.2 12.5 43.6 26.0 61.0 General Math & Code SFT results Kimi Linear demonstrates strong performance across both general and math & code tasks after undergoing the same supervised fine-tuning (SFT) recipe, consistently outperforming MLA and GDN-H. In general tasks, Kimi Linear leads across the board, achieving the top scores on various MMLU benchmarks, BBH, and GPQA-Diamond. In math & code tasks, it surpasses both baselines on difficult benchmarks like AIME 2025, HMMT 2025, PolyMath-en, and LiveCodeBench. Despite some minor exceptions like MATH500 and EvalPlus, Kimi Linear shows robust superiority across the tasks, confirming its clear superiority to the other models tested (GDN-H and MLA). 11 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Table 5: Comparisons of Kimi Linear with MLA, GDN-H, and Kimi Linear (RoPE) across long-context benchmarks. The last column reports the overall average (). All models is trained on 1.4T tokens. Best per-column results are bolded. RULER MRCR HELMET-ICL LongBench V2 Frames RepoQA MLA GDN-H Kimi Linear (RoPE) Kimi Linear 81.3 80.5 78.8 84.3 22.6 23.9 22.0 29.6 88.0 85.5 88.0 90.0 36.1 32.6 35.4 35.0 60.5 58.7 59.9 58.8 63.0 63.0 66.5 68. Long Code Arena Lib 32.8 34.7 31.3 37.1 Commit 33.2 30.5 32.5 32.7 Avg. 52.2 51.2 51.8 54.5 r A 65 50 35 MLA@1.4T Kimi Linear@1.4T 20 40 60 Train 80 a c 94 86 78 70 MLA@1.4T Kimi Linear@1.4T 20 40 60 MATH 500 Test 80 r A 20 15 10 100 MLA@1.4T Kimi Linear@1.4T 40 60 AIME 2025 80 100 (a) (b) (c) Figure 6: The training and test accuracy curves for Kimi Linear@1.4T and MLA@1.4T during Math RL training. Kimi Linear consistently outperforms the full attention baseline by sizable margin during the whole RL process. Long Context Performance Evaluation We evaluate the long-context performance of Kimi Linear against three baseline modelsMLA, GDN-H, and Kimi Linear (RoPE)across several benchmarks at 128k context length (see Table 5). The results highlight Kimi Linears clear superiority in these long-context tasks. It consistently outperformed MLA and GDN-H, achieving the highest scores on RULER (84.3) and RepoQA (68.5) by significant margin. This pattern of outperformance held across most other tasks, except for LongBench V2 and Frames. Overall, Kimi Linear achieved the highest average score (54.5), further reinforcing its effectiveness as leading attention architecture in long-context scenarios. RL results To compare the RL convergence properties of Kimi Linear and MLA, we conduct RLVR using the in-house mathematics training set from [50], and evaluate on mathematics test sets (e.g., AIME 2025, MATH500), while keeping the algorithm and all hyperparameters identical to ensure fair comparison of performance. As shown in Figure 6, Kimi Linear demonstrates better efficiency compared to MLA. On the training set, even though both models start at similar points, the growth rate of training accuracy for Kimi Linear is significantly higher than that of MLA, and the gap gradually widens. On the test set, similar phenomena are observed. For example, on MATH500 and AIME2025, Kimi Linear achieves faster and better improvement compared to MLA. Overall, in reasoning-intensive long-form generation under RL, we empirically observe that Kimi Linear performs significantly better than MLA. Summary of overall findings During the pretraining and SFT stages, clear performance hierarchy was established: Kimi Linear outperformed GDN-H, which in turn outperformed MLA. However, this hierarchy shifted in long-context evaluations. While Kimi Linear maintained its top position, GDN-Hs performance declined, placing it behind MLA. Furthermore, in the RL stage, Kimi Linear also demonstrated superior performance over MLA. Overall, Kimi Linear consistently ranked as the top performer across all stages, establishing itself as superior alternative to full attention architectures. 5.6 Efficiency Comparison Prefilling & Decoding speed We compare the training and decoding times for full attention MLA [19], GDN-H, and Kimi Linear in Figure 7a and Figure 7b. Note that all models are based on the Kimi Linear 48B setting, with the same number of layers and attention heads. We observe that: 1) Despite incorporating more fine-grained decay mechanism, Kimi Linear introduces negligible latency overhead compared to GDN-H during prefilling. As shown in Figure 7a, their 12 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT MLA GDN-H Kimi Linear 60 MLA GDN-H Kimi Linear 40 ) ( e 2.9 15 10 ) ( T 2.3 2.2 1.8 0 4K 128K 256K 512K 1M 4K 128K 256K 512K 1M Prefilling Length (a) Decoding Length (b) Figure 7: (a) The prefilling time of MLA (full attention), hybrid GDN-H and our Kimi Linear. (b) The time per output token (TPOT) for MLA, GDN-H and Kimi Linear during decoding. (We use batch size = 1 here for tests.) performance curves are virtually indistinguishable, confirming that our method maintains high efficiency. The hybrid Kimi Linear model demonstrates clear efficiency advantage over the MLA baseline as sequence length increases. While its performance is comparable to MLA at shorter lengths (4k16k), it becomes significantly faster from 128k onwards. This efficiency gap widens dramatically at scale, with Kimi Linear outperforming MLA by factor of 2.3 for 512k sequences and 2.9 for 1M sequences. As shown in Figure 1b, Kimi Linear fully demonstrates its advantages during the decoding phase. For decoding at 1M context length, Kimi Linear is 6 faster than full attention."
        },
        {
            "title": "6 Discussions",
            "content": "6.1 Kimi Delta Attention as learnable position embeddings The standard attention in transformers is by design agnostic to the sequence order of its inputs [99], thus necessitating explicit positional encodings [75, 86]. Among various methods, RoPE [88] has emerged as the de facto standard in modern LLMs due to its effectiveness [98, 1, 19]. The mechanism of multiplicative positional encodings like RoPE can be analyzed through generalized attention formulation: st,i = (cid:89) Rj ki (11) j=i+1 where the position relationship between the t-th query qt and the i-th key ki is reflected by the cumulative matrix products. RoPE defines the transformation matrix Rj as block diagonal matrix composed of dk/2 2D rotation matrices Rk with per-2-dimensional angular frequency θk. Due to the properties of rotation = matrices, i.e., Rti = Ri, absolute positional information Rt and Ri can be applied separately to qt and ki, which (cid:17) are then transformed into relative positional information encoded as (cid:81)t . (cid:16) cos(jθk) sin(jθk) sin(jθk) cos(jθk) (cid:16) cos((ti)θk) sin((ti)θk) sin((ti)θk) cos((ti)θk) j=i+1 Rj = (cid:17) Consequently, we show that linear attentions with the gated delta rule can be expressed in comparable formulation in Eq. 12. Similar forms for other attention variants are summarized in Table 6. (cid:88) (cid:89) ot = Aj (cid:0)I βjkjk (cid:1) kj vj (12) i=1 j=i+1 From this perspective, GDN can be interpreted as form of multiplicative positional encoding whose transition matrix is data-dependent, thereby relaxing the orthogonality constraint imposed by RoPE and can be potentially more powerful [115]. 6 This provides potential solution to the known extrapolation issues of RoPE, whose fixed frequencies can cause overfitting to context lengths seen during training [108, 72]. Some recent works adopt workarounds like partial RoPE 6When preserving orthogonality, absolute positional encodings can be applied independently to and k, which are then automatically transformed into relative positional encodings during the attention computation [87]. Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Table 6: An overview of attention mechanisms in their mathematically equivalent recurrent (ot) and parallel (O) forms. We omitted the normalization term and βt to achieve more concise representation. The function ϕ refers to the infinite-dimensional feature space corresponding to the exponential kernel, i.e., ϕ(q)ϕ(k) = exp(qk). Recurrent form kj exp (cid:0)q (cid:32) exp (cid:1) vj (cid:32) (cid:81) s=j+1 (cid:33) (cid:33) Rs kj vj SA [99] SA + RoPE [88] LA [101] Mamba2 [16] GLA [114] DeltaNet [84] FoX [58] DeltaFormer [125] PaTH-FoX [115] GDN [111] Comba [40] RWKV7 [71] KDA (ours) (cid:80) j=1 (cid:80) j=1 (cid:80) j=1 (cid:80) j= (cid:80) j=1 (cid:80) j=1 (cid:80) j=1 (cid:80) j=1 (cid:80) j=1 (cid:80) j= (cid:80) j=1 (cid:80) j=1 (cid:80) j=1 kj (cid:0)q (cid:32) t q (cid:32) (cid:32) (cid:1) vj (cid:32) (cid:81) s=j+1 (cid:32) (cid:81) s=j+ (cid:32) (cid:81) s=j+1 (cid:1) kj exp (cid:0)q (cid:32) ϕ(qt) (cid:32) exp (cid:32) (cid:32) (cid:32) (cid:32) t q q (cid:32) (cid:81) s=j+1 (cid:32) (cid:81) s=j+1 (cid:32) (cid:81) s=j+ (cid:32) (cid:81) s=j+1 (cid:33) (cid:33) αs kj vj (cid:33) (cid:33) Diag (αs) kj vj (cid:33) (cid:1) (cid:33) vj kj (cid:0)I ksk (cid:33) (cid:32) (cid:81) s=j+1 αs vj (cid:32) (cid:81) s=j+1 (cid:32) (cid:81) s=j+1 (cid:16) ϕ (ks) ϕ (ws)(cid:17) (cid:0)I wsw (cid:33) (cid:1) (cid:0)I ksk (cid:33) (cid:1) (cid:0)αs ksk αs (cid:33) (cid:1) kj (cid:33) kj vj (cid:33) vj kj (cid:16) Diag (αs) (cid:17) ˆk (cid:16) bs ˆks (cid:33) (cid:33) (cid:1) kj Diag (αs) (cid:0)I ksk Parallel form (cid:0)exp (cid:0)QK(cid:1) M(cid:1) (cid:16) (cid:16) (Q) (K)(cid:17) exp (cid:17) (cid:0)QK M(cid:1) (cid:0)QK M(cid:1) (cid:16) (Q Γ) (cid:0) Γ (cid:1) (cid:17) (cid:0)QK M(cid:1) (cid:0)I + KK M(cid:1)1 (cid:0)exp (cid:0)QK(cid:1) M(cid:1) (cid:33) (cid:33) ϕ (kj) vj (cid:0)exp (cid:0)QK(cid:1) M(cid:1) (cid:0)I + exp (cid:0)WK(cid:1) M(cid:1)1 (cid:33) (cid:32) (cid:81) s=j+ (cid:33) αs vj (cid:16) (cid:16)(cid:0)QK M(cid:1) (cid:0)I + WW M(cid:1)1(cid:17) exp (cid:17) (cid:0)QK M(cid:1) (cid:0)I + KK M(cid:1)1 (cid:0)QK M(cid:1) (cid:16) + KK Ai1/j M(cid:17)1 (cid:17) (cid:33) (cid:33) kj vj vj (cid:16) (cid:16) (Q Γ) (cid:0) Γ (cid:1) (cid:17) (cid:18) (cid:18) ˆK + 0t1 Γ (cid:19) (cid:16) KB (cid:17) M1 (cid:19)1 Γ (Q Γ) (cid:0) Γ (cid:1) (cid:17) (cid:16) + (K Γ) (cid:0) Γ (cid:1) M1(cid:17)1 [7] or even forgo explicit positional encodings entirely (NoPE) [49, 76, 19]. Given that GDN serves as an analogue role to RoPE, we choose NoPE for global full attention layers (MLA) in our model, allowing positional information to be captured dynamically by our proposed KDA model. Moreover, key strength of RoPE is its fine-grained positional encoding, achieved by assigning different rotation frequencies to each pair of dimensions, which functions analogously to Nonuniform Fourier Transform [7, 41] along the feature dimension. Standard GDN, however, employs per-head scalar decay and lacks this per-dimensional diversity, which motivates us to propose KDA with learnable channel-wise gate. 6.2 Relation to DPLR (Gated) DeltaNet can be generalized to more expressive Diagonal-Plus-Low-Rank (DPLR) structure, defined as atb . This structure was also explored in models such as S4 [30], which employed static DPLR formulation as the state transition matrix. During computation, this matrix is typically jointly diagonalized into the complex plane, thereby restricting its expressiveness to diagonal transformations [64]. While the DPLR structure introduces richer model interactions and can potentially enhance recall through its keyvalue update rule, it also suffers from notable limitation: high computational cost and poor parallelizability. These drawbacks make DPLR inherently slower in large-scale or real-time scenarios, where maintaining parameter efficiency becomes crucial design challenge. To address this issue, KDA introduces constrained variant of DPLR, where Eq. 1 can be rewritten as St = (cid:0)Diag(αt) βtktk with the correspondence between the two given by: Diag(αt)(cid:1) St1 + βtktv St = (D atb )St1 + ktv , s.t., = Diag(αt), at = βtkt, bt = kt αt. Furthermore, by sharing αt, we can factor it out as in Eq. 1, enabling fine-grained multiplicative decay over St in manner similar to GLA [114], followed by Householder-style transformation like DeltaNet [84, 112] for efficient 14 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT 1 def chunk_dplr(q, k, v, a, b, g, chunk_size): 2 3 B, H, T, K, V, BT = *q.shape, v.shape[-1], chunk_size NT, = // BT, k.new_zeros(B, H, K, V) q, k, v, a, b, = map(lambda x: rearrange(x, 'b (n c) (cid:44) gc = g.cumsum(-2) Aab, Aak, Aqb, Aqk = (torch.zeros(B, H, NT, BT, BT) for _ in range(4)) -> c d', c=BT), [q, k, v, a, b, g]) 1 def chunk_kda(q, k, v, a, b, g, chunk_size): 2 3 4 B, H, T, K, V, BT = *q.shape, v.shape[-1], chunk_size NT, = // BT, k.new_zeros(B, H, K, V) q, k, v, = map(lambda x: rearrange(x, 'b (n c) ... (cid:44) gc = g.cumsum(-2) Aqk, Akk = (torch.zeros(B, H, NT, BT, BT) for _ in range(2)) -> c ...', c=BT), [q, k, v, g]) 5 6 - (cid:44) 7 8 9 10 11 12 13 - 14 - 15 - 16 - 17 18 19 20 21 22 23 24 25 - 26 - 27 - 28 29 30 31 - 32 - 33 for in range(BT): gc)) a_i, q_i, g_i = (x[:,:,:,i,None] for in (a, q, (cid:44) mask = (torch.arange(BT) <= i)[..., None] s1_i = (g_i - gc).exp().where(mask, 0) s2_i= (g_i - g[:,:,:,i,None] - gc).where(mask, 0) Aqk[..., i, :] = (q_i * * s1_i).sum(-1) Aqb[..., i, :] = (q_i * * s1_i).sum(-1) Aab[..., i, :] = (a_i * * s2_i).sum(-1) Aak[..., i, :] = (a_i * * s2_i).sum(-1) for in range(1, BT): Aab[..., i, :i] = Aab[..., i, :i] + (Aab[..., i, :, (cid:44) None] * Aab[..., :, :i]).sum(-2) Aab = Aab + torch.eye(BT) u, = Aab @ (Aak @ v), Aab @ ((gc-g).exp() * a) = torch.zeros_like(v) mask = torch.triu(torch.ones(BT, BT), diagonal=1) for in range(0, NT): q_i, k_i, v_i, u_i, w_i, b_i = (x[:, :, i] for in (q, k, v, u, w, b)) (cid:44) o1 = Aqk[:, :, i] @ v_i o2 = Aqb[:, :, i] @ (u_i + w_i @ S) o3 = (q_i * gkc[:, :, i].exp()) @ o[:, :, i] = o1 + o2 + o3 decay = (gc[:, :, i, -1, None] - gc[:, :, i]).exp() = * gc[:,:,i,-1,:,None].exp() +=(k_i * decay).transpose(-1,-2) @ v_i +=(b_i * decay).transpose(-1,-2) @ (u_i + w_i @ S) return o, (a) PyTorch-style pseudo code for chunkwise DPLR. 5 6 + (cid:44) 7 8 9 10 11 12 13 14 + 15 + 16 17 18 20 21 22 23 24 25 26 + 27 28 29 + 30 for in range(BT): k_i, q_i = k[:, :, :, i, None], q[:, :, :, i, None] g_i = gc[...,i:i+1,:] mask = (torch.arange(BT) <= i)[..., None] s1_i = (g_i - gc).exp().where(mask, 0) s2_i = (gc - g_i).exp() Aqk[:, :, :, i, :] = (q_i * * s1_i).sum(-1) Akk[..., i] = (k_i * * s2_i).sum(-1) mask = torch.triu(torch.ones(BT, BT), diagonal=0) = -Akk.masked_fill(mask, 0) for in range(1, BT): A[..., i, :i] = A[..., i, :i] + (A[..., i, :, None] (cid:44) * A[..., :, :i].clone()).sum(-2) = (A + torch.eye(BT)) w, = @ (gc.exp() * k), @ = torch.zeros_like(v) mask = torch.triu(torch.ones(BT, BT), diagonal=1) for in range(0, NT): u, gc, w)) q_i, k_i, u_i, g_i, w_i = (x[:, :, i] for in (q, k, (cid:44) o[:,:,i]=(q_i *g_i.exp()) @ + Aqk @(u_i-w_i @ S) decay = (g_i[:,:,-1:] - g_i).exp() = * g_i[:, :, -1, :, None].exp() += (k_i * decay).transpose(-1,-2) @ v_i return o, (b) PyTorch-style pseudo code for chunkwise KDA. state updating. We provide side-by-side comparison of the chunkwise PyTorch-style pseudocode implementations for DPLR and KDA in Listing 8a and Listing 8b.The key improvements are highlighted below: Listing 8a Line 13-16 vs., Listing 8b Line 14-15 : the reciprocal of the cumulative decay term 1/Γ in chunkwise form (Eq. 9) can introduce numerical instability. While we can resolve this issue by secondary chunking [113], it incurs additional computation and I/O overhead. By fixing = = in the DPLR formulation, KDA removes the need for two secondary chunking steps, substantially reducing redundant operations and improving overall efficiency. Listing 8a Line 25-27,31-32 vs., Listing 8b Line 26,29 : KDA further eliminates roughly three matrix multiplications during inter-chunk and output computation, leading to significant kernel-level acceleration. We further benchmark the kernel speed in Fig. 2, showing that KDA achieves nearly 2 the speed of DPLR for sequence lengths up to 64k. 6.3 Complexity Analysis Training flops We maintain similar number of parameters in Kimi Linear as in the full attention MLA. The linear projection calculation remains identical to that of the global attention layer. The key distinction lies in the FLOPs associated with attention computation. For simplicity, we focus on non-variable length scenarios. Based on the implementation of the gated rule kernel, the theoretical FLOPs for single attention head with headdim dh and fixed chunk size = 64 in the gated delta rule [102] (per sequence of length ) are as follows: FLOPsKDA(T ; C, dh) = 6T d2 + 3T Cdh + 2. For full (global) attention, the dominant term per head is FLOPsAttn(T ; dh) = 2T 2dh. (13) (14) Inference strategy and cost The inference strategy in Kimi Linear employs hybrid approach to optimize both computational and I/O efficiency. During the prefill phase, the model utilizes FLOP-intensive chunk kernel (see 15 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Table 7: An overview of different attention mechanisms through the lens of state updating rules and their learning objective under the TTT framework [90]. We ignore all normalizer terms and activation/kernel functions for brevity. Objective Update rule St = St1 St1 LA [48] RetNet [92] βt (cid:10)S (cid:11) t1kt, vt (cid:10)S (cid:10)S t1kt, vt t1kt, vt βt (cid:10)S (cid:10)S t1kt, vt (cid:11) + 1 t1(1 αt), vt 2 (cid:13) 2 (cid:13) (cid:13) 2 (cid:13) 1 α St1 (cid:13) (cid:11) + 1 (cid:13) (cid:13) (cid:11) + 1 1 αtSt1 (cid:13) 2 (cid:13) (cid:112)Diag (1 αt)St1 (cid:13) (cid:13) (cid:11) + 1 2 (cid:13) (cid:13) (cid:13) (cid:13) 2 (cid:13) (cid:13) (cid:112)Diag (1 αt)St1 St = St1 + ktv St = αSt1 + βtktv St = αtSt1 + βtktv St = Diag(αt)St1 + ktv St = Diag(αt)St1 + (1 αt)v (cid:13) 2 (cid:13) (cid:13) 1 2 βt 1 2 βt 2 βt 2 t1kt 1 αtSt (cid:13) (cid:13)vt (cid:13) (cid:13)vt (cid:13) (cid:13)vt (cid:13) (cid:13) (cid:13)vt (cid:13) (cid:13) (cid:13)vt (cid:13) (cid:13) 2 (cid:13) Diag(βt) (cid:13) (cid:13) 2 + 1 t1kt (cid:13) (cid:13) 2 (cid:13) (cid:13) 2 (cid:112)Diag (1 αt)St1 (cid:13) (cid:13) + 1 (cid:13) (cid:13) 2 (cid:13) 2 (cid:13) (cid:13) (cid:13) 2 (cid:13) (cid:13) t1kt t1kt kt (cid:13) (cid:13) t1 2 (cid:13) 2 (cid:13) (cid:13) (cid:16) (cid:16) St = St = ktk (cid:17) βt kt 1+βtk αt βtkt ˆk (cid:16) (cid:16) St = Diag (αt) St = (cid:0)I βtktk St = (cid:0)I βtktk (cid:17) St1 + βtktv St1 + βtktv (cid:17) ˆk bs ˆks (cid:17) St1 + ktv (cid:1) αtSt1 + βtktv (cid:1) Diag (αt)St1 + βtktv Mamba2 [16] GLA [114] HGRN2 [77] Longhorn [59] Comba [40] RWKV7 [71] GDN [111] KDA (ours) For GDN and KDA, the update can be viewed as performing an Stochastic Gradient Descent(SGD) process on the decayed state S, that is, St = St1 St L, where St1 is decayed by scalar or fine-grained gate. 3.1), while switching to the more efficient recurrent kernel (Eq. 2) for autoregressive generation. key advantage of the Linear KDA is its ability to maintain fixed-sized state (dk dv per head, with dk = dv = 128) regardless of sequence length. For our hybrid model, as sequence length increases, the I/O-bounded decoding time approaches maximum hybrid efficiency ratio of 3:1 compared to full attention. This trend is reflected in Fig. 7b, where Kimi Linear achieves 2.3 speedup at 1M token context. Additionally, by eliminating the need for large, linear-scaling KV cache, Kimi Linear is able to reallocate memory resources to support larger batch sizes, enhancing overall throughput. In long-context scenarios (up to 1M tokens), this memory efficiency results in theoretical decoding speedup of up to 6.3 (see Fig. 1b)."
        },
        {
            "title": "7 Related Works",
            "content": "7.1 Efficient Subquadratic Attention The quadratic time complexity of the standard self-attention mechanism [99] remains fundamental bottleneck for processing long contexts in Transformer-based models. This limitation has become increasingly critical as large language models (LLMs) are now expected to handle million-token sequences for tasks such as agentic tool use and repository-level code analysis [19, 50]. To overcome this challenge, substantial body of research has explored more efficient attention mechanisms [91, 89], which can broadly be categorized into two main directions: (1) linear attention, and (2) sparse attention. Linear Attention reformulates the quadratic attention map into kernelized feature interactions, replacing the softmax with positive feature map so that attention can be computed through two associative matrix products [48]. This eliminates the explicit O(T 2) similarity matrix and enables linear-time computation with respect to sequence length. Subsequent work strengthens the vanilla linear attention significantly through more refined memory control, shifting from data-independent decay [92, 78] to more adaptive, data-dependent mechanisms [29, 93], and refining the decay granularity from coarse headwise [16] to precise, channel-wise decay. GLA generalizes these approaches with diagonal, channel-wise gates that balance expressiveness and efficiency while retaining chunk-wise parallelism [113, 114]. Table 7 summarizes the corresponding update rules. Collectively, these methods cast attention as compact recurrent memory updated with parallel prefix-scan operators and fused matrix multiplies, aligning well with modern accelerators [42]. complementary view connects linear attention to fast-weight memory [84]: the state is low-capacity associative table updated online by Hebbian-like rules [69], while slow weights amortize when to store, update, or forget [68]. In Table 7, we provide summary of the existing efficient token mixing methods, comparing them from the perspectives of state update mechanisms and optimization objectives. Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT From this perspective, gating and decay serve as learnable criteria that mitigate interference and stabilize optimization [90]. Despite these advances, linear attention still lags full attention on exact copying and fine-grained selection in extreme long-context retrieval. This motivates hybrid designs (interleaving linear and full attention) and more structured updates. In particular, the gated delta rule used by GDN/KDA introduces rank-1 corrective updates to the fast-weight state, improving targeted retention while remaining parallelizable at the operator level [112]. Linear Attention with Gating Mechanism The vanilla Linear Attention [48] is known to lack the selection mechanism inherent in softmax attention [99], falling short in expressiveness. To address this, Gated Linear Attention models have emerged as memory-efficient and parallelizable alternatives [113, 114, 29]. Instead of storing an everexpanding KV cache, these models employ fixed-size matrix-valued state and learnable gates to selectively retain and forget information. This design achieves expressive power comparable to softmax attention [65, 125, 64] while maintaining constant time and memory complexity during inference time. The general recurrent formulation of such models for memory update St Rdkdv can be expressed as: St = AtSt1 + ktv , ot = t qt. (15) The primary distinction among various gated linear attention mechanisms lies in the parameterization of the forget gate At, as summarized in Table 7. For instance, RetNet [92] uses data-independent scalar decay α, and Mamba2 [16] employs data-dependent scalar αt. Specifically, GLA [114] utilized diagonalized fine-grained matrix Diag(αt) Rdkdk , offering an effective trade-off between efficiency and performance. Other variants are displayed in Table 7. Sparse Attention separate body of work reduces the quadratic complexity of standard attention by exploiting its inherent sparsity, approximating the full attention score by performing the computation on strategically selected subset of tokens. The central challenge lies in identifying this subset effectively without degrading model performance. Early methods often utilized efficient, training-free static patterns, such as sliding and dilated windows [20, 31, 107], or fixed patterns [120, 35], but their rigid structure often compromises model accuracy. More advanced methods determine the important positions based on the context, such as clustering [51, 106] and lightweight routing mechanisms [25, 73, 2, 9], but this dynamic selection process introduces computational overhead that can prevent them from achieving their full theoretical speedup without dedicated kernel acceleration [21]. Some models further introduce training-free sparsification during the inference stage [107, 109]. Recent approaches to sparse attention have begun to prioritize hardware co-design, as exemplified by NSA [119, 96] and MoBA [63], which both move from token-level to chunk-level selection. In NSA, each query dynamically selects chunks based on scores produced by an MLP. The methods efficiency relies on its use of Grouped-Query Attention (GQA) [98] with large head count (typically multiple of 16), configuration specifically designed to accelerate computation through highly parallelized tensormatrix multiplications. Similarly, MoBA performs top-k chunk selection, but leverages log-sum-exp (LSE) scores computed efficiently via flash-attention kernels [17]. In contrast to NSA and MoBA, the recently proposed DeepSeek-V3.2-Exp Attention (DSA) [18] revives token-level sparsity, maintaining efficiency through learnable full-attention indexer implemented with low-precision fp8 and small head dimension for token selection. Discussion Linear attention and sparse attention represent two distinct pathways toward efficient long-context modeling. Sparse attention tends to retrieve fine-grained historical information more effectively, but this advantage comes at the cost of storing the entire KV cache for token selection, making it less efficient than linear attention models that maintain constant state. Moreover, sparse attention performs only information selection, and its theoretical expressive upper bound remains that of full attention. In contrast, linear attention, grounded in the principle of compression as intelligence, enables generalization with fixed-size state and, when combined with the Delta learning rule, can achieve theoretically stronger expressive capacity. Although linear attentions have traditionally been criticized for weak retrieval ability, this limitation can be mitigated through state expansion [23, 34, 117, 39] or related techniques. Nevertheless, despite these advantages, linear attention remains limited by current hardware implementations and the absence of optimized inference infrastructure. Our work overcomes these limitations with Kimi Linear, powerful model integrated with vLLM for efficient inference. Our proposed KDA delivers competitive performance compared to the full-attention baseline  (Table 3)  and achieves over 2 decoding speedup at the one-million-token context (Figure 7b). Despite their distinct approaches to efficient long-context modeling, linear attention and sparse attention are not mutually exclusive. Future work could explore hybrid models that integrate the strengths of both, leveraging the compression and generalization capabilities of linear attention with the fine-grained retrieval advantages of sparse attention to further enhance model performance and efficiency. 17 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT 7.2 Hybrid Model Despite efficiency, pure Linear Attention still struggle with precise memory retrieval and exact copying [45, 104] This deficiency hinders their adoption in industrial-scale LLMs where robust long-context recall (e.g., beyond 1M tokens) and reliable tool-use over extensive code repositories are critical [50]. Recent work shows that Linear Attention and full attention can effectively complement each other, leading to various hybrid designs. Intra-layer hybrid One category of hybrid architectures is the intra-layer hybrid, which adaptively fuses the outputs of different mechanisms within each layer. common implementation fuses outputs from heterogeneous heads within each layer, such as combining standard attention with state space models (SSMs) [22, 56]. In contrast, sequence-level approaches apply distinct mechanisms to different parts of the input. For example, some use linear attention for past context and SWA for recent tokens [123, 54, 67], while NHA [24] compresses the history with GSA [124] and combines it with local sliding window context to emulate standard attention operation. Inter-layer Hybrid key drawback of the intra-layer hybrid is the increased system complexity and inference overhead. The heterogeneous mechanisms require separate computational paths, complicating optimizations like distributed parallelism. To mitigate this challenge, inter-layer hybrids have become more widely adopted and practical strategy in LLMs [66, 57, 97]. This approach involves stacking distinct layer types, such as full attention and linear alternative, in predefined ratio. Building on this paradigm, we implement simple yet effective strategy: interleaving linear and full attention layers at fixed 3:1 ratio (see 5.2 for ablations). This regular, repeating structure simplifies KV cache management and integrates seamlessly with standard optimizations. For the linear component of our hybrid, we deviate from the common practice of using Mamba2 [16]. Instead, we employ KDA, as we found it yields superior overall performance, particularly in retrieval and copying abilities. Discussion Recent work indicates that hybrid models can be sensitive to adjustments in the RoPE base frequency, vulnerability that complicates context window extension [126]. This sensitivity can hinder the models ability to extrapolate to longer sequences. To address this challenge, recent models have trended towards solutions that incorporate No Position Embeddings (NoPE). Falcon-H [126], for example, uses an unconventionally high base frequency (e.g., 1011) to push its positional encoding to near-NoPE state. Architecturally, SwanGPT [76] interleaves RoPE-based layers with NoPE-based full attention layers. Aligning with this direction, we found that hybridizing our KDA layers with NoPE full attention is also highly effective strategy, facilitating straightforward context window extension."
        },
        {
            "title": "Conclusion",
            "content": "We introduce Kimi Linear, hybrid linear attention architecture designed to meet the efficiency demands of agentic intelligence and test-time scaling without sacrificing quality. Central to Kimi Linear is Kimi Delta Attention (KDA), an advanced linear attention module with channel-wise gating mechanism that enhances memory control and enables RNN-style models in hybrid architectures. By interleaving KDA with global attention in 3:1 ratio, Kimi Linear reduces memory usage by up to 75%, while achieving up to 6.3 higher decoding throughput and outperforming full-attention baselines. Our approach provides scalable, efficient solution for large language models, with open-source KDA kernels and pre-trained checkpoints facilitating further research. 18 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT"
        },
        {
            "title": "References",
            "content": "[1] Sandhini Agarwal et al. gpt-oss-120b & gpt-oss-20b model card. In: arXiv preprint arXiv:2508.10925 (2025). Joshua Ainslie et al. Colt5: Faster long-range transformers with conditional computation. In: arXiv preprint [2] arXiv:2303.09752 (2023). [3] Zeyuan Allen-Zhu. Physics of Language Models: Part 4.1, Architecture Design and the Magic of Canon Layers. In: SSRN Electronic Journal (May 2025). Available at SSRN: https://ssrn.com/abstract=5240330 or http://dx.doi.org/10.2139/ssrn.5240330. DOI: 10.2139/ssrn.5240330. [4] Simran Arora et al. Simple linear attention language models balance the recall-throughput tradeoff. In: Forty-first International Conference on Machine Learning. 2024. URL: https://openreview.net/forum? id=e93ffDcpH3. [5] Simran Arora et al. Zoology: Measuring and Improving Recall in Efficient Language Models. 2023. arXiv: 2312.04927 [cs.CL]. [6] Yushi Bai et al. Longbench v2: Towards deeper understanding and reasoning on realistic long-context multitasks. In: arXiv preprint arXiv:2412.15204 (2024). [7] Federico Barbero et al. Round and Round We Go! What makes Rotary Positional Encodings useful? In: Proceedings of ICLR. 2025. URL: https://openreview.net/forum?id=GtvuNrk58a. [8] Ali Behrouz et al. Atlas: Learning to optimally memorize the context at test time. In: arXiv preprint arXiv:2505.23735 (2025). [9] Amanda Bertsch et al. Unlimiformer: Long-range transformers with unlimited length input. In: Advances in NeurIPS 36 (2023), pp. 3552235543. [10] Stella Biderman et al. Lessons from the trenches on reproducible evaluation of language models. In: arXiv preprint arXiv:2405.14782 (2024). [11] Christian Bischof and Charles Van Loan. The WY Representation for Products of Householder Matrices. In: SIAM Journal on Scientific and Statistical Computing (1987), s2s13. URL: https://doi.org/10.1137/ 0908009. [12] Aaron Blakeman et al. Nemotron-h: family of accurate and efficient hybrid mamba-transformer models. In: arXiv preprint arXiv:2504.03624 (2025). [13] Egor Bogomolov et al. Long code arena: set of benchmarks for long-context code models. In: arXiv preprint arXiv:2406.11612 (2024). [14] Peter Clark et al. Think you have Solved Question Answering? Try ARC, the AI2 Reasoning Challenge. In: arXiv:1803.05457v1 (2018). [15] Ganqu Cui et al. The entropy mechanism of reinforcement learning for reasoning language models. In: arXiv preprint arXiv:2505.22617 (2025). [16] Tri Dao and Albert Gu. Transformers are SSMs: Generalized Models and Efficient Algorithms Through Structured State Space Duality. In: CoRR abs/2405.21060 (2024). DOI: 10.48550/ARXIV.2405.21060. arXiv: 2405.21060. URL: https://doi.org/10.48550/arXiv.2405.21060. [17] Tri Dao et al. FlashAttention: Fast and Memory-Efficient Exact Attention with IO-Awareness. In: Advances in NeurIPS. 2022, pp. 1634416359. URL: https://proceedings.neurips.cc/paper_files/paper/ 2022/file/67d57c32e20fd0a7a302cb81d36e40d5-Paper-Conference.pdf. [18] DeepSeek-AI. DeepSeek-V3.2-Exp: Boosting Long-Context Efficiency with DeepSeek Sparse Attention. 2025. [19] DeepSeek-AI et al. DeepSeek-V3 Technical Report. 2025. arXiv: 2412.19437 [cs.CL]. URL: https:// [20] [21] arxiv.org/abs/2412.19437. Jiayu Ding et al. LongNet: Scaling Transformers to 1,000,000,000 Tokens. 2023. arXiv: 2307.02486 [cs.CL]. URL: https://arxiv.org/abs/2307.02486. Juechu Dong et al. Flex Attention: Programming Model for Generating Optimized Attention Kernels. 2024. arXiv: 2412.05496 [cs.LG]. URL: https://arxiv.org/abs/2412.05496. [22] Xin Dong et al. Hymba: Hybrid-head Architecture for Small Language Models. 2024. arXiv: 2411.13676 [23] [24] [cs.CL]. URL: https://arxiv.org/abs/2411.13676. Jusen Du et al. Mom: Linear sequence modeling with mixture-of-memories. In: arXiv preprint arXiv:2502.13685 (2025). Jusen Du et al. Native Hybrid Attention for Efficient Sequence Modeling. In: arXiv preprint arXiv:2510.07019 (2025). [25] Tianyu Fu et al. Moa: Mixture of sparse attention for automatic large language model compression. In: arXiv preprint arXiv:2406.14909 (2024). 19 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT [26] Aryo Pradipta Gema et al. Are we done with mmlu? In: arXiv preprint arXiv:2406.04127 (2024). [27] Riccardo Grazzi et al. Unlocking State-Tracking in Linear RNNs Through Negative Eigenvalues. In: Proceed- [28] ings of ICLR. 2025. URL: https://openreview.net/forum?id=UvTo3tVBk2. Joseph F. Grcar. How ordinary elimination became Gaussian elimination. In: Historia Mathematica 38.2 (May 2011), pp. 163218. ISSN: 0315-0860. DOI: 10.1016/j.hm.2010.06.003. URL: http://dx.doi. org/10.1016/j.hm.2010.06.003. [29] Albert Gu and Tri Dao. Mamba: Linear-Time Sequence Modeling with Selective State Spaces. 2023. arXiv: 2312.00752 [cs.LG]. [30] Albert Gu, Karan Goel, and Christopher Ré. Efficiently Modeling Long Sequences with Structured State Spaces. 2022. arXiv: 2111.00396 [cs.LG]. [31] Xiangming Gu et al. When Attention Sink Emerges in Language Models: An Empirical View. 2025. arXiv: 2410.10781 [cs.CL]. URL: https://arxiv.org/abs/2410.10781. [32] Yuxian Gu et al. Jet-Nemotron: Efficient Language Model with Post Neural Architecture Search. 2025. arXiv: 2508.15884 [cs.CL]. URL: https://arxiv.org/abs/2508.15884. [33] Daya Guo et al. DeepSeek-R1 incentivizes reasoning in LLMs through reinforcement learning. In: Nature 645.8081 (2025), pp. 633638. [34] Han Guo et al. Log-linear attention. In: arXiv preprint arXiv:2506.04761 (2025). [35] Qipeng Guo et al. Star-transformer. In: arXiv preprint arXiv:1902.09113 (2019). [36] Dan Hendrycks et al. Measuring Massive Multitask Language Understanding. 2021. arXiv: 2009.03300 [37] [cs.CY]. URL: https://arxiv.org/abs/2009.03300. Jordan Hoffmann et al. Training Compute-Optimal Large Language Models. 2022. arXiv: 2203 . 15556 [cs.CL]. URL: https://arxiv.org/abs/2203.15556. [38] Cheng-Ping Hsieh et al. RULER: Whats the Real Context Size of Your Long-Context Language Models? In: [39] [40] arXiv preprint arXiv:2404.06654 (2024). Jiaxi Hu et al. Attractor memory for long-term time series forecasting: chaos perspective. In: Advances in NeurIPS 37 (2024), pp. 2078620818. Jiaxi Hu et al. Comba: Improving Nonlinear RNNs with Closed-loop Control. In: arXiv preprint arXiv:2506.02475 (2025). [41] Ermo Hua et al. Fourier Position Embedding: Enhancing Attentions Periodic Extension for Length Generalization. In: arXiv preprint arXiv:2412.17739 (2024). [42] Weizhe Hua et al. Transformer Quality in Linear Time. In: Proceedings of ICML. Ed. by Kamalika Chaudhuri et al. PMLR, 2022, pp. 90999117. URL: https://proceedings.mlr.press/v162/hua22a.html. [43] Yuzhen Huang et al. C-eval: multi-level multi-discipline chinese evaluation suite for foundation models. In: Advances in NeurIPS 36 (2023), pp. 6299163010. [44] Naman Jain et al. Livecodebench: Holistic and contamination free evaluation of large language models for code. In: arXiv preprint arXiv:2403.07974 (2024). [45] Samy Jelassi et al. Repeat After Me: Transformers are Better than State Space Models at Copying. 2024. arXiv: 2402.01032 [cs.LG]. [46] Thierry Joffrain et al. Accumulating Householder transformations, revisited. In: (2006), pp. 169179. URL: https://doi.org/10.1145/1141885.1141886. [47] Mandar Joshi et al. Triviaqa: large scale distantly supervised challenge dataset for reading comprehension. In: arXiv preprint arXiv:1705.03551 (2017). [48] Angelos Katharopoulos et al. Transformers are RNNs: Fast Autoregressive Transformers with Linear Attention. In: Proceedings of ICML. Ed. by Hal Daumé III and Aarti Singh. PMLR, 2020, pp. 51565165. URL: https://proceedings.mlr.press/v119/katharopoulos20a.html. [49] Amirhossein Kazemnejad et al. The impact of positional encoding on length generalization in transformers. In: Advances in NeurIPS 36 (2023), pp. 2489224928. [50] Team Kimi et al. Kimi k2: Open agentic intelligence. In: arXiv preprint arXiv:2507.20534 (2025). [51] Nikita Kitaev, Łukasz Kaiser, and Anselm Levskaya. Reformer: The efficient transformer. In: arXiv preprint arXiv:2001.04451 (2020). [52] Satyapriya Krishna et al. Fact, fetch, and reason: unified evaluation of retrieval-augmented generation. In: arXiv preprint arXiv:2409.12941 (2024). [53] Hanyu Lai et al. Survey of Post-Training Scaling in Large Language Models. In: Proceedings of the 63rd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2025, pp. 2771 2791. 20 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT [54] Disen Lan et al. Liger: Linearizing Large Language Models to Gated Recurrent Structures. In: arXiv preprint arXiv:2503.01496 (2025). [55] Haonan Li et al. CMMLU: Measuring massive multitask language understanding in Chinese. In: Findings of the Association for Computational Linguistics: ACL 2024. Ed. by Lun-Wei Ku, Andre Martins, and Vivek Srikumar. Bangkok, Thailand: Association for Computational Linguistics, Aug. 2024, pp. 1126011285. DOI: 10 . 18653 / v1 / 2024 . findings - acl . 671. URL: https : / / aclanthology . org / 2024 . findings - acl.671/. [56] Yixing Li et al. Transmamba: Flexibly switching between transformer and mamba. In: arXiv preprint arXiv:2503.24067 (2025). [57] Opher Lieber et al. Jamba: Hybrid Transformer-Mamba Language Model. 2024. arXiv: 2403 . 19887 [cs.CL]. [58] Zhixuan Lin et al. Forgetting transformer: Softmax attention with forget gate. In: arXiv preprint arXiv:2503.02130 (2025). [59] Bo Liu et al. Longhorn: State Space Models are Amortized Online Learners. In: ArXiv abs/2407.14207 (2024). [60] [61] [62] URL: https://api.semanticscholar.org/CorpusID:271310065. Jiawei Liu et al. Is Your Code Generated by ChatGPT Really Correct? Rigorous Evaluation of Large Language Models for Code Generation. In: Thirty-seventh Conference on NeurIPS. 2023. URL: https://openreview. net/forum?id=1qvx610Cu7. Jiawei Liu et al. Repoqa: Evaluating long context code understanding. In: arXiv preprint arXiv:2406.06025 (2024). Jingyuan Liu et al. Muon is Scalable for LLM Training. 2025. arXiv: 2502.16982 [cs.LG]. URL: https: //arxiv.org/abs/2502.16982. [63] Enzhe Lu et al. MoBA: Mixture of Block Attention for Long-Context LLMs. 2025. arXiv: 2502.13189 [cs.LG]. URL: https://arxiv.org/abs/2502.13189. [64] William Merrill, Jackson Petty, and Ashish Sabharwal. The illusion of state in state-space models. In: arXiv preprint arXiv:2404.08819 (2024). [65] William Merrill and Ashish Sabharwal. The Parallelism Tradeoff: Limitations of Log-Precision Transformers. In: Transactions of the Association for Computational Linguistics 11 (2023), pp. 531545. DOI: 10.1162/ tacl_a_00562. URL: https://aclanthology.org/2023.tacl-1.31/. [66] MiniMax et al. MiniMax-01: Scaling Foundation Models with Lightning Attention. 2025. arXiv: 2501. [cs.CL]. [67] Tsendsuren Munkhdalai, Manaal Faruqui, and Siddharth Gopal. Leave No Context Behind: Efficient Infinite Context Transformers with Infini-attention. 2024. arXiv: 2404.07143 [cs.CL]. [68] Tsendsuren Munkhdalai and Adam Trischler. Metalearning with Hebbian Fast Weights. 2018. arXiv: 1807. 05076 [cs.NE]. URL: https://arxiv.org/abs/1807.05076. [69] Tsendsuren Munkhdalai et al. Metalearned Neural Memory. In: ArXiv abs/1907.09720 (2019). URL: https: //api.semanticscholar.org/CorpusID:198179407. [70] Long Ouyang et al. Training language models to follow instructions with human feedback. In: Advances in NeurIPS 35 (2022), pp. 2773027744. [71] Bo Peng et al. RWKV-7 \"Goose\" with Expressive Dynamic State Evolution. 2025. arXiv: 2503.14456 [cs.CL]. [72] Bowen Peng et al. Yarn: Efficient context window extension of large language models. In: arXiv preprint arXiv:2309.00071 (2023). [73] Piotr Piekos, Róbert Csordás, and Jürgen Schmidhuber. Mixture of Sparse Attention: Content-Based Learnable Sparse Attention via Expert-Choice Routing. In: arXiv preprint arXiv:2505.00315 (2025). [74] Aske Plaat et al. Reasoning with large language models, survey. In: CoRR (2024). [75] Ofir Press, Noah Smith, and Mike Lewis. Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation. In: Proceedings of ICLR. 2022. URL: https://openreview.net/forum?id= R8sQPpGCv0. [76] Krishna C. Puvvada et al. SWAN-GPT: An Efficient and Scalable Approach for Long-Context Language Modeling. 2025. arXiv: 2504.08719 [cs.CL]. [77] Zhen Qin et al. HGRN2: Gated Linear RNNs with State Expansion. 2024. arXiv: 2404.07904 [cs.CL]. [78] Zhen Qin et al. TransNormerLLM: Faster and Better Large Language Model with Improved TransNormer. 2024. arXiv: 2307.14995 [cs.CL]. [79] Zihan Qiu et al. Gated Attention for Large Language Models: Non-linearity, Sparsity, and Attention-Sink-Free. 2025. arXiv: 2505.06708 [cs.CL]. 21 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT [80] Xiaoye Qu et al. survey of efficient reasoning for large reasoning models: Language, multimodality, and beyond. In: arXiv preprint arXiv:2503.21614 (2025). [81] Qwen Team. Qwen3-Next: Towards Ultimate Training & Inference Efficiency. Accessed: 2025-10-27. Sept. 2025. [82] David Rein et al. Gpqa: graduate-level google-proof q&a benchmark. In: First Conference on Language Modeling. 2024. [83] Keisuke Sakaguchi et al. WinoGrande: An Adversarial Winograd Schema Challenge at Scale. 2019. arXiv: [84] 1907.10641 [cs.CL]. URL: https://arxiv.org/abs/1907.10641. Imanol Schlag, Kazuki Irie, and Jürgen Schmidhuber. Linear Transformers Are Secretly Fast Weight Programmers. In: Proceedings of ICML. Ed. by Marina Meila and Tong Zhang. PMLR, 2021, pp. 93559366. URL: https://proceedings.mlr.press/v139/schlag21a.html. Imanol Schlag, Tsendsuren Munkhdalai, and Jürgen Schmidhuber. Learning Associative Inference Using Fast Weight Memory. 2021. arXiv: 2011.07831 [cs.LG]. URL: https://arxiv.org/abs/2011.07831. [86] Peter Shaw, Jakob Uszkoreit, and Ashish Vaswani. Self-Attention with Relative Position Representations. 2018. [85] [87] [88] arXiv: 1803.02155 [cs.CL]. Jianlin Su. Linear Attention: Brief History of Imitation, Innovation, and Feedback. June 2025. URL: https: //kexue.fm/archives/11033. Jianlin Su et al. Roformer: Enhanced transformer with rotary position embedding. In: Neurocomputing 568 (2024), p. 127063. [89] Weigao Sun et al. Speed Always Wins: Survey on Efficient Architectures for Large Language Models. 2025. arXiv: 2508.09834 [cs.CL]. URL: https://arxiv.org/abs/2508.09834. [90] Yu Sun et al. Learning to (Learn at Test Time): RNNs with Expressive Hidden States. In: ArXiv abs/2407.04620 (2024). URL: https://api.semanticscholar.org/CorpusID:271039606. [91] Yutao Sun et al. Efficient attention mechanisms for large language models: survey. In: arXiv preprint arXiv:2507.19595 (2025). [92] Yutao Sun et al. Retentive Network: Successor to Transformer for Large Language Models. 2023. arXiv: 2307.08621 [cs.CL]. [93] Yutao Sun et al. You Only Cache Once: Decoder-Decoder Architectures for Language Models. 2024. arXiv: 2405.05254 [cs.CL]. URL: https://arxiv.org/abs/2405.05254. [94] Mirac Suzgun et al. Challenging big-bench tasks and whether chain-of-thought can solve them. In: arXiv preprint arXiv:2210.09261 (2022). [95] Kimi Team et al. Kimi k1.5: Scaling Reinforcement Learning with LLMs. 2025. arXiv: 2501.12599 [cs.AI]. URL: https://arxiv.org/abs/2501.12599. [96] MiniCPM Team et al. MiniCPM4: Ultra-Efficient LLMs on End Devices. 2025. arXiv: 2506.07900 [cs.CL]. URL: https://arxiv.org/abs/2506.07900. [97] Tencent Hunyuan Team et al. Hunyuan-turbos: Advancing large language models through mamba-transformer synergy and adaptive chain-of-thought. In: arXiv preprint arXiv:2505.15431 (2025). [98] Hugo Touvron et al. LLaMA: Open and Efficient Foundation Language Models. 2023. arXiv: 2302.13971 [cs.CL]. [99] Ashish Vaswani et al. Attention is All you Need. In: Advances in NeurIPS. Ed. by I. Guyon et al. Curran Associates, Inc., 2017. URL: https://proceedings.neurips.cc/paper_files/paper/2017/file/ 3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf. [100] Roger Waleffe et al. An Empirical Study of Mamba-based Language Models. 2024. arXiv: 2406 . 07887 [cs.LG]. URL: https://arxiv.org/abs/2406.07887. [101] Sinong Wang et al. Linformer: Self-Attention with Linear Complexity. 2020. arXiv: 2006.04768 [cs.LG]. [102] Yaoyu Wang. Understanding DeltaNet from the Perspective of Inference Frameworks. May 2025. URL: https: //yywangcs.notion.site/DeltaNet-1fefc9f5d80580a496f8eb406a496f09. [103] Yubo Wang et al. Mmlu-pro: more robust and challenging multi-task language understanding benchmark. In: Advances in NeurIPS 37 (2024), pp. 9526695290. [104] Kaiyue Wen, Xingyu Dang, and Kaifeng Lyu. Rnns are not transformers (yet): The key bottleneck on in-context retrieval. In: arXiv preprint arXiv:2402.18510 (2024). [105] Colin White et al. Livebench: challenging, contamination-free llm benchmark. In: arXiv preprint arXiv:2406.19314 4 (2024). [106] Yuhuai Wu et al. Memorizing transformers. In: arXiv preprint arXiv:2203.08913 (2022). 22 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT [107] Guangxuan Xiao et al. Efficient streaming language models with attention sinks. In: arXiv preprint arXiv:2309.17453 (2023). [108] Wenhan Xiong et al. Effective Long-Context Scaling of Foundation Models. 2023. arXiv: 2309.16039 [cs.CL]. URL: https://arxiv.org/abs/2309.16039. [109] Ruyi Xu et al. Xattention: Block sparse attention with antidiagonal scoring. In: arXiv preprint arXiv:2503.16428 (2025). [110] Bowen Yang et al. Rope to Nope and Back Again: New Hybrid Attention Strategy. 2025. arXiv: 2501. [cs.CL]. URL: https://arxiv.org/abs/2501.18795. [111] Songlin Yang, Jan Kautz, and Ali Hatamizadeh. Gated Delta Networks: Improving Mamba2 with Delta Rule. In: Proceedings of ICLR. 2025. URL: https://openreview.net/forum?id=r8H7xhYPwz. [112] Songlin Yang and Bailin Wang. Parallelizing Linear Transformers with the Delta Rule over Sequence Length. In: ArXiv abs/2406.06484 (2024). URL: https://api.semanticscholar.org/CorpusID:270371554. [113] Songlin Yang and Yu Zhang. FLA: Triton-Based Library for Hardware-Efficient Implementations of Linear Attention Mechanism. 2024. URL: https://github.com/fla-org/flash-linear-attention. [114] Songlin Yang et al. Gated Linear Attention Transformers with Hardware-Efficient Training. In: Proceedings of ICML. PMLR, 2024. [115] Songlin Yang et al. PaTH Attention: Position Encoding via Accumulating Householder Transformations. In: arXiv preprint arXiv:2505.16381 (2025). [116] Feng Yao et al. Your Efficient RL Framework Secretly Brings You Off-Policy RL Training. Aug. 2025. URL: https://fengyao.notion.site/off-policy-rl. [117] Morris Yau et al. Sequential-Parallel Duality in Prefix Scannable Models. In: arXiv preprint arXiv:2506. (2025). [118] Howard Yen et al. HELMET: How to Evaluate Long-Context Language Models Effectively and Thoroughly. [119] In: International Conference on Learning Representations (ICLR). 2025. Jingyang Yuan et al. Native Sparse Attention: Hardware-Aligned and Natively Trainable Sparse Attention. 2025. arXiv: 2502.11089 [cs.CL]. URL: https://arxiv.org/abs/2502.11089. [120] Manzil Zaheer et al. Big bird: Transformers for longer sequences. In: Advances in NeurIPS 33 (2020), pp. 1728317297. [121] Rowan Zellers et al. HellaSwag: Can Machine Really Finish Your Sentence? In: Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics. 2019. [122] Biao Zhang and Rico Sennrich. Root mean square layer normalization. In: Advances in NeurIPS 32 (2019). [123] Michael Zhang et al. Lolcats: On low-rank linearizing of large language models. In: arXiv preprint arXiv:2410.10254 (2024). [124] Yu Zhang et al. Gated Slot Attention for Efficient Linear-Time Sequence Modeling. 2024. arXiv: 2409.07146 [cs.CL]. [125] Shu Zhong et al. Understanding Transformer from the Perspective of Associative Memory. In: arXiv preprint [126] arXiv:2505.19488 (2025). Jingwei Zuo et al. Falcon-H1: Family of Hybrid-Head Language Models Redefining Efficiency and Performance. 2025. arXiv: 2507.22448 [cs.CL]. URL: https://arxiv.org/abs/2507.22448. 23 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT"
        },
        {
            "title": "A Contributions",
            "content": "The authors are listed in order of the significance of their contributions, with those in project leadership roles appearing last. The project is developed at Moonshot AI, with several external collaborators that are marked with #. Names marked with an asterisk (*) indicate people who are no longer part of our team. Yu Zhang1 Zongyu Lin Xingcheng Yao Jiaxi Hu2 Fanqing Meng Chengyin Liu Xin Men Songlin Yang#3 Zhiyuan Li Wentao Li Enzhe Lu Weizhou Liu Yanru Chen Weixin Xu Longhui Yu Yejie Wang Yu Fan Longguang Zhong Enming Yuan Dehao Zhang Yizhi Zhang T.Y. Liu Haiming Wang Shengjun Fang Weiran He Shaowei Liu Yiwei Li Jianlin Su Jiezhong Qiu4 Bo Pang Junjie Yan Zhejun Jiang Weixiao Huang Bohong Yin Jiacheng You Chu Wei Zhengtao Wang Chao Hong Yutian Chen Guanduo Chen Yucheng Wang Huabin Zheng Feng Wang Yibo Liu Mengnan Dong Zheng Zhang Siyuan Pan Wenhao Wu Yuhao Wu Longyu Guan Jiawen Tao Guohong Fu#1 Xinran Xu Yuzhi Wang Guokun Lai Yuxin Wu Xinyu Zhou Zhilin Yang Yulun Du 1 Soochow University, China 2 The Hong Kong University of Science and Technology (Guangzhou) 3 Massachusetts Institute of Technology 4 Hangzhou Institute of Medicine, CAS 24 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT"
        },
        {
            "title": "B Derivations for Chunkwise Parallelism of KDA",
            "content": "We first recall the recurrent form of KDA: Sr [t] = (cid:32) (cid:89) (cid:16) i= (cid:124) βi [t]ki [t]ki [t] (cid:17) (cid:33) Diag(αi [t]) S0 [t] + (cid:123)(cid:122) :=Pr [t] (cid:125) (cid:89) (cid:16) j=i (cid:88) i=1 (cid:124) βj [t]kj [t]kj [t] (cid:17) Diag(αj [t]) βi [t]ki [t]vi [t] (cid:123)(cid:122) :=Hr [t] (cid:125) = Pr [t] + Hr [t] [t] and Hr Our goal is to transform Pr [t] Sr [t] into matrix forms suitable for parallel computation. [t], which involves the cumulative product of generalized Householder matrices, can be optimized using We show that Pr the classic WY representation. Proposition 1. The matrix Pr [t] can be expressed as: Pr [t] = Diag(γr [t]) (cid:88) i=1 Diag(γir [t] )ki [t]wi [t] where the auxiliary vector wr [t] Rdk is computed via the following recurrence relation: (cid:32) wr [t] = βr [t] Diag(γr [t])kr [t] (cid:16) wi [t] ki [t] Diag (cid:16) γir [t] (cid:17) kr [t] (cid:33) (cid:17) r1 (cid:88) i= Proof. We proceed with proof by mathematical induction. [t] = Diag(γr1 [t] ) (cid:80)r1 i=1 Diag(γir1 [t] Inductive Step: Assume the proposition holds for 1, i.e., Pr1 We now derive: (cid:16) (cid:17) Pr [t] = βr [t]kr [t]kr [t] Diag(αr [t])Pr1 [t] (cid:32) (cid:16) = (cid:16) = βr [t]kr [t]kr [t] βr [t]kr [t]kr [t] (cid:17) (cid:17) Diag(αr [t]) Diag(γr1 [t] ) (cid:16) Diag γir1 [t] (cid:17) ki [t]wi [t] (cid:33) r1 (cid:88) i=1 (cid:32) Diag(γr [t]) r1 (cid:88) i=1 Diag (cid:16) γir [t] (cid:17) [t]wi ki [t] (cid:33) (16) (17) )ki [t]wi [t] . = Diag(γr [t]) = Diag(γr [t]) = Diag(γr [t]) = Diag(γr [t]) = Diag(γr [t]) Diag Diag Diag Diag Diag (cid:16) (cid:16) (cid:16) (cid:16) (cid:16) γir [t] γir [t] γir [t] γir [t] γir [t] (cid:17) (cid:17) (cid:17) (cid:17) (cid:17) r1 (cid:88) i=1 r1 (cid:88) i=1 r1 (cid:88) i=1 r1 (cid:88) i=1 (cid:88) i=1 The inductive step holds. [t]wi ki [t] βr [t]kr [t]kr [t] Diag(γr [t]) + βr [t]kr [t]kr [t] Diag (cid:16) γir [t] (cid:17) [t]wi ki [t] r1 (cid:88) i= ki [t]wi [t] kr [t] (cid:16) [t]Diag(γr βr [t])kr [t] (cid:17) (cid:32) + kr [t] βr [t] r1 (cid:88) i=1 (cid:16) wi [t] ki [t] Diag (cid:16) γir [t] (cid:17) kr [t] (cid:33) (cid:17) (cid:32) (cid:32) Diag(γr [t])kr [t] [t]wi ki [t] kr [t] βr [t] (cid:124) [t]wi ki [t] kr [t]wr [t] [t]wi ki [t] r1 (cid:88) i=1 (cid:16) wi [t] ki [t] Diag (cid:16) γir [t] (cid:17) (cid:17) kr [t] (cid:33)(cid:33) (cid:123)(cid:122) wr [t] (cid:125) Similar to Pr [t], Hr [t] can also be expressed in parallelizable form. 25 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Proposition 2. The matrix Hr [t] can be expressed as: Hr [t] = (cid:88) i="
        },
        {
            "title": "Diag",
            "content": "(cid:16) γir [t] (cid:17) [t]ui ki [t] where the auxiliary vector ur [t] Rdv is computed via the following recurrence relation: (cid:32) [t] = βr ur [t] vr [t] r1 (cid:88) i=1 (cid:16) ui [t] ki [t] Diag (cid:16) γir [t] (cid:17) kr [t] (cid:33) (cid:17) Proof. We again use mathematical induction. Inductive Step: Assume the proposition holds for 1. (18) (19) Hr [t] = = (cid:16) βr [t]kr [t]kr [t] (cid:16) βr [t]kr [t]kr [t] (cid:17) (cid:17) [t])Hr1 (cid:32)r1 (cid:88) Diag(αr [t]) Diag(αr [t] + βr [t]kr [t]vr [t]"
        },
        {
            "title": "Diag",
            "content": "(cid:16) γir1 [t] (cid:17) [t]ui ki [t] (cid:33) + βr [t]kr [t]vr [t] (cid:16) = βr [t]kr [t]kr [t] i=1 Diag (cid:16) γir [t] (cid:17) [t]ui ki [t] (cid:33) (cid:32)r1 (cid:88) (cid:17) i=1 + βr [t]kr [t]vr [t] Diag Diag (cid:16) (cid:16) γir [t] γir [t] (cid:17) (cid:17) [t]ui ki [t] βr [t]kr [t]kr [t] Diag (cid:16) γir [t] (cid:17) r1 (cid:88) i=1 [t]ui ki [t] + βr [t]kr [t]vr [t] (cid:32) [t]ui ki [t] kr [t] βr [t] r1 (cid:88) (cid:16) i=1 kr [t] Diag (cid:16) γir [t] (cid:17) (cid:17) ki [t] ui [t] (cid:33) + kr [t]βr [t]vr [t] Diag (cid:16) γir [t] (cid:17) ki [t]ui [t] + kr [t] βr [t] (cid:124) (cid:32) vr [t] r1 (cid:88) i=1 (cid:16) ui [t] ki [t] Diag (cid:16) γir [t] (cid:17) (cid:17) kr [t] (cid:123)(cid:122) ur [t] (cid:33) (cid:125) Diag Diag (cid:16) (cid:16) γir [t] γir [t] (cid:17) (cid:17) [t]ui ki [t] + kr [t]ur [t] ki [t]ui [t] = = r1 (cid:88) i= r1 (cid:88) i=1 = r1 (cid:88) i=1 = = r1 (cid:88) i=1 (cid:88) i=1 The inductive step holds. 26 Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT"
        },
        {
            "title": "C Pseudo Code for chunkwise KDA",
            "content": "1 def chunk_kda( 2 3 4 5 6 7 8 9 ): 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 q: torch.Tensor, k: torch.Tensor, v: torch.Tensor, g: torch.Tensor, beta: torch.Tensor, initial_state: Optional[torch.Tensor] = None, chunk_size: int = 64 dtype = v.dtype B, T, H, K, V, = *q.shape, v.shape[-1], chunk_size = // q, k, v, g, beta = map( lambda x: rearrange(x, 'b (n c) ... -> c ...', c=C).to(torch.float), [q, k, v, g, beta] ) = * K**-0.5 = g.cumsum(-2) mask = torch.triu(torch.ones(C, C, dtype=torch.bool, device=q.device), diagonal=0) = torch.zeros(B, H, N, C, C, dtype=torch.float, device=q.device) for in range(C): k_i = k[..., i, :] g_i = g[..., i:i+1, :] A[..., i] = torch.einsum('... d, ... -> ... c', * (g - g_i).exp(), k_i) = * beta[..., None] # matrix inverse by forward substitution = -A.masked_fill(mask, 0) for in range(1, C): A[..., i, :i] = A[..., i, :i].clone() + (A[..., i, :, None].clone() * A[..., :, 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 (cid:44) :i].clone()).sum(-2) = (A + torch.eye(C, dtype=torch.float, device=q.device)) * beta[..., None, :] = @ (g.exp() * k) = @ = k.new_zeros(B, H, K, V) if initial_state is not None: += initial_state = torch.zeros_like(v) # strictly lower triangular mask = torch.triu(torch.ones(C, C, dtype=torch.bool, device=q.device), diagonal=1) for in range(0, N): # [B, H, C, ...] q_i, k_i, u_i, g_i, w_i = q[:, :, i], k[:, :, i], u[:, :, i], g[:, :, i], w[:, :, i] = torch.zeros(B, H, C, C, dtype=torch.float, device=q.device) # secondary chunking for numerical stability for in range(C): k_j = k[:, :, i, j] g_j = g[:, :, i, j:j+1, :] A[..., j] = torch.einsum('... d, ... -> ... c', q_i * (g_i - g_j).exp(), k_j) = A.masked_fill(mask, 0) v_i = u_i - w_i @ o[:, :, i] = (q_i * g_i.exp()) @ + @ v_i = * rearrange(g_i[:, :, -1].exp(), 'b -> 1') += rearrange((g_i[:, :, -1:] - g_i).exp() * k_i, 'b -> c') @ v_i return rearrange(o, 'b d -> (n c) d').to(dtype) Listing 1: Pseudo PyTorch-style code snippet for KDA chunked form. Kimi Linear: An Expressive, Efficient Attention Architecture TECHNICAL REPORT Kimi Linear@5.7T results Following Moonlight, we also trained Kimi Linear with an extended 5.7T token dataset to demonstrate its effectiveness. With 3 sparsity and new attention architecture design, Kimi Linear consistently outperforms Moonlight across nearly all benchmarks, underscoring the efficacy of the new architecture. The results are shown in Table 8 for base model and Table 9 for instruction tuned model. Moonlight-Instruct was not evaluated (-) on tasks exceeding its 8K context limit. Kimi Linear@5.7T obtains score of 94.8 on RULER at 1M context length. This long context performance reinforces that Kimi Linear is promising alternative to full-attention architectures, delivering comparable or superior results while potentially offering more efficient resource utilization. Table 8: Performance of Kimi-Linear-Base and Moonlight-Base across diverse tasks. Benchmark #Shots Kimi-Linear-Base Moonlight-Base Architecture # Activated Params # Total Params Trained Tokens TriviaQA SimpleQA MMLU-Pro MMLU-redux WinoGrande GPQA-Diamond (avg@8) General Math Code MATH GSM8k GSM8k-platinum CMATH CRUXEval-I-cot CRUXEval-O-cot LiveCodeBench (v6) EvalPlus Chinese C-Eval CSimpleQA - - - - 5-shots 5-shots 5-shots 5-shots 5-shots 5-shots 4-shots 8-shots 8-shots 6-shots 0-shots 0-shots 1-shots - 5-shots 5-shots MoE 3B 48B 5.7T 75.2 10.1 54.8 79.7 81.5 40. 58.5 86.3 89.6 85.5 61.0 67.0 20.0 64.9 83.3 53.5 MoE 3B 16B 5.7T 66.2 05.6 42.4 73.8 74.6 35.2 45.3 77.2 79.4 79. 45.9 46.6 14.3 50.3 77.6 34.7 Table 9: Performance of Kimi-Linear-Instruct and Moonlight-Instruct across diverse tasks. Benchmark Kimi-Linear-Instruct Moonlight-Instruct Architecture # Activated Params # Total Params Trained Tokens RULER@128k RULER@1M GPQA-Diamond (Avg@8) MMLU-Redux (EM) MMLU-Pro (EM) FaithJudge (1-Hallu.) AIME 2025 (Avg@64) MATH500 (Acc.) HMMT 2025 (Avg@32) LiveCodeBench v6 (Pass@1) OJBench (Pass@1) Humaneval+ MBPP+ General Math Code MoE 3B 48B 5.7T 95.4 94.8 71.7 86.9 72.7 64.2 58.6 94.6 44.5 45.7 14.2 70.9 72.4 28 MoE 3B 16B 5.7T - - 24.7 66.9 43.8 56.0 - 58.0 - 11.9 - 46.3 56."
        }
    ],
    "affiliations": [
        "MoonshotAI"
    ]
}