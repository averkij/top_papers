{
    "paper_title": "Value-Based Deep RL Scales Predictably",
    "authors": [
        "Oleh Rybkin",
        "Michal Nauman",
        "Preston Fu",
        "Charlie Snell",
        "Pieter Abbeel",
        "Sergey Levine",
        "Aviral Kumar"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Scaling data and compute is critical to the success of machine learning. However, scaling demands predictability: we want methods to not only perform well with more compute or data, but also have their performance be predictable from small-scale runs, without running the large-scale experiment. In this paper, we show that value-based off-policy RL methods are predictable despite community lore regarding their pathological behavior. First, we show that data and compute requirements to attain a given performance level lie on a Pareto frontier, controlled by the updates-to-data (UTD) ratio. By estimating this frontier, we can predict this data requirement when given more compute, and this compute requirement when given more data. Second, we determine the optimal allocation of a total resource budget across data and compute for a given performance and use it to determine hyperparameters that maximize performance for a given budget. Third, this scaling behavior is enabled by first estimating predictable relationships between hyperparameters, which is used to manage effects of overfitting and plasticity loss unique to RL. We validate our approach using three algorithms: SAC, BRO, and PQL on DeepMind Control, OpenAI gym, and IsaacGym, when extrapolating to higher levels of data, compute, budget, or performance."
        },
        {
            "title": "Start",
            "content": "Value-Based Deep RL Scales Predictably Oleh Rybkin1, Michal Nauman1,2, Preston Fu1, Charlie Snell1, Pieter Abbeel1, Sergey Levine1 and Aviral Kumar3 1University of California, Berkeley, 2University of Warsaw, 3Carnegie Mellon University 5 2 0 2 6 ] . [ 1 7 2 3 4 0 . 2 0 5 2 : r Figure 1: Scaling properties when increasing compute ğ’, data ğ’Ÿ, budget â„±, or performance ğ½. Left: Compute versus data requirements Pareto frontier controlled by the UTD ratio ğœ. We observe that we can trade off data for compute and vice versa, and this relationship is predictable. Middle: Extrapolation from low to high performance. We observe that the optimal resource allocation controlled by ğœ evolves predictably with increasing budget, and can be used to extrapolate from low to high performance. Right: Pareto frontiers for several performance levels ğ½. Abstract: Scaling data and compute is critical to the success of modern ML. However, scaling demands predictability: we want methods to not only perform well with more compute or data, but also have their performance be predictable from small-scale runs, without running the large-scale experiment. In this paper, we show that value-based off-policy RL methods are predictable despite community lore regarding their pathological behavior. First, we show that data and compute requirements to attain given performance level lie on Pareto frontier, controlled by the updates-to-data (UTD) ratio. By estimating this frontier, we can predict this data requirement when given more compute, and this compute requirement when given more data. Second, we determine the optimal allocation of total resource budget across data and compute for given performance and use it to determine hyperparameters that maximize performance for given budget. Third, this scaling is enabled by first estimating predictable relationships between hyperparameters, which is used to manage effects of overfitting and plasticity loss unique to RL. We validate our approach using three algorithms: SAC, BRO, and PQL on DeepMind Control, OpenAI gym, and IsaacGym, when extrapolating to higher levels of data, compute, budget, or performance. Corresponding author(s): oleh.rybkin@gmail.com, aviralku@andrew.cmu.edu Value-Based Deep RL Scales Predictably 1. Introduction Many latest advances in various areas of machine learning have emerged from training big models on large datasets. In this scaling guided research landscape, successfully executing even one single training run often requires large amount of data, computational resources, and wall-clock time, such as weeks or months (Achiam et al., 2023; Team et al., 2023; Ramesh et al., 2022; Brooks et al., 2024). To maximize the success of these large-scale runs, the trend in the machine learning (ML) community has shifted toward not just performant, but also more predictable algorithms that scale reliably with more computation and training data size, such that downstream performance can be predicted from small-scale experiments, without actually running the large-scale experiment. (McCandlish et al., 2018; Kaplan et al., 2020; Hoffmann et al., 2022; Dubey et al., 2024). In this paper, we study if deep reinforcement learning (RL) is also amenable to such scaling and predictability benefits. We focus on value-based methods that train value functions using temporal difference (TD) learning, which are known to be performant at small scales, especially in dense reward environments (Mnih et al., 2015; Lillicrap et al., 2015; Haarnoja et al., 2018a). Compared to policy gradient (Mnih, 2016; Schulman et al., 2017) and search methods (Silver et al., 2016), value-based RL can learn from arbitrary data and require less sampling or search, which can be inefficient or infeasible for open-world problems where environment interaction is costly. We study scaling properties by predicting relationships between different resources required for training. Data requirement ğ’Ÿ is the amount of data needed to attain certain level of performance. Likewise, compute requirement ğ’ refers to the amount of FLOPs or gradient steps needed to attain certain level of performance. In RL uniquely, performance can be improved by increasing either available data or compute (e.g., training multiple times on the same data), which we capture via budget requirement that combines data and compute â„± = ğ’ + ğ›¿ ğ’Ÿ, where ğ›¿ refers to constant multiplier. An additive budget function is representative of practical scenarios where the cost of data and compute can be expressed in similar units, such as wall-clock time or required finances. To establish scaling relationships, we first require way to predict the best hyperparameter settings at each scale. We find that learning rate ğœ‚, batch size ğµ, and the updates-to-data (UTD) ratio ğœ are the most crucial hyperparameters for value-based RL. While supervised learning benefits from abundant theory to establish optimal hyperparameters (Krizhevsky, 2014; McCandlish et al., 2018; Yang et al., 2022), value-based RL often does not satisfy assumptions typical of supervised learning. For example, value-based RL needs to account for the non-i.i.d. nature of training data. Distribution shift due to periodic changes in the data collection policy (Levine et al., 2020) contributes to form of overfitting where minimizing training TD error may not result in low TD error under the data distribution induced by the new policy. In addition, objective shift due to changing target values (Dabney et al., 2020) contributes to plasticity loss (DOro et al., 2022; Kumar et al., 2021a). We show that it is possible to account for the training dynamics unique to value-based RL, and are able to find the best hyperparameters by setting the batch size and learning rate inversely proportional to the UTD ratio. We estimate this dependency using power law (Kaplan et al., 2020), and observe that this model makes effective predictions. Using the best predicted hyperparameters, we are now able to establish that data and compute requirements evolve as predictable function of the UTD ratio ğœ. Furthermore, ğœ defines the tradeoff between data and compute, which can be visualized as Pareto frontier (Figure 1, left). Using this model, we are able to extrapolate the resource requirements from low-compute to high-compute setting, as well as from low-data to high-data setting as shown in the figure. Value-Based Deep RL Scales Predictably Using the Pareto frontiers, we are now able to extrapolate from low to high performance levels. Instead of extrapolating as function of return, which can be arbitrary and non-smooth, we extrapolate as function of the allowed budget â„±. We can define an optimal tradeoff between data and compute, and we observe that such optimal tradeoff value evolves predictably to higher budgets, which also attains higher performance level (Figure 1, middle). Thus we are able to predict optimal hyperparameters, as well as data and compute allocation, for high-budget runs using only data from low-budget runs. Our contribution is showing that the behavior of value-based deep RL methods based on TD-learning is predictable in larger data and compute regimes. Specifically, we: 1. establish predictable rules for dependencies between hyperparameters batch size (ğµ), learning rate (ğœ‚), and UTD ratio (ğœ) in value-based RL, and show that these rules enable more effective scaling. 2. show that data and compute required to attain given performance level lie on Pareto frontier, and are respectively predictable in the higher-compute or higher-data regimes. 3. show the optimal allocation of budget between data and compute, and predict how such allocation evolves with higher budgets for best performance. Our findings apply to algorithms such as SAC, BRO, and PQL, and domains such as the DeepMind Control Suite (DMC), OpenAI Gym, and IsaacGym. The generality of our conclusions challenges conventional wisdom and community lore that value-based deep RL does not scale predictably. 2. RL Preliminaries and Notation We study standard off-policy online RL, which maximizes the agents return by training on replay buffer and periodically collecting new data (Sutton and Barto, 2018). Value-based deep RL methods train Q-network, ğ‘„ğœƒ, to minimize the temporal difference (TD) error: ğ¿(ğœƒ) = E(ğ‘ ,ğ‘,ğ‘ )ğ’«,ğ‘ğœ‹(ğ‘ ) [(ğ‘Ÿ(ğ‘ , ğ‘) + ğ›¾ ğ‘„(ğ‘ , ğ‘) ğ‘„ğœƒ(ğ‘ , ğ‘))2] , (2.1) where ğ’« is the replay buffer, ğ‘„ is the target Q-network, ğ‘  denotes state, and ğ‘ is an action drawn from policy ğœ‹(ğ‘ ) that aims to maximize ğ‘„ğœƒ(ğ‘ , ğ‘). We implement this operation by sampling batch of size ğµ from the buffer and taking gradient step along the gradient of this loss with learning rate ğœ‚. In theory, off-policy algorithms can be made very sample efficient by minimizing the TD error fully over any data batch, which in practice translates to making more update steps to the Q-network per environment step, or higher updates-to-data ratio (UTD) (Chen et al., 2020). However, increasing the UTD ratio naÃ¯vely can lead to worse performance (Nikishin et al., 2022; Janner et al., 2019). To this end, unlike the standard supervised learning or LLM literature that considers ğµ and ğœ‚ as two main hyperparameters affecting training (Kaplan et al., 2020; Hoffmann et al., 2022), our setting presents another hyperparameter, the UTD ratio ğœ, that we also study in our paper. Notation. In this paper, we focus on the following key hyperparameters: the UTD ratio ğœ, learning rate ğœ‚, and the batch size ğµ. We will answer questions pertaining to performance of policy ğœ‹ denoted by ğ½(ğœ‹), the total data utilized by an algorithm to reach given target level of performance ğ½ (denoted by ğ’Ÿğ½ ), and the total compute budget utilized by the algorithm to reach performance ğ½ (denoted by ğ’ğ½ ), which is measured in terms of FLOPs or wall-clock time taken by the algorithm. 3 Value-Based Deep RL Scales Predictably 3. Problem Statement and Formulation To demonstrate that the behavior of value-based RL can be predicted reliably at scale, we first post multiple resource optimization questions that guide our scaling study. Viewing data and compute as two resources, we answer questions of the form: what is the minimum value of [resource] needed to attain given target performance? And what should the hyperparameters (e.g., ğµ, ğœ‚, ğœ) be in such this training run? We will answer questions of this form by fitting empirical laws from low data and compute runs to determine relationships between hyperparameters. Doing so, in turn, enables us to determine how to set hyperparameters and allocate resources to maximize performance when provided with larger data and compute budget. Note that we wish to make these hyperparameter predictions without running the large data and compute budget experiment. While questions of this form have been studied in supervised learning, answering them is different in the context of online RL, because online RL requires the algorithm to collect its own data during training, which ties data and compute in complex manner and breaks i.i.d. nature of datapoints and induces complexities. Concretely, we study three resource optimization questions: (1) maximizing sample efficiency (i.e., minimize the amount of data ğ’Ÿ to attain given target performance under given compute budget), (2) conversely, minimizing compute ğ’ (e.g., FLOPs or gradient steps, whichever is more appropriate for the practitioner) to attain given performance given an upper bound on data that can be collected, and (3) maximizing performance given total bound on data and compute. Problem 3.1 (Resource optimization problems). Find the best configuration (ğµ, ğœ‚, ğœ) for algorithm Alg that minimizes either the data ğ’Ÿ or compute ğ’ consumed to obtain performance ğ½0: 1. Maximal sample efficiency: (ğµ*, ğœ‚*, ğœ*) := arg min (ğµ,ğœ‚,ğœ) ğ’Ÿ s.t. ğ½ (ğœ‹Alg(ğµ, ğœ‚, ğœ)) ğ½0, ğ’ ğ’0 2. Maximal compute efficiency: (ğµ*, ğœ‚*, ğœ*) := arg min (ğµ,ğœ‚,ğœ) ğ’ s.t. ğ½ (ğœ‹Alg(ğµ, ğœ‚, ğœ)) ğ½0, ğ’Ÿ ğ’Ÿ0 We solve these problems by fitting empirical models of the minimum data and compute needed to attain target performance for different values of ğ½0. Doing so allows us to then solve the third setting (3) for maximizing performance given total budget on data and compute as shown below. Problem 3.2 (Maximize performance at large data and compute budget). Find the best configuration (ğµ, ğœ‚, ğœ) and resource allocations for data ğ’Ÿ and compute ğ’ that enable Alg to maximize performance at budget â„± (ğµ*, ğœ‚*, ğœ*) := arg max (ğµ,ğœ‚,ğœ) ğ½ (ğœ‹Alg(ğµ, ğœ‚, ğœ)) s.t. ğ’ + ğ›¿ ğ’Ÿ â„±0. 4. Scaling Results For Value-Based Deep RL We will now present our main results addressing Problem 3.1 under the two settings discussed above. We will then use these results to present results for Problem 3.2. In order to do so, we run several experiments and estimate scaling trends from the results. Although this procedure might appear standard from scaling studies in language modeling, we found that instantiating it for value-based RL requires 4 Value-Based Deep RL Scales Predictably understanding the interaction of the various hyperparameters appearing in TD updates, and the data and compute efficiency of the algorithm. We will formalize these relationships via empirically estimated laws and show that these laws extrapolate reliably to new settings not used to obtain these empirical laws. Therefore, in this section, we present empirical and conceptual arguments to build functional forms of relationships between different hyperparameters. Before doing so, we provide our answers to Problems 3.1 and 3.2. 4.1. Main Scaling Results We begin by answering Problem 3.1 where we need to maximize sample efficiency. We wish to estimate the minimal amount of data ğ’Ÿğ½ needed to attain given target performance, given an upper bound on compute ğ’ ğ’0. To do so, we fit ğ’Ÿğ½ needed to attain the target performance ğ½ = ğ½0 parameterized by the UTD ratio ğœ (Eq. (4.1)). Intuitively, we would expect the minimum amount of data needed to attain given performance to be low as more updates are made per datapoint (i.e., when ğœ is high), as more value could be derived from the same datapoint. In addition, we would expect that even for the best value of ğœ, there is minimum number of datapoints ğ’Ÿmin that are needed to learn given the intrinsic difficulty of the task at hand. Based on these intuitions, we hypothesize power law relationship between ğ’Ÿğ½ (ğœ) and ğœ, with an offset ğ’Ÿmin and constants ğ›¼ğ½ and ğ›½ğ½ . Figure 2: The data-compute tradeoff on DMC. Left: The minimum required data ğ’Ÿğ½ scales with the UTD ğœ as power law. Right: The minimum required compute ğ’ğ½ increases with the UTD ğœ as sum of two power laws. ğ’Ÿğ½ (ğœ) ğ’Ÿmin ğ½ + )ğ›¼ğ½ ( ğ›½ğ½ ğœ (4.1) Empirical fits of ğ’Ÿğ½ and ğœ on the DMC suite are in Figure 2 and they validate the efficacy of this fit. Scaling Observation 1: Data Requirements The amount of data ğ’Ÿğ½ needed to reach given return target ğ½0 decreases as predictable function of the UTD ğœ, and is power law (Eq. (4.1)). We also emphasize that the existence of this power law makes ğ’Ÿğ½ predictable, in that this relation is able to predict ğ’Ÿğ½ for larger values of ğœ that fall outside the range of ğœ values used to get the fit (Figure 6). To answer the optimization questions in Problem 3.1, we also need an expression for required compute until the target return ğ’ğ½ . As ğœ determines the number of gradient steps run per data point, ğ’ğ½ is function of ğœ. In particular, total compute is equal to the number of gradient steps taken multiplied by the parameter count of the model. Our study does not optimize over the model size and treats it as constant. Thus, we can write the compute ğ’ğ½ as function of ğœ as: ğ’ğ½ (ğœ) 10 ğ‘ ğµ(ğœ) ğœ ğ’Ÿğ½ (ğœ) where ğ‘ denotes the model size, ğµ(ğœ) denotes the best choice batch size for given UTD value ğœ, and other variables follow definitions from before. Note the additional factor of 10 in Eq. (4.2) emerges from (4.2) 5 Value-Based Deep RL Scales Predictably the use of multiple forward passes to compute the loss function for value-based RL and the backward pass, through the Q-network (to contrast with language modeling, the typical multiplier is 6; the gap in our setting comes from the use of multiple forward passes). We plot ğ’ğ½ (ğœ) for different values of ğœ and ğ½ = ğ½0 in Figure 2. Since ğ’Ÿğ½ (ğœ) is not constant and depends itself on ğœ, we note that this particular relationship between ğ’ğ½ (ğœ) and ğœ is not simple power law unlike Eq. (4.1). Instead, our derivation in Eq. (A.4) shows that ğ’ğ½ (ğœ) is given by sum of two different power laws in ğœ. Similarly to ğ’Ÿğ½ , we also observe that the compute utilized is predictable function of ğœ: we are able to accurately estimate the compute at larger values of ğœ using the relationship in Eq. (4.2). Scaling Observation 2: Compute Requirements The compute ğ’ğ½ to attain given return target ğ½0 increases as predictable function of the UTD ratio ğœ, and is sum of two power laws (Eq. (4.2)). We observe that both required compute and data are controlled by the UTD ratio ğœ, which allows us to define tradeoff between compute and data controlled by ğœ. We plot this tradeoff as curve with compute ğ’ğ½ (ğœ) as ğ‘¥-axis and ğ’Ÿğ½ (ğœ) as ğ‘¦-axis in Figure 1 (left). Further, as ğ’Ÿğ½ (ğœ) is monotonically decreasing function of ğœ, this curve defines Pareto frontier: we can move left on the curve to increase data efficiency as the expense of compute and move right to increase compute efficiency at the expense of data. Also interestingly, due to the compute law being sum of two power laws, in many environments there is minimum ğœ after which compute efficiency no longer improves as seen on OAI Gym in Figure 1. Solving for maximal data efficiency (Problem 3.1, (1)). We can now solve Problem 3.1 in setting (1). our strategy to address setting (1) is to find the largest ğœ (say ğœmax) that satisfies the compute constraint ğ’ğ½ (ğœ) ğ’0, and then plug this ğœmax into ğ’Ÿğ½ (ğœ) to obtain the data estimate. This approach enables us to express ğ’Ÿğ½ directly as function of the available compute ğ’0, as we calculate in Eq. (4.2). This can be visualized as finding the value ğ’Ÿğ½ corresponding to some value ğ’0 on the Pareto frontier (Figure 1, left) Solving for maximal compute efficiency (Problem 3.1, (2)). Likewise, the solution in (2) can be obtained by finding the smallest value of ğœ in the range that satisfies the data constraint ğ’Ÿğ½ (ğœ) ğ’Ÿ0, and computing the corresponding value of ğ’ğ½ (ğœ). This can similarly be visualized on the Pareto frontier (Figure 1, left). We summarize our observations in terms of the following takeaway. Solving Problem 3.1: Defining the Compute-Data Pareto frontier The UTD ratio ğœ defines Pareto frontier between data and compute requirements, and estimating this frontier yields predictable solutions to resource optimization problems in settings (1) and (2). Theoretically, the optimal ğ’Ÿ* ğ½ for an available compute budget ğ’0 is: ğ½ (ğ’0) ğ’0 (10 ğ‘ ğµ(ğœ*) ğœ*)1 . (4.3) ğ’Ÿ* The optimal ğ’ğ½ for given data budget ğ’Ÿ0 is: Above, ğœ* denotes the minimizing UTD value. Calculation details are in Appendix A. ğ½ (ğ’Ÿ0) 10 ğ‘ ğµ(ğœ*) ğœ* ğ’Ÿ0. ğ’* (4.4) Maximize return within budget (Problem 3.2). Finally, we tackle Problem 3.2 in order to extrapolate from low to high return. Here, we do not want to minimize resources, but rather want to maximize performance within given total budget on data and compute. As discussed in Section 3, we consider budget functions linear in both data and compute, i.e., â„± = ğ’ +ğ›¿ ğ’Ÿ, for given constant ğ›¿. Our estimated 6 Value-Based Deep RL Scales Predictably Pareto frontier in Eq. (4.4) will enable answering this question. To do so, we turn to directly predicting good UTD value ğœ*. This UTD value is one that not only leads to maximal performance, but also stays within the total resource budget â„±0. Once the UTD value has been identified, it prescribes concrete way to partition the total resource budget into good data and compute requirements using the solutions to Problem 3.1. We plot the data-compute Pareto frontiers for multiple values of ğ½0 in Figure 3 and in Figure 1 (right), and find that these curves move diagonally to the top-right for larger ğ½0. Intersecting these curves with iso-budget frontiers over ğ’Ÿ and ğ’ prescribed by the budget function, gives us the largest possible ğ½0 for which there is still (ğ’Ÿ, ğ’) pair that just falls just within the budget â„±0 but attains performance ğ½0 (see Figure 3 for worked out version of this procedure). Since both ğ’Ÿ and ğ’ are explained by ğœ, we can associate this point with given ğœ value. Hence, we can estimate the best value of ğœ*(â„±0) for given budget threshold â„±0. Concretely, we observe power law between ğœ(â„±0) and â„±0, with constants ğ›½ğœ and ğ›¼ğœ. Figure 3: Visualization of the solution to Problem 3.2. Several Pareto frontiers (Figure 1, left) are shown, together with lines of iso-budget â„±, which define optimal budget points (ğ’Ÿ*, ğ’*). Corresponding optimal UTD ratios ğœ* are predictable function of the budgets â„±0, trend line shown dashed. ğœ*(â„±0) )ğ›¼ğœ ( ğ›½ğœ â„±0 . (4.5) Solving Problem 3.2: Maximize return given total data and compute budget The best UTD value ğœ that leads to maximal ğ½ is predictable function of the budget â„±0 over data and compute, this relationship follows power law, and also extrapolates to large budgets. This relationship produces the optimal ğœ, and as result, the optimal data and compute allocations to reliably attain maximum performance. As shown in Figure 1, estimating this law from low-budget experiments is sufficient for predicting good ğœ values for large budget runs. These predicted ğœ*(â„±0) values extrapolate reliably to budgets outside the range used to fit this law (as shown by in Figure 1). This concludes an exposition of our main results. 4.2. Fitting Relationships Between (ğµ, ğœ‚, ğœ) To arrive at these scaling law fits above, we had to set hyperparameters ğµ and ğœ‚, which we empirically observed to be important. We fit these hyperparameters as function of ğœ, the only variable appearing in many of the scaling relationships discussed above. In this section, we will now describe how to estimate good values of ğµ and ğœ‚ in terms of ğœ. Our analysis here relies crucially on the behavior of TD-learning that is distinct from supervised learning, where the UTD ratio ğœ does not exist. To understand relationships between batch size ğµ, learning rate ğœ‚, and the UTD ratio ğœ, we ran an extensive grid search. We first attempted to explain the relationship between the ğµ and ğœ‚ values that attain the highest data efficiency (denoted ğµ*, ğœ‚*) using the standard heuristic in supervised learning: when the batch size is smaller than the critical batch size, ğµ and ğœ‚ are inversely correlated with each other (McCandlish et al., 2018). However, as shown in Figure 5 (right), we find that without including the 7 Value-Based Deep RL Scales Predictably Figure 4: Hyperparameter effects in supervised learning and TD learning on DMC. Top: Overfitting increases with UTD while batch size can be used to counteract it. Bottom: Higher UTD leads to poor training dynamics and plasticity loss (DOro et al., 2022). Lower learning rates can be used to counteract it. While these relationships are not perfectly predictable, we use them to inform our design choices. UTD ratio ğœ, best ğµ* and ğœ‚* exhibit very weak correlation. Further, the critical batch size (McCandlish et al., 2018) does not correlate with empirically best batch size as we show in Appendix E. Instead, surprisingly, we observe strong correlation between ğµ* and ğœ, as well as ğœ‚* and ğœ, respectively. Since ğµ* and ğœ‚* exhibit near zero correlation among themselves, we can simply omit their dependency and opt for modeling them independently as function of the UTD ratio, ğœ. We conceptually explain relationships between ğµ* and ğœ, and ğœ‚* and ğœ below and show that models developed from this understanding enable us to reliably predict good values of ğµ and ğœ‚, allowing us to fully answer Problem 3.1. Predicting best choice of ğµ in terms of ğœ. Our proposed functional form for the best batch size ğµ* takes the form of power law in ğœ, which we also empirically validate in Figure 5 (left). We posit this form because, intuitively, large batch sizes increase the risk of overfitting because they lead to repetitive training on fixed set of data. Furthermore, small training loss on the distribution of data in the buffer does not necessarily reflect the behavior policy distribution of learning agent (Levine et al., 2020). This means that minimizing the training loss to large extent can result in poor test performance ğ½(ğœ‹), as also seen by prior work (Li et al., 2023a; Nauman et al., 2024a). One way to counteract this form of overfitting from high UTD value ğœ is to instead reduce the batch size in the run so that the training process sees given sample fewer times. In fact, for fixed UTD value ğœ, we empirically validate this hypothesis that lower ğµ leads to substantially reduced overfitting on several tasks in Figure 4. Hence, we post an inverse relationship between the best batch size ğµ* and the UTD value ğœ. We show in Figure 5 that indeed this inverse relationship can be estimated well by power law, given formally as: ğµ*(ğœ) ( ğ›½ğµ ğœ )ğ›¼ğµ . (4.6) Predicting best choice of learning rate ğœ‚ as function of ğœ. Next we turn to understanding the Value-Based Deep RL Scales Predictably Figure 5: Left, middle: Fitting the best learning rate ğœ‚* and batch size ğµ* given UTD ğœ on DMC. Modeling the dependency on ğœ is crucial to obtain good hyperparameters, whereas using constant ğµ, ğœ‚ as is commonly done leads too poor extrapolation. Right: the best learning rate and batch size are not significantly correlated, major difference from supervised learning. relationship between ğœ‚ and ğœ. We start from simple observation: very large ğœ typically leads to worse performance not only due to overfitting but also due to plasticity loss (Kumar et al., 2021a; DOro et al., 2022; Lyle et al., 2023), defined broadly as the inability of the value network to fit TD targets appearing later in training. Prior work states that plasticity loss is inherently related to the number of gradient steps performed and claims that larger norms of parameters of the Q-network are indicative of plasticity loss (DOro et al., 2022; Lyle et al., 2023). We would expect larger learning rate to make higher magnitude updates against the same TD target, and hence move parameters to state that suffers from difficulty in fitting subsequent targets (Dabney et al., 2021; Lee et al., 2024). As shown in Figure 4, the parameter norm indeed increases with high learning rate. Therefore, given UTD value ğœ, we hypothesize that the best choice of learning rate, ğœ‚*(ğœ) for given performance should scale inversely in ğœ. Empirically we observe that this is indeed the case (Figure 5 (middle)), and we model this relationship: ğœ‚*(ğœ) )ğ›¼ğœ‚ . ( ğ›½ğœ‚ ğœ (4.7) Scaling Observation 3: Hyperparameter Selection The best choices for the batch size and learning rate are predictable functions of the UTD ğœ, and both of these relationships follow power law. 4.3. Empirical Workflow for Obtaining Fits"
        },
        {
            "title": "Our Workflow for Fitting Empirical Relationships",
            "content": "1. Run sweep for batch size ğµ and learning rate ğœ‚ for several values of UTD ğœ. Since the batch size and learning rate are independent for the best ğœ, we can run these sweeps independently. 2. Estimate empirically the best of batch size ğµ and learning rate ğœ‚, with statistical bootstrapping. 3. Fit ğµ*(ğœ) and ğœ‚*(ğœ) on ğµ, ğœ‚ according to Equations (4.6) and (4.7). 4. Using the found fits ğµ*(ğœ), ğœ‚*(ğœ), run different values of ğœ that cover range spanning an order of magnitude; we use 16, i.e., ğœmax/ğœmin > 16. 5. Fit ğ’Ÿğ½ (ğœ) according to Eq. (4.1). 6. Using fits of ğ’Ÿğ½ (ğœ) for different values of ğ½0, fit ğœ*(â„±0) according to Eq. (4.5). 7. Optimal hyperparameters can now be extrapolated to larger data, larger compute, or larger budget settings according to Problem 3.1. 9 Value-Based Deep RL Scales Predictably Figure 6: Extrapolation towards unseen values of ğœ on OpenAI Gym. Left: We show Pareto frontier extrapolation towards higher data regime. Middle: We show Pareto frontier extrapolation towards higher compute regime. Right: We compare the best-performing hyperparameters (red) for ğœ = 2 to hyperparameters predicted via our proposed workflow (blue). Having presented solutions to Problems 3.1 and 3.2, we now present the workflow we utilize to estimate these empirical fits. Further details are in Section 5 and Appendix D. This workflow can serve as useful skeletion for scaling law studies with other value-based algorithms as well. 4.4. Evaluating Extrapolation Evaluating budget extrapolation. Results on all environments are shown in Figure 1 (middle). We estimate several Pareto frontiers corresponding to points with equal changes in budget. We perform the ğœ*(â„±0) fit, while holding out two largest budgets. The quality of our fit for these two extrapolated budgets can be seen in the figure. Evaluating Pareto frontier extrapolation. Results on OpenAI Gym are shown in Figure 6. We fit the data efficiency equation ğ’Ÿğ½ (ğœ) Eq. (4.1) while holding out either two UTD values ğœ with largest data requirement (left) or two ğœ values with largest compute requirement (right). The quality of our fit for these two extrapolated ğœ values can be seen in the figure. Hyperparameter fit extrapolation. Results on OpenAI Gym are shown in Figure 6 (right). We plot the data efficiency fit when using hyperparameters according to our found dependency ğµ*(ğœ), ğœ‚*(ğœ) (shown in olive). These fits are estimated from ğœ = 1, , 8 and extrapolated to ğœ = 0.5. We compare the typical approach of tuning hyperparameters in online RL, where hyperparameters are tuned for one setting of ğœ = 2 and this setting is used for all UTD values (shown in blue). We see that our proposed hyperparameter fits improve results for values other than ğœ = 2. Further, this improvement is larger for larger values of ğœ, showing that accounting for hyperparameter dependency is critical. 5. Experimental Details Experimental Setup We focus on 12 tasks from 3 domains in our study. On OpenAI Gym (Brockman et al., 2016), we use Soft Actor Critic, commonly used TD-learning algorithm (Haarnoja et al., 2018b). We first run sweep on 5 values of ğœ‚, then grid of runs with 4 values of ğœ and 3 values of ğµ, and then use hyperparameter fits to run 2 more value of ğœ with 8 seeds per task. To test our approach with larger models, we use DMC (Tassa et al., 2018), where, we utilize the state-of-the-art Bigger, Regularized, Optimistic (BRO) algorithm (Nauman et al., 2024b) that uses larger and more modern architecture. We first run 5 values of ğµ, 4 values of ğœ‚, and 4 ğœ; and then use hyperparameters fits to run 2 more values of ğœ, with 10 seeds per task. Finally, we test our approach with more data on IsaacGym (Makoviychuk et al., 2021), where we use the Parallel Q-Learning (PQL) algorithm (Li et al., 2023b), which was designed to 10 Value-Based Deep RL Scales Predictably leverage massively parallel simulation like Isaac Gym that can quickly produce billions of environment samples. Because of computational expense, we only run one IsaacGym task. We first run 4 values of ğœ, 3 values of ğœ‚, as well as 5 values of ğµ, with 5 seeds per task, after which we run second round of grid search with 7 values of ğœ. Further details are in Appendices and and Table 3. Fitting Functional Forms for Scaling Laws We approximate Eq. (4.1) via brute-force search followed by LBFG-S with log-MSE loss following (Hoffmann et al., 2022). For Equations (4.6) and (4.7), we fit line in log space using least squares regression following Kaplan et al. (2020). In our experiments, we run single fit that is shared across different tasks in given benchmark. Specifically, we share the ğµ , ğœenv slope ğ›¼ğµ, ğ›¼ğœ‚ and use task-specific intercepts ğœenv (as defined in Equations (4.6) and (4.7)) to be ğœ‚ different for separate tasks. This technique is standard in ordinary least squares modeling and is referred to as fixed effect regression (Bishop and Nasrabadi, 2006). Sharing this slope serves the goal of variance reduction, which can be important if the granularity of the grid search over various hyperparameters run is coarse. More details are in Appendices and D. 6. Related Work Scaling laws and predictability. Prior work has studied scaling laws in the context of supervised learning (Kaplan et al., 2020; Hoffmann et al., 2022), primarily to predict the effect of model size and training data on validation loss, while marginalizing out hyperparameters like batch size (McCandlish et al., 2018) and learning rate (Kaplan et al., 2020). There are several extensions of such scaling laws for language models, such as laws for settings with data repetition (Muennighoff et al., 2023) or mixture-ofexperts (Ludziejewski et al., 2024), but most focus on cross-entropy loss, with an exception of Gadre et al. (2024), which focuses on downstream metrics. While scaling laws have guided supervised learning experiments, little work explores this for RL. The closest works are: Hilton et al. (2023) which fits power laws for on-policy RL methods using model size and the number of environment steps; Jones (2021) which studies the scaling of AlphaZero on board games of increasing complexity; and Gao et al. (2023) which studies reward model overoptimization in RLHF. In contrast, we are the first ones to study off-policy value-based RL methods that are trained via TD-learning. Not only do off-policy methods exhibit training dynamics distinct from supervised learning and on-policy methods (Kumar et al., 2021b; Lyle et al., 2023), but we show that this distinction also results in different functional form for scaling law altogether. We also note that while Hilton et al. (2023) use minimal compute, i.e., ğ’ğ½ in our notation as metric of performance, our analysis goes further in several respects: (1) we also study the tradeoff between data and compute (Figure 1), (2) we can predict the algorithm configuration for best performance (Problem 3.1); (3) we study many budget functions (ğ’ + ğ›¿ ğ’Ÿ can be any affine function). Methods for large-scale deep RL. Recent work has scaled deep RL across three axes: model size (Kumar et al., 2023; Schwarzer et al., 2023; Nauman et al., 2024b), data (Kumar et al., 2023; Gallici et al., 2024; Singla et al., 2024), and UTD (Chen et al., 2020; DOro et al., 2022). NaÃ¯ve scaling of model size or UTD often degrades performance or causes divergence (Nikishin et al., 2022; Schwarzer et al., 2023), mitigated by classification losses (Kumar et al., 2023), layer normalization (Nauman et al., 2024a), or feature normalization (Kumar et al., 2021b). In our work, we use scaled network architectures from Nauman et al. (2024b) (Section 5). In on-policy RL, prior works focus on effective learning from parallelized data streams in simulator or world model (Mnih, 2016; Silver et al., 2016; Schrittwieser et al., 2020). Follow-up works like IMPALA (Espeholt et al., 2018) and SAPG (Singla et al., 2024) use centralized learner that collects experience from distributed workers with importance sampling updates. These 11 Value-Based Deep RL Scales Predictably works differ substantially from our study as we focus exclusively on value-based off-policy RL algorithms that use TD-learning and not on-policy methods. In value-based RL, prior work on data scaling focuses on offline (Yu et al.; Kumar et al., 2023; Park et al., 2024) and multi-task RL (Hafner et al., 2023). In contrast, we study online RL and fit scaling laws to answer resource optimization questions. 7. Discussion, Limitations, and Future Work In this paper, we show that value-based deep RL algorithms scale predictably. We establish relationships between good values of hyperparameters of value-based RL. We then establish relationship between required data and required compute for certain performance. Finally, this allows us to determine an optimal allocation of resources to either data and compute. Although only estimated from small-scale runs, our empirical models reliably extrapolate to large compute, data, budget, or performance regimes. To the best of our knowledge, this is the first demonstration that it is possible to predict behavior of value-based off-policy RL algorithms at larger scale using small-scale experiments. At the same time, this first study also presents number of open questions and challenges: 1. While simple power law models work well, an open question remains as to whether such laws are theoretically grounded, and whether there are better and more refined functional forms. 2. Our study only focused on three hyperparameters (ğµ, ğœ‚, and ğœ). We do not focus on optimal tradeoff between model size and UTD, which is important for compute scaling. For data efficient RL, it is important to analyze the dependency of weight decay and weight reset frequency on UTD, which are typical tricks employed by many of the most performant methods in literature. 3. While we focus on online RL, it is important to study scaling of offline-to-online and offline RL, which will allow direct applications of scaling law findings to large model training. 4. Finally, while we study relatively small models, future work will focus on verifying our results with larger model scales, larger scale tasks, study the effect of modern architectures, and cover larger range of compute scales spanning multiple orders of magnitude. Our work is only the first step in studying scaling laws for value-based RL methods. Further research has the potential to improve our understanding of value-based RL at scale, provide researchers with tools to focus innovation on more important components, and eventually provide guidelines towards scaling value-based RL similarly to scaling enjoyed by other modern deep learning approaches."
        },
        {
            "title": "Acknowledgements",
            "content": "We would like to thank Zhang-Wei Hong, Amrith Setlur, Rishabh Agarwal, Seohong Park, and Max Simchowitz for feedback on an earlier version of this paper. We would like to thank Andrea Zanette, Seohong Park, Kyle Stachowicz, and Qiyang Li for informative discussions. This research was supported by ONR under N00014-24-12206, N00014-22-1-2773, and ONR DURIP grant, with compute support from the Berkeley Research Compute, Polish high-performance computing infrastructure, PLGrid (HPC Center: ACK Cyfronet AGH), that provided computational resources and support under grant no. PLG/2024/017817. Pieter Abbeel holds concurrent appointments as Professor at UC Berkeley and as an Amazon Scholar. This work was done at UC Berkeley and CMU, and is not associated with Amazon. 12 Value-Based Deep RL Scales Predictably"
        },
        {
            "title": "References",
            "content": "Josh Achiam, Steven Adler, Sandhini Agarwal, Lama Ahmad, Ilge Akkaya, Florencia Leoni Aleman, Diogo Almeida, Janko Altenschmidt, Sam Altman, Shyamal Anadkat, et al. Gpt-4 technical report. arXiv preprint arXiv:2303.08774, 2023. Richard Barlow and Hugh Brunk. The isotonic regression problem and its dual. Journal of the American Statistical Association, 67(337):140147, 1972. Christopher Bishop and Nasser Nasrabadi. Pattern recognition and machine learning, volume 4. Springer, 2006. Greg Brockman, Vicki Cheung, Ludwig Pettersson, Jonas Schneider, John Schulman, Jie Tang, and Wojciech Zaremba. Openai gym, 2016. Tim Brooks, Bill Peebles, Connor Holmes, Will DePue, Yufei Guo, Li Jing, David Schnurr, Joe Video URL https://openai.com/research/ Taylor, Troy Luhman, Eric Luhman, Clarence Ng, Ricky Wang, and Aditya Ramesh. generation models as world simulators. video-generation-models-as-world-simulators. 2024. Xinyue Chen, Che Wang, Zijian Zhou, and Keith Ross. Randomized ensembled double q-learning: Learning fast without model. In International Conference on Learning Representations, 2020. Will Dabney, AndrÃ© Barreto, Mark Rowland, Robert Dadashi, John Quan, Marc Bellemare, and David Silver. The value-improvement path: Towards better representations for reinforcement learning. arXiv preprint arXiv:2006.02243, 2020. Will Dabney, AndrÃ© Barreto, Mark Rowland, Robert Dadashi, John Quan, Marc Bellemare, and David Silver. The value-improvement path: Towards better representations for reinforcement learning. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 35, pages 71607168, 2021. Pierluca DOro, Max Schwarzer, Evgenii Nikishin, Pierre-Luc Bacon, Marc Bellemare, and Aaron Courville. Sample-efficient reinforcement learning by breaking the replay ratio barrier. In The Eleventh International Conference on Learning Representations, 2022. Abhimanyu Dubey, Abhinav Jauhri, Abhinav Pandey, Abhishek Kadian, Ahmad Al-Dahle, Aiesha Letman, Akhil Mathur, Alan Schelten, Amy Yang, Angela Fan, et al. The llama 3 herd of models. arXiv preprint arXiv:2407.21783, 2024. Lasse Espeholt, Hubert Soyer, Remi Munos, Karen Simonyan, Volodymir Mnih, Tom Ward, Yotam Doron, Vlad Firoiu, Tim Harley, Iain Dunning, et al. Impala: Scalable distributed deep-rl with importance weighted actor-learner architectures. arXiv preprint arXiv:1802.01561, 2018. Samir Yitzhak Gadre, Georgios Smyrnis, Vaishaal Shankar, Suchin Gururangan, Mitchell Wortsman, Rulin Shao, Jean Mercat, Alex Fang, Jeffrey Li, Sedrick Keh, et al. Language models scale reliably with over-training and on downstream tasks. arXiv preprint arXiv:2403.08540, 2024. Matteo Gallici, Mattie Fellows, Benjamin Ellis, Bartomeu Pou, Ivan Masmitja, Jakob Nicolaus Foerster, and Mario Martin. Simplifying deep temporal difference learning. arXiv preprint arXiv:2407.04811, 2024. 13 Value-Based Deep RL Scales Predictably Leo Gao, John Schulman, and Jacob Hilton. Scaling laws for reward model overoptimization. In International Conference on Machine Learning, pages 1083510866. PMLR, 2023. T. Haarnoja, A. Zhou, P. Abbeel, and S. Levine. Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with stochastic actor. In arXiv, 2018a. URL https://arxiv.org/pdf/ 1801.01290.pdf. Tuomas Haarnoja, Aurick Zhou, Pieter Abbeel, and Sergey Levine. Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with stochastic actor. In International conference on machine learning, pages 18611870. PMLR, 2018b. Danijar Hafner, Jurgis Pasukonis, Jimmy Ba, and Timothy Lillicrap. Mastering diverse domains through world models. arXiv preprint arXiv:2301.04104, 2023. Jacob Hilton, Jie Tang, and John Schulman. Scaling laws for single-agent reinforcement learning. arXiv preprint arXiv:2301.13442, 2023. Jordan Hoffmann, Sebastian Borgeaud, Arthur Mensch, Elena Buchatskaya, Trevor Cai, Eliza Rutherford, Diego de Las Casas, Lisa Anne Hendricks, Johannes Welbl, Aidan Clark, et al. Training compute-optimal large language models. arXiv preprint arXiv:2203.15556, 2022. Michael Janner, Justin Fu, Marvin Zhang, and Sergey Levine. When to trust your model: Model-based policy optimization. In Advances in Neural Information Processing Systems, pages 1249812509, 2019. Andy L. Jones. Scaling scaling laws with board games, 2021. URL https://arxiv.org/abs/2104. 03113. Jared Kaplan, Sam McCandlish, Tom Henighan, Tom Brown, Benjamin Chess, Rewon Child, Scott Gray, Alec Radford, Jeffrey Wu, and Dario Amodei. Scaling laws for neural language models. arXiv preprint arXiv:2001.08361, 2020. Alex Krizhevsky. One weird trick for parallelizing convolutional neural networks. arXiv preprint arXiv:1404.5997, 2014. Aviral Kumar, Rishabh Agarwal, Dibya Ghosh, and Sergey Levine. Implicit under-parameterization inhibits data-efficient deep reinforcement learning. In International Conference on Learning Representations, 2021a. URL https://openreview.net/forum?id=O9bnihsFfXU. Aviral Kumar, Rishabh Agarwal, Tengyu Ma, Aaron Courville, George Tucker, and Sergey Levine. DR3: Value-Based Deep Reinforcement Learning Requires Explicit Regularization. arXiv preprint arXiv:2112.04716, 2021b. Aviral Kumar, Rishabh Agarwal, Xinyang Geng, George Tucker, and Sergey Levine. Offline q-learning on diverse multi-task data both scales and generalizes. In The Eleventh International Conference on Learning Representations, 2023. URL https://openreview.net/forum?id=4-k7kUavAj. Hojoon Lee, Hanseul Cho, Hyunseung Kim, Daehoon Gwak, Joonkee Kim, Jaegul Choo, Se-Young Yun, and Chulhee Yun. Plastic: Improving input and label plasticity for sample efficient reinforcement learning. Advances in Neural Information Processing Systems, 36, 2024. Value-Based Deep RL Scales Predictably Sergey Levine, Aviral Kumar, George Tucker, and Justin Fu. Offline reinforcement learning: Tutorial, review, and perspectives on open problems. arXiv preprint arXiv:2005.01643, 2020. Qiyang Li, Aviral Kumar, Ilya Kostrikov, and Sergey Levine. Efficient deep reinforcement learning requires regulating overfitting. In The Eleventh International Conference on Learning Representations, 2023a. URL https://openreview.net/forum?id=14-kr46GvP-. Zechu Li, Tao Chen, Zhang-Wei Hong, Anurag Ajay, and Pulkit Agrawal. Parallel ğ‘-learning: Scaling off-policy reinforcement learning under massively parallel simulation. In International Conference on Machine Learning, pages 1944019459. PMLR, 2023b. Timothy Lillicrap, Jonathan Hunt, Alexander Pritzel, Nicolas Heess, Tom Erez, Yuval Tassa, David Silver, and Daan Wierstra. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015. Jan Ludziejewski, Jakub Krajewski, Kamil Adamczewski, Maciej PiÃ³ro, MichaÅ‚ Krutul, Szymon Antoniak, Kamil Ciebiera, Krystian KrÃ³l, Tomasz OdrzygÃ³ÅºdÅº, Piotr Sankowski, et al. Scaling laws for fine-grained mixture of experts. In Forty-first International Conference on Machine Learning, 2024. Clare Lyle, Zeyu Zheng, Evgenii Nikishin, Bernardo Avila Pires, Razvan Pascanu, and Will Dabney. Understanding plasticity in neural networks. In International Conference on Machine Learning, pages 2319023211. PMLR, 2023. Viktor Makoviychuk, Lukasz Wawrzyniak, Yunrong Guo, Michelle Lu, Kier Storey, Miles Macklin, David Hoeller, Nikita Rudin, Arthur Allshire, Ankur Handa, et al. Isaac gym: High performance gpu-based physics simulation for robot learning. arXiv preprint arXiv:2108.10470, 2021. Sam McCandlish, Jared Kaplan, Dario Amodei, and OpenAI Dota Team. An empirical model of large-batch training. arXiv preprint arXiv:1812.06162, 2018. Volodymyr Mnih. Asynchronous methods for deep reinforcement learning. arXiv preprint arXiv:1602.01783, 2016. Volodymyr Mnih, Koray Kavukcuoglu, David Silver, Andrei Rusu, Joel Veness, Marc Bellemare, Alex Graves, Martin Riedmiller, Andreas Fidjeland, Georg Ostrovski, et al. Human-level control through deep reinforcement learning. nature, 518(7540):529533, 2015. Niklas Muennighoff, Alexander Rush, Boaz Barak, Teven Le Scao, Nouamane Tazi, Aleksandra Piktus, Sampo Pyysalo, Thomas Wolf, and Colin Raffel. Scaling data-constrained language models. Advances in Neural Information Processing Systems, 36:5035850376, 2023. Michal Nauman, MichaÅ‚ Bortkiewicz, Piotr MiÅ‚oÅ›, Tomasz Trzcinski, Mateusz Ostaszewski, and Marek Cygan. Overestimation, overfitting, and plasticity in actor-critic: the bitter lesson of reinforcement In Proceedings of the 41st International Conference on Machine Learning, 2024a. URL learning. https://arxiv.org/pdf/2403.00514. PMLR 235:37342-37364. Michal Nauman, Mateusz Ostaszewski, Krzysztof Jankowski, Piotr MiÅ‚oÅ›, and Marek Cygan. Bigger, regularized, optimistic: scaling for compute and sample-efficient continuous control. arXiv preprint arXiv:2405.16158, 2024b. 15 Value-Based Deep RL Scales Predictably Evgenii Nikishin, Max Schwarzer, Pierluca DOro, Pierre-Luc Bacon, and Aaron Courville. The primacy bias in deep reinforcement learning. In International conference on machine learning, pages 1682816847. PMLR, 2022. Seohong Park, Kevin Frans, Sergey Levine, and Aviral Kumar. Is value learning really the main bottleneck in offline rl? arXiv preprint arXiv:2406.09329, 2024. Aditya Ramesh, Prafulla Dhariwal, Alex Nichol, Casey Chu, and Mark Chen. Hierarchical text-conditional image generation with clip latents. arXiv preprint arXiv:2204.06125, 1(2):3, 2022. Julian Schrittwieser, Ioannis Antonoglou, Thomas Hubert, Karen Simonyan, Laurent Sifre, Simon Schmitt, Arthur Guez, Edward Lockhart, Demis Hassabis, Thore Graepel, et al. Mastering atari, go, chess and shogi by planning with learned model. Nature, 588(7839):604609, 2020. John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347, 2017. Max Schwarzer, Johan Samir Obando Ceron, Aaron Courville, Marc Bellemare, Rishabh Agarwal, and Pablo Samuel Castro. Bigger, better, faster: Human-level atari with human-level efficiency. In International Conference on Machine Learning, pages 3036530380. PMLR, 2023. David Silver, Aja Huang, Chris Maddison, Arthur Guez, Laurent Sifre, George Van Den Driessche, Julian Schrittwieser, Ioannis Antonoglou, Veda Panneershelvam, Marc Lanctot, et al. Mastering the game of go with deep neural networks and tree search. nature, 529(7587):484489, 2016. Jayesh Singla, Ananye Agarwal, and Deepak Pathak. Sapg: split and aggregate policy gradients. arXiv preprint arXiv:2407.20230, 2024. Richard Sutton and Andrew Barto. Reinforcement learning: An introduction. MIT press, 2018. Yuval Tassa, Yotam Doron, Alistair Muldal, Tom Erez, Yazhe Li, Diego de Las Casas, David Budden, Abbas Abdolmaleki, Josh Merel, Andrew Lefrancq, et al. Deepmind control suite. arXiv preprint arXiv:1801.00690, 2018. Gemini Team, Rohan Anil, Sebastian Borgeaud, Jean-Baptiste Alayrac, Jiahui Yu, Radu Soricut, Johan Schalkwyk, Andrew Dai, Anja Hauth, Katie Millican, et al. Gemini: family of highly capable multimodal models. arXiv preprint arXiv:2312.11805, 2023. Saran Tunyasuvunakool, Alistair Muldal, Yotam Doron, Siqi Liu, Steven Bohez, Josh Merel, Tom Erez, Timothy Lillicrap, Nicolas Heess, and Yuval Tassa. dm_control: Software and tasks for continuous control. Software Impacts, 6:100022, 2020. ISSN 2665-9638. doi: https://doi.org/10. 1016/j.simpa.2020.100022. URL https://www.sciencedirect.com/science/article/pii/ S2665963820300099. Pauli Virtanen, Ralf Gommers, Travis Oliphant, Matt Haberland, Tyler Reddy, David Cournapeau, Evgeni Burovski, Pearu Peterson, Warren Weckesser, Jonathan Bright, et al. Scipy 1.0: fundamental algorithms for scientific computing in python. Nature methods, 17(3):261272, 2020. Greg Yang, Edward Hu, Igor Babuschkin, Szymon Sidor, Xiaodong Liu, David Farhi, Nick Ryder, Jakub Pachocki, Weizhu Chen, and Jianfeng Gao. Tensor programs v: Tuning large neural networks via zero-shot hyperparameter transfer. arXiv preprint arXiv:2203.03466, 2022. 16 Value-Based Deep RL Scales Predictably T. Yu, A. Kumar, et al. How to Leverage Unlabeled Data in Offline Reinforcement Learning. ICML 2022. 17 Value-Based Deep RL Scales Predictably"
        },
        {
            "title": "Appendices",
            "content": "A. Additional details on derivations ğ½ FLOPs calculation. Recall that FLOPs per forward and backward passes are equal to ğ’forward (ğœ) 2 ğ‘ ğµ(ğœ) ğœ ğ’Ÿğ½ (ğœ) and ğ’backward (ğœ) 4 ğ‘ ğµ(ğœ) ğœ ğ’Ÿğ½ (ğœ), with ğœ denoting the number of gradient steps per environment steps. Q-learning methods used in our study use MLP and ResNet architectures, which are well modeled with this approximation. Assuming same size for actor and critic as an approximation, training iteration of the critic requires three forward passes and one backward pass, totaling ğ’critic (ğœ) 10 ğ‘ ğµ(ğœ) ğœ ğ’Ÿğ½ (ğœ). training iteration of the actor requires two forward and two backward passes, totaling ğ’actor (ğœ) 12 ğ‘ ğµ(ğœ) ğœ ğ’Ÿğ½ (ğœ). Here we follow the standard practice of updating the actor every time new data point collected, while the critic is updated according to the UTD ratio ğœ. Since we expect the critic to be updated more then the actor. As such, in this study we assume ğ½ ğ½ ğ½ ğ’ğ½ (ğœ) ğ’critic ğ½ (ğœ) 10 ğ‘ ğµ(ğœ) ğœ ğ’Ÿğ½ (ğœ). (A.1) Compute and sample efficiency. Following Eq. (4.1), the number of data points required to achieve performance ğ½ is equal to: ğ’Ÿğ½ (ğœ) ğ’Ÿmin ğ½ + )ğ›¼ğ½ ( ğ›½ğ½ ğœ (A.2) Given the expressions for required data points, practical batch size, and FLOPs Equations (4.1), (4.6) and (A.1), we can now derive the expression for compute required to reach particular performance expressed in terms of ğœ. First, note that the number of parameter updates is ğœ ğ’Ÿğ½ (ğœ) ğœ ğ’Ÿmin ğ½ + ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ 1 Combining above, Eq. (4.6) with Eq. (A.1) yields: ğ’ğ½ (ğœ) 10 ğ‘ ğµ(ğœ) ( ğ›½ğµ ğœ ( ğ’Ÿmin ğ½ 10 ğ‘ 10 ğ‘ ( ğœ ğ’Ÿmin ğ½ + ) ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ 1 )ğ›¼ğµ ( ğœ ğ’Ÿmin ğ½ + ğ›½ğ›¼ğµ ğµ ğœğ›¼ğµ1 + ğ›½ğ›¼ğµ ğ›½ğ›¼ğ½ ğµ ğ½ ğœğ›¼ğ½ +ğ›¼ğµ ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ 1 ) . (A.3) (A.4) ) We observe that the resulting expression is sum of two power laws. In practice, one of the power laws will dominate the expression and simple mental model is that compute increases with UTD as power law with coefficient < 1 (see Figure 2). 18 Value-Based Deep RL Scales Predictably Maximal compute efficiency. Here, we solve the compute optimization problem presented in Section 3. We write the problem: (ğµ*, ğœ‚*, ğœ*) := arg min (ğµ,ğœ‚,ğœ) ğ’ s.t. ğ½ (ğœ‹Alg(ğµ, ğœ‚, ğœ)) ğ½0 ğ’Ÿ ğ·0. (A.5) Firstly, we formulate the Lagrangian â„’: â„’(ğœ, ğœ†) = ğ’ğ½ (ğœ) + ğœ† (ğ’Ÿğ½ (ğœ) ğ·0) 10 ğ‘ ğµ(ğœ) ( ğœ ğ’Ÿmin ğ½ + ) ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ 1 + ğœ† ( ğ’Ÿmin ğ½ + ( ğ›½ğ½ ğœ )ğ›¼ğ½ ) ğ’Ÿ0 (A.6) Here, the constrained with respect to performance ğ½0 is upheld through the use of ğ’ğ½ (ğœ) and ğ’Ÿğ½ (ğœ) which are defined such that ğ½ = ğ½0. We proceed with calculating the derivative with respect to ğœ† to find the minimal ğœ that is able to achieve the desired sample efficiency ğ’Ÿğ½ . We denote such such optimal UTD as ğœ*: â„’ ğœ† = ğ’Ÿmin ğ½ + )ğ›¼ğ½ ( ğ›½ğ½ ğœ ğ’Ÿ0 = 0 = ğœ* = ğ›½ğ½ ğ½ ğ’Ÿ0 (ğ’Ÿmin )1/ğ›¼ğ½ Then, we substitute the ğœ* into the expression defining compute, as well as use Eq. (4.6): ğ’ğ½ (ğœ*) 10 ğ‘ 10 ğ‘ 10 ğ‘ ğ›½ğ›¼ğµ ) ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ ( ğ’Ÿmin ğ½ + ( ğ›½ğ›¼ğµ ğµ ğœğ›¼ğµ1 ğ›½ğ›¼ğµ ğµ (ğœ*)ğ›¼ğµ1 ğµ (ğœ*)1ğ›¼ğµ ğ’Ÿ0 ğ’Ÿmin ğ½ + ğ›½ğ›¼ğ½ ğ½ ğ½ ğ’Ÿ (ğ’Ÿmin ğ›½ğ›¼ğ½ ğ½ ) ) (A.7) (A.8) Maximal sample efficiency. Firstly, we note that we treat ğµ(ğœ) as constant and do not optimize with respect to it. We start with the problem definition: (ğµ*, ğœ‚*, ğœ*) := arg min (ğµ,ğœ‚,ğœ) ğ’Ÿ s.t. ğ½ (ğœ‹Alg(ğµ, ğœ‚, ğœ)) ğ½0 ğ’ ğ¶0. (A.9) Similarly to the maximal compute efficiency problem, we formulate the Lagrangian â„’: â„’(ğœ, ğœ†) = ğ’Ÿğ½ (ğœ) + ğœ† (ğ’ğ½ (ğœ) ğ¶0) ( )ğ›¼ğ½ ğ’Ÿmin ğ½ + ( ğ›½ğ½ ğœ + ğœ† 10 ğ‘ ğµ(ğœ) ğœ ( ğ’Ÿmin ğ½ + ) ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ ) ğ’0 (A.10) 19 Value-Based Deep RL Scales Predictably Again, we uphold the constraint with respect to the performance through the use of ğ’Ÿğ½ (ğœ) and ğ’ğ½ (ğœ). We calculate the derivative with respect to ğœ†: â„’ ğœ† = 10 ğ‘ ğµ(ğœ) ğœ ( ğ’Ÿmin ğ½ + ) ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ ğ’0 = 0 = ğ’Ÿmin ğ½ + ğ›½ğ›¼ğ½ ğ½ ğœğ›¼ğ½ = ğ’0 10 ğ‘ ğµ(ğœ) ğœ = ğ’Ÿğ½ (A.11) Since ğ’Ÿğ½ is monotonic in ğœ and does not model impact of ğµ on the sample efficiency, the optimization problem can be solved via Weierstrass extreme value theorem. As such, we find the biggest ğœ and that fulfills the compute constraint, and find the data requirement for such ğœ. B. Experimental details For our experiments, we use total of 12 tasks from 3 benchmarks (DeepMind Control (Tunyasuvunakool et al., 2020), Isaac Gym (Makoviychuk et al., 2021), and OpenAI Gym (Brockman et al., 2016)). We list all considered tasks in Table 1. Table 1: Tasks used in presented experiments. Domain Task Optimal ğœ‹ Returns DeepMind Control Cartpole-Swingup Cheetah-Run Dog-Stand Finger-Spin Humanoid-Stand Quadruped-Walk Walker-Walk Isaac Gym Franka-Push OpenAI Gym HalfCheetah-v4 Walker2d-v4 Ant-v4 Humanoid-v4 1000 1000 1000 1000 1000 1000 1000 0.05 8500 4500 6625 6125 Figure 1. We use all available UTD values for the fits, which is 6 for DMC, 5 for OAI Gym, and 7 for Isaac Gym. Given the dependency of compute and data on UTD, we plot the resulting curve. We average the data efficiencies across all tasks in each domain, as described in Appendix D. We calculate compute given the model sizes of ğ‘ = 4.92e6 for DMC, ğ‘ = 1.5e5 for OAI Gym, and ğ‘ = 2e6 following standard implementations of the respective algorithms. For budget extrapolation, we use tradeoff values ğ›¿ to mimic the wall-clock time of the algorithm. We use ğ›¿ = 1e10 for DMC, ğ›¿ = 5e9 for OAI Gym, and ğ›¿ = 1e4 for Isaac Gym. We exclude runs affected by resets (ğœ = 8) for DMC since the returns right after the reset are lower, which adds noise to the results. 20 Value-Based Deep RL Scales Predictably Figure 2. We use the same data as for DMC in Figure 1 (left). Figure 3. We use the same data as for DMC in Figure 1 (right). In the left and central Figures, we evaluate the ğµ* and ğœ‚* models. For each DMC task, we Figure 5. find the best hyperparameters according to our workflow and procedure described in Section 5 and Appendix D. While the intercepts vary across environments, for simplicity we plot data points and fits from all environments in the same figure by shifting them with the corresponding intercept. In the right Figure, we marginalize over ğœ and visualize best performing pairs of ğµ and ğœ‚. Figure 4. Left: we show an illustration that reflects our observed empirical results about the dependencies between hyperparameters. Right, middle: we investigate the correlations between overfitting, parameter norm of the critic network, and ğœ. We observed the same relationships on all tasks. Here, to avoid clutter, we plot 3 tasks from DMC benchmark: cheetah-run, dog-stand, and quadruped-walk. To measure overfitting, we compare the TD loss calculated on samples randomly sampled from the buffer (corresponding to training data) to TD loss calculated on 16 newest transitions (corresponding to validation data) according to: Overfitting = ğ‘‡ ğ·training ğ‘‡ ğ·validation. (B.1) We fit the linear curves using ordinary least squares with mean absolute error loss. Figure 6. Here, we investigate 4 tasks from OpenAI Gym, listed in Table 1, and compare the extrapolation performance of two hyperparameter sets: the best performing hyperparameters for ğœ = 1, found by testing 8 different hyperparameter values listed in Table 3 (we refer to this configuration as baseline); and hyperparameters predicted by our proposed models of ğµ* and ğœ‚*. We fit our models using ğœ (1, 2, 4, 8), and extrapolate to ğœ (0.5, 16). The graph shows the data efficiency with threshold as 700, normalized according to the procedure in Appendix D. Figure 7. The goal of the left Figure is to visualize the effects of isotropic regression fit on noisy data. We use the SciPy package (Virtanen et al., 2020) to run the isotropic model. In the right Figure we visualize the process of best hyperparameter selection using bootstrapped confidence intervals. We describe the bootstrapping strategy in Appendix D. 21 Value-Based Deep RL Scales Predictably C. Resulting Fits DMC Refer to Table 2 for environment-specific values. ğœ‚* = ğ›½ğœ‚ ğœ0.26 ğµ* = ğ›½ğµ ğœ0.47 ğ’Ÿğ½ = ğ’Ÿmin ( 1 + ( ğœ )0.74) 0.45 ğœ* = 1.4e8 â„± 0.53 0 OpenAI Gym Refer to Table 2 for environment-specific values. ğœ‚* = ğ›½ğœ‚ğœ0.30 ğµ* = ğ›½ğµğœ0.33 ( ğ’Ÿğ½ = ğ’Ÿmin 1 + ( ğœ )0.69) 4.02 ğœ* = 1.4e8 â„± 0.53 Isaac Gym ğœ‚* = 8.77 ğµ* = 38.6 1 + ( ( 1 + ( ğ’Ÿğ½ = 6.8e7 1 + ğœ* = 11.3 â„± 0.57 ( ( ğœ 2.57e-3 ğœ 1.42e-2 ( ğœ 1.88 )0.26) )0.68) )0.87) Table 2: Coefficients for DMC and OpenAI Gym fits."
        },
        {
            "title": "Task",
            "content": "ğ›½ğœ‚ ğ›½ğµ ğ’Ÿmin"
        },
        {
            "title": "DMC",
            "content": "cartpole-swingup 7.55e-4 538.2 2.4e4 6.25e-4 564.9 3.5e5 cheetah-run 8.77e-4 608.2 2.9e4 finger-spin 3.86e-4 451.8 3.8e5 humanoid-stand 8.46e-4 526.4 6.2e4 quadruped-walk 9.38e-4 313.3 3.3e4 walker-walk 1.35e-4 447.0 2.7e5 1.86e-3 415.4 7.8e4 1.65e-4 351.6 1.8e5 7.85e-4 399.1 1.7e5 HalfCheetah-v4 Humanoid-v4 Walker2d-v4 OpenAI Gym Ant-v4 (C.1) (C.2) (C.3) 22 Value-Based Deep RL Scales Predictably Table 3: Tested configurations. Hyperparameters DeepMind Control Isaac Gym OpenAI Gym Updates-to-data ğœ Batch size ğµ Learning rate ğœ‚ 1, 2, 4, 8 32, 64, 128, 256, 512 15e-5, 3e-4, 6e-4, 12e-3 1 1024 , 1 4096 , 1 1 1 32768 , 8192 , 2048 , 512, 1024, 2048, 4096, 8192 1e-4, 2e-4, 3e1 16384 , 1 65536 1, 2, 4, 8 128, 256, 512 1e-4, 2e-4, 5e-4, 1e-3, 2e-3 D. Additional details on the fitting procedure In order to estimate the fits from our laws, we need to track the data Preprocessing return values. and compute needed by run to hit target performance level. Due to stochasticity both in training and and evaluation, naÃ¯ve measurements of this point can exhibit high variance. This in turn would result in low-quality fits for ğ’Ÿğ½ and ğ’ğ½ . Thus, we preprocess the return values before estimating the fits by running isotonic regression (Barlow and Brunk, 1972). Isotonic regression transforms return values to the most aligned monotonic sequence of values that can then be used to estimate ğ’Ÿğ½ . While in general return values can decrease with more training after reaching target value, and this will result in large deviation between the isotonic fit and true return values, the proposed isotonic transformation still suffices for us as our goal is to simply fit the minimum number of samples or compute needed to attain target return. As we can still make reliable predictions that extrapolate to larger scales, the downstream impact of this error is clearly not substantial. We also average across random seeds before running isotonic regression to further reduce noise. We normalize the returns for all environments to be between 0 and 1000 (Table 1 lists pre-normalized returns), and reserve the points of 700 and 800 for budget extrapolation in Figure 1. Uncertainty-adjusted optimal hyperparameters. While averaging across seeds and applying isotonic regression reduces noise, we observe that the granularity of our grid search on learning rate and batch size limits the precision of the resulting hyperparameter fits ğµ, ğœ‚. Noise due to random seed generation makes hyperparameter selection harder as some hyperparameters that appear empirically optimal might simply be so due to noise. We observe that we can correct for this precision loss by constructing more precise estimate of ğµ, ğœ‚ adjusted for this uncertainty. Specifically, we run ğ¾ = 100 bootstrap estimates by sampling ğ‘› random seeds with replacement out of the original ğ‘› random seeds, applying isotonic regression, and selecting the optimal hyperparameters ğµğ‘˜, ğœ‚ğ‘˜. We then use the mean of this bootstrapped estimate to improve the precision: ğµbootstrap = ğœ‚bootstrap = 1 ğ¾ 1 ğ¾ ğµğ‘˜ ğœ‚ğ‘˜ ğ‘˜ ğ‘˜ (D.1) We have also experimented with more precise laws for learning rate and batchsize by adding an additive offset. In this case, we follow Hoffmann et al. (2022) and fit the data using brute-force search followed Value-Based Deep RL Scales Predictably by LBFG-S. We use MSE in log space as the error: MSElog(ğ‘, ğ‘) = (log ğ‘ log ğ‘)2. ğµ*(ğœ) ğµmin + ğœ‚*(ğœ) ğœ‚min + ğœğµ ğœğ›¼ğµ ğœğœ‚ . ğœğ›¼ğœ‚ (D.2) (D.3) However, we found that this more complex fit did not validate the decrease of degrees of freedom given limited sweep range, resulting in accuracy of extrapolation. Independence of ğµ and ğœ‚. Whereas the optimal choice of ğµ and ğœ‚ is often intertwined as UTD changes, we observe in our experiments that the correlation between them is relatively low (Figure 5). If we ran cross-product grid search with hyperparameter space {ğµ1, . . . , ğµğ‘›ğµ } {ğœ‚1, . . . , ğœ‚ğ‘›ğœ‚ }, we can use this fact to further improve the results by averaging the estimate ğµ over different values of ğœ‚. That is, we produce the estimate ğµ[ğœ‚=ğœ‚ğ‘–] (respectively ğœ‚[ğµ=ğµğ‘–]) by only looking at the runs where ğœ‚ = ğœ‚ğ‘–, and averaging such estimates. ğµmean = ğœ‚mean = 1 ğ‘›ğœ‚ 1 ğ‘›ğµ ğµ[ğœ‚=ğœ‚ğ‘–] ğ‘– ğ‘– ğœ‚[ğµ=ğµğ‘–] (D.4) Data efficiency. We fit data efficiency of the runs with our found practical hyperparameters ğµ*, ğœ‚* according to Eq. (4.1). We follow Hoffmann et al. (2022) and fit the data using brute-force search followed by LBFG-S. We use MSE in log space as the error: MSElog(ğ‘, ğ‘) = (log ğ‘ log ğ‘)2. In DeepMind Control Suite, we would like to share the data efficiency fit across different environments env. We normalize the data efficiency ğ’Ÿ by the intra-environment median data efficiency medians ğ’Ÿenv [ğœ=ğœğ‘–]ğ‘– = 1..ğ‘›ğœ}. For interpretability, we further re-normalize ğ· with the overall median ğ’Ÿmed: ğ’Ÿnorm = ğ’Ÿ ğ’Ÿmed/ğ’Ÿenv med. We will need to express the data efficiency law alternatively as: med = median{ğ’Ÿenv ğ·ğ½ (ğœ) ğ’Ÿmin ğ½ ( 1 + ( ğ›½ğ½ ğœ )ğ›¼ğ½ ) . (D.5) This is equivalent to Eq. (4.1) because the coefficient ğ›½ğ½ absorbs ğ’Ÿmin . However, this expression makes explicit an overall multiplicative offset1 ğ’Ÿmin . Our median normalization is then equivalent to fitting per-environment coefficients ğ’Ÿmin , following our procedure for environment-shared hyperparameter fits. However, we further improve robustness by fixing the per-environment coefficients to be the median data efficiency and do not require fitting them. ğ½ ğ½ ğ½ E. Critical batch size analysis Previous work has argued that there is critical batch size ğµcrit for neural network training in image classification, generative modeling, and reinforcement learning with policy gradient algorithms (McCandlish et al., 2018) transition point at which increasing the batch size begins to yield diminishing returns. 1This form enforces that ğ’Ÿmin ğ½ is positive. 24 Value-Based Deep RL Scales Predictably Figure 7: Left: Determining performance via isotonic regression on DMC. Right: improving hyperparameter selection with uncertainty adjustment on DMC. Further details are in Appendix D. Figure 8: An approximation of the critical batch size over training. Further details are in Appendix E. 25 Value-Based Deep RL Scales Predictably Figure 9: ğµfinal vs. ğµcrit, grouped by task and UTD. We follow this work and compute an estimate of the gradient noise scale ğµnoise ğµcrit according to the following procedure: throughout training, we compute the gradient norm ğºğµ of the critic network for batches of size ğµ = ğµsmall := 64 and ğµ = ğµbig := 1024. Then, we evaluate ğ’¢2 := 1 ğµbig ğµsmall ( ğ’® := 1 1/ğµsmall 1/ğµbig ğµbigğºğµbig2 ğµsmallğºğµsmall2) ğºğµsmall2 ğºğµbig2) ( and take ğµcrit := ğ’®/ğ’¢2. In practice, to account for the noisiness of ğº2, we first take rolling averages of ğºğµsmall and ğºğµbig over training, and tune the window size so that the estimates for ğ’¢2 and ğ’® are stable. We show the values of ğµcrit over training in Figure 8. Unlike policy gradient methods, we find that the critical batch size (averaged over training) has little correlation with the optimal batch size, as shown in Figure 9. Table 4: Batch size values predicted by the proposed model on DMC. Task ğœ = 0.25 ğœ = 0.5 ğœ = 1 ğœ = 2 ğœ = 4 ğœ = 8 cartpole-swingup cheetah-run dog-stand finger-spin humanoid-stand quadruped-walk walker-walk 1040 1088 240 1168 864 1008 608 752 784 176 848 624 736 544 560 128 608 448 528 320 384 400 96 432 320 384 224 288 288 64 320 240 272 160 208 208 48 224 176 192 112 26 Value-Based Deep RL Scales Predictably Table 5: Learning rate values predicted by the proposed model on DMC. Task ğœ = 0.25 ğœ = 0.5 ğœ = 1 ğœ = ğœ = 4 ğœ = 8 cartpole-swingup cheetah-run dog-stand finger-spin humanoid-stand quadruped-walk walker-walk .00108 .000893 .000664 .00125 .000551 .00121 .00134 .000902 .000755 .000631 .000528 .000442 .000747 .000625 .000523 .000438 .000366 .000555 .000465 .000389 .000325 .000272 .000877 .000734 .000614 .000514 .00105 .000226 .000461 .000386 .000323 .000846 .000708 .000592 .000496 .00101 .000938 .000785 .000657 .000549 .00112 . Table 6: Batch size values predicted by the proposed model on OpenAI Gym. Task ğœ = 0.25 ğœ = 0.5 ğœ = 1 ğœ = 2 ğœ = 4 ğœ = 8 ğœ = 16 Ant-v4 HalfCheetah-v4 Humanoid-v4 Walker2d-v4 704 672 560 640 560 528 432 448 416 352 400 352 336 272 320 288 256 224 256 224 208 176 192 176 160 144 160 Table 7: Learning rate values predicted by the proposed model on OpenAI Gym."
        },
        {
            "title": "Task",
            "content": "ğœ = 0.25 ğœ = 0.5 ğœ = 1 ğœ = 2 ğœ = 4 ğœ = ğœ = 16 Ant-v4 HalfCheetah-v4 Humanoid-v4 Walker2d-v4 .000206 .002820 .000251 .001180 .000167 .000138 .000109 .000087 .000070 .000060 .002280 .001900 .001510 .001210 .000972 .000827 .000203 .000169 .000134 .000107 .000086 .000073 .000958 .000806 .000640 .000512 .000412 ."
        }
    ],
    "affiliations": [
        "Carnegie Mellon University",
        "University of California, Berkeley",
        "University of Warsaw"
    ]
}