{
    "paper_title": "Monadic Context Engineering",
    "authors": [
        "Yifan Zhang",
        "Mengdi Wang"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "The proliferation of Large Language Models (LLMs) has catalyzed a shift towards autonomous agents capable of complex reasoning and tool use. However, current agent architectures are frequently constructed using imperative, ad hoc patterns. This results in brittle systems plagued by difficulties in state management, error handling, and concurrency. This paper introduces Monadic Context Engineering (MCE), a novel architectural paradigm leveraging the algebraic structures of Functors, Applicative Functors, and Monads to provide a formal foundation for agent design. MCE treats agent workflows as computational contexts where cross-cutting concerns, such as state propagation, short-circuiting error handling, and asynchronous execution, are managed intrinsically by the algebraic properties of the abstraction. We demonstrate how Monads enable robust sequential composition, how Applicatives provide a principled structure for parallel execution, and crucially, how Monad Transformers allow for the systematic composition of these capabilities. This layered approach enables developers to construct complex, resilient, and efficient AI agents from simple, independently verifiable components. We further extend this framework to describe Meta-Agents, which leverage MCE for generative orchestration, dynamically creating and managing sub-agent workflows through metaprogramming. Project Page: https://github.com/yifanzhang-pro/monadic-context-engineering."
        },
        {
            "title": "Start",
            "content": "5 2 0 2 7 2 ] . [ 1 1 3 4 2 2 . 2 1 5 2 : r a"
        },
        {
            "title": "Monadic Context Engineering",
            "content": "Yifan Zhang1 Mengdi Wang1 1Princeton University yifzhang@princeton.edu December 30,"
        },
        {
            "title": "Abstract",
            "content": "The proliferation of Large Language Models (LLMs) has catalyzed shift towards autonomous agents capable of complex reasoning and tool use. However, current agent architectures are frequently constructed using imperative, ad hoc patterns. This results in brittle systems plagued by difficulties in state management, error handling, and concurrency. This paper introduces Monadic Context Engineering (MCE), novel architectural paradigm leveraging the algebraic structures of Functors, Applicative Functors, and Monads to provide formal foundation for agent design. MCE treats agent workflows as computational contexts where cross-cutting concerns, such as state propagation, short-circuiting error handling, and asynchronous execution, are managed intrinsically by the algebraic properties of the abstraction. We demonstrate how Monads enable robust sequential composition, how Applicatives provide principled structure for parallel execution, and crucially, how Monad Transformers allow for the systematic composition of these capabilities. This layered approach enables developers to construct complex, resilient, and efficient AI agents from simple, independently verifiable components. We further extend this framework to describe Meta-Agents, which leverage MCE for generative orchestration, dynamically creating and managing sub-agent workflows through metaprogramming. Project Page: https://github.com/yifanzhang-pro/monadic-context-engineering"
        },
        {
            "title": "Introduction",
            "content": "The vanguard of artificial intelligence research increasingly focuses on building autonomous agents: systems that reason, plan, and act to accomplish goals by interacting with environments (Yao et al., 2022; Shinn et al., 2023). While the cognitive capabilities of underlying LLMs are critical, the architectural challenge of orchestrating the operational loop, typically cycle of Thought, Action, and Observation, presents formidable barrier to creating robust and scalable systems. Engineers building these agents confront recurring set of fundamental challenges. Paramount among these is the maintenance of state integrity, requiring the reliable propagation of memory, beliefs, and history across sequence of potentially fallible operations. Simultaneously, agents require error resilience to gracefully handle real-world failures, such as API timeouts or malformed model outputs, without obfuscating core logic with defensive boilerplate. Furthermore, developers need logical composability to construct complex behaviors from independent units of logic, facilitating the seamless assembly, reordering, and substitution of steps. 1 Beyond sequential logic, modern agents demand robust concurrency to orchestrate multiple simultaneous actions without descending into the complexities of manual thread management. Ideally, the architecture should also strictly manage computational effects, separating deterministic logic from non-deterministic interactions with the external world. Finally, as systems scale, we must address agent orchestration, managing specialized teams of agents that can be formed dynamically to address novel problems without introducing chaotic interactions. Current mainstream approaches are typically imperative, addressing these issues with improvisational solutions. Consequently, developers face highly coupled codebases with convoluted control flow, rendering the resulting agents difficult to test, debug, and evolve. The lack of principled structure for managing state, failure, and concurrency leads to inherently brittle systems. This architectural deficit is becoming more apparent as the community moves towards standardized interaction patterns, such as the Model Context Protocol (MCP) (Anthropic, 2024), which demand robust and predictable orchestration logic. We propose that solution resides in powerful hierarchy of abstractions from functional programming and category theory: the Functor, the Applicative Functor, and the Monad (Moggi, 1991; Wadler, 1992). These are not merely design patterns but formal algebraic structures that provide standardized method to compose computations within context. Functor allows one to apply pure function to value inside context (mapping). An Applicative extends this by enabling the application of wrapped function to wrapped value, structure essential for executing independent computations concurrently. Finally, Monad allows for the sequencing of dependent operations where the subsequent computation is determined by the result of the previous one (binding). This progression, culminating in the Monads bind operation, allows us to construct railway for computation. Each logical step acts as station, while bind lays the track, ensuring the computational process proceeds smoothly on the success track. If any step fails, bind automatically shunts the entire computation to failure track, bypassing subsequent stations to proceed directly to the destination. This paper details the design, implementation, and application of AgentMonad, structure embodying these principles to bring profound benefits to AI agent engineering."
        },
        {
            "title": "2 From Functors to Monads: The AgentMonad Design",
            "content": "To apply Monadic Context Engineering to AI agents, we introduce specialized structure: the AgentMonad. The context it manages is composite structure encapsulating all critical aspects of an agents execution. We build our understanding by following the classic Functor-Applicative-Monad progression."
        },
        {
            "title": "2.1 The Anatomy of the AgentMonad: A Monad Transformer Stack",
            "content": "The core architectural challenge in agent design is managing multiple, overlapping concerns simultaneously. single-agent operation might need to interact with an external API, handle possible failures, and update the internal memory or world model of the agent. Attempting to manage these concerns with naive nesting, for example, type like Task<Either<State<...>, is unworkable. It forces developers to manually unwrap each layer of the context, reintroducing the deeply nested, callback-style code that monads are intended to eliminate. The principled solution is the Monad Transformer, concept from functional programming 2 that allows for the systematic composition of monadic capabilities Liang et al. (1995). monad transformer, T, is type constructor that takes an existing monad and produces new, more powerful monad, T(M), that combines the behaviors of both. Crucially, transformers provide lift operation (lift : M A) that allows any computation in an inner monad to be seamlessly used within the context of the combined outer monad. This enables the creation of layered stack of capabilities that share single, unified interface. The AgentMonad utilizes this technique to create stack designed specifically for agentic workflows (Figure 1). At the base lies the IO or Task Monad, which manages interactions with the external world. This separates the description of an action from its execution, making behavior observable. We then apply the EitherT Transformer, which introduces short circuiting error handling. This directly models the requirements of specifications like the Model Context Protocol (MCP) Anthropic (2024), where tool results must explicitly indicate success or failure. Finally, we wrap the stack in the StateT Transformer. The resulting type, StateT (EitherT IO), represents computation that is simultaneously stateful, fallible, and capable of side effects. single bind operation on this composite structure correctly threads the state, checks for errors, and sequences external actions. Mathematically, this implies the shape IO(Either(E, (A, S))), unifying all contexts into single return type. This layered construction provides robust and formal foundation for agent architecture. The resulting AgentMonad, with its type signature StateT (EitherT IO) A, directly maps its algebraic structure to the primary challenges of agent engineering. It ensures interactions are observable, error handling is robust, state management is functional, and workflows are composable. The AgentMonad is concrete implementation of this final, layered monad, combining all capabilities. Final AgentMonad StateT (EitherT IO)"
        },
        {
            "title": "Constructs",
            "content": "Layer 3: State Management (StateT S) Layer 2: Error Handling (EitherT E) Base Layer: Side Effects (IO or Task) Figure 1 Constructing the AgentMonad by stacking monad transformers. Each layer adds new capability (context) to the monad below it, culminating in single, unified structure that handles state, errors, and side effects."
        },
        {
            "title": "2.2 Level 1: AgentMonad as a Functor",
            "content": "The most fundamental operation involves applying pure function to the value inside our context without altering the context itself. This is the role of the Functor and its map operation. The map function (or fmap) accepts function : and an AgentMonad[S, A], returning an AgentMonad[S, B]. It applies to the wrapped value while preserving the state and success status. Crucially, if the flow has already failed, map performs no operation."
        },
        {
            "title": "2.3 Level 2: AgentMonad as an Applicative Functor",
            "content": "Applicatives extend Functors to handle more complex scenario: what if the function we want to apply is also wrapped in our context? This is particularly useful for combining the results of independent computations. The apply operation (or <*>) takes an AgentMonad containing function (A B) and an AgentMonad containing value (A), returning new context containing the result (B). This mechanism extracts the function and value from their respective contexts and applies them, ensuring state is propagated and failures are bypassed."
        },
        {
            "title": "2.4 Level 3: AgentMonad as a Monad",
            "content": "The final and most powerful abstraction is the Monad. It addresses the core challenge of agent orchestration: sequencing operations where each steps logic depends on the result of the previous one. The bind operation (often called flatMap or then) facilitates this chaining. It accepts an AgentMonad[S, A] and function : AgentMonad[S, B]. The operation unwraps the value and state from the first context and passes them to , which returns new AgentMonad. This allows each step to alter the state or fail independently, with the state passed implicitly by the structure. The logic for bind is formalized in Algorithm 1 and visualized in Figure 2."
        },
        {
            "title": "This structure abstracts away the repetitive and error prone boilerplate of state passing and",
            "content": "error checking. The developer can focus entirely on defining the logic of each individual step. Monad: Success Path AgentMonad(Success, S1, V1)"
        },
        {
            "title": "Unwrap\nthen",
            "content": "step_function"
        },
        {
            "title": "Wrap",
            "content": "AgentMonad(Success, S2, V2) AgentMonad(Failure, S1, Error) step_function is skipped AgentMonad(Failure, S1, Error) Monad: Failure Path (Short-circuit) Figure 2 Visualization of the Monads bind operation. transforming the entire context. In the failure path, the function is skipped, and the failure is propagated. In the success path, the function is executed, 4 Algorithm 1 The bind (then) Operation Logic for AgentMonad 1: procedure then(current_flow, step_function) 2: current_flow is an AgentMonad of (status, state, value) step_function is function: (state, value) AgentMonad if current_flow.status is FAILURE then return current_flow Short-circuit: propagate the failure without execution. end if If successful, unwrap the container to get the current state and value. current_flow.state current_flow.value Execute the next step with the unwrapped values. try next_flow step_function(s, v) catch Exception next_flow AgentMonad(FAILURE, s, e) end try return next_flow 16: 17: end procedure Capture runtime exceptions as failures. 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15:"
        },
        {
            "title": "3 Case Study: A Simple Research Agent",
            "content": "To demonstrate MCE in practice, we present simple agent that answers the question: What is Monad?. We model the interaction of the agent with its tools using the structure of the Model Context Protocol (MCP) (Anthropic, 2024), where the agent must process formal tool requests. The agent logic is decomposed into four composable steps. First, plan_action uses an LLM to formulate plan which resolves into structured MCP tool call. Second, execute_tool consumes the request; if the tool exists, it is executed, and the monadic return value determines the structure of the resulting tool result block. Third, synthesize_answer generates final answer from the tool output. Finally, format_output formats the final answer. Using AgentMonad, we chain these steps into single, declarative workflow. (cid:11) 1 task = \" What is Monad ? \" 2 initial_state = AgentState ( task = task ) 3 4 # The agent logic is defined as single , declarative , and robust chain . 5 final_flow = ( AgentMonad . start ( initial_state ) . then ( lambda , _ : plan_action (s , task ) ) . then ( lambda , call : execute_tool (s , call ) ) . then ( synthesize_answer ) . then ( format_output ) 6 7 8 10 11 ) (cid:10) Listing 1 Chaining agent steps using Monadic Context Engineering. 5 (cid:8) (cid:9)"
        },
        {
            "title": "3.1 Robust Failure Handling",
            "content": "The utility of MCE is most apparent during failure states, clarifying its synergy with protocols like MCP. Consider scenario where the plan_action step generates request for non-existent tool, such as guess. In this sequence, the plan_action step succeeds, returning an AgentMonad in Success state. The monadic chain then passes this object to execute_tool. The internal logic of the function attempts to dispatch the tool call, finds no tool named guess, and returns an AgentMonad in Failure state. This failure corresponds directly to creating an MCP tool result with an error flag. Crucially, when the subsequent .then(synthesize_answer) is called, the bind logic immediately detects the failure status and bypasses the rest of the chain. The synthesize_answer function is never executed. The failure is propagated to the end of the chain, preserving the error message and the state at the point of failure. The final flow object cleanly reports failure without single top-level conditional or exception block in the main orchestration logic, demonstrating the inherent resilience of the framework."
        },
        {
            "title": "4 Extending MCE for Concurrent and Parallel Orchestration",
            "content": "Modern AI agents often interact with multiple external services, such as querying several APIs for data or running different tools to gather diverse information. purely sequential monadic chain, while robust, creates performance bottleneck. To address this, MCE must handle asynchronous computations to provide principled structure for concurrency that enables effective I/O parallelism. While our core AgentMonad design, built on the transformer stack, can accommodate any base monad, specializing it for asynchronous operations unlocks significant performance gains. By instantiating our stack with base Task or Future monad, common in modern programming languages for managing non-blocking I/O, we derive the AsyncAgentMonad, structure purpose-built for high-performance agent orchestration."
        },
        {
            "title": "4.1 AsyncAgentMonad: A Monad Transformer in Practice",
            "content": "It provides The AsyncAgentMonad is the concrete implementation of our transformer stack. single, unified interface for chaining operations that are asynchronous, stateful, and fallible. An AsyncAgentMonad[S, V] does not hold value directly; instead, it holds promise to eventually produce an AgentMonad[S, V]. The bind (then) operation chains asynchronous functions, allowing developers to write non-blocking I/O code that looks clean and sequential. (cid:11) (cid:8) 1 task = \" What is Monad ? \" 2 initial_state = AgentState ( task = task ) 3 4 # Each step is now an async function that returns an AgentMonad . 5 async_flow = ( 7 8 9 10 AsyncAgentMonad . start ( initial_state ) . then ( lambda , _ : async_plan_action (s , task ) ) . then ( async_execute_tool ) . then ( sy nc _ sy th si ze _ an we ) . then ( async_format_output ) 11 ) 12 13 # The result is itself promise , which must be awaited to run the flow . 14 inal_result_flow = await async_flow . run () (cid:10) Listing 2 Chaining asynchronous steps with AsyncAgentMonad. (cid:9)"
        },
        {
            "title": "4.2 Unlocking True Parallelism via the Applicative Interface",
            "content": "The most significant advantage of this extension emerges from the Applicative interface. While the Monads then operation is inherently sequential (where step + 1 depends on step ), the Applicatives power lies in combining computations that are independent of one another. When the monadic context involves asynchronicity (like our AsyncAgentMonad), this distinction becomes critical. An Applicative combinator, which we will call gather, can take list of independent AsyncAgentMonad instances and execute their underlying asynchronous operations concurrently. On platforms supporting concurrent I/O or distributed execution, these tasks are effectively parallelized. The gather operation initiates all tasks simultaneously and waits for completion. It then collects their results into single list within new AsyncAgentMonad, correctly propagating state and aborting the entire group if any one of the tasks fails. For example, consider an agent tasked with creating daily briefing. It needs to fetch information from several independent sources: news API, weather service, and stock market tracker. These tasks do not depend on each other and can be run in parallel to minimize latency. (cid:11) (cid:8) 1 async def creat e_da ily_ brie fing ( state : AgentState , user_query : str ) -> AgentMonad : # 1. Define independent , asynchronous tasks news_task = AsyncAgentMonad . start ( state , user_query ) . then ( async_fetch_news ) weather_task = AsyncAgentMonad . start ( state , user_query ) . then ( async_fetch_weather ) stocks_task = AsyncAgentMonad . start ( state , user_query ) . then ( async_fetch_stocks ) # 2. Execute concurrently via Applicative gather # The result is an AsyncAgentMonad that will resolve to list of results gathered_data_flow = AsyncAgentMonad . gather ([ news_task , weather_task , stocks_task ]) # 3. Synthesize the collected results synthesis_step = await gathered_data_flow . then ( y _ t i e_ e g ) . run () return synthesis_step (cid:10) (cid:9) 2 4 5 6 7 8 10 11 12 13 14 Listing 3 Parallel data gathering using an Applicative gather operation. 7 AsyncAgentMonad(fetch_news)"
        },
        {
            "title": "Applicative Parallelism",
            "content": "AsyncAgentMonad(fetch_weather) gather"
        },
        {
            "title": "Execute Concurrently",
            "content": "AsyncAgentMonad([Vnews, Vweather, Vstocks]) AsyncAgentMonad(fetch_stocks) Figure 3 Parallel execution via an Applicative gather operation. Three independent asynchronous flows are initiated concurrently. The gather combinator waits for all to complete, then merges their results into single flow. If any task fails, the entire gathered flow fails. This pattern, visualized in Figure 3, is impossible to express elegantly with purely monadic chain. crucial consideration in this parallel model is the handling of state. Since each parallel flow could potentially modify the state, merge strategy is required. simple approach is to propagate the state from one predetermined flow, while more complex strategies could involve custom merge function provided by the developer. Our framework defaults to the former for simplicity but acknowledges the need for more sophisticated state reconciliation in advanced use cases. The combination of the Monad for sequencing dependent computations and the Applicative for executing independent computations in parallel provides complete, robust, and high performance toolkit for orchestrating complex agent behaviors."
        },
        {
            "title": "5 MCE for Meta-Agents: Generative Orchestration",
            "content": "The robustness of an architectural pattern is demonstrated by its ability to scale in complexity and abstraction. We now elevate the MCE paradigm from orchestrating single agents workflow to orchestrating team of agents. We introduce Meta-Agent: higher-level agent whose primary function is not to solve the domain problem directly, but to dynamically create, configure, and supervise team of specialized sub-agents. This approach is critical for tackling complex, multi-faceted problems that exceed the capabilities of single monolithic agent."
        },
        {
            "title": "5.1 The Meta-Agent as a Metaprogrammer",
            "content": "Its operations do not manipulate In this model, the Meta-Agent acts as metaprogrammer. domain data, but rather computational structures, specifically, the monadic flows of its sub-agents. The AgentMonad of the Meta-Agent operates at higher level of abstraction, where the state encompasses the entire system configuration, including active sub-agents and the overall plan. The values produced by steps in Meta-Agents flow are often fully formed AgentMonad workflows ready for execution. The bind operation for Meta-Agent becomes an act of generative orchestration. step might take the overall goal, determine that search capability is required, and output new AsyncAgentMonad chain pre-configured for search agent. This dynamically generated workflow 8 is then executed, and its final result is fed back into the Meta-Agents monadic context for the next step of supervision."
        },
        {
            "title": "5.2 Meta-Prompting for Dynamic Configuration",
            "content": "A key mechanism for this dynamic configuration is meta-prompting (Zhang et al., 2023; Suzgun and Kalai, 2024). The Meta-Agent uses an LLM not to answer question, but to generate the prompts and configurations for its sub-agents. For example, given complex task, the Meta-Agents first step might be call to an LLM with meta-prompt that requests decomposition of the task into specialized roles. The result of this meta-prompt is then used by the Meta-Agent to programmatically construct and dispatch multiple sub-agents, each with tailored monadic workflow (Figure 4). Meta-Agent Step 1: Decompose Task & Meta-Prompt .then() Meta-Agent Step 2: Spawn & Delegate to Sub-Agents .then() Meta-Agent Step 3: Synthesize Results Generates & Runs Dynamically Generated Sub-Agent Workflows SearchAgent: plan_search SearchAgent: execute_tool"
        },
        {
            "title": "Results collected",
            "content": "DataAgent: query_api DataAgent: validate_data WriterAgent: draft_section WriterAgent: refine_prose Figure 4 Meta-Agents monadic flow. Each step of the Meta-Agents then chain orchestrates the creation and execution of entire monadic workflows for specialized sub-agents. The results are then gathered back into the Meta-Agents context for synthesis."
        },
        {
            "title": "6 Related Work",
            "content": "The challenge of orchestrating agentic workflows is not new, and MCE builds upon rich history of research in both AI and software engineering. Agent Frameworks. Modern agent toolkits like LangChain (LangChain, 2022) and LlamaIndex have introduced expression languages to chain components. Their Runnable protocol provides degree of composability, often resembling Functor or limited Monad. However, state and error management are frequently handled as side channels rather than being intrinsic to the core abstraction. MCE offers more formally grounded approach by unifying state, value, and error status into single, cohesive monadic context, drawing from decades of established practice in functional programming for building robust systems (Hudak et al., 2007). 9 Multi-Agent Systems. The paradigm of using multiple, collaborating agents to solve complex tasks has gained significant traction, exemplified by systems like AutoGen (Microsoft, 2023) and ChatDev (Qian et al., 2023). These frameworks typically rely on conversational managers or predefined topologies to orchestrate agent interactions. While powerful, their orchestration logic is often imperative and event-driven, which can make the overall system behavior difficult to predict and verify. MCE offers complementary formal layer to these systems. Meta-Agent can use monadic chain to formally define the process of agent creation, task delegation, and result synthesis, bringing the benefits of predictable state and error management to the multi-agent domain. Reasoning Paradigms. High-level reasoning paradigms like ReAct (Yao et al., 2022), Reflexion (Shinn et al., 2023), and the patterns in AutoGPT (Gravitas, 2023) define the agents cognitive cycle. MCE is not replacement for these paradigms; rather, it is superior low-level implementation framework. An entire ReAct loop can be modeled as single AgentMonad step, which can then be composed with other steps with the guarantee that state and errors are managed robustly throughout. Model Context Protocol (MCP). Recently, there has been push to standardize the communication layer between language models and external tools. prominent example is the Model Context Protocol (MCP) introduced by Anthropic (Anthropic, 2024). MCP proposes standardized JSONbased format for models to request tool invocations and for the results to be returned to the model. The protocol explicitly includes fields like tool_id for tracking requests and an isError flag in the result, formalizing the success or failure state of tool call. MCE and MCP are highly complementary and operate at different levels of abstraction. MCP standardizes the data interface, the format of messages exchanged between the model and the agents tool execution environment. In contrast, MCE provides formal structure for the control flow within the agent that processes these messages. For instance, an agent built with MCE would receive tools_call request, and the entire process of parsing the request, calling the corresponding tool, handling potential runtime exceptions, and packaging the output or error into an MCP-compliant tool_result block can be encapsulated within single, resilient monadic step. The EitherT layer of the AgentMonad directly maps to the isError flag in the MCP tool_result, demonstrating natural synergy between the two approaches. MCE provides the robust internal engine required to reliably implement the external contract defined by MCP. Concurrent and Distributed Systems. From software engineering perspective, MCE is philosophically related to the Actor Model (Hewitt and Baker Jr, 1977), which underpins systems like Erlang/OTP and Akka. Actors are independent agents that manage their own state and communicate via asynchronous messages. While the Actor Model excels at managing highly concurrent, distributed systems, MCE is specifically tailored for the goal-oriented, often sequential but parallelizable workflows of single logical agent, providing simpler and more direct abstraction for this common use case, with natural extensions towards parallelism via Applicatives."
        },
        {
            "title": "7 Conclusion",
            "content": "Monadic Context Engineering provides paradigm shift for AI agent development, advocating transition from brittle imperative scripts to principled, functional architecture. The benefits are immediate and significant. Agent logic becomes clear, linear sequence of transformations where developers specify what to do at each step, while the framework handles how state, errors, and asynchronicity are propagated. The error model ensures that failures are handled gracefully and predictably, preventing corrupted states and unexpected crashes. Furthermore, agent behaviors are 10 encapsulated in functions that can be independently tested and composed in novel ways to build increasingly complex agents. Finally, state is managed explicitly through the monadic flow, while the combination of Monad and Applicative interfaces provides unified model for both sequential and concurrent execution, enabling parallelism. In essence, MCE is the application of mature, powerful idea from computer science to address the acute pain points of new and rapidly evolving domain. By adopting these principled algebraic structures, the AI community can build more reliable, scalable, and understandable agents, laying solid engineering foundation on the path toward more general and capable artificial intelligence."
        },
        {
            "title": "References",
            "content": "Anthropic. Model Context Protocol. https://modelcontextprotocol.io, 2024. Accessed: July 2025. Significant Gravitas. Autogpt. https://github.com/Significant-Gravitas/Auto-GPT, 2023. Carl Hewitt and Henry Baker Jr. Actors and continuous functionals, 1977. Paul Hudak, John Hughes, Simon Peyton Jones, and Philip Wadler. history of haskell: being lazy with class. In Proceedings of the third ACM SIGPLAN conference on History of programming languages, pages 121, 2007. LangChain. Langchain. https://github.com/langchain-ai/langchain, 2022. Sheng Liang, Paul Hudak, and Mark Jones. Monad transformers and modular interpreters. In Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 333343, 1995. Microsoft. AutoGen: programming framework for agentic AI. https://github.com/microsoft/ autogen, 2023. Accessed: July 2025. Eugenio Moggi. Notions of computation and monads. Information and Computation, 93(1):5592, 1991. Chen Qian, Wei Liu, Hongzhang Liu, Nuo Chen, Yufan Dang, Jiahao Li, Cheng Yang, Weize Chen, Yusheng Su, Xin Cong, et al. Chatdev: Communicative agents for software development. arXiv preprint arXiv:2307.07924, 2023. Noah Shinn, Federico Cassano, Beck Labash, Ashwin Gopinath, Karthik Narasimhan, and Shunyu Yao. Reflexion: Language agents with verbal reinforcement learning. arXiv preprint arXiv:2303.11366, 2023. Mirac Suzgun and Adam Tauman Kalai. Meta-prompting: Enhancing language models with task-agnostic scaffolding. arXiv preprint arXiv:2401.12954, 2024. Philip Wadler. The essence of functional programming. In Proceedings of the 19th ACM SIGPLANSIGACT symposium on Principles of programming languages, pages 114, 1992. Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao. React: Synergizing reasoning and acting in language models. arXiv preprint arXiv:2210.03629, 2022. Yifan Zhang, Yang Yuan, and Andrew Chi-Chih Yao. Meta prompting for ai systems. arXiv preprint arXiv:2311.11482, 2023."
        },
        {
            "title": "A Conceptual Python Implementation",
            "content": "Below are aligned excerpts of the AgentMonad and AsyncAgentMonad implementations, along with the reference step functions used in this paper. (cid:11) (cid:8) 1 from __future__ import annotations 2 3 from collections . abc import Callable 4 from dataclasses import dataclass 5 from typing import Any , Generic , TypeVar , cast 6 7 from mce . models import AgentState , ToolCall , ToolRegistry , default_registry 8 9 = TypeVar ( \" \" ) 10 = TypeVar ( \" \" ) 11 = TypeVar ( \" \" ) 12 13 14 @dataclass ( frozen = True ) 15 class AgentMonad ( Generic [S , ]) : 16 18 19 20 21 22 24 25 26 27 28 30 31 32 33 34 36 37 38 \" \" \" Monadic container for stateful , fallible agent steps . \" \" \" state : value : None is_successful : bool = True error_info : Any = None def _require_value ( self ) -> : if self . value is None : raise ValueError ( \" AgentMonad has no value . \" ) return self . value def then ( self , func : Callable [[ , ] , AgentMonad [S , ]]) -> AgentMonad [S , ]: if not self . is_successful : return AgentMonad . failure ( self . state , self . error_info ) try : value = self . _require_value () return func ( self . state , value ) except Exception as exc : return AgentMonad . failure ( self . state , exc ) def map ( self , func : Callable [[ ] , ]) -> AgentMonad [S , ]: if not self . is_successful : 13 return AgentMonad . failure ( self . state , self . error_info ) value = self . _require_value () return AgentMonad . success ( self . state , func ( value ) ) def apply ( self , func_flow : AgentMonad [S , Callable [[ ] , ]]) -> AgentMonad [S , ]: if not self . is_successful or not func_flow . is_successful : error = self . error_info if not self . is_successful else func_flow . error_info return AgentMonad . failure ( self . state , error ) func = func_flow . _require_value () return self . map ( func ) @staticmethod def start ( state : , initial_value : None = None ) -> AgentMonad [S , ]: value = initial_value if initial_value is not None else cast (V , state ) return AgentMonad ( state , value ) @staticmethod def success ( state : , value : ) -> AgentMonad [S , ]: return AgentMonad ( state , value , is_successful = True ) @staticmethod def failure ( state : , error_info : Any ) -> AgentMonad [S , ]: return cast ( AgentMonad [S , ] , AgentMonad ( state , None , is_successful = False , error_info = error_info ) , ) 40 41 42 43 44 46 47 48 49 50 52 53 54 55 56 58 59 60 61 62 64 65 66 67 # --- Example : Defining the agent behavioral steps --- 68 def plan_action ( state : AgentState , task : str ) -> AgentMonad [ AgentState , ToolCall ]: call = ToolCall ( tool_id = \" tool -1 \" , name = \" search \" , arguments ={ \" query \" : task }) next_state = state . with_history ( \" Plan : call { call . name } with query = { task } . \" ) return AgentMonad . success ( next_state , call ) 69 70 71 72 73 74 def execute_tool ( 14 75 state : AgentState , call : ToolCall , registry : ToolRegistry None = None 76 ) -> AgentMonad [ AgentState , str ]: registry = registry or default_registry () result = registry . run ( state , call ) next_state = state . with_history ( \" Tool Result ({ call . name }) : { result . content } \" ) if result . is_error : return AgentMonad . failure ( next_state , result . content ) return AgentMonad . success ( next_state , result . content ) 77 79 80 81 82 83 84 85 def synthesize_answer ( state : AgentState , tool_output : str ) -> AgentMonad [ AgentState , str ]: answer = ( \" Monadic Context Engineering structures agent workflows as composable steps \" \" with built - in state threading , error short - circuiting , and optional parallelism . \" \" Evidence : { tool_output } \" ) next_state = state . with_history ( \" Synthesized final answer . \" ) return AgentMonad . success ( next_state , answer ) 86 87 88 90 91 92 93 94 95 def format_output ( state : AgentState , answer : str ) -> AgentMonad [ AgentState , str ]: formatted = \" Final Report : { answer } \" next_state = state . with_history ( \" Formatted response for delivery . \" ) return AgentMonad . success ( next_state , formatted ) 96 97 (cid:10) Listing 4 Conceptual Implementation of the AgentMonad Class."
        },
        {
            "title": "B Conceptual AsyncAgentMonad Implementation",
            "content": "(cid:11) 1 from __future__ import annotations 2 3 import asyncio 4 from collections . abc import Awaitable , Callable , Sequence 5 from typing import Any , Generic , TypeVar , cast 6 7 = TypeVar ( \" \" ) 8 = TypeVar ( \" \" ) 15 (cid:9) (cid:8)"
        },
        {
            "title": "9 R = TypeVar ( \" R \" )",
            "content": "10 11 AsyncStep = Callable [[ , ] , Awaitable [ AgentMonad [S , ]]] 12 13 14 class AsyncAgentMonad ( Generic [S , ]) : 15 16 18 19 20 21 22 24 25 26 27 28 30 31 32 33 34 36 37 38 39 40 42 43 44 45 46 \" \" \" Async monadic container for parallel , stateful , fallible workflows . \" \" \" def __init__ ( self , run_func : Callable [[] , Awaitable [ AgentMonad [S , ]]]) -> None : self . _run = run_func async def run ( self ) -> AgentMonad [S , ]: return await self . _run () def then ( self , func : AsyncStep [S , , ]) -> AsyncAgentMonad [S , ]: async def new_run () -> AgentMonad [S , ]: current_flow = await self . run () if not current_flow . is_successful : return AgentMonad . failure ( current_flow . state , current_flow . error_info ) try : value = current_flow . _require_value () return await func ( current_flow . state , value ) except Exception as exc : return AgentMonad . failure ( current_flow . state , exc ) return AsyncAgentMonad ( new_run ) @staticmethod def start ( state : , initial_value : None = None ) -> AsyncAgentMonad [S , ]: async def run_func () -> AgentMonad [S , ]: return AgentMonad . start ( state , initial_value ) return AsyncAgentMonad ( run_func ) @staticmethod def gather ( flows : Sequence [ AsyncAgentMonad [S , Any ]] , merge_state : Callable [[ Sequence [ ]] , ] None = None , ) -> AsyncAgentMonad [S , list [ Any ]]: 16 48 49 51 52 53 54 55 57 58 59 60 61 63 async def new_run () -> AgentMonad [S , list [ Any ]]: if not flows : return AgentMonad . failure ( cast (S , None ) , \" No flows provided \" ) results = await asyncio . gather (*( flow . run () for flow in flows ) ) errors = [ result for result in results if not result . is_successful ] if errors : failing = errors [0] return AgentMonad . failure ( failing . state , failing . error_info ) states = [ result . state for result in results ] final_state = merge_state ( states ) if merge_state else states [ -1] values = [ result . value for result in results ] return AgentMonad . success ( final_state , values ) (cid:10) return AsyncAgentMonad ( new_run ) (cid:9) Listing 5 Conceptual Implementation of AsyncAgentMonad."
        }
    ],
    "affiliations": [
        "Princeton University"
    ]
}