{
    "paper_title": "Scaling Latent Reasoning via Looped Language Models",
    "authors": [
        "Rui-Jie Zhu",
        "Zixuan Wang",
        "Kai Hua",
        "Tianyu Zhang",
        "Ziniu Li",
        "Haoran Que",
        "Boyi Wei",
        "Zixin Wen",
        "Fan Yin",
        "He Xing",
        "Lu Li",
        "Jiajun Shi",
        "Kaijing Ma",
        "Shanda Li",
        "Taylor Kergan",
        "Andrew Smith",
        "Xingwei Qu",
        "Mude Hui",
        "Bohong Wu",
        "Qiyang Min",
        "Hongzhi Huang",
        "Xun Zhou",
        "Wei Ye",
        "Jiaheng Liu",
        "Jian Yang",
        "Yunfeng Shi",
        "Chenghua Lin",
        "Enduo Zhao",
        "Tianle Cai",
        "Ge Zhang",
        "Wenhao Huang",
        "Yoshua Bengio",
        "Jason Eshraghian"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Modern LLMs are trained to \"think\" primarily via explicit text generation, such as chain-of-thought (CoT), which defers reasoning to post-training and under-leverages pre-training data. We present and open-source Ouro, named after the recursive Ouroboros, a family of pre-trained Looped Language Models (LoopLM) that instead build reasoning into the pre-training phase through (i) iterative computation in latent space, (ii) an entropy-regularized objective for learned depth allocation, and (iii) scaling to 7.7T tokens. Ouro 1.4B and 2.6B models enjoy superior performance that match the results of up to 12B SOTA LLMs across a wide range of benchmarks. Through controlled experiments, we show this advantage stems not from increased knowledge capacity, but from superior knowledge manipulation capabilities. We also show that LoopLM yields reasoning traces more aligned with final outputs than explicit CoT. We hope our results show the potential of LoopLM as a novel scaling direction in the reasoning era. Our model could be found in: http://ouro-llm.github.io."
        },
        {
            "title": "Start",
            "content": "Rui-Jie Zhu*1,2,, Zixuan Wang*1,3, Kai Hua*1, Tianyu Zhang*4,5, Ziniu Li*1, Haoran Que*1,6, Boyi Wei*3, Zixin Wen*1,7, Fan Yin*1, He Xing*11, Lu Li8, Jiajun Shi1, Kaijing Ma1, Shanda Li1,7, Taylor Kergan2,9, Andrew Smith2,9, Xingwei Qu1,10, Mude Hui2, Bohong Wu1, Qiyang Min1, Hongzhi Huang1, Xun Zhou1, Wei Ye6, Jiaheng Liu11, Jian Yang11, Yunfeng Shi11, Chenghua Lin10, Enduo Zhao11, Tianle Cai1, Ge Zhang*1,, Wenhao Huang1,, Yoshua Bengio4,5, Jason Eshraghian2, 1ByteDance Seed, 2UC Santa Cruz, 3Princeton University, 4Mila - Quebec AI Institute, 5University of Montreal, 6Peking University, 7Carnegie Mellon University, 8University of Pennsylvania, 9Conscium, 10University of Manchester, 11M-A-P Core Contributors, Corresponding authors Abstract Modern LLMs are trained to think primarily via explicit text generation, such as chain-of-thought (CoT), which defers reasoning to post-training and under-leverages pre-training data. We present and open-source Ouro, named after the recursive Ouroboros, family of pre-trained Looped Language Models (LoopLM) that instead build reasoning into the pre-training phase through (i) iterative computation in latent space, (ii) an entropy-regularized objective for learned depth allocation, and (iii) scaling to 7.7T tokens. Ouro 1.4B and 2.6B models enjoy superior performance that match the results of up to 12B SOTA LLMs across wide range of benchmarks. Through controlled experiments, we show this advantage stems not from increased knowledge capacity, but from superior knowledge manipulation capabilities. We also show that LoopLM yields reasoning traces more aligned with final outputs than explicit CoT. We hope our results show the potential of LoopLM as novel scaling direction in the reasoning era. Correspondence: ridger@ucsc.edu, zhangge.eli@bytedance.com, huang.wenhao@bytedance.com, jsn@ucsc.edu Project Page & Base / Reasoning Models: http://ouro-llm.github.io 5 2 0 2 9 ] . [ 1 1 4 7 5 2 . 0 1 5 2 : r Figure 1 Ouro Looped Language Model performance. (Left) The parameter-shared looped architecture. (Middle & Right) Radar plots comparing the Ouro 1.4B and 2.6B models, both with 4 recurrent steps (red), against individual transformer baselines. Our models demonstrate strong performance comparable to or exceeding much larger baselines."
        },
        {
            "title": "Introduction",
            "content": "The advancement of Large Language Models (LLMs) has historically relied on scaling up model size as the primary driver, accompanied by increases in data and compute [14]. However, deploying models with hundreds of billions of parameters requires extensive infrastructure, increasing latency and cost while limiting accessibility. These factors make parameter efficiency critical: achieving better model capability within fixed parameter budget. Such models not only mitigate overfitting on finite datasets with fewer trainable parameters, but also enable more practical deployment with lighter infrastructure. To achieve such parameter efficiency, two main avenues have been explored. The first expands the training corpus regardless of model size [5], though data scarcity increasingly limits this path. The second leverages inference-time compute through Chain-of-Thought (CoT) reasoning [6], allowing models to spend more compute on complex problems via extended token generation. We explore third pathway based on architectural innovation: achieving dynamic computation within fixed parameter budget. This is accomplished by recursively reapplying shared parameters, where group of weight-tied layers are iteratively reused during the forward pass. We call this the Looped Language Model (LoopLM). The LoopLM paradigm has gained wide attention and shown strong promise recently, originating with the seminal Universal Transformer [7]. Plenty of works on looped transformers [813], recursive transformers [14], and latent reasoning frameworks [15, 16] have demonstrated the benefits of deeper computational processing on equivalent training data, indicating the potential benefits at larger scale. These approaches share common principle: through iterative reuse of weight-shared layers, computational scaling is decoupled into the depth of computation and the number of parameters involved. The LoopLM design yields several advantages. First, LoopLM allows adaptive computation via learned early exit mechanism: simple inputs may terminate after fewer recurrent steps, while complex ones naturally allocate more iterations, enabling flexible computational depth without increasing the parameter count. Moreover, unlike inference-time methods like CoT, LoopLM achieves scalability by deepening its internal computational graph rather than extending the output sequence, thereby avoiding excessive context growth. Finally, LoopLM potentially improves capacity per parameter and achieves stronger performance than standard transformers of comparable size when trained on the same data. While the prior studies have demonstrated the benefits of LoopLM at modest scales, there is little evidence that Looped Language Models can perform on par with non-looped architecture at practically meaningful scales. To this end, we ask the following question: Does LoopLM exhibit more favorable scaling behavior (in loss, efficiency, safety, or capability growth), compared to existing non-recursive transformer models? In this work, we aim to answer this question affirmatively. We carefully investigate the LoopLM scaling trajectory to understand its point of saturation, illustrating that LoopLM represents fundamentally more efficient path towards higher performance. While prior works have shown promise on modest scales (e.g., hundreds of billions of tokens), we study whether these benefits persist or even amplify when scaled to the multi-trillion token regimes of training that define SOTA foundation models. In particular, we study the mechanisms of LoopLM by further asking the following questions: 1. Does the recursive application of weight-shared layers enhance the LoopLMs capabilities in manner analogous to increasing the number of unshared layers? 2. Are the performance gains LoopLM monotonic in the number of loops? Are there more factors involved in the use of the adaptive computation of LoopLM that are different with prior empirical results in smaller scale experiments? To resolve these uncertainties, we move beyond small-scale proofs of concept and undertake comprehensive empirical investigation. Our results are presented below."
        },
        {
            "title": "Our Contribution",
            "content": "In this work, we attempt to address the above research questions through multi-faceted approach. We scale up the pretraining of LoopLM to total of 7.7T tokens and thoroughly investigate the scaling behavior of LoopLM in various aspects. To achieve adaptive computation with LoopLM, we develop novel training 2 Figure 2 Performance on advanced reasoning benchmarks. Ouro-Thinking models compared with strong baselines such as Qwen3 and DeepSeek-Distill. Ouro-1.4B-Thinking R4 is competitive with 4B models, and Ouro-2.6B-Thinking R4 matches or exceeds 8B models across multiple math and science datasets. objectives that enable computationally efficient recurrent computation while maintaining peak performance. We further conducted several controlled experiments on synthetic tasks to understand the mechanism of LoopLM superiority. Specifically, our contributions are: Exceptional parameter efficiency at scale. By pre-training on 7.7 trillion tokens, we demonstrate that 1.4B and 2.6B parameter LoopLMs match the performance of 4B and 8B standard transformers respectively across nearly all benchmarks, achieving 2-3 parameter efficiency improvements critical for deployment under resource constraints. As illustrated in Figure 1 and Figure 2, our Ouro and Ouro-Thinking models demonstrate exceptional parameter efficiency across suite of benchmarks, with our 1.4B and 2.6B parameter models matching the performance of larger non-recurrent LLMs. Entropy regularized adaptive computation. We develop an entropy regularized training objective with uniform prior over exit steps that enables unbiased exploration of all recurrent depths. Moreover, we add focused training stage for adaptive gates training, specifically to optimize the tradeoff between computation efficiency and loop performance, allowing learned adaptive allocation of recurrent steps based on input difficulty. Mechanistic understanding via synthetic tasks. Using controlled experiments inspired by the physics of language models framework, we show that recurrence does not increase raw knowledge storage (approximately 2 bits per parameter for both looped and non-looped models) but dramatically enhances knowledge manipulation capabilities on tasks requiring fact composition and multi-hop reasoning. Improved safety and faithfulness. LoopLM architectures reduce harmfulness on HEx-PHI [17], with safety improving as recurrent steps increase, including extrapolated steps. In contrast to CoT, our iterative latent updates yield causally faithful reasoning process rather than post hoc rationalization. Our study of LoopLM establishes the number of recursion as third scaling axis beyond model size and data, and we publicly release the Ouro model family (1.4B and 2.6B parameters) to demonstrate the benefits of LoopLM at scale."
        },
        {
            "title": "2 Related Works",
            "content": "We define notation and confine background only to what is needed for presenting our method. standard L-layer Transformer is composition of layer functions. It processes an input sequence of hidden states (0) RN through series of unique layers, parameterized by θ1, . . . , θL: (L) = TransformerLayer θL (cid:0) . . . TransformerLayer θ2 (TransformerLayer θ1(H (0))) . . . (cid:1) In contrast, the Universal Transformer [7] replaces distinct layers with recurrent application of single Transformer block repeatedly for updates: (t) = TransformerLayer θ(H (t1)), for = 1, . . . , , with (0) as input The core ideas of this architecture have resurfaced in recent literature, with recurrent-depth structures used to improve the efficiency and reasoning capabilities of modern LLMs. For example, Geiping et al. [15] adopts recurrent depth to scale test-time computation in latent space. Similarly, Saunshi et al. [8] demonstrates that looped transformers can match the performance of much deeper non-looped models on reasoning tasks, formally connecting looping to the generation of latent thoughts. The approach is refined by converting standard models into Relaxed Recursive Transformers with common base block while injecting unique LoRA adapters across recursive steps [14]. Similar concepts have emerged under different terms, such as pondering in continuous space [16] and inner thinking for adaptive computation [18]. More advanced variants, such as Mixture-of-Recursions [19] combine recursive parameter efficiency with adaptive, token-level routing. Across all these works, from the original Universal Transformer to its modern descendants, this emerging line of architectures can be understood in two complementary ways. From one perspective, it behaves like deep Transformer where the weights of all layers are tied. From another, iteration functions as latent reasoning, where the hidden states (1), . . . , (T ) form latent chain of thought that progressively refines the representation to solve task. Taken together, these results suggest that models can improve their ability to reason by reusing computation internally without having to increase parameter count, shifting scale to substance. Perspective 1: Parameter Sharing for Model Efficiency. This view treats LoopLM as parameter sharing: one or more Transformer blocks, or even submodules (e.g., attention, FFN), are reused across the depth of the model, reducing parameters without changing the computation. The most prominent example in the modern transformer era is ALBERT [20], which combines parameter re-use with embedding factorization to drastically reduce the total parameter count. Prior to the widespread adoption of LLMs, parameter sharing was explored extensively in machine translation [21]; Takase et al. [22] systematically studied sharing strategies to balance compression and accuracy. Interest in parameter reuse dropped as models grew larger, but it has resurged to shrink the memory footprint of LLMs. For example, Megrez2 [23] reuses experts across layers in standard Mixture-of-Experts (MoE) model, and shows viable path forward for edge LLM deployment with limited memory. Perspective 2: Latent Reasoning and Iterative Refinement. Here, the LoopLMs iteration is viewed as latent reasoning where each step is non-verbal thought that refines the models internal representation. Empirically, increasing the number of recurrent steps improves performance on complex reaasoning tasks [8, 15]. Some models make this process explicit by feeding hidden states back into the input. Coconut inserts continuous thought token, which is derived from the previous stepss last-layer hidden state, so the model can ponder in continuous latent space [24]. CoTFormer interleaves activations back into the input before reapplying this augmented sequence to the shared layers [25]. These explicit feedback loops contrast with implicit LoopLM variants, where the entire thought process is contained within the evolution of hidden states from (t1) to (t). Thus, both Perspective 1 (model compression) and Perspective 2 (latent reasoning) leverage shared-parameter iteration to improve parameter efficiency, and are being explored for enhance reasoning and efficient sequence-length expansion (e.g., PHD-Transformer [26]). 4 Figure 3 Overview of Looped Language Model (LoopLM) architecture. Left (Training): During training, the model applies stack of shared-weight layers for recurrent steps (R = 1 to = n). At each recurrent step i, an exit gate predicts the probability pi of exiting, and language modeling head Li computes the task loss. The training objective combines the expected task loss across all steps with an entropy regularization term H(p1, . . . , pn) to encourage exploration of different computational depths. Right (Inference): At inference time, the model can exit early based on the cumulative distribution function (CDF) computed from exit probabilities. When CDFi = (cid:80)i k=1 pk exceeds threshold, the model terminates at step i, enabling adaptive computation that allocates more steps to harder inputs while maintaining efficiency on simpler ones. The dashed line indicates potential future steps that may be skipped through early exit."
        },
        {
            "title": "3 Learning Adaptive Latent Reasoning with LoopLM",
            "content": "In this section, we shall formally define the LoopLM architecture based on (causal) transformers and explain how we train LoopLMs that are able to perform latent reasoning with adaptive computation. Figure 3 illustrates our architecture during both training and inference phases. Our objective is to let the model decide how many recurrent steps to use for each token and each example, spending less compute on easy inputs and more compute on hard inputs, without sacrificing accuracy when many steps are available."
        },
        {
            "title": "3.1 LoopLM Architecture\nLet Trθ(·) : RM ×d → RM ×d denote a causal transformer layer equipped with parameter θ, with hidden\ndimension d and input length M . Moreover we let lmhead(·) : Rd → R|V | denote the language-modeling\nhead where V is the vocabulary of tokens, and emb(·) : R|V | → Rd denote the embedding layer. A typical\nnon-looped causal language model is defined by stacking L layers as follows:",
            "content": "F () := lmhead emb(), where L() := TrθL Trθ1() is the hidden layers. Let N, Tmax be the number of loop steps, which we also call the number of recurrent steps or recurrent depth, we define the looped language model (t) by: (t)() = lmhead L (cid:125) (cid:124) (cid:123)(cid:122) times emb(). (1) Apparantly (1) is the non-loop model. Given sequence of tokens x1:M = (x1, x2, . . . , xM ) of length , LoopLM model (t) acts as sequence to sequence model and produces tokens y1:M = (y1, y2, . . . yM ) that is consistent with the causal dependency condition that y1:m = (t)(x1:m) and for any . The 5 Algorithm 1 Q-exit Early Stopping Criterion Require: Input x; maximum steps Tmax; threshold [0, 1]; 1: cdf 0; surv 1 2: for = 1 to Tmax do 3: λt σ(Gate(F (t)(x))) qϕ(tx) λt surv cdf cdf + pt if cdf then return 4: 5: 6: 7: surv = (cid:81)t j=1(1 λj) CDF(t x) texit(x) surv surv (1 λt) 8: 9: return Tmax fallback if the threshold is never reached next-token-prediction objective is simply the cross-entropy loss on all yi, 1 , L(t) = Ex1:M (cid:20) (cid:88) 1iM 1 log Pr(F (t)(x1:i) = x2:i+1) (cid:21) , for [1, Tmax] (2) where Pr(F (t)(x1:i) = xi+1) is computed by taking softmax over the lmhead output. The loss L(t) measures the precision of t-step LoopLM. Prior literature such as [8, 12] have shown that scaling up the loop count is beneficial for reasoning tasks in smaller scale. However, increasing the loop count costs computation, and not all language tokens are reasoning-heavy and need those computation to be predicted correctly. In fact, many tokens in the next-token-prediction tasks are simple or can be learned with high certainty [27, 28]. Thus it is crucial to spend the computation budget on the right tokens for pareto-optimal allocation between performance and efficiency. This is achieved by the gating mechanism we shall describe below."
        },
        {
            "title": "3.2 Adaptive Computation via Gating Mechanism\nThe early exit gate at loop step t ≤ Tmax is defined by λt(x) = σ(Gate(F (t)(x))) for an input sequence x\nthrough a learned linear projection followed by sigmoid activation σ. After that, LoopLM uses the gates\n{λt(x)}t∈[1,Tmax] to compute a distribution qϕ(·|x) ∈ ∆Tmax over {1, . . . , Tmax}1 to decide whether to continue\nthe recursive computation or stop to yield the output. Following [29], we adopt a deterministic Q-exit criterion\nbased on the cumulative distribution function (CDF), described in Algorithm 1. At each step t, we compute\nthe following:",
            "content": "CDF(tx) = (cid:88) i=1 qϕ(ix) = (cid:88) i= i1 (cid:89) λi(x) (1 λj(x)) j=1 and qϕ(ix) represents the probability of exiting exactly at step given input x. The product term (cid:81)i1 j=1(1λj) ensures that we can only stop at step if we did not exit at any earlier step < i. For input x, we exit early when the CDF exceeds set threshold [0, 1]: texit(x) = min{t : CDF(tx) q} The threshold controls the compute-accuracy tradeoff, where lower values encourage earlier exits and higher values allow deeper computation. The gating function λt shall be learned in the two-stage training: Stage I: during pre-training, the gates λt() are learned by optimizing an entropy-regularized objective. In this stage, the exit distribution aims to widen the coverage of the optimal exit step. Stage II: we focus on training only the gates in this stage. The objective exploits the pattern learned in stage and sharpens the distribution by choosing the optimal exit step with soft cross-entropy loss. We shall immediately explain the two stages below. 1d = {x [0, 1]d (cid:80)d i=1 xi = 1} is the probability simplex."
        },
        {
            "title": "3.3 Stage I: Learning An Entropy-Regularized Objective",
            "content": "To obtain LoopLM that can exit early while maintaining performance, we need an objective that jointly optimizes accuracy and computational efficiency. Let L(t) follow (2), then our training objective combines the next-token prediction loss with an entropy regularization term over qϕ: Tmax(cid:88) = qϕ(tx) L(t) t=1 (cid:124) (cid:123)(cid:122) expected task loss (cid:125) β H(qϕ(x)) (cid:125) (cid:123)(cid:122) entropy regularization (cid:124) H(qϕ(x)) = Tmax(cid:88) t=1 qϕ(tx) log qϕ(tx) (3) where L(t) is the next token prediction loss at loop step t, and H(qϕ(x)) is the entropy of the exit step distribution. The hyperparameter β controls the exploration-exploitation trade-off: larger β encourages more uniform distributions (higher entropy), allowing the model to explore different depths, while smaller β allows more concentrated distributions when the model is confident about the optimal depth for given input. Alternative perspective: variational inference with uniform prior. The entropy-regularized objective can be equivalently viewed through the lens of variational inference. If we treat the exit step as latent variable with prior distribution π, we can derive an Evidence Lower Bound (ELBO) objective: LELBO = Tmax(cid:88) t=1 qϕ(t x) L(t) + β KL(cid:0)qϕ( x) π(cid:1) When we choose uniform prior πt = 1/Tmax, t, the KL divergence simplifies to: KL(qϕ( x)π) = H(qϕ( x)) + log Tmax Since log Tmax is constant, minimizing the ELBO with uniform prior is equivalent to our entropy-regularized objective. This connection reveals that our approach aligns with adaptive computation methods like PonderNet [30], which also optimize an ELBO objective for dynamic halting. Why uniform prior? While our formulation is similar to PonderNet [30], critical difference lies in the choice of prior. PonderNet and other adaptive computation methods typically employ geometric priors: πgeo = λ (1 λ) t1 1 (1 λ) Tmax , = 1, . . . , Tmax, λ (0, 1) Similarly, methods like Recurrent Depth [15] use Poisson-lognormal priors that also favor shallow computation. We argue that such priors conflate two distinct goals: (1) learning when to exit based on input difficulty, and (2) minimizing average computation cost. In fact, these priors contain strong inductive bias toward shallow computation by placing more mass on early steps, explicitly encouraging the model to exit early. Therefore, they risk under-exploring deeper steps and may fail to fully exploit the benefits of recurrent depth. In contrast, the uniform prior makes no assumptions about the optimal exit step distribution. It optimizes all depths uniformly, enabling the model to infer the computational requirements of different inputs without relying on predefined inductive biases. This is particularly important for complex reasoning tasks, where the optimal depth should be learned from the data rather than being constrained by the prior. We provide detailed empirical validation of this choice against geometric priors in Section A."
        },
        {
            "title": "3.4 Stage II: Focused Adaptive Gate Training",
            "content": "Unlike traditional approaches that treat the gating mechanism as an auxiliary component, we directly optimize the exit gate for effective adaptive computation. The core idea of our gate training approach is to teach the model to make termination decisions based on actual performance improvements. We adopt greedy approach that optimizes the trade-off between improvement via recurrent step and computation efficiency below. 7 Figure 4 The Ouro model training pipeline. The process starts with common Warmup and an initial 3T token Stable Training phase. The model is then split into two streams: one Keep 1.3B (resulting in Ouro-1.4B) and one Upcycle 2.6B (resulting in Ouro-2.6B). Both streams independently undergo an identical subsequent four-stage training process: second Stable Training (3T tokens), CT Annealing (1.4T tokens), LongCT (20B tokens), and Mid-Training (300B tokens). This 7.7T token pre-training pipeline produces the base models (Ouro-1.4B and Ouro-2.6B), which are then passed through final Reasoning SFT stage to create the Ouro-Thinking models. In this stage, the adaptive exit objective must exclusively optimize the gating mechanism without interfering with the language models learned representations. We compute the detached loss L(t) at each token position and define the loss improvement of advancing from step 1 to step by i,stop = max(0, L(t1) (t) i,stop L(t) i,stop) (4) Intuitively, when (t) is small, the improvement has stagnated and LoopLM should opt for an early exit. We implement this intuition by computing the ideal continuation probability w(t) τ )) using = 50.0 as the slope and τ = 0.005 as the improvement threshold. When (t) is large and the model performs the next recurrent step; When (t) τ , early exit is favored in step t. The adaptive exit loss at step takes the form of weighted cross-entropy averaged over the sequence length between this ideal behavior and the actual gate prediction. = σ(k (I (t) > τ , w(t) L(t) adaptive = 1 (cid:88) (cid:104) w(t) iM log(1 λ(t) ) + (1 w(t) (cid:105) ) log(λ(t) ) (5) The total adaptive training loss is averaged across all recurrent steps: Ladaptive = 1 Tmax Tmax(cid:88) t=2 L(t) adaptive Significance of our adaptive loss. The adaptive loss (5) trains the gate in step by matching its weights λ(t1) . This formulation penalizes two failure modes simultaneously: with the ideal probability w(t) Underthinking, where the gate wants to stop when it should continue (when the ideal continuation probability w(t) is large, but the early stop gate λ(t1) is also large); Overthinking, where the gate wants to continue when it should stop (when the ideal continuation probability w(t) is small, but λ(t) is also small). By optimizing (5), the gates learn to greedily search for the optimal exit step, to tradeoff computation efficiency for better performance. For empirical evaluations, see Section 5.4.1."
        },
        {
            "title": "4 Training Looped Language Models",
            "content": "Our training pipeline for the Ouro model family is multi-stage process, as illustrated in Figure 4. The process begins with common warmup stage, followed by an initial Stable Training phase on 3T tokens. After this, the model is split into two variants: 1.4B parameter model and 2.6B model created via upcycling. Both variants then undergo an identical series of four subsequent training stages: second Stable Training phase (3T tokens), CT Annealing (1.4T tokens), LongCT (20B tokens), and Mid-Training (300B tokens). This comprehensive pipeline, totaling 7.7T tokens of training data, produces our base models, Ouro-1.4B and 8 Ouro-2.6B. Finally, these base models are further refined through specialized Reasoning SFT (Supervised Fine-Tuning) stage to create the final, reasoning-focused models: Ouro-1.4B-Thinking and Ouro-2.6B-Thinking. This section details the model architecture, data composition, and specific configurations used in each of these training stages."
        },
        {
            "title": "4.1 Transformer Architecture",
            "content": "Our Ouro models are built upon the standard decoder-only Transformer architecture [31], prioritizing clean implementation of the looped computation mechanism without extraneous modifications. The core architecture consists of stack of identical Transformer blocks, which are applied recurrently. Each block uses Multi-Head Attention (MHA) with Rotary Position Embeddings (RoPE) [32] to handle sequence order. For computational efficiency, The feed-forward network (FFN) in each block utilizes SwiGLU activation [33]. To enhance training stability, which is especially critical for deep recurrent computation, we employ sandwich normalization structure. This places an RMSNorm layer before both the attention and FFN sub-layers, an approach noted in prior literature to improve stability in loop transformers [15]. Table 1 Ouro model architecture configurations. Both models share the same vocabulary and core component types, differing in parameter count and layer depth. Model Parameters Layers Hidden Size (dmodel) Attention FFN Pos. Embed. Vocab Size Ouro 1.4B Ouro 2.6B 1.4B 2.6B 24 48 2048 MHA MHA SwiGLU SwiGLU RoPE RoPE 49,152 49,152 For both models, we use shared vocabulary of 49,152 tokens, reused from the SmolM2 [34] model. This tokenizer is optimized for languages with Latin alphabet and code and contains no Chinese tokens. Our inclusion of Chinese data in Stage 1 thus resulted in highly inefficient tokenization and poor performance. Consequently, we removed all Chinese data from Stage 2 onwards to focus our training budget on English and code. This limited vocabulary may also impose constraints on the models advanced mathematical reasoning capabilities due to potential lack of specialized symbols. This shift is reflected in the data compositions detailed in the following sections."
        },
        {
            "title": "4.2 Data",
            "content": "As data defines the capability boundaries of large foundational models, our model is trained on diverse collection of datasets spanning multiple domains and stages, including web data, mathematical content, code, and long-context documents, enabling it to perform acquire fundamental language understanding and perform advanced reasoning, coding, and long-context understanding through unified training pipeline. In addition to standard web crawl datasets, we adopt specialized datasets for mathematical reasoning and code generation to further enhance the models capabilities for complex problem-solving. In Table 2, we summarize the composition and quantity of our training data across different stages. In the following sections, we detail our dataset sources, preparation protocols, and data mixing strategies. 4.2.1 Data Composition The capabilities of modern language models primarily stem from their training data, and this principle holds true for our model as well. To ensure reproducibility, our training corpus is entirely composed of open-source datasets, with data statistics summarized in Table 3. We partition the data into four distinct subsets, called stages, each employing different data construction strategies that align with the Warmup-Stable-Decay (WSD) [35] learning rate scheduler, which is widely adopted in modern language model pretraining. Stage 1: Pre-training The pre-training stage supports the warmup and stable phases of training. The dataset is primarily composed of Web CommonCrawl (CC) data. Since our objective is to train the model on more than 2T tokens, many commonly used open-source datasets would not suffice: Fineweb-Edu [36] provides 1.3T tokens, and DCLM [37] offers 2.6T tokens. We select Nemotron-CC [38] (6.3T tokens) as the main 9 Table 2 Statistics of the training corpus. Since data are randomly sampled during pre-training, the dataset size does not directly correspond to the total number of seen tokens. Data Source Nemotron-CC (Web Data) MAP-CC (Web Data) Ultra-FineWeb-zh (Web Data) OpenCoder-pretrain MegaMath-web MegaMath-high-quailty Nemotron-CC-Math-v1 Nemotron-Code Nemotron-SFT-Code Nemotron-SFT-General OpenCoder-Annealing ProLong-64K Mid-training SFT Mix Stage # Tokens (B) # Used Tokens (B) Stage 1 Stage 1 Stage 1 Stage 1 Stage 1 Stage 2 Stage 2 Stage 2 Stage 2 Stage 2 Stage 2 Stage 3 Stage 4 6386 800 120 450 247 64 210 53 48 87 7 20 182 4404 780 120 450 246 64 210 53 48 87 7 20 90 Table 3 Data composition for Stage 1 (Pre-training Phase & II). Total dataset size: 6T tokens. Data Source Proportion (%) Nemotron-CC MAP-CC Ultra-FineWeb-zh OpenCoder-pretrain MegaMath-web 73.4 13.0 2.0 7. 4.1 dataset for the stable phase due to its large scale and suitability for our training requirements. To provide the model with basic Chinese proficiency, we include Ultra-FineWeb-zh [39] and MAP-CC [40]. Additionally, to enhance coding and mathematical abilities, we incorporate OpenCoder [41] and MegaMath [42]. Stage 2: Continual Training (CT) Annealing The CT annealing stage incorporates higher-quality data to enhance the model under the annealing learning rate. We construct our dataset using the high-quality subset of Nemotron-CC as the base. To further strengthen mathematical, coding, and general capabilities, we incorporate the high-quality subset of MegaMath, Nemotron-CC-Math-v1 [43, 44], OpenCoder-Annealing [41], Nemotron-Pretraining-Code-v1 [44], and Nemotron-Pretraining-SFT-v1 [44]. Table 4 Data composition for Stage 2 (CT Annealing). Total dataset size: 1.4T tokens. Data Source Nemotron-CC-high-quailty Nemotron-CC-Math-v1 MegaMath-high-quailty OpenCoder-LLM/opc-annealing-corpus Nemotron-Pretraining-Code-v1/Synthetic-Code Nemotron-Pretraining-SFT-v1/Nemotron-SFT-Code Nemotron-Pretraining-SFT-v1/Nemotron-SFT-General Proportion (%) 66.5 15.0 4.6 0.5 3.8 3.4 6. Stage 3: Long Context Training (LongCT) The LongCT stage extends the long-context capabilities of the model. We adopt the 64K-length subset of ProLong [45], consisting of 20B tokens, to train the model on longer sequences and improve its ability to handle long contexts. Stage 4: Mid-training The mid-training stage leverages wide and diverse set of extremely high-quality data, consisting of both Question, Answer and Question, CoT, Answer samples, to further enhance the models advanced abilities. We integrate more than 20 open-source supervised fine-tuning (SFT) datasets to maximize data diversity, while conducting thorough decontamination to minimize potential overlaps with mainstream evaluation benchmarks. All samples are converted into ChatML format to reduce alignment 10 tax in the subsequent post-training stage. After processing the previous datasets, we obtain total of 182B tokens, from which we sample 90B tokens to form the newly incorporated datasets. To ensure stable data distribution during training, 30B tokens from Stage 1 and 180B tokens from Stage 2 are replayed, resulting in an effective training volume of 300B tokens. Consequently, this stage is designed to push the model to the limits of its advanced abilities developed during pretraining."
        },
        {
            "title": "4.3 Pre and Mid-Training",
            "content": "We adopt multi-stage training strategy using dynamic mixture of the curated data described, specifically: Pre-training stage (split into two phases with different recurrent configurations), CT Annealing stage for quality enhancement, LongCT stage for context extension, and Mid-training stage for advanced capability refinement. Throughout our training pipeline, we train the model with maximum of 4 recurrent steps."
        },
        {
            "title": "4.3.1 Training Stability and Adaptive Configuration",
            "content": "During training, we prioritized stability over aggressive scaling, making several key adjustments based on empirical observations of training dynamics. These decisions were critical for achieving stable convergence with recurrent architectures, which exhibit different optimization characteristics compared to standard transformers. Recurrent Step Reduction for Stability. Our initial experiments with 8 recurrent steps in Stage 1a reveal training instabilities, including loss spikes and gradient oscillations. We hypothesize this stems from the compounding gradient flow through multiple recurrent iterations, which can amplify small perturbations. Consequently, we reduced the recurrent steps from 8 to 4 in Stage 1b, finding this sweet spot balanced computational depth with training stability. Batch Size Scaling. To further enhance stability, we progressively increased the batch size from 4M to 8M tokens. Larger batch sizes provide more stable gradient estimates, which is particularly important for recurrent architectures where gradient flow through multiple iterations can introduce additional variance. KL Divergence Coefficient Reduction. We strategically reduced β from 0.1 in Stage 1a to 0.05 in subsequent stages. This reduction serves dual purposes: (1) it decreases the conflicting gradients between task loss and the KL penalty, leading to more stable optimization, and (2) it reduces the pull from the uniform Table 5 Training recipe for both Ouro 1.4B and 2.6B. Stage 1a Pre-train Stage 1b Pre-train II CT Annealing Stage 2 Stage 3 LongCT Stage 4 Mid-training Hyperparameters Learning rate (Final) LR scheduler Weight decay Gradient norm clip Optimizer Batch size (tokens) Sequence length Training tokens Recurrent steps β for KL divergence RoPE base Data Focus Web data Math & Code Long-context SFT-quality 3.0 104 Constant 4M 8M 4K 3T 8 0.1 10K High Low None None 3.0 105 Constant 1.0 105 Cosine Decay 3.0 104 Constant 3.0 105 Cosine Decay 0.1 1.0 AdamW (β1 = 0.9, β2 = 0.95) 8M 16K 1.4T 40K 4 0.05 Medium High Low Low 64K 20B 1M Low Low High Low 32K 300B 1M Low High Medium High 4K 3T 10K High Low None None 11 prior, allowing the model greater freedom to explore beneficial depth patterns without being artificially constrained. This adjustment was crucial for maintaining stable training dynamics while enabling the model to learn effective depth allocation."
        },
        {
            "title": "4.3.2 Stage-wise Training Details",
            "content": "We utilize the flame [46] framework for performing pretraining, built upon torchtitan [47]. To fully utilize our resources, we adopt an upcycling strategy that enables efficient scaling of model capacity during training. Stage 1a: Pre-training Phase (Exploration Phase). We initially train the model on 3T tokens of web data from Nemotron-CC with 8 recurrent steps. The training uses the Warmup-Stable-Decay (WSD) learning rate scheduler with peak learning rate of 3 104. The sequence length is set to 4K tokens with an initial batch size of 4M tokens, gradually increased to 8M for stability. During this phase, we observed training instabilities that prompted our subsequent architectural adjustments. Stage 1b: Pre-training Phase II with Stability-Driven Upcycling. After identifying stability issues in Stage 1a, we implemented an architectural pivot: reducing recurrent steps from 8 to 4. To maintain computational efficiency while improving stability, we split our approach into two variants: Variant 1: 1.4B parameter model maintaining 24 layers with 4 recurrent steps Variant 2: 2.6B parameter model created through layer stacking (48 layers) with 4 recurrent steps The recurrent nature of our architecture makes this upcycling process particularly smooth, as the shared weights across iterations naturally facilitate layer duplication without the typical instabilities seen in standard transformer upcycling. Both variants are trained on an additional 3T tokens with the stabilized configuration. The data composition is carefully balanced as shown in Table 3. Stage 2: CT Annealing. Building on the stable foundation from Stage 1b, we enhance the model with higher-quality data while annealing the learning rate to 3 105. The training corpus comprises 1.4T tokens with increased emphasis on mathematical and coding capabilities. >We extend the sequence length to 16K tokens, exceeding the length of most samples to minimize truncation and better utilize the enhanced data quality. The recurrent steps remain at 4, having proven optimal for the stability-performance trade-off. The data composition is carefully balanced as shown in Table 4. Stage 3: LongCT. This stage focuses on extending the models context window capabilities. We train on 20B tokens from the ProLong-64K dataset with sequences of 64K tokens, maintaining the batch size at 8M tokens. The reduced KL coefficient (β = 0.05) continues to provide stable training dynamics even with these extended sequences. Stage 4: Mid-training. The final stage leverages 90B tokens of extremely high-quality SFT data, consisting of both <Question, Answer> and <Question, CoT, Answer> samples. All SFT-style data is converted to ChatML format to facilitate subsequent post-training alignment. The learning rate is further reduced to 1 105 with cosine scheduler to help the model better absorb on this diverse, high-quality dataset. Optimization Configuration. Throughout all stages, we use AdamW optimizer with weight decay set to 0.1, β1 = 0.9, β2 = 0.95, and gradient clipping at 1.0. These conservative settings were chosen specifically to maintain stability with recurrent architectures. Learning Rate Considerations. We empirically found that recurrent architectures require smaller learning rates compared to standard transformers of equivalent parameter count. While resource constraints prevented exhaustive hyperparameter search, our chosen rates represent conservative values that prioritized stable convergence over potentially faster but riskier optimization trajectories. Sequence Length Progression. The sequence length is progressively increased across stages: 4K tokens for both pre-training phases, 16K for continual training with learning rate annealing, 64K for long-context training, and 32K for mid-training. This gradual progression helps maintain stability while enhancing the training throughput and expanding the models long-context capability."
        },
        {
            "title": "4.4 Supervised Fine-Tuning\nData Composition. We perform supervised fine-tuning (SFT) on a diverse corpus of approximately 8.3M\nexamples drawn from high-quality public datasets. As shown in Table 6, our training mixture emphasizes\nmathematical reasoning (3.5M examples) and code generation (3.2M examples), while also incorporating\nscientific reasoning (808K examples) and conversational abilities (767K examples).",
            "content": "For mathematical reasoning, we combine OpenThoughts3 [48] and AceReason-1.1-SFT [49] to provide comprehensive coverage of problem-solving strategies. Our code training data aggregates multiple sources including AceReason-1.1-SFT, OpenCodeReasoning [50], Llama-Nemotron-Post-Training-Dataset [51], and OpenThoughts3, ensuring broad exposure to diverse programming paradigms and reasoning patterns. Scientific reasoning capabilities are developed through OpenThoughts3 and Llama-Nemotron-Post-Training-Dataset, while conversational proficiency is enhanced using the OO1-Chat-747K2 and DeepWriting-20K [52] datasets. Training Configuration. We train for 2 epochs with maximum sequence length of 32K tokens using the LlamaFactory codebase [53]. We employ the Adam optimizer with learning rate of 2 105 and β = (0.9, 0.95), applying cosine decay schedule for stable convergence.3 Table 6 Supervised fine-tuning data composition. The training corpus comprises 8.3M examples across four key capability domains. Topic Math Code Data Source OpenThoughts3, AceReason-1.1-SFT AceReason-1.1-SFT, OpenCodeReasoning, Llama-Nemotron-PostTraining-Dataset, OpenThoughts3 Science OpenThoughts3, Llama-Nemotron-Post-Training-Dataset Chat OO1-Chat-747K, DeepWriting-20K Size 3.5M 3.2M 808K 767K"
        },
        {
            "title": "4.5 Reinforcement Learning Attempts",
            "content": "Following the SFT stage, we conducted exploratory RLVR (Reinforcement Learning with Verifiable Rewards) alignment experiments using algorithms such as DAPO [54] and GRPO [55] on the DAPO-17K dataset. However, these attempts did not yield significant performance gains over the final SFT checkpoint. We hypothesize two primary reasons for this. First, Model Saturation: the models are relatively small and had already undergone extensive SFT, which may have saturated their capabilities and left little room for further improvement via RL. Second, Infrastructure Challenges: the unique LoopLM architecture posed difficulties for our RL infrastructure. Specifically, our vLLM-based system could not efficiently perform rollouts with dynamic early exits and subsequently use that variable-depth information for the update step. This forced us to adopt trade-off solution for training and inference. We explored two main strategies based on these constraints: 1. Fixed 4-Round RL: We performed both rollouts and updates using fixed 4 recurrent steps. In this setup, model performance increased normally but did not surpass the SFT checkpoint. Interestingly, we found that even when trained at fixed 4-round depth, the model could still utilize fewer rounds at inference time, behaving as incentivized by the RL objective. The reason for this generalization is currently unknown. 2. Adaptive RL: We attempted to perform both rollouts and updates using the models native adaptive early exit mechanism. This approach failed to yield performance improvements, which we primarily attribute to the infrastructure challenges in handling the dynamic computational graphs. 2https://huggingface.co/datasets/m-a-p/OO1-Chat-747K 3Training was interrupted due to infrastructure issues; we resumed from the last saved checkpoint with learning rate close to the original cosine decay schedule. 13 We will further explore RL alignment for this architecture as we continue to develop infrastructure that can fully support LoopLMs dynamic computation."
        },
        {
            "title": "5.1 Base Model Evaluation",
            "content": "We conduct comprehensive evaluations of the Ouro base models trained on 7.7T tokens using the LoopLM architecture. The evaluation focuses on their performance across general knowledge, reasoning, mathematics, science, coding, and multilingual capabilities. All benchmarks are evaluated using lm-eval-harness [56] and evalplus [57] frameworks with settings detailed in Appendix. C.1. For the base model baselines, we compare our Ouro models with leading open-source base models, including Qwen2.5 [2], Qwen3 [3], Gemma3 [4], Llama3.1 [5], and Llama3.2 [5] series base models. All models are evaluated using the same evaluation pipeline to ensure fair comparison. Table 7 Comparison of 1.4B LoopLM model with 1-4B parameter baselines. The best score is bolded, and the second-best is underlined. LoopLMs column is highlighted in gray. Gemma3 Llama3.2 Qwen2.5 Qwen3 Qwen2.5 Llama3.2 Qwen3 Gemma3 Ouro 1B Dense 1.0B 2T 1.2B Dense 1.0B 9T 1.5B Dense 1.5B 18T 1.7B Dense 1.7B 36T 3B Dense 3.0B 18T 3B Dense 3.0B 9T 4B Dense 4.0B 36T 4B 1.4B R4 Dense 4.0B 4T LoopLM 1.4B 7.7T 39.85 11.31 30.26 39.25 56.12 58.72 2.05 41.00 6.70 5.50 12.40 10.10 45.46 11.80 30.72 41.98 59.35 62. 7.05 7.40 19.50 17.40 35.70 29.10 General Tasks 62.46 37.27 53.51 55.72 67.09 66.30 65.62 37.87 55.37 55.46 74.54 70.17 60.99 29.11 43.66 54.44 67.73 66.77 Math & Coding Tasks 60.73 17.60 52.40 46.30 60.30 50.00 70.28 25.80 66.50 59.80 68.00 58.50 74.60 42.60 68.90 62.20 63.00 54.20 59.69 33.34 39.45 52.47 73.09 69.14 67.20 40.80 29.90 26.20 50.30 39.70 73.19 51.40 70.95 63.65 75.66 71. 72.86 59.60 77.40 70.70 78.80 65.90 58.37 34.61 66.32 60.92 75.58 71.07 68.69 68.60 34.80 29.30 60.60 51.10 67.35 48.62 71.02 60.92 74.29 72.30 78.92 82.40 74.40 67.40 73.00 62.70 Architecture # Params # Tokens MMLU MMLU-Pro BBH ARC-C HellaSwag Winogrande GSM8K MATH500 HumanEval HumanEval+ MBPP MBPP+ Summary of Evaluation Results Based on the overall evaluation results, we highlight key conclusions about our base models: (1) Our 1.4B parameter Ouro model (with 4 recurrent steps) achieves performance comparable to the 4B Qwen3-Base across most benchmarks. Notably, it matches or exceeds the 4B model on challenging reasoning tasks such as BBH (71.02 vs 70.95), GSM8K (78.92 vs 72.86) and MATH500 (82.40 vs 59.60) (2) The 2.6B parameter Ouro model outperforms dense models up to 8B parameters on reasoning-intensive benchmarks. It achieves 55.73 on MMLU-Pro, 80.46 on BBH and 90.85 on MATH500, surpassing the 8B Qwen3-Base (53.72, 77.65 and 62.30 respectively). (3) The recurrent architecture shows particular strength on tasks requiring multi-step reasoning and knowledge manipulation, with the most pronounced gains observed on MMLU-Pro, BBH, GSM8K and MATH500 benchmarks, validating our hypothesis that iterative computation enhances reasoning capabilities. 14 Table 8 Comparison of 2.6B LoopLM model with 3-12B parameter baselines. The best score is bolded, and the second-best is underlined. LoopLMs column is highlighted in gray. Qwen2.5 Llama3.2 Qwen3 Gemma3 Qwen2.5 Llama3.1 Qwen3 Gemma3 Ouro Architecture # Total Params # Trained Tokens 3B Dense 3.0B 18T 3B Dense 3.0B 9T 4B Dense 4.0B 36T 4B Dense 4.0B 4T 7B Dense 7.0B 18T 74.20 43.55 53.72 63.65 79.98 76.48 General Tasks 73.19 51.40 71.14 63.65 75.66 71.19 58.37 34.61 66.32 60.75 75.58 71. Math & Coding Tasks 72.86 59.60 77.70 70.70 78.80 65.90 68.69 68.60 34.80 29.30 60.60 51.10 81.50 61.20 79.30 70.60 73.80 63.50 8B Dense 8.0B 15T 8B Dense 8.0B 36T 12B 2.6B R4 Dense 12.0B 12T LoopLM 2.6B 7.7T 73.02 43.24 71.56 60.75 81.97 77.11 78.17 52.90 38.40 31.10 62.40 51.60 76.63 53.72 77.65 66.10 79.60 76.80 83.09 62.30 84.80 75.30 79.00 67.90 72.14 49.21 78.41 72.44 83.68 77.74 77.18 83.20 46.30 37.20 73.50 66. 74.60 55.73 80.46 66.40 79.69 75.85 81.58 90.85 78.70 70.70 80.40 66.60 MMLU MMLU-Pro BBH ARC-C HellaSwag Winogrande GSM8K MATH500 HumanEval HumanEval+ MBPP MBPP+ 65.62 37.87 55.37 55.46 74.54 70.17 74.60 42.60 68.90 62.20 63.00 54. 59.69 33.34 39.45 52.47 73.09 69.14 67.20 40.80 29.90 26.20 50.30 39.70 Table 9 Performance comparison across different benchmarks. For AIME24 and AIME25, we report pass@1/pass@10 metrics. The best score is bolded, and the second-best is underlined. Model AIME24 pass@ pass@10 AIME25 pass@1 pass@10 Ouro-1.4B-Thinking-R4 Ouro-2.6B-Thinking-R4 Qwen3-1.7B Qwen3-4B Qwen3-8B Deepseek-Distill-Qwen-1.5B Deepseek-Distill-Qwen-7B 65.0 64.7 32.0 61.3 73.0 29.6 57.3 83.3 90.0 55.6 75.0 86.7 66.7 83. 46.3 50.3 22.0 51.3 66.7 23.0 36.0 73.3 76.7 33.3 63.3 81.3 43.33 73. Olympiad bench 71.6 76.4 56.4 73.2 75.3 56.44 72.0 Beyond HLE AIME 34.0 39.0 15.0 31.0 38. 9.0 30.0 5.21 5.58 4.13 5.21 2.22 4.2 5.14 Super GPQA GPQA 47.4 45.5 52. 34.0 54.5 59.1 33.2 51.0 53.7 35.9 51.9 48.0 26.5 46."
        },
        {
            "title": "5.2 Reasoning Model Evaluation\nWe evaluate the reasoning capabilities of our Ouro reasoning models (Ouro-Thinking) with 4 recurrent steps\non challenging mathematical and scientific benchmarks that require multi-step problem solving and deep\nreasoning. The evaluation includes AIME 2024/2025 (American Invitational Mathematics Examination),\nOlympiadBench, GPQA, SuperGPQA, BeyondAIME, and HLE, representing some of the most challenging\nreasoning tasks in the field.",
            "content": "Benchmarks. AIME 2024/2025 [58]. 30 questions per year from AIME and II; integer answers 0999. OlympiadBench [59]. Olympiad-level bilingual scientific problems; supports images for multimodal inputs. GPQA [60]. 448 graduate-level multiple-choice questions in biology, physics, and chemistry; searchresistant design. SuperGPQA [61]. GPQA scaled to about 285 graduate disciplines; curated to remain challenging. BeyondAIME [62]. Hard integer-answer math beyond AIME; emphasizes contamination resistance. HLE [63]. Multi-disciplinary closed-ended benchmark; expert-written with public splits and private test set. Models compared. We report results for Ouro-1.4B-Thinking and Ouro-2.6B-Thinking, which are LoopLMbased looped language models with iterative depth. As baselines we include Qwen3-1.7B, Qwen3-4B, Qwen3-8B, DeepSeek-Distill-Qwen-1.5B, and DeepSeek-Distill-Qwen-7B. We use size-matched baselines whenever available, otherwise we compare to the next larger widely used model. Evaluation protocol. All systems are evaluated with single in-house harness and identical prompting. We adopt an LLM-as-judge protocol across benchmarks with fixed rubric and tie-breaking policy. Unless otherwise noted, decoding uses temperature = 1.0 and top_p = 0.7 for every model. Evaluation results. Table 9 summarizes outcomes. Iterative reasoning in the LoopLM architecture provides consistent gains on these tasks. The 1.4B Ouro model with 4 recurrent steps reaches 71.55 on OlympiadBench (vs. 73.18 for Qwen3-4B) and 34.0 on BeyondAIME (vs. 31.0 for Qwen3-4B). The 2.6B with 4 recurrent steps variant scores 76.44 on OlympiadBench (vs. 75.25 for Qwen3-8B) and 39.0 on BeyondAIME (vs. 38.0 for Qwen3-8B)."
        },
        {
            "title": "5.3 Performance by Recurrent Depth and Extrapolation",
            "content": "Table 10 Performance of the Ouro 1.4B base model across different recurrent steps (C-QA is CommonsenseQA [64]). Steps 5-8 represent extrapolation, as the model was trained with maximum of 4 steps. Performance peaks at the trained depth (T = 4) and then degrades. UT Step ARC-C (25-shot) ARC-E (8-shot) C-QA (10-shot) HellaSwag (10-shot) MMLU (5-shot avg) Winogrande (5-shot) 1 2 3 4 37.63 54.86 59.47 60.92 63.85 80.30 83.33 83.96 Extrapolation (Trained on T=4) 5 6 7 8 58.96 59.73 58.96 58.19 82.91 82.58 81.99 82.07 44.64 67.98 74.37 75.43 75.35 74.94 74.28 73.55 55.24 71.15 74.07 74. 73.72 72.77 72.35 71.60 41.21 60.43 66.71 67.45 66.64 65.77 65.28 64.49 56.99 66.69 71.35 72.30 70.32 71.03 70.09 69.30 We analyze the Ouro models performance as function of its recurrent computational depth. Our models were trained with maximum of 4 recurrent steps (T = 4). We investigate this behavior for both our base models and our SFT Ouro-Thinking models. Base Model Performance. Tables 10 and 11 present the performance of the Ouro 1.4B and 2.6B base models, respectively, evaluated at depths from = 1 to = 8. For both base models, performance on standard benchmarks (e.g., MMLU, ARC-C) generally improves up to the trained depth of = 4. Steps = 5 through = 8 represent extrapolation beyond the training configuration. As shown in both tables, benchmark performance sees moderate degradation when extrapolating, with noticeable drop compared to the peak at = 4. However, this degradation in task-specific performance contrasts sharply with the models safety alignment. As detailed in Section 7.1, the models safety improves as the number of recurrent steps increases, even into the 16 Table 11 Performance of the Ouro 2.6B base model across different recurrent steps (C-QA is CommonsenseQA [64]). Steps 5-8 represent extrapolation, as the model was trained with maximum of 4 steps. Performance is strongest around the trained depth (T = 4) and shows varied degradation patterns during extrapolation. UT Step ARC-C (25-shot) ARC-E (8-shot) C-QA (10-shot) HellaSwag (10-shot) MMLU (5-shot avg) Winogrande (5-shot) 1 2 3 47.95 62.37 65.36 66.38 72.39 85.23 87.33 86.95 Extrapolation (Trained on T=4) 5 6 7 8 65.36 65.02 65.44 64.76 86.83 86.74 86.57 86. 57.58 76.90 79.77 81.65 81.24 81.08 80.75 81.08 68.94 77.61 79.12 79.56 79.57 79.63 79.59 79.50 51.55 67.63 73.57 74.60 74.43 73.79 72.92 72. 61.48 70.48 74.35 75.53 75.93 75.37 75.77 74.59 Table 12 Performance of Ouro-1.4B-Thinking model by recurrent step. The model was trained at = 4. Performance peaks around = 4 or = 5. All scores are percentages (0-100). Benchmark OlympiadBench SuperGPQA AIME 2024 AIME 2025 T= 2.22 2.03 0.00 0.33 T=2 T=3 59.70 33.07 37.33 25.00 70.67 44.50 62.33 43.33 T= T=5 T=6 72.30 69.48 71.55 46.15 47.37 48.73 65.00 60.67 50.67 47.00 43.00 46.30 T=7 T=8 69.04 45.29 42.33 41.00 66.81 42.88 38.67 38.00 extrapolated regime (T > 4). This suggests that while the models fine-grained knowledge for benchmarks may falter beyond its training depth, the iterative refinement process continues to enhance its safety alignment. Reasoning Model (SFT) Performance. We conduct similar analysis on our SFT models, Ouro-Thinking, to see how recurrent depth affects specialized reasoning tasks. Results for the 1.4B and 2.6B models are presented in Table 12 and Table 13, respectively. We conduct similar analysis on our SFT models, Ouro-Thinking, to see how recurrent depth affects specialized reasoning tasks. Results for the 1.4B and 2.6B models are presented in Table 12 and Table 13, respectively. For both SFT models, performance at = 1 is very low, confirming that iterative refinement is essential for these complex tasks. Performance generally peaks at or near the trained depth, but shows slightly different patterns. The 1.4B model  (Table 12)  peaks around = 4 or = 5. The 2.6B model  (Table 13)  tends to peak slightly earlier, at = 3 or = 4. Interestingly, neither model peaks strictly at = 4 across all tasks, unlike the base model evaluations which are often logit-based. This may suggest that the longer decoding required for these reasoning tasks allows for more active exploration of capabilities at different recurrent depths. For both models, performance degrades as they extrapolate to deeper, unseen recurrent steps (T = 6 8), reinforcing that performance is optimized for the depth seen during training. Table 13 Performance of Ouro-2.6B-Thinking model by recurrent step. The model was trained at = 4. Performance peaks at = 3 or = 4. All scores are percentages (0-100). Benchmark T= T=2 T=3 OlympiadBench SuperGPQA AIME 2024 AIME 2025 18.96 15.66 3.00 2.00 68.59 48.58 52.00 40.67 T=4 T=5 76.44 71.85 56.45 57.00 49. 75.56 56.70 53.68 64.70 70.33 50.30 50.67 T=6 T=7 T=8 69.19 55.44 56.33 46.00 57.63 53.32 49.67 38. 39.26 46.84 39.00 24."
        },
        {
            "title": "5.4 Early Exit and Adaptive Computation Efficiency",
            "content": "A defining advantage of the LoopLM architecture lies in its capacity for adaptive computation allocation. Unlike standard transformers with fixed computational budgets, our model can dynamically adjust the number of recurrent steps based on input complexity. This section investigates various strategies for implementing adaptive early exit, comparing their effectiveness in balancing computational efficiency with task performance."
        },
        {
            "title": "5.4.1 Early Exit Strategies",
            "content": "We explore three distinct approaches to determining when the model should terminate its iterative computation and produce the final output. Baseline: Static Exit. The simplest strategy forces the model to exit at predetermined recurrent step, regardless of the input characteristics. While this approach provides predictable computational costs, it fails to leverage the models potential for adaptive resource allocation. We evaluate static exit at steps 1 through 4 to establish performance bounds and understand the relationship between computational depth and accuracy. Hidden State Difference Threshold. This heuristic-based approach monitors the magnitude of representational changes between consecutive recurrent steps. At each step t, we compute ht = ht ht12 and trigger early exit when ht < ϵ for some threshold ϵ. Learned Gating with Q-Exit Criterion. Our primary approach employs the learned exit gate described in Section 4, which produces step-wise halting probabilities λt based on the models current hidden states. During inference, we apply the Q-exit criterion: at each step t, we compute the cumulative distribution function CDF(t) = (cid:80)t i=1 p(ix) and exit when CDF(t) exceeds the threshold [0, 1]. The threshold serves as deployment-time hyperparameter that controls the compute-accuracy trade-off without requiring model retraining. We evaluate this strategy under two training configurations. The untrained configuration uses the gate as trained during our standard pretraining pipeline with the entropy-regularized objective (uniform prior KL loss). This represents the gates behavior when jointly optimized with language modeling throughout Stages 1-4. The trained configuration additionally applies the specialized adaptive exit loss described in Section 3.4, which explicitly teaches the gate to base stopping decisions on observed task loss improvements. Figure 5 Comparison of early exit strategies on MMLU. We evaluate four approaches across different average exit rounds: static baseline (red triangle), hidden state difference threshold (green squares), Ponder gate from standard pretraining (blue circles), and Ponder gate with specialized adaptive exit training from Section 3.4 (orange diamonds). Experimental Results. Figure 5 presents the accuracy-efficiency trade-off curves for all strategies on the MMLU benchmark. By varying the exit threshold (or static exit step for baseline), we obtain multiple operating points for each method, enabling direct comparison at equivalent computational budgets measured by average exit round. Several key findings emerge from this analysis: 1. The Ponder gate with specialized adaptive exit training achieves the best accuracy at every computational budget, demonstrating that the loss improvement-based training signal described in Section 3.4 provides 18 clear benefits over standard entropy regularization. At an average exit round of 2.5, the specialized training reaches 66% accuracy while the standard gate achieves approximately 64%; 2. Even without specialized training, the Ponder gate from standard pretraining substantially outperforms the static baseline, validating that the entropy-regularized objective with uniform prior successfully enables adaptive computation. The gate learns to differentiate input difficulty through the general training dynamics, though it lacks the explicit supervision to correlate stopping decisions with actual performance improvements. This demonstrates that our base training approach already captures useful signals for resource allocation; 3. The hidden state difference threshold strategy performs surprisingly competitively, closely tracking both gate configurations. At moderate computational budgets (2-3 average rounds), it achieves accuracy within 1%-2% of the specialized trained gate, suggesting that representation stability provides reasonable proxy for computational convergence. However, the consistently superior performance of the specialized trained gate across all operating points confirms that explicit supervision via the adaptive exit loss captures information beyond what can be inferred from representational dynamics alone. 4. Comparing the untrained and trained gate configurations reveals the value proposition of the specialized training procedure. The gap between these curves, approximately 2%-3% accuracy at most operating points, represents the benefit of teaching the gate to explicitly monitor task loss improvements (n) rather than relying solely on entropy regularization to discover stopping policies. This empirical result validates our design choice to introduce the adaptive exit loss as specialized training objective. 5. The baselines monotonic improvement from 1 to 4 rounds confirms the deeper is better property while revealing diminishing returns. The dramatic jump from 1.0 to 2 rounds (40% to 60% accuracy) contrasts with the marginal gain from 3 to 4 rounds (67.35% accuracy). This pattern explains why adaptive methods prove effective: most examples achieve near-maximal performance at intermediate depths, with only minority requiring full computational depth. 5.4.2 KV Cache Sharing for Inference Efficiency The recurrent nature of our architecture introduces challenge: naively, each recurrent step requires maintaining its own KV cache, leading to 4 memory overhead for our 4-step model. We investigate strategies to reduce this overhead through KV cache reuse. Prefilling Phase During the prefilling phase (processing the input prompt), we find that all four recurrent steps require their own KV caches, as each step transforms the representations in ways that cannot be approximated by earlier steps. Attempting to reuse KV caches during prefilling leads to performance degradation (>10 points on GSM8K). Decoding Phase However, during the decoding phase (auto-regressive generation), we discover that KV cache reuse becomes viable. We explore two strategies: 1. Last-step reuse: Only maintain KV cache from the final (4th) recurrent step 2. First-step reuse: Only maintain KV cache from the first (1st) recurrent step. 3. Averaged reuse: Maintain an averaged KV cache across all four steps As shown in Table 14, these strategies yield dramatically different outcomes. Reusing only the first steps cache results in catastrophic performance collapse (e.g., 18.73 on GSM8K, down from 78.92), indicating that the initial representations are insufficient for subsequent decoding steps. In contrast, both the last-step and averaged reuse strategies achieve nearly identical performance (within 0.3 points on GSM8K) to the full cache baseline, while successfully reducing memory requirements by 4. The last-step strategy performs slightly better than the averaged approach on MATH-500, suggesting that the final recurrent steps representations are most informative for subsequent token generation. This finding enables practical deployment of LoopLM models with memory footprints comparable to standard transformers of similar parameter count. 19 Table 14 KV cache sharing strategies during decoding. Both last-step and averaged strategies achieve minimal performance loss while reducing memory by 4. Strategy Full (4 cache) First-step only Last-step only Averaged GSM8K MATH-500 Memory Reduction 78.92 18.73 78.85 78.73 82.40 8.43 80.40 78.52 1.00 4.00 4.00 4."
        },
        {
            "title": "6 Understanding LoopLMs Superiority from a Parametric Knowledge Viewpoint",
            "content": "Why LoopLMs achieve far better performance when the parameter counts do not increase? Although potential enhanced reasoning capabilities were observed in [8], the source of the advantage remains unclear. Specifically, do LoopLMs perform better due to the models increased knowledge capacity with the same size of parameters? Or do they have better capability in extracting and composing the knowledge encoded within the parameters? Toward understanding the improvement of the phenomenon, we explore what capabilities are exactly enhanced by simply looping more times. In this section, we perform experiments to test the models abilities to memorize factual knowledge in its parameters, and the capabilities of manipulating and composing existing knowledge encoded in the parameters based on set of fully controllable synthetic tasks in [6567]."
        },
        {
            "title": "6.1 LoopLMs does not increase knowledge capacity\nWe first explore the knowledge capacity, i.e. the model’s storage capacity of facts in the parameters. We aim\nto answer the first question: do LoopLMs achieve better performance by memorizing knowledge when the\nparameter count is not increased?",
            "content": "Settings. Following the Capo task setting in Physics of language models [65, 66], we construct synthetic biographies to test how much information the model memorizes. Specifically, we generate several synthetic biographic datasets bioS(N ) with different number of people , and train series of language models to memorize the information contained in the dataset. Each biography contains the individuals name and five attributes a1, a2, ..., a5 of the person: gender, birth date, university, major, and employer. The names and the attributes ai are randomly selected from pre-defined set and Ai and combined together as biography using random template. Based on the random generation process, we have an information-theoretic lower bound for the model in the minimum bits required to encode all the names and attributes. To check whether the models memorize the biographic information accurately, we look at the probability of predicting the ground-truth attributes with the trained models given the biography context. Calculating the sum of cross-entropy loss on each attribute token positions, we can estimate how much information (estimated in bits) has already been memorized in the trained language model, which is our knowledge capacity metric. With this metric, we can compare the knowledge capacity between the original model (with only one recurrent step) and the looped model (with 4 recurrent steps) with the same parameter count to investigate whether looping increases knowledge capacity. Moreover, as larger models should encode more information than smaller models, we also aim to investigate whether looped models have better scaling effect when the size of the model grows. We thereby trained GPT-2 style models of different parameter numbers ranging from 1M to 40M (with depth and hidden dimension varied) and measured the number of bits of knowledge learned by each model. We trained on bioS(N ) with ranging from 20K to 500K individuals for 1000 exposures. More training details are provided in Section B.1. Results. The results are visualized in the plot bits vs. # of parameters, where we can observe the comparison between iso-parameter looped and non-looped models. Our results are shown in Figure 6 (Left): looping does not increase knowledge capacity nor improve capacity scaling. Models with and without loops all attain around similar capacity ratio 2 bits/parameter. Therefore, the number of parameters itself can be seen as direct indicator of knowledge capacity, and merely increasing looping does not help enhance knowledge capacity itself. 20 = 10 = 16 = 24 Baseline model Base (12 1) 93.6 94.4 34.8 Base (2 1) Loop (2 6) Base (3 1) Loop (3 4) Base (6 1) Loop (6 2) 2 layer model 3 layer model 6 layer model 21.5 98.1 75.4 97.9 84.7 93. 8.4 96.3 29.8 95.8 59.5 88.5 7.5 78.0 11.0 92.2 20.0 35. Figure 6 Left. We trained both LoopLM and standard trasnformer baseline with the same parameters on Capo task to compare the knowledge capacity gain by looping more times. With the same parameter count, the looped model and its non-looped baseline has almost the same knowledge capacity measured in bits of knowledge on Capo task. Right. Accuracy of looped/non-looped models on Mano task. Looped models are better than the iso-param ({2, 3, 6} 1) models. They also achieve better or comparable performance comparing to the iso-flop baseline (12 1) model."
        },
        {
            "title": "6.2 LoopLMs prevails in knowledge manipulation",
            "content": "We have already shown that reusing parameters cannot help the model memorize more atomic factual knowledge. However, natural language is not only about single-hop factual knowledge. In most of the scenarios, predicting the next token requires combining different piece of knowledge, which we called knowledge manipulation [65]. Does looping and reusing parameters help LoopLMs in tasks that require flexible usage of knowledge? We further consider two synthetic tasks to investigate the hypothesis on knowledge manipulation capacity: the synthetic Mano task in [66] based on modular arithmetic, and multi-hop QA task in natural language [67] composing individual facts. Mano Task. We first explore the knowledge manipulation task Mano in [66], based on complex tree structure with restricted modular arithmetic knowledge. Models need to solve the task without intermediate thinking process. As illustration, an example could be <bos> + * <eos> requires the model to directly output (a b) + mod 23. To solve this task, the model needs to (1) apply the arithmetic rules modulo 23 as the factual knowledge encoded in the parameters, and (2) parse the binary tree structure of the arithmetic to compose all calculations. To evaluate the manipulation capability thoroughly, we consider the test accuracy across different difficulty levels based on maximum expression length L, which accounts for the number of operations in the sample. The model is trained with online samples with all possible expression lengths ℓ [1, L] and tested on the maximum expression length L. We prepare three levels of difficulties = [10, 16, 24] to test LoopLMs superiority over non-looped models given fixed training budget. We train ({2, 3, 6, 12} 1) standard transformers as the baselines and several looped models (k 12/k) with = 2, 3, 6. More details are included in Appendix B.2. Results. The results in Figure 6 show that given the same parameters, looped models always outperform their non-looped counterpart for all possible {2, 3, 6}. Even with the same number of FLOPs in the model, the looped models can often perform better. This indicates that LoopLM has better inductive bias towards knowledge manipulation: with the same budget on training samples and computation, LoopLM can achieve comparable or even better performance after training when the task requires manipulation capability (e.g., parsing the arithmetic tree) given limited amount of required knowledge (e.g., modular arithmetic rules). Multi-hop QA. Next, we corroborate our conjecture with natural language multi-hop reasoning task proposed in [67], based on synthetic facts on relations between different individuals, like The instructor of is and The teacher of is C. The target is to answer multi-hop questions like Who is the teacher of the instructor of A?. We aim to study whether looping enables the original transformer better learn to perform Figure 7 We trained LoopLMs and standard transformer baselines with the same parameters on Multi-hop QA tasks. To investigate the sample efficiency of LoopLMs, we vary the number of unique training samples (from 2.5% to 25% all possible QA pairs) for models with different loops. We compare the final performance using the same compute budget in total training tokens. Left. As shown, models with more loops requires fewer samples to learn the 3-hop QA task. Right. As an example, we train with 15% of all possible QA pairs (12000 unique samples) for 20000 steps with context length 1024 and batch size 2048. Models with more loops learn faster and achieve better performance comparing with models without loops. internal multi-hop reasoning in natural language setting. Compared to the Mano task, the task requires the model to memorize more factual knowledge with layer-wise data structure, which is closer to practical natural language multi-hop reasoning. Multi-hop QA tasks require huge amount of samples to learn according to [67] when training standard transformers. To study whether LoopLMs accelerate the learning process of this multi-hop knowledge manipulation task, we consider sample efficiency in learning. Specifically, we study how many different QA pairs are necessary for the trained model to achieve 100% accuracy, as well as the performance after training on fixed budget of unique training samples. For simplicity, we focus on the task with 3-hop QA pairs. We separate all possible QA pairs into training subsets of different sizes, and compare when each model perfectly generalizes on the leave-out test set. Similarly to the Mano task, we train standard (6 1) transformer as the baseline, and compare it with looped models (6 {2, 3, 4}) to study the effect of the universal transformer. We also train an iso-flop model (24 1) for comparison. More details are included in Appendix B.3. Results. The results in Figure 7 show that looped models generally learn the multi-hop QA task with fewer examples compared to both the non-looped iso-parameter model when the training budget is the same. Moreover, LoopLMs learn the multi-hop task much faster than the non-looped model with the same number of unique QA samples. The improved sample efficiency on the multi-hop reasoning task further demonstrates that LoopLM has better ability to learn to compose and manipulate atomic factual knowledge. Based on the results in both Mano and multi-hop QAs, we can conclude that LoopLMs have better inductive bias towards more flexible manipulation of learned knowledge, instead of increasing the knowledge capacity. The conclusion holds for both synthetic tasks regardless of whether the task is more reasoning-heavy (Mano) or knowledge-heavy (Multi-hop QA). This also corresponds to the analysis (see Appendix B.4) on the existing benchmarks (e.g. MMLU): adding more recurrent steps significantly improves the performance on more reasoning-heavy categories, while the improvements on more knowledge-heavy tasks is limited."
        },
        {
            "title": "6.3 Discussion: towards understanding why LoopLM helps knowledge manipulation",
            "content": "Why does LoopLM naturally bias towards better manipulation of the knowledge encoded in the parameter space? We conjecture that the reason lies in the inherent recurrent structure of LoopLM. Given that the knowledge capacity is limited by the parameter counts, looping enables LoopLM to better utilize the knowledge encoded in the parameters. LoopLM can reuse the knowledge in each looped block, retrieve new necessary factual information, or apply structured procedures to obtain the final prediction. Search on the parametric knowledge graph. During pretraining, language models often obtain an enormous 22 amount of factual knowledge and learn analysis procedures with rather shallow thinking depth. To perform more challenging tasks, the model needs to use multiple pieces of knowledge in the parameter space, which requires the model to search in-depth in the knowledge graph with directional dependencies formed by the atomic facts or knowledge. LoopLM naturally support an efficient reuse of the knowledge and algorithms stored in the parameter spaces: even though the knowledge piece is not retrieved or used in the previous calculations, the recurrent structure enables LoopLM to redo the procedure and extract necessary information. Based on the abstraction above, we try to understand why LoopLMs are able to search on knowledge graph without adding more parameters. Specifically, we study the expressivity of LoopLM on synthetic task. We consider the extensively studied search problem in the literature of latent reasoning [24, 68, 69]: graph reachability on knowledge graph. Here, we consider that only part of the knowledge graph Gctx is included in the context, and most of the knowledge relations must be encoded in the parameters. The model must learn to compose the context knowledge Gctx and the learned knowledge G. Compared to traditional CoT and recent proposed latent CoT [24, 68], we show that LoopLM is parallelizable latent reasoning paradigm that requires fewer sequential reasoning steps. Theorem 1 (Informal). Fix as the maximum size of the combined knowledge graph G. Given the adjacency matrix of the context graph Gctx and query pair (s, t), there exists one-layer transformer independent of Gctx with loops O(log2 D) times that checks whether there exists path from to in the combined knowledge graph (G + Gctx), where is the diameter of (G + Gctx). Latent reasoning method Discrete CoT Continuous CoT Universal Transformer Sequential computation steps O(n2) O(D) O(log D) The proof and the discussion on LoopLMs efficiency are deferred to Appendix B.5. We claim that the universal transformers maximize the parallelism in exploring all-pair connectivity and reduce the sequential computation steps exponentially from O(n2) to O(log D), making the latent reasoning much more efficient than the traditional CoT view of looping [8] and continuous CoT [68]. The potential efficient latent reasoning ability may account for the superiority of LoopLM in knowledge manipulation, which also may contribute to the superior performance in reasoning-heavy tasks. Recurrence improves sample efficiency. The expressiveness result of LoopLM does not explain why the transformers with loops often learns knowledge manipulation tasks with samples much fewer than its iso-FLOP counterpart. We conjecture that the reason lies again in the recurrent structure of LoopLM. Assuming the reasoning tasks require multiple manipulation and recursion using learned parametric knowledge or algorithmic procedure, the models have to learn repeated structure across layers of different depth. For deep transformer models without looping, they potentially have to explore large function class where each block of parameters are not tied. The parameter-sharing layers may help the model explore much smaller realizable hypothesis class, thus reducing the sample complexity of learning those manipulation tasks. It could be possible statistical reason that LoopLM enjoys better sample complexity on those reasoning/manipulation tasks."
        },
        {
            "title": "7.1 Safety",
            "content": "We assess model safety using HEx-PHI dataset [17], which contains 330 examples covering 11 prohibited categories. HEx-PHI employs GPT-4o as judge to assign each model response harmfulness score from 1 to 5; higher score indicates less safe output. Additionally, we compute the harmfulness rate, defined as the proportion of the test cases that receive the highest harmfulness score of 5. For Ouro Base models, we use greedy decoding with max_new_tokens=128; For Ouro Thinking models, we sample with temperature=1.0, top_p=0.7 with max_new_tokens=8192. We evaluate Ouro 1.4B and 2.6B models with recurrent steps ranging from 1 to 8, and report the result in Figure 8a. Notably, while our models were trained with only 4 recurrent steps, both models show their extrapolation capability by extending recurrence steps to 5-8 during inference. This demonstrates the models ability to generalize to deeper computation than seen during training. The Ouro Thinking checkpoints further enhance safety alignment, reducing harmful rates to 0.009 for Ouro 23 (a) HEx-PHI evaluation (b) PCA analysis on Ouro 1.4B Figure 8 (a) For both 1.4B and 2.6B models, Ouro demonstrates improved safety alignment on HEx-PHI as the recurrent steps increase. Note that models were trained with 4 recurrent steps; evaluations at steps 5-8 demonstrate successful extrapolation beyond the training configuration. (b) As the recurrent steps increase, Ouro 1.4B can better distinguish the benign prompts and harmful prompts, leading to safer responses. We perform PCA on the hidden representation of the last input token from the models top layer. Harmful prompts with harmfulness score of 4 or 5 at recurrent step 1 are marked with , while other harmful prompts are shown as circles. The color of each point reflects the harmfulness score of the corresponding response. Benign prompts are shown as green squares. 1.4B Thinking and 0.003 for Ouro 2.6B Thinking at 4 recurrent steps, comparable to Qwen3-4B-Thinking (0.009). To further investigate how increasing recurrent steps affects the models safety alignment, we conduct Principal Component Analysis (PCA) on the hidden representation of the last input token from the top model layer. For controlled analysis, we select 100 benign and 100 harmful questions with identical formats (all the examples are the questions starting with How to) from Zheng et al.(2024) [70]4. Additionally, we evaluate the models responses to the 100 harmful questions and compute 5-level harmfulness score (same as the one used in HEx-PHI) for each response. We plot our PCA analysis on Ouro 1.4B in Figure 8b, from which we have the following observations. First, as the number of recurrent steps increases, the model becomes more capable of separating benign and harmful prompts, resulting in safer responses, as indicated by the decreasing number of red points. Furthermore, most points associated with unsafe responses appear near the middle of the plot, which represents the boundary between the benign and harmful clusters. This suggests that difficulty in distinguishing harmfulness may lead to unsafe responses, which can be alleviated by increasing the number of recurrent steps."
        },
        {
            "title": "7.2 Faithfulness",
            "content": "We call models thinking process faithful if it is (i) procedurally correct and (ii) causally coupled to the final answer. Concretely, faithful process should satisfy counterfactual criterion: if the justification is intervened on (e.g., altered to different intermediate state), the final prediction should change accordingly. growing 4Harmful questions: https://github.com/chujiezheng/LLM-Safeguard/blob/main/code/data/custom.txt; Benign questions: https://github.com/chujiezheng/LLM-Safeguard/blob/main/code/data_harmless/custom.txt 24 Figure 9 Left. ROCAUC of linear probes by layer on Quora Question Pairs. Each colored curve shows probe trained on hidden states within given 2 to 8 recurrent steps to predict that loops answer; Qwen3-4B models are the baselines. Vertical dotted lines mark loop boundaries. In recurrent step = 2, 3, 4, the ROC AUC rises quickly within recurrent step, then partially resets at the next loop, indicating that intra-step answers are determined early while cross-step updates modify the provisional answer. Right. Agreement across recurrent steps. Heat map (A) over 1,000 Quora Question Pairs. Entry A[i, j] is the number of items for which steps (i) and (j) assign the same label. body of work [7174] shows that standard LLMs often appear to decide on an answer before generating chain-of-thought text and then use that text to rationalize the already-formed decision. In LoopLM, the reasoning substrate is the sequence of latent states (1) (2) (T ). Each transition (k) (k+1) performs non-trivial computation using the same shared-weight block, and each step is trained to improve the task objective. Thus, the causal path to the answer is this latent trajectory, not any optional natural-language trace. When we decode intermediate text Text(Rk) from (k) via the LM head, we treat it as an instrumented readout of the internal state rather than the mechanism itself. Because (k) is directly supervised by the LM loss, its projection into token space provides faithful snapshot of what the model currently represents. Standard evaluation of faithfulness is often based on the manipulation of the reasoning process, CoT, and check if the average treatment effect of CoT is significant. In our case, we cannot manipulate the latent reasoning process. Instead, we adopt an observational proxy for mediation: we read out intermediate hidden representations and test whether predictions change as recurrence deepens on inputs that admit multiple plausible labels. Concretely, we assess whether intermediate thinking genuinely mediates decisions by measuring step-by-step predictability and agreement patterns. We use the Quora Question Pairs dataset [75], which asks whether two short questions are semantically equivalent: setting with ambiguity and weaklydefined decision boundaries. There are lot of ambiguous questions in this dataset: Example: Ambiguous questions in Quora dataset Question: does the following two questions have the same intent? Pair 1: 1. What are the questions should not ask on Quora? Pair 2: 1. How do we prepare for Union Public Service Commission? 2. Which question should ask on Quora? 2. How do prepare for civil service? Answer: False Answer: True If thinking process merely rationalizes the pre-committed answer, even if the questions are very ambiguous, the answers will not change after the reasoning process. This has been reported for Gemma-2 9B and reproduced by us on Qwen-3-4B-Thinking. As shown in the left part of Figure 9, the simple linear probe on the final-token logits on the Qwen3-4B-Thinking model shows 0.99 ROC AUC predicting the models eventual answer, which means the thinking process almost does not affect the results. In our model, the situation is very different. our 1.4B4 model uses 24 layers per recurrent step. We train linear probes on hidden states from layers 1 through 24i to predict the step-i answer, for {2, 3, 4}. Within single recurrent step, the step-i answer is well predicted by probe on representation within layer 24i, indicating strong intra-step alignment between state and decision, which is similar to the non-reasoning model Qwen-4B-Instruct, showing in left part of Figure 9. Crucially, probes on the preceding representation (layer 24(i1)) do not reliably predict the step-i decision for {2, 3, 4}, showing that the new recurrent pass performs additional computation that can revise provisional choice. To further examine the consistency between the results of different rounds. We also compute step-by-step agreement matrix over 1,000 Quora Question Pairs, where A[i, j] counts identical labels between step and step (diagonal = 1000 by construction). See the right side of Figure 9. Adjacent steps never reach full agreement; for example, A[3, 4] = 361 indicates only 36.1% of step-3 answers match step-4. A[2, 3] = 551 indicates only 44.9% of step-2 answers match step-3. We also notice that when 4, the overlap consistency between step-i and step-i + 1, A[i, + 1], is close to 1000. We think this phenomenon comes from: (1) the model does not learn to reason recursively when > 4. The model is trained within 4 loops; (2) as the number of loops increases, the answer gradually converges to fixed point. All in all, this systematic disagreement across steps when 4 is precisely what faithful latent process should exhibit: the model is updating its decision as recurrence deepens, and intermediate predictions are not frozen rationalizations of the final output."
        },
        {
            "title": "7.3 More Discussion",
            "content": "The practical barrier for safety-critical deployment is that models articulated reasoning and its final answer may diverge. The LoopLM architecture reduces this gap by exposing sequence of intermediate predictors that are strongly aligned with the final predictor and can be used both for acceleration and for pre-emptive control. We summarize three deployment advantages. Built-in draft model for speculative decoding. Let ext(Rt) denote the language-model head attached to the latent state after recurrent step t, and let be the maximum step used at deployment. The pair (cid:0)Text(Rs) (cid:123)(cid:122) (cid:125) (cid:124) proposal , Text(RT ) (cid:123)(cid:122) (cid:125) verifier (cid:124) (cid:1), 1 < T. forms native proposalverification decomposition for speculative decoding without training an external draft model. Proposals are sampled from ext(Rs) and verified under ext(RT ) using standard acceptance tests; rejected tokens are rolled back as usual. Because both heads share the same parameters up to step s, cached activations and KV states can be reused, reducing verifier overhead. This turns the recurrent structure into an architectural primitive for draftverify decoding rather than an add-on. Joint acceleration and pre-emptive safety. Using the same proposalverification split, safety checks can be interleaved with speculative decoding without extra models. At step s: 1. Generate draft tokens with Text(Rt) and compute their acceptance under Text(RT ). 2. Run safety screening on the draft distribution or sampled drafts before any token is surfaced to the user. Screening can operate on logits, beams, or short candidate spans. 3. If violation is detected, halt or reroute the response before streaming; otherwise, accept tokens that pass both verification and safety checks. Because Text(Rs) and Text(RT ) share the latent trajectory, intermediate predictions are well-aligned with the final answer distribution. This alignment makes the step-s output reliable proxy for the step-T output for the purpose of early screening, while the verifier maintains final quality. The Q-exit threshold further provides single deployment knob that simultaneously adjusts compute, consistency, and safety strictness by shifting the average exit depth. 26 Anytime generation with monotone refinement. The training objective in Section 3.4 optimizes the expected task loss across steps while preserving the deeper-is-better property. Consequently, for next-token prediction loss, E(cid:2)L(t+1)(cid:3) E(cid:2)L(t)(cid:3), 1 < T, so each additional loop refines the distribution toward higher-quality predictions. This yields an anytime algorithm: decoding may begin from any intermediate step and continue streaming while later steps continue to verify or revise. Unlike chain-of-thought pipelines, which often require completing reasoning prefix before emitting answers, LoopLM exposes single predictive interface at every step, enabling immediate fallback to smaller compute budget when latency constraints apply."
        },
        {
            "title": "8 Conclusion",
            "content": "In this work, we introduced Ouro, family of Looped Language Models that demonstrate exceptional parameter efficiency by integrating iterative computation and adaptive depth directly into pre-training on 7.7T tokens. Our 1.4B and 2.6B models consistently match or exceed the performance of 4B and 8B standard transformers, showcasing 2-3 efficiency gain. We demonstrated this advantage stems not from increased knowledge storage, but from fundamentally superior capability for knowledge manipulation, supported by synthetic experiments and theoretical analysis. We also presented practical training objective using entropy regularization with uniform prior to learn adaptive depth, and validated efficient KV cache sharing strategies that make LoopLMs viable for real-world deployment. Beyond performance, the LoopLM architecture exhibits unique properties: its iterative refinement process provides causally faithful reasoning trace, mitigating the post-hoc rationalization issues seen in standard CoT, and its safety alignment uniquely improves with increased recurrent steps, even when extrapolating. This work establishes iterative latent computation as critical third scaling axis beyond parameters and data. Future research should focus on enhancing performance extrapolation at greater depths and exploring more complex recurrent mechanisms, solidifying this parameter-efficient approach as necessary direction in data-constrained era."
        },
        {
            "title": "Acknowledgement",
            "content": "We sincerely thank Zeyuan Allen-Zhu for his in-depth discussion on the physics of language model part and his enlightening insights on knowledge manipulation. We also thank Yonghui Wu, Guang Shi, Shu Zhong, Tenglong Ao, Chen Chen, Songlin Yang, Wenhao Chai, and Yuhong Chou for their insightful discussions. Special thanks to Wenjia Zhu his words opened our eyes to what the real problems are in current models, and inspired us to explore this direction."
        },
        {
            "title": "Contributions",
            "content": "Project Lead Rui-Jie Zhu, Zixuan Wang, Kai Hua, Ge Zhang Core Contributors Rui-Jie Zhu: Proposes the project and leads the pre-training of Ouro. Optimizes pre-training and inference infrastructure, develops the initial vLLM implementation, and explores RLVR. Zixuan Wang: Leads the analysis on understanding LoopLM superiority and is responsible for related experiments. He contributes to the design of adaptive early exit strategies, training, and the safety analysis. Kai Hua: Designs and curates all pre-training data mixtures and provides key insights during the pre-training process. Ge Zhang: Co-leads and supervises the Ouro. Provides several key insights during the pre-training and post-training process. Tianyu Zhang: Leads the analysis of Ouro on consistency, safety, and faithfulness. He designs the pipeline evaluation on faithfulness. He contributes to post-training, probing and efficient KV cache design. Ziniu Li: Leads the post-training phase, developing supervised fine-tuning and providing key contributions to RLVR exploration. Haoran Que: Leads the scaling law analysis for LoopLM, investigating the relationship between performance, model size, and recurrent depth. Boyi Wei: Contributes to the safety analysis, conducting evaluations on the HEx-PHI benchmark and performing PCA on model representations. Zixin Wen: Contributes to the theoretical analysis, Physics of LLMs experiments, paper writing, and RLVR. Fan Yin: Optimizes the vLLM and SGLang implementations for Ouro, contributing core pull requests to improve inference efficiency. He Xing: Contributes to the vLLM infrastructure development and optimization. Contributors Lu Li, Jiajun Shi, Kaijing Ma, Shanda Li, Taylor Kergan, Andrew Smith, Xingwei Qu, Mude Hui, Bohong Wu, Xun Zhou, Qiyang Min, Hongzhi Huang, Wei Ye, Jiaheng Liu, Jian Yang, Yunfeng Shi, Chenghua Lin, Enduo Zhao, Tianle Cai Supervision Ge Zhang, Wenhao Huang, Yoshua Bengio, Jason Eshraghian"
        },
        {
            "title": "References",
            "content": "[1] Tom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared Kaplan, Prafulla Dhariwal, Arvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al. Language models are few-shot learners. Advances in neural information processing systems, 33:18771901, 2020. [2] Qwen Team et al. Qwen2 technical report. arXiv preprint arXiv:2407.10671, 2:3, 2024. [3] An Yang, Anfeng Li, Baosong Yang, Beichen Zhang, Binyuan Hui, Bo Zheng, Bowen Yu, Chang Gao, Chengen Huang, Chenxu Lv, et al. Qwen3 technical report. arXiv preprint arXiv:2505.09388, 2025. [4] Gemma Team, Aishwarya Kamath, Johan Ferret, Shreya Pathak, Nino Vieillard, Ramona Merhej, Sarah Perrin, Tatiana Matejovicova, Alexandre Ramé, Morgane Rivière, et al. Gemma 3 technical report. arXiv preprint arXiv:2503.19786, 2025. [5] Abhimanyu Dubey, Abhinav Jauhri, Abhinav Pandey, Abhishek Kadian, Ahmad Al-Dahle, Aiesha Letman, Akhil Mathur, Alan Schelten, Amy Yang, Angela Fan, et al. The llama 3 herd of models. arXiv e-prints, pages arXiv2407, 2024. [6] Jason Wei, Xuezhi Wang, Dale Schuurmans, Maarten Bosma, Fei Xia, Ed Chi, Quoc Le, Denny Zhou, et al. Chain-of-thought prompting elicits reasoning in large language models. Advances in neural information processing systems, 35:2482424837, 2022. [7] Mostafa Dehghani, Stephan Gouws, Oriol Vinyals, Jakob Uszkoreit, and Łukasz Kaiser. Universal transformers. arXiv preprint arXiv:1807.03819, 2018. [8] Nikunj Saunshi, Nishanth Dikkala, Zhiyuan Li, Sanjiv Kumar, and Sashank Reddi. Reasoning with latent thoughts: On the power of looped transformers. arXiv preprint arXiv:2502.17416, 2025. [9] Khashayar Gatmiry, Nikunj Saunshi, Sashank Reddi, Stefanie Jegelka, and Sanjiv Kumar. Can looped transformers learn to implement multi-step gradient descent for in-context learning? arXiv preprint arXiv:2410.08292, 2024. [10] Khashayar Gatmiry, Nikunj Saunshi, Sashank Reddi, Stefanie Jegelka, and Sanjiv Kumar. On the role of depth and looping for in-context learning with task diversity. arXiv preprint arXiv:2410.21698, 2024. [11] Jianhao Huang, Zixuan Wang, and Jason Lee. Transformers learn to implement multi-step gradient descent with chain of thought. arXiv preprint arXiv:2502.21212, 2025. [12] William Merrill and Ashish Sabharwal. little depth goes long way: The expressive power of log-depth transformers. arXiv preprint arXiv:2503.03961, 2025. [13] William Merrill and Ashish Sabharwal. Exact expressive power of transformers with padding. arXiv preprint arXiv:2505.18948, 2025. [14] Sangmin Bae, Adam Fisch, Hrayr Harutyunyan, Ziwei Ji, Seungyeon Kim, and Tal Schuster. Relaxed recursive transformers: Effective parameter sharing with layer-wise lora. arXiv preprint arXiv:2410.20672, 2024. [15] Jonas Geiping, Sean McLeish, Neel Jain, John Kirchenbauer, Siddharth Singh, Brian Bartoldson, Bhavya Kailkhura, Abhinav Bhatele, and Tom Goldstein. Scaling up test-time compute with latent reasoning: recurrent depth approach. arXiv preprint arXiv:2502.05171, 2025. [16] Boyi Zeng, Shixiang Song, Siyuan Huang, Yixuan Wang, He Li, Ziwei He, Xinbing Wang, Zhiyu Li, and Zhouhan Lin. Pretraining language models to ponder in continuous space. arXiv preprint arXiv:2505.20674, 2025. [17] Xiangyu Qi, Yi Zeng, Tinghao Xie, Pin-Yu Chen, Ruoxi Jia, Prateek Mittal, and Peter Henderson. Fine-tuning aligned language models compromises safety, even when users do not intend to! In The Twelfth International Conference on Learning Representations. [18] Yilong Chen, Junyuan Shang, Zhenyu Zhang, Yanxi Xie, Jiawei Sheng, Tingwen Liu, Shuohuan Wang, Yu Sun, Hua Wu, and Haifeng Wang. Inner thinking transformer: Leveraging dynamic depth scaling to foster adaptive internal thinking. arXiv preprint arXiv:2502.13842, 2025. [19] Sangmin Bae, Yujin Kim, Reza Bayat, Sungnyun Kim, Jiyoun Ha, Tal Schuster, Adam Fisch, Hrayr Harutyunyan, Ziwei Ji, Aaron Courville, et al. Mixture-of-recursions: Learning dynamic recursive depths for adaptive token-level computation. arXiv preprint arXiv:2507.10524, 2025. [20] Zhenzhong Lan, Mingda Chen, Sebastian Goodman, Kevin Gimpel, Piyush Sharma, and Radu Soricut. Albert: lite bert for self-supervised learning of language representations. arXiv preprint arXiv:1909.11942, 2019. [21] Raj Dabre and Atsushi Fujita. Recurrent stacking of layers for compact neural machine translation models. In Proceedings of the AAAI Conference on Artificial Intelligence, volume 33, pages 62926299, 2019. [22] Sho Takase and Shun Kiyono. Lessons on parameter sharing across layers in transformers. arXiv preprint arXiv:2104.06022, 2021. [23] Boxun Li, Yadong Li, Zhiyuan Li, Congyi Liu, Weilin Liu, Guowei Niu, Zheyue Tan, Haiyang Xu, Zhuyu Yao, Tao Yuan, et al. Megrez2 technical report. arXiv preprint arXiv:2507.17728, 2025. [24] Shibo Hao, Sainbayar Sukhbaatar, DiJia Su, Xian Li, Zhiting Hu, Jason Weston, and Yuandong Tian. Training large language models to reason in continuous latent space. arXiv preprint arXiv:2412.06769, 2024. 29 [25] Amirkeivan Mohtashami, Matteo Pagliardini, and Martin Jaggi. Cotformer: More tokens with attention make up for less depth. In Workshop on Advancing Neural Network Training: Computational Efficiency, Scalability, and Resource Optimization (WANT@ NeurIPS 2023), 2023. [26] Bohong Wu, Shen Yan, Sijun Zhang, Jianqiao Lu, Yutao Zeng, Ya Wang, and Xun Zhou. Efficient pretraining length scaling. arXiv preprint arXiv:2504.14992, 2025. [27] Tian Ye, Zicheng Xu, Yuanzhi Li, and Zeyuan Allen-Zhu. Physics of language models: Part 2.1, grade-school math and the hidden reasoning process. arXiv preprint arXiv:2407.20311, 2024. [28] Shenzhi Wang, Le Yu, Chang Gao, Chujie Zheng, Shixuan Liu, Rui Lu, Kai Dang, Xionghui Chen, Jianxin Yang, Zhenru Zhang, et al. Beyond the 80/20 rule: High-entropy minority tokens drive effective reinforcement learning for llm reasoning. arXiv preprint arXiv:2506.01939, 2025. [29] Nikita Balagansky and Daniil Gavrilov. Palbert: Teaching albert to ponder. Advances in Neural Information Processing Systems, 35:1400214012, 2022. [30] Andrea Banino, Jan Balaguer, and Charles Blundell. Pondernet: Learning to ponder. arXiv preprint arXiv:2107.05407, 2021. [31] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan Gomez, Łukasz Kaiser, and Illia Polosukhin. Attention is all you need. Advances in neural information processing systems, 30, 2017. [32] Jianlin Su, Yu Lu, Shengfeng Pan, Ahmed Murtadha, Bo Wen, and Yunfeng Liu. Roformer: Enhanced transformer with rotary position embedding, 2023. [33] Noam Shazeer. Glu variants improve transformer. arXiv preprint arXiv:2002.05202, 2020. [34] Loubna Ben Allal, Anton Lozhkov, Elie Bakouch, Gabriel Martín Blázquez, Guilherme Penedo, Lewis Tunstall, Andrés Marafioti, Hynek Kydlíček, Agustín Piqueres Lajarín, Vaibhav Srivastav, et al. Smollm2: When smol goes bigdata-centric training of small language model. arXiv preprint arXiv:2502.02737, 2025. [35] Kaiyue Wen, Zhiyuan Li, Jason Wang, David Hall, Percy Liang, and Tengyu Ma. Understanding warmup-stabledecay learning rates: river valley loss landscape perspective. arXiv preprint arXiv:2410.05192, 2024. [36] Guilherme Penedo, Hynek Kydlíček, Anton Lozhkov, Margaret Mitchell, Colin Raffel, Leandro Von Werra, Thomas Wolf, et al. The fineweb datasets: Decanting the web for the finest text data at scale. Advances in Neural Information Processing Systems, 37:3081130849, 2024. [37] Jeffrey Li, Alex Fang, Georgios Smyrnis, Maor Ivgi, Matt Jordan, Samir Yitzhak Gadre, Hritik Bansal, Etash Guha, Sedrick Scott Keh, Kushal Arora, et al. Datacomp-lm: In search of the next generation of training sets for language models. Advances in Neural Information Processing Systems, 37:1420014282, 2024. [38] Dan Su, Kezhi Kong, Ying Lin, Joseph Jennings, Brandon Norick, Markus Kliegl, Mostofa Patwary, Mohammad Shoeybi, and Bryan Catanzaro. Nemotron-cc: Transforming common crawl into refined long-horizon pretraining dataset. arXiv preprint arXiv:2412.02595, 2024. [39] Yudong Wang, Zixuan Fu, Jie Cai, Peijun Tang, Hongya Lyu, Yewei Fang, Zhi Zheng, Jie Zhou, Guoyang Zeng, Chaojun Xiao, et al. Ultra-fineweb: Efficient data filtering and verification for high-quality llm training data. arXiv preprint arXiv:2505.05427, 2025. [40] Xinrun Du, Zhouliang Yu, Songyang Gao, Ding Pan, Yuyang Cheng, Ziyang Ma, Ruibin Yuan, Xingwei Qu, Jiaheng Liu, Tianyu Zheng, et al. Chinese tiny llm: Pretraining chinese-centric large language model. arXiv preprint arXiv:2404.04167, 2024. [41] Siming Huang, Tianhao Cheng, Jason Klein Liu, Jiaran Hao, Liuyihan Song, Yang Xu, J. Yang, J. H. Liu, Chenchen Zhang, Linzheng Chai, Ruifeng Yuan, Zhaoxiang Zhang, Jie Fu, Qian Liu, Ge Zhang, Zili Wang, Yuan Qi, Yinghui Xu, and Wei Chu. Opencoder: The open cookbook for top-tier code large language models. 2024. [42] Fan Zhou, Zengzhi Wang, Nikhil Ranjan, Zhoujun Cheng, Liping Tang, Guowei He, Zhengzhong Liu, and Eric P. Xing. Megamath: Pushing the limits of open math corpora. arXiv preprint arXiv:2504.02807, 2025. Preprint. [43] Rabeeh Karimi Mahabadi, Sanjeev Satheesh, Shrimai Prabhumoye, Mostofa Patwary, Mohammad Shoeybi, and Bryan Catanzaro. Nemotron-cc-math: 133 billion-token-scale high quality math pretraining dataset. 2025. [44] NVIDIA, Aarti Basant, Abhijit Khairnar, Abhijit Paithankar, Abhinav Khattar, Adithya Renduchintala, Aditya Malte, Akhiad Bercovich, Akshay Hazare, Alejandra Rico, Aleksander Ficek, Alex Kondratenko, Alex Shaposhnikov, 30 Alexander Bukharin, Ali Taghibakhshi, Amelia Barton, Ameya Sunil Mahabaleshwarkar, Amy Shen, Andrew Tao, Ann Guan, Anna Shors, Anubhav Mandarwal, Arham Mehta, Arun Venkatesan, Ashton Sharabiani, Ashwath Aithal, Ashwin Poojary, Ayush Dattagupta, Balaram Buddharaju, Banghua Zhu, Barnaby Simkin, Bilal Kartal, Bita Darvish Rouhani, Bobby Chen, Boris Ginsburg, Brandon Norick, Brian Yu, Bryan Catanzaro, Charles Wang, Charlie Truong, Chetan Mungekar, Chintan Patel, Chris Alexiuk, Christian Munley, Christopher Parisien, Dan Su, Daniel Afrimi, Daniel Korzekwa, Daniel Rohrer, Daria Gitman, David Mosallanezhad, Deepak Narayanan, Dima Rekesh, Dina Yared, Dmytro Pykhtar, Dong Ahn, Duncan Riach, Eileen Long, Elliott Ning, Eric Chung, Erick Galinkin, Evelina Bakhturina, Gargi Prasad, Gerald Shen, Haifeng Qian, Haim Elisha, Harsh Sharma, Hayley Ross, Helen Ngo, Herman Sahota, Hexin Wang, Hoo Chang Shin, Hua Huang, Iain Cunningham, Igor Gitman, Ivan Moshkov, Jaehun Jung, Jan Kautz, Jane Polak Scowcroft, Jared Casper, Jian Zhang, Jiaqi Zeng, Jimmy Zhang, Jinze Xue, Jocelyn Huang, Joey Conway, John Kamalu, Jonathan Cohen, Joseph Jennings, Julien Veron Vialard, Junkeun Yi, Jupinder Parmar, Kari Briski, Katherine Cheung, Katherine Luna, Keith Wyss, Keshav Santhanam, Kezhi Kong, Krzysztof Pawelec, Kumar Anik, Kunlun Li, Kushan Ahmadian, Lawrence McAfee, Laya Sleiman, Leon Derczynski, Luis Vega, Maer Rodrigues de Melo, Makesh Narsimhan Sreedhar, Marcin Chochowski, Mark Cai, Markus Kliegl, Marta Stepniewska-Dziubinska, Matvei Novikov, Mehrzad Samadi, Meredith Price, Meriem Boubdir, Michael Boone, Michael Evans, Michal Bien, Michal Zawalski, Miguel Martinez, Mike Chrzanowski, Mohammad Shoeybi, Mostofa Patwary, Namit Dhameja, Nave Assaf, Negar Habibi, Nidhi Bhatia, Nikki Pope, Nima Tajbakhsh, Nirmal Kumar Juluru, Oleg Rybakov, Oleksii Hrinchuk, Oleksii Kuchaiev, Oluwatobi Olabiyi, Pablo Ribalta, Padmavathy Subramanian, Parth Chadha, Pavlo Molchanov, Peter Dykas, Peter Jin, Piotr Bialecki, Piotr Januszewski, Pradeep Thalasta, Prashant Gaikwad, Prasoon Varshney, Pritam Gundecha, Przemek Tredak, Rabeeh Karimi Mahabadi, Rajen Patel, Ran El-Yaniv, Ranjit Rajan, Ria Cheruvu, Rima Shahbazyan, Ritika Borkar, Ritu Gala, Roger Waleffe, Ruoxi Zhang, Russell J. Hewett, Ryan Prenger, Sahil Jain, Samuel Kriman, Sanjeev Satheesh, Saori Kaji, Sarah Yurick, Saurav Muralidharan, Sean Narenthiran, Seonmyeong Bak, Sepehr Sameni, Seungju Han, Shanmugam Ramasamy, Shaona Ghosh, Sharath Turuvekere Sreenivas, Shelby Thomas, Shizhe Diao, Shreya Gopal, Shrimai Prabhumoye, Shubham Toshniwal, Shuoyang Ding, Siddharth Singh, Siddhartha Jain, Somshubra Majumdar, Soumye Singhal, Stefania Alborghetti, Syeda Nahida Akter, Terry Kong, Tim Moon, Tomasz Hliwiak, Tomer Asida, Tony Wang, Tugrul Konuk, Twinkle Vashishth, Tyler Poon, Udi Karpas, Vahid Noroozi, Venkat Srinivasan, Vijay Korthikanti, Vikram Fugro, Vineeth Kalluru, Vitaly Kurin, Vitaly Lavrukhin, Wasi Uddin Ahmad, Wei Du, Wonmin Byeon, Ximing Lu, Xin Dong, Yashaswi Karnati, Yejin Choi, Yian Zhang, Ying Lin, Yonggan Fu, Yoshi Suhara, Zhen Dong, Zhiyu Li, Zhongbo Zhu, and Zijia Chen. Nvidia nemotron nano 2: An accurate and efficient hybrid mamba-transformer reasoning model, 2025. [45] Tianyu Gao, Alexander Wettig, Howard Yen, and Danqi Chen. How to train long-context language models (effectively). arXiv preprint arXiv:2410.02660, 2024. [46] Yu Zhang and Songlin Yang. Flame: Flash language modeling made easy, January 2025. [47] Wanchao Liang, Tianyu Liu, Less Wright, Will Constable, Andrew Gu, Chien-Chin Huang, Iris Zhang, Wei Feng, Howard Huang, Junjie Wang, Sanket Purandare, Gokul Nadathur, and Stratos Idreos. Torchtitan: One-stop pytorch native solution for production ready LLM pretraining. In The Thirteenth International Conference on Learning Representations, 2025. [48] Etash Guha, Ryan Marten, Sedrick Keh, Negin Raoof, Georgios Smyrnis, Hritik Bansal, Marianna Nezhurina, Jean Mercat, Trung Vu, Zayne Sprague, et al. Openthoughts: Data recipes for reasoning models. arXiv preprint arXiv:2506.04178, 2025. [49] Zihan Liu, Zhuolin Yang, Yang Chen, Chankyu Lee, Mohammad Shoeybi, Bryan Catanzaro, and Wei Ping. Acereason-nemotron 1.1: Advancing math and code reasoning through sft and rl synergy. arXiv preprint arXiv:2506.13284, 2025. [50] Wasi Uddin Ahmad, Sean Narenthiran, Somshubra Majumdar, Aleksander Ficek, Siddhartha Jain, Jocelyn Huang, Vahid Noroozi, and Boris Ginsburg. Opencodereasoning: Advancing data distillation for competitive coding. arXiv preprint arXiv:2504.01943, 2025. [51] Akhiad Bercovich, Itay Levy, Izik Golan, Mohammad Dabbah, Ran El-Yaniv, Omri Puny, Ido Galil, Zach Moshe, Tomer Ronen, Najeeb Nabwani, et al. Llama-nemotron: Efficient reasoning models. arXiv preprint arXiv:2505.00949, 2025. [52] Haozhe Wang, Haoran Que, Qixin Xu, Minghao Liu, Wangchunshu Zhou, Jiazhan Feng, Wanjun Zhong, Wei Ye, Tong Yang, Wenhao Huang, et al. Reverse-engineered reasoning for open-ended generation. arXiv preprint arXiv:2509.06160, 2025. 31 [53] Yaowei Zheng, Richong Zhang, Junhao Zhang, Yanhan Ye, Zheyan Luo, Zhangchi Feng, and Yongqiang Ma. Llamafactory: Unified efficient fine-tuning of 100+ language models. arXiv preprint arXiv:2403.13372, 2024. [54] Qiying Yu, Zheng Zhang, Ruofei Zhu, Yufeng Yuan, Xiaochen Zuo, Yu Yue, Weinan Dai, Tiantian Fan, Gaohong Liu, Lingjun Liu, et al. Dapo: An open-source llm reinforcement learning system at scale. arXiv preprint arXiv:2503.14476, 2025. [55] Zhihong Shao, Peiyi Wang, Qihao Zhu, Runxin Xu, Junxiao Song, Xiao Bi, Haowei Zhang, Mingchuan Zhang, YK Li, Yang Wu, et al. Deepseekmath: Pushing the limits of mathematical reasoning in open language models. arXiv preprint arXiv:2402.03300, 2024. [56] Leo Gao, Jonathan Tow, Baber Abbasi, Stella Biderman, Sid Black, Anthony DiPofi, Charles Foster, Laurence Golding, Jeffrey Hsu, Alain Le Noach, Haonan Li, Kyle McDonell, Niklas Muennighoff, Chris Ociepa, Jason Phang, Laria Reynolds, Hailey Schoelkopf, Aviya Skowron, Lintang Sutawika, Eric Tang, Anish Thite, Ben Wang, Kevin Wang, and Andy Zou. The language model evaluation harness, 07 2024. [57] Jiawei Liu, Chunqiu Steven Xia, Yuyao Wang, and Lingming Zhang. Is your code generated by chatGPT really correct? rigorous evaluation of large language models for code generation. In Thirty-seventh Conference on Neural Information Processing Systems, 2023. [58] HuggingFaceH4. Aime 2024. https://huggingface.co/datasets/HuggingFaceH4/aime_2024, 2024. 30 problems from AIME & II 2024. [59] Chaoqun He, Renjie Luo, Yuzhuo Bai, et al. Olympiadbench: challenging benchmark for promoting agi with olympiad-level bilingual multimodal scientific problems. arXiv preprint arXiv:2402.14008, 2024. [60] David Rein, Betty Li Hou, Asa Cooper Stickland, Jackson Petty, Richard Yuanzhe Pang, Julien Dirani, Julian Michael, and Samuel R. Bowman. GPQA: graduate-level google-proof q&a benchmark. arXiv preprint arXiv:2311.12022, 2023. [61] M-A-P Team, Xinrun Du, Yifan Yao, et al. Supergpqa: Scaling llm evaluation across 285 graduate disciplines. arXiv preprint arXiv:2502.14739, 2025. [62] ByteDance-Seed. Beyondaime. https://huggingface.co/datasets/ByteDance-Seed/BeyondAIME, 2025. CC0-1.0 license. [63] Long Phan, Alice Gatti, Ziwen Han, Nathaniel Li, et al. Humanitys last exam. arXiv preprint arXiv:2501.14249, 2025. [64] Alon Talmor, Jonathan Herzig, Nicholas Lourie, and Jonathan Berant. CommonsenseQA: question answering challenge targeting commonsense knowledge. In Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, Volume 1 (Long and Short Papers), pages 41494158, Minneapolis, Minnesota, June 2019. Association for Computational Linguistics. [65] Zeyuan Allen-Zhu and Yuanzhi Li. Physics of Language Models: Part 3.3, Knowledge Capacity Scaling Laws. In Proceedings of the 13th International Conference on Learning Representations, ICLR 25, April 2025. Full version available at https://ssrn.com/abstract=5250617. [66] Zeyuan Allen-Zhu. Physics of Language Models: Part 4.1, Architecture Design and the Magic of Canon Layers. SSRN Electronic Journal, May 2025. https://ssrn.com/abstract=5240330. [67] Yuekun Yao, Yupei Du, Dawei Zhu, Michael Hahn, and Alexander Koller. Language models can learn implicit multi-hop reasoning, but only if they have lots of training data. arXiv preprint arXiv:2505.17923, 2025. [68] Hanlin Zhu, Shibo Hao, Zhiting Hu, Jiantao Jiao, Stuart Russell, and Yuandong Tian. Reasoning by superposition: theoretical perspective on chain of continuous thought. arXiv preprint arXiv:2505.12514, 2025. [69] Shu Zhong, Mingyu Xu, Tenglong Ao, and Guang Shi. Understanding transformer from the perspective of associative memory. arXiv preprint arXiv:2505.19488, 2025. [70] Chujie Zheng, Fan Yin, Hao Zhou, Fandong Meng, Jie Zhou, Kai-Wei Chang, Minlie Huang, and Nanyun Peng. On prompt-driven safeguarding for large language models. In Proceedings of the 41st International Conference on Machine Learning, pages 6159361613, 2024. [71] Kyle Cox. Post-hoc reasoning in chain of thought, December 2024. Blog post. 32 [72] Iván Arcuschin, Jett Janiak, Robert Krzyzanowski, Senthooran Rajamanoharan, Neel Nanda, and Arthur Conmy. Chain-of-thought reasoning in the wild is not always faithful. arXiv preprint arXiv: 2503.08679, 2025. [73] Fazl Barez, Tung-Yu Wu, Iván Arcuschin, Michael Lan, Vincent Wang, Noah Siegel, Nicolas Collignon, Clement Neo, Isabelle Lee, Alasdair Paren, Adel Bibi, Robert Trager, Damiano Fornasiere, John Yan, Yanai Elazar, and Yoshua Bengio. Chain-of-thought is not explainability. 2025. [74] Tomek Korbak, Mikita Balesni, Elizabeth Barnes, Yoshua Bengio, Joe Benton, Joseph Bloom, Mark Chen, Alan Cooney, Allan Dafoe, Anca Dragan, Scott Emmons, Owain Evans, David Farhi, Ryan Greenblatt, Dan Hendrycks, Marius Hobbhahn, Evan Hubinger, Geoffrey Irving, Erik Jenner, Daniel Kokotajlo, Victoria Krakovna, Shane Legg, David Lindner, David Luan, Aleksander Mądry, Julian Michael, Neel Nanda, Dave Orr, Jakub Pachocki, Ethan Perez, Mary Phuong, Fabien Roger, Joshua Saxe, Buck Shlegeris, Martín Soto, Eric Steinberger, Jasmine Wang, Wojciech Zaremba, Bowen Baker, Rohin Shah, and Vlad Mikulik. Chain of thought monitorability: new and fragile opportunity for ai safety. arXiv preprint arXiv: 2507.11473, 2025. [75] Quora. Quora question pairs. https://www.kaggle.com/competitions/quora-question-pairs/, 2017. Kaggle competition. [76] Clayton Sanford, Bahare Fatemi, Ethan Hall, Anton Tsitsulin, Mehran Kazemi, Jonathan Halcrow, Bryan Perozzi, and Vahab Mirrokni. Understanding transformer reasoning capabilities via graph algorithms. In A. Globerson, L. Mackey, D. Belgrave, A. Fan, U. Paquet, J. Tomczak, and C. Zhang, editors, Advances in Neural Information Processing Systems, volume 37, pages 7832078370. Curran Associates, Inc., 2024. [77] Clayton Sanford, Daniel Hsu, and Matus Telgarsky. Transformers, parallel computation, and logarithmic depth. arXiv preprint arXiv:2402.09268, 2024. [78] Bingbin Liu, Jordan Ash, Surbhi Goel, Akshay Krishnamurthy, and Cyril Zhang. Transformers learn shortcuts to automata. arXiv preprint arXiv:2210.10749, 2022. [79] Zixuan Wang, Eshaan Nichani, Alberto Bietti, Alex Damian, Daniel Hsu, Jason Lee, and Denny Wu. Learning compositional functions with transformers from easy-to-hard data. arXiv preprint arXiv:2505.23683, 2025. [80] Dan Hendrycks, Collin Burns, Steven Basart, Andy Zou, Mantas Mazeika, Dawn Song, and Jacob Steinhardt. Measuring massive multitask language understanding. In International Conference on Learning Representations (ICLR), 2021. [81] Yizhong Wang, Yada Pruksachatkun, Sheng Chen, Zexuan Zhong, Pengfei Chen, et al. MMLU-Pro: more challenging and reliable evaluation for massive multitask language understanding. arXiv preprint arXiv:2406.01574, 2024. [82] Mirac Suzgun, Nathan Scales, Nathanael Schärli, Sebastian Gehrmann, Yi Tay, Hyung Won Chung, Aakanksha Chowdhery, Quoc V. Le, Ed H. Chi, Denny Zhou, and Jason Wei. Challenging big-bench tasks and whether chain-of-thought can solve them. arXiv preprint arXiv:2210.09261, 2022. [83] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge. arXiv preprint arXiv:1803.05457, 2018. [84] Rowan Zellers, Ari Holtzman, Yonatan Bisk, Ali Farhadi, and Yejin Choi. HellaSwag: Can machine really finish your sentence? In Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics, pages 47914800, Florence, Italy, 2019. Association for Computational Linguistics. [85] Keisuke Sakaguchi, Ronan Le Bras, Chandra Bhagavatula, and Yejin Choi. Winogrande: An adversarial winograd schema challenge at scale. arXiv preprint arXiv:1907.10641, 2019. [86] Karl Cobbe, Vineet Kosaraju, Mohammad Bavarian, Mark Chen, Heewoo Jun, Lukasz Kaiser, Matthias Plappert, Jerry Tworek, Jacob Hilton, Reiichiro Nakano, Christopher Hesse, and John Schulman. Training verifiers to solve math word problems. arXiv preprint arXiv:2110.14168, 2021. [87] Dan Hendrycks, Collin Burns, Saurav Kadavath, Akul Arora, Steven Basart, Eric Tang, Dawn Song, and Jacob Steinhardt. Measuring mathematical problem solving with the MATH dataset. In NeurIPS 2021 Datasets and Benchmarks Track, 2021. [88] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, 33 Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders, Christopher Hesse, Andrew N. Carr, Jan Leike, Josh Achiam, Vedant Misra, Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, and Wojciech Zaremba. Evaluating large language models trained on code. arXiv preprint arXiv:2107.03374, 2021. [89] Jacob Austin, Augustus Odena, Maxwell Nye, Maarten Bosma, Henryk Michalewski, David Dohan, Ellen Jiang, Carrie Cai, Michael Terry, Quoc Le, and Charles Sutton. Program synthesis with large language models. arXiv preprint arXiv:2108.07732, 2021. [90] Peter Clark, Isaac Cowhey, Oren Etzioni, Tushar Khot, Ashish Sabharwal, Carissa Schoenick, and Oyvind Tafjord. Think you have solved question answering? try arc, the ai2 reasoning challenge. arXiv:1803.05457v1, 2018. [91] Denis Paperno, Germán Kruszewski, Angeliki Lazaridou, Quan Ngoc Pham, Raffaella Bernardi, Sandro Pezzelle, Marco Baroni, Gemma Boleda, and Raquel Fernández. The lambada dataset, Aug 2016. [92] Todor Mihaylov, Peter Clark, Tushar Khot, and Ashish Sabharwal. Can suit of armor conduct electricity? new dataset for open book question answering. arXiv preprint arXiv:1809.02789, 2018. [93] Yonatan Bisk, Rowan Zellers, Jianfeng Gao, Yejin Choi, et al. Piqa: Reasoning about physical commonsense in natural language. In Proceedings of the AAAI conference on artificial intelligence, volume 34, pages 74327439, 2020. [94] Jordan Hoffmann, Sebastian Borgeaud, Arthur Mensch, Elena Buchatskaya, Trevor Cai, Eliza Rutherford, Diego de Las Casas, Lisa Anne Hendricks, Johannes Welbl, Aidan Clark, et al. Training compute-optimal large language models. arXiv preprint arXiv:2203.15556, 2022. [95] Haoran Que, Jiaheng Liu, Ge Zhang, Chenchen Zhang, Xingwei Qu, Yinghao Ma, Feiyu Duan, Zhiqi Bai, Jiakai Wang, Yuanxing Zhang, et al. D-cpt law: domain-specific continual pre-training scaling law for large language models. In Proceedings of the 38th International Conference on Neural Information Processing Systems, pages 9031890354, 2024."
        },
        {
            "title": "A Empirical Validation of Prior Choice",
            "content": "Figure 10 Effect of the prior over exit steps. Left: training loss (300-step sliding average) for LoopLM with Tmax = 4 under different priors on z. Colored curves correspond to geometric priors with parameter λ {0.1, . . . , 0.9}; the red curve uses uniform prior. Shaded regions indicate variability across runs. Right: prior probability over LoopLM steps induced by each λ (uniform shown in red). Stronger geometric bias (larger λ) concentrates mass on shallow steps, reducing credit assignment to deeper computation. Experimental setup. Unless otherwise noted, we keep the model, data, optimizer, and schedule identical across conditions and only change the prior π used in the KL term of the loss. All results are obtained on 776M-parameter LoopLM with Tmax = 4 recurrent steps. Training is performed on the FineWeb-Edu corpus [36] for total of 20B tokens with global batch of 50K tokens per optimization step, i.e., roughly 40K steps in total.5 For geometric priors we sweep λ {0.1, 0.2, . . . , 0.9}; the uniform prior assigns equal mass to all steps. To assess variability, we repeat each condition with multiple random seeds; shaded areas in Figure 10 denote the variability across runs. All other hyperparameters follow our training recipe, keeping β fixed across prior choices. Convergence and final loss. As shown on the left of Figure 10, the uniform prior consistently achieves lower training loss and cleaner convergence on the 776M LoopLM. Geometric priors plateau higher, with the gap widening as λ grows (i.e., stronger bias toward early exit), reflecting weaker supervision for deeper iterations. Stability and exploration. Geometric priors exhibit larger late-training oscillations, consistent with premature collapse of qϕ(z x) onto shallow steps and reduced entropy. The uniform prior imposes no structural depth preference, so the KL term behaves as pure entropy regularization: exploration is maintained longer, and the model can allocate probability mass across multiple depths until it has learned which examples benefit from deeper computation. Depth utilization. The right panel of Figure 10 visualizes the priors. Large-λ geometric priors concentrate mass at t=12, starving deeper steps (t3) of credit assignment; this undermines the deeper is better property. With uniform prior, all depths receive comparable signal, enabling later iterations to specialize and deliver higher accuracy when maximum depth is allowed at inference. Computeaccuracy trade-off. Although the uniform prior does not explicitly favor early exit, it does not preclude efficient inference: at test time we can still cap steps or apply halting threshold. For fixed average 5The loss curves plot 300-step sliding average over the training trajectory. 35 step budget, models trained with uniform prior achieve strictly better accuracycompute Pareto frontier than those trained with geometric priors, indicating that unbiased depth exploration during pretraining turns into better deployment trade-offs."
        },
        {
            "title": "B Physics of LoopLMs",
            "content": "In this appendix, we conclude all the experimental settings and details in Section 6. Section B.1 includes the experiments on knowledge capacity; section B.2 includes the settings on knowledge manipulation synthetic tasks. Section B.3 introduces the detailed setting on the synthetic QA task following [67]. Finally, Section B.5 provides the theoretical results, detailed proof, and the discussion with the current theoretical results. B.1 Capo: knowledge capacity In this section, we introduce the knowledge capacity proposed in [65, 66]. The task evaluates models efficiency in memorizing factual knowledge within its parameters, which is measured by bits per parameter. We tested different sizes of models and visualize the knowledge scaling law through plotting bits v.s. parameter number. Dataset: Synthetic Biographies We synthesize fake biographies following the bioS(N ) dataset in [65]. Specifically, we generate biographies of random generated person together with their date of birth, city of birth, university, major, and employer. In our work, we online sample the individual attributes and generate the biographies in natural language using random selected fixed template. An illustrative example is: Layla Jack Beasley celebrates their birthday on January 24, 1914. They spent formative years in Portland, ME. They focused on Business Analytics. They supported operations for Delta Air Lines Inc. in Atlanta, GA. They received their education at Pepperdine University. Model We use original GPT2 architecture and replace the positional encoding with RoPE [32]. In the Capo task, we tie the LM head and the embedding layer. To test the capability of universal transformer, we also added looping module s.t. the transformer blocks can be looped several times. We explore broad range of model sizes varying in hidden dimension and depth. The notation a-b-lc represents the model with 64a hidden dimensions (a attention heads with each head 64 dimensions), layers, and LoopLM steps (loops). The context length is set to 512. Training details We use AdamW optimizer by setting (β1, β2) = (0.9, 0.98), ϵ = 106 with 1000 steps of warmup followed by cosine learning rate schedule from 1 to 0.1 of the original learning rate. We use bf16 training and packing is used during training. We masked different pieces of biographies from each other in each concatenated chunk. We pass each data piece for 1000 times (similar to the 1000-exposure in [65]) during training. Since the final performance is not sensitive to learning rate choices, we consider learning rate η = 0.001, wd = 0.02, and total batch size 192. We pick {20K, 50K, 100K, 200K, 500K}. Evaluation: Knowledge Capacity Ratio After pretraining on the bioS(N ) dataset, we assess models knowledge capacity, defined as the number of bits of information it can reliably store. To make this measure comparable across models of different sizes, the raw bit count is normalized by the number of model parameters, yielding bits per parameter metric. The derivation and motivation of the metric in discussed in [65]. For readers, we refer the detailed setting to Section 2.1 of [65]. Definition 1. Given model with parameters trained over the bioS(N ) dataset Z, suppose it gives p1 = lossname(Z) and p2 = lossvalue(Z), which are the sum of cross entropy loss on the name tokens and attribute tokens, respectively. The capacity ratio and the maximum achievable capacity ratio are defined as R(F ) def = log2 N0 ep1 + log2 S0 ep2 , Rmax(F ) def = log2 N0 + log2 S0 , for N0 = 400 400 1000, S0 = 2 (12 28 200) 200 300 100 263 as all possible configurations. 36 Ignoring names, each person encodes approximately log2(S0) 47.6 bits of knowledge. The evaluation accounts for partial correctness. For instance, if model recalls the year of persons birth but not the exact date, the partially correct information still contributes to the overall bit-level computation. This approach allows for fine-grained measurement of knowledge retention, rather than relying on strict all-or-nothing scoring. B.2 Mano: knowledge manipulation We followed [66] and used the Mano task to investigate the models capability of manipulating stored knowledge within the parameters without intermediate thoughts. Dataset The dataset consists of modular arithmetic instances with tree structures of ℓ operations, where the number of operations ℓ as the maximum length. ℓ is uniformly sampled from [1, L]. The expressions are presented in prefix notation. For example, length-3 instance is: <bos> <len_3> - * + <ans> ans which corresponds to (a b) + (c d) mod 23. All the operations are on F23. The task only involves (+, , ). The only tokens we use are the operations, numbers from 0 to 22, and the special <bos>, <ans> and length tokens len_{i} with [0, L]. Training details We use AdamW optimizer with (β1, β2) = (0.9, 0.98), ϵ = 106 and gradient clipping with maximum norm 1.0. We employ 1000 steps of warmup followed by cosine learning rate schedule to minimal learning rate 0.1 of the peak learning rate. We use bf16 training with packing and set the context length to 1024 tokens. Different pieces of mano problems are masked from each other in each concatenated chunk during training. We conduct hyperparameter search over learning rates lr {0.00005, 0.0001, 0.0002, 0.0005} with weight decay 0.1 and global batch size 128. We experiment with model depths {10, 16, 24} layers and hidden dimension 1024. Training is performed for {80K, 110K, 200K} steps respectively for different difficulties. We run all experiments across 3 random seeds and report the best performance. Evaluation During evaluation, we only use the expressions with the hardest length ℓ = L. Accuracy is computed separately due to the masks. We consider exact match accuracy since the final answer is single-token. B.3 Multi-hop question answering on synthetic relations We followed [67] to construct the natural language multi-hop QA task. Comparing with Mano, the QA task is more knowledge-heavy and with slightly simpler structure. [67] found that the model needs exponential many k-hop data for traditional transformer to learn. We chose this task to investigate if recursive structure in the reused-parameters can improve the sample efficiency of the task, showing better manipulation capability of LoopLM. Dataset The dataset contains entitieseach with unique nameand relation types. We created 500 distinct single-token person names (e.g., Jennifer) and 20 single-token relation names (e.g., instructor) to serve as namespaces for entities and relations. We reused the name list in [67]. The complete list of relation names and partial list of entity names appear in Tables 5 and 6 in [67]. The multi-hop questions are generated through = 5 hierarchical layers, where each layer has 100 individuals. Each entity is connected to randomly chosen person in the next layer. This structure naturally generates E/5 Rk k-hop questions. In our setting, since we only consider 3-hop questions, the number should be 8 105. For training, we use part of all the 3-hop training set and test on the leave-out 3000 test questions. For each test instance, we greedy decode the single token answer given the question prompt (e.g. Who is the instructor of the teacher of Bob? Answer:). We evaluate the exact match accuracy. 37 Figure 11 Left & Right. We further train with 100000 and 140000 unique QA pairs for 20000 steps with context length 1024 and batch size 2048. Similar to the main text, models with more loops learn faster and achieve better performance comparing with models without loops. Figure 12 Left & Right. We further train with 100000 and 120000 unique QA pairs for 20000 steps with context length 1024 and batch size 2048. We train the baseline with 24 layers, which is equivalent flops with the loop 4 transformers. Similar to the main text, models with more loops learn faster and achieve better performance comparing with models without loops, even with iso-flop transformers. The loop 2 average performance is weaker than the iso-flop version transformer since it has less equivalent depth when = 105, but it surpasses the baseline with more data provided. Training details We use AdamW optimizer with (β1, β2) = (0.9, 0.98), ϵ = 106 and gradient clipping 1.0. We run 1000 steps of linear warmup followed by cosine learning rate schedule to minimal learning rate 0.1 of the peak learning rate. We use bf16 training with packing with context length 1024 tokens. QA pairs from distinct samples are masked from each other during training. We use base model architecture with 1024 hidden dimensions, 16 attention heads, and 6 layers. We allow it to loop in {1, 2, 3, 4} times. Following the experimental setup in [67], we set the learning rate to 0.0005 with 1000 warmup steps and train for total of 20,000 steps using batch size 2048. We run all experiments across 4 random seeds and report the average performance. B.3.1 Additional experimental results As the supplement of the main text, we present additional experiments to show that the superiority of LoopLM is general across different number of unique samples. For presentation, we only consider the interval of {105, 1.2 105, 1.4 105} to exhibit the difference between looped models and non-looped baselines. We also checked iso-flop baseline models with the same hidden dimension and 24 layers6. The results are presented below in Figure 11 and Figure 12. 6We note that in Figure 12, the iso-flop baseline with = 1.2 105 does not perform significantly better than the shallower version in the main paper. We conjecture that it could be because of the randomness, or insufficient hyperparameter tuning. We believe further follow-up experiments should be necessary to further validate this conclusion here in the appendix. 38 B.4 Case study: improvements across different categories in MMLU To validate our findings from synthetic tasks on broad, real-world benchmark, we conducted granular analysis of performance gains across all 57 sub-categories of MMLU. Our hypothesis is that if LoopLMs primarily enhance knowledge manipulation and reasoning, the largest performance gains should appear in procedural, reasoning-heavy tasks, while knowledge-heavy, retrieval-based subjects should see less improvement. We measured the relative improvement by comparing the accuracy at the single recurrent step (Loop 1) against the accuracy at our fully trained depth (Loop 4). The detailed results for all 57 categories are available in Table 15. The analysis strongly supports our hypothesis. The categories with the most significant improvements are those requiring logical, maths, or procedural reasoning; conversely, categories that depend more on retrieving specific, memorized facts or nuanced world knowledge showed the most modest gains. Example: Categories with the most significant/modest improvements With most significant improvements: With most modest improvements: Elementary Mathematics: +155.6% Formal Logic: +143.3% Logical Fallacies: +127.8% High School Statistics: +126.9% Moral Scenarios: +7.8% Global Facts: +8.3% Virology: +13.7% Anatomy: +21.4% This stark contrast indicates that the iterative computation is not simply increasing the models accessible knowledge (as seen in the nearly flat global_facts improvement) but is actively performing the multistep symbolic manipulation required for complex subjects like logic and math. This real-world benchmark result corroborates our synthetic findings in Section 6.2, confirming that the LoopLM architectures primary advantage lies in enhancing knowledge manipulation, not raw storage. B.5 Theory: latent thought with LoopLM In this section, we prove that LoopLM can solve the graph reachability problem (with part of the graph knowledge learned in the parameters) in O(log n) steps. The results are closely related to the expressivity power of transformers and looped transformers with padding [12, 13, 76, 77]. It matches the expressiveness lower bound results in [76, 77], and also resembles the state tracking tasks [78, 79] which requires O(log n) depths. We first define the task rigorously and state our main theorem. We finally discuss the theoretical improvement, caveats of the results, and all related theoretical results. We first define our task based on the intuition of knowledge manipulation. Challenging knowledge manipulation tasks often have multiple steps or hierarchical structures, which requires the model to search in the knowledge graph with directional dependencies formed by the atomic facts or knowledge. Moreover, the context also contains conditions or new facts necessary for the problem. Therefore, we consider the searching task that requires the model to both encode the fixed hidden knowledge graph in the parameters and utilize the contextual information (additional graph) Gctx. The goal is to check if two queried nodes are connected. The formal definition is as follows (modified from [68]): Definition 2 (Graph reachability on knowledge graph). Let = {v1, v2, . . . , vn} is the set of vertices and = {e1, e2, . . . , em} is the set of edges. Let = (V, E) be directed hidden knowledge graph, and Gctx = (V, Ectx) be an input additional knowledge graph. Given source node target node t, the task is to output 1 when there exists path from to on the combined graph + Gctx := (V, + Ectx), and output 0 when cannot reach on the combined graph. Transformer architecture In this setting, we consider simple single-head transformer architecture. We only use one-head and two-layer gated MLP layer. For clearer theoretical demonstration, we use special normalization layer LN() to threshold on H: LN(H)i,j = 1{Hi,j > 0}. And the overall architecture for each loop is (where Q, K, V, W1, W2 are all shared through layers) Hi+0.5 = LN(Hi + AttnQ,K,V (Hi)), AttnQ,K,V (Hi) = Hisoftmax(H QHi) Table 15 Performance metrics across different depths by category in MMLU. Category elementary_mathematics formal_logic logical_fallacies high_school_statistics high_school_macroeconomics management high_school_government_and_politics high_school_microeconomics high_school_psychology high_school_biology college_chemistry conceptual_physics college_biology machine_learning miscellaneous high_school_geography high_school_physics high_school_chemistry college_medicine college_computer_science professional_accounting world_religions high_school_computer_science clinical_knowledge astronomy prehistory high_school_us_history professional_psychology philosophy business_ethics high_school_mathematics high_school_european_history medical_genetics human_sexuality computer_security college_physics international_law marketing nutrition college_mathematics econometrics sociology professional_medicine high_school_world_history human_aging security_studies professional_law public_relations us_foreign_policy electrical_engineering abstract_algebra moral_disputes anatomy jurisprudence virology global_facts moral_scenarios Loop 2 0.6190 0.4841 0.7178 0.5833 0.6564 0.6699 0.7202 0.7143 0.7817 0.7452 0.5000 0.6340 0.6806 0.4286 0.6564 0.7121 0.3841 0.5320 0.5607 0.5100 0.4539 0.6374 0.6800 0.5887 0.6184 0.5586 0.6912 0.5392 0.6495 0.6400 0.4444 0.6909 0.6900 0.6336 0.6200 0.3333 0.7107 0.8547 0.6634 0.3700 0.4123 0.7413 0.5368 0.7300 0.6143 0.6898 0.4055 0.6182 0.7200 0.5655 0.3000 0.6503 0.5111 0.6944 0.5000 0.3700 0.2693 Loop 3 0.7460 0.5238 0.7546 0.6620 0.7513 0.7864 0.8238 0.8361 0.8294 0.8129 0.5500 0.7149 0.7569 0.5089 0.7101 0.7980 0.5033 0.5665 0.6416 0.6000 0.4929 0.6959 0.7600 0.6415 0.6711 0.6389 0.7304 0.5850 0.7042 0.6500 0.5037 0.7273 0.7100 0.7023 0.6700 0.3922 0.7769 0.8803 0.6863 0.4200 0.5088 0.7910 0.5735 0.7595 0.6457 0.7510 0.4596 0.6727 0.8100 0.5862 0.3700 0.6850 0.5333 0.7593 0.4880 0.3600 0.2492 Loop 4 0.7910 0.5794 0.7546 0.7037 0.7718 0.7961 0.7979 0.8193 0.8385 0.8161 0.5000 0.7319 0.7431 0.4732 0.7178 0.8182 0.4834 0.5517 0.6358 0.6100 0.5000 0.7251 0.7800 0.6943 0.6711 0.6235 0.7108 0.6095 0.7106 0.6700 0.4778 0.8000 0.7100 0.7176 0.7000 0.3922 0.7851 0.8761 0.6863 0.4400 0.5175 0.8010 0.5625 0.7722 0.6502 0.7592 0.4570 0.6364 0.8000 0.6069 0.3600 0.6994 0.5037 0.7130 0.5000 0.3900 0.2626 Improvement% 155.5556 143.3333 127.7778 126.8657 109.0278 105.0000 102.6316 101.0309 100.4386 97.6563 92.3077 91.1111 91.0714 89.2857 85.4785 84.0909 82.5000 80.6452 77.4194 74.2857 74.0741 72.2222 69.5652 67.2727 67.2131 65.5738 64.7727 64.3172 61.3139 59.5238 59.2593 59.0361 57.7778 56.6667 55.5556 53.8462 53.2258 52.9851 52.1739 51.7241 51.2821 49.0741 48.5437 46.4000 45.0000 44.1860 40.7631 37.2549 35.5932 35.3846 33.3333 27.3684 21.4286 20.3125 13.6986 8.3333 7. Loop 1 0.3095 0.2381 0.3313 0.3102 0.3692 0.3883 0.3938 0.4076 0.4183 0.4129 0.2600 0.3830 0.3889 0.2500 0.3870 0.4444 0.2649 0.3054 0.3584 0.3500 0.2872 0.4211 0.4600 0.4151 0.4013 0.3765 0.4314 0.3709 0.4405 0.4200 0.3000 0.5030 0.4500 0.4580 0.4500 0.2549 0.5124 0.5726 0.4510 0.2900 0.3421 0.5373 0.3787 0.5274 0.4484 0.5265 0.3246 0.4636 0.5900 0.4483 0.2700 0.5491 0.4148 0.5926 0.4398 0.3600 0.2436 40 Hi+1 = LN(Hi+0.5 + W2ReLU(W1Hi+0.5)) Input Format We define the adjacency matrix of the graph as = [a1, a2, ..., an] Rnn. Similarly, we define Actx = [a1,ctx, a2,ctx, ..., an,ctx]. We use one-hot embeddings vi to denote the vertex embedding. We consider the following input sequence format with length + 1 for this task (assuming we already have the embeddings): H0 = (cid:20) v1 a1,ctx a2,ctx v2 (cid:21) vn an,ctx R2nn where the first tokens are the input context graph adjacency matrix. We assume the LoopLM recurrent for steps, and we denote the hidden state sequence for the i-th recurrence: Hi = (cid:34) v(i) 1 a(i) 1 v(i) 2 a(i) 2 (cid:35) . v(i) a(i) For simplicity, we ignore the encoding and decoding process and have direct output protocol: the final output for query (s, t) is the t-th entry of a(L) Now we state the main theorem given the previous setting. . Theorem 2 (LoopLM solves reachability in log steps). Fix as the maximum size of the combined knowledge graph G. Taking the adjacency matrix of the context graph Gctx Rnn fed in as n-token sequence and given query pair (s, t), there exists one-layer, single-head transformer independent of Gctx, with recurrent O(log2 D) times and hidden dimension of de = 2n that can check whether there exists path from to in the combined knowledge graph (G + Gctx), where is the diameter of (G + Gctx). We directly construct the attention and the MLP layer for the LoopLM to implement an algorithm that is similar to Warshalls algorithm, using Boolean matrix powers with repeated squaring. The proof idea is to do parallel search on all pairs connectivity, doubling the reachable distance with each loop. Since the maximum distance (i.e. diameter) is D, we only need O(log D) rounds to decide whether two nodes are connected or not. The attention enables each loop to iterative square the current adjacency matrix, and the MLP stores the hidden encoded graph Gs adjacency matrix to help internal knowledge manipulation. Proof. We assign the parameters Q, K, V, W1, W2 as follows (β + is large scalar): = β (cid:20) In 0nn (cid:21) 0nn 0nn , = = (cid:20)0nn 0nn (cid:21) 0nn In , W2 = I2n, W1 = (cid:20)0nn (cid:21) . 0nn 0nn Recall that the input sequence is H0 = (cid:20) v1 a1,ctx a2,ctx v2 (cid:21) vn an,ctx R2nn, which only contains the input context graphs adjacency matrix. We assume the LoopLM loops for steps, and we denote the hidden state sequence for the i-th loop: Hi = (cid:34) v(i) 1 a(i) 1 v(i) 2 a(i) 2 (cid:35) . v(i) a(i) for query (s, t). The model should check whether (s, t) )t = 1 or 0. We are going to prove by induction that for each recursion, a(i) contains )k = 1) that vertex vj is connected to, and the distance between vj and are less For simplicity, we directly output the t-th entry of a(L) are connected, i.e. (a(L) all the vertices vk (i.e. (a(i) than or equal to 2i1. Therefore, we only need log + 1 loops to get the final answer. Base. When = 1, the constructed parameters ensure that the j-th node vj attend to all the nodes that are directly connected to vj with the same attention score β. This guarantees that the attention layer will average 41 the nodes tokens that vj is connected to. The j-th column of the attention before the thresholding layer becomes (aj,ctx means the nodes that vj connects to) (cid:21) (cid:20)vj = (cid:21) (cid:20) vj aj,ctx + 1 aj,ctx (cid:88) k:(aj,ctx)k=1 (cid:21) (cid:20) 0n ak,ctx This updated adjacency vector naturally contains all nodes that has distance 2 to vj in context graph Gctx after the thresholding layer. It naturally includes nodes with distance 1. Now we consider the output of the MLP layer, which only adds the adjacency matrix of hidden knowledge graph to the residual stream. (cid:21) (cid:20)vj j + W2ReLU (cid:20)0n aj (cid:20)vj (cid:20)vj (cid:20)vj W (cid:21)(cid:19) = + = (cid:18) (cid:21) (cid:21) (cid:21) , which combines the adjacency matrices of the context graph Gctx and the hidden knowledge graph G. After the thresholding in the end, all non-zero entries become 1, which already includes all distance 1 nodes for all nodes. Therefore, we have that a(1) contains all reachable nodes within distance 1 of node vj after the first recursion. j,ctx Induction. Assume at the recursion step (i 1), all a(i) contains all reachable vertices within distance 2i1 of vj. Now the hidden state sequence is going through loop + 1. To finish the proof, we show that a(i+1) contains all reachable vertices within distance 2i of vj. The attention for this stage looks at a(i+1) now, and the j-th node vj uniformly attend to all the nodes that are connected to vj within distance 2i1. The j-th column of the attention before the thresholding layer becomes (a(i) means the number of nodes) (cid:21) (cid:20) vj a(i+0.5) = (cid:21) (cid:20) vj a(i) + 1 a(i) (cid:88) k:(a(i) )k=1 (cid:21) (cid:20) 0n a(i) After thresholding, the adjacency vector aggregates a(i) in combined graph Gctx + G. Meanwhile, a(i) Therefore, the combined vector includes all nodes within distance 2i of vj. Finally, we consider the final MLP: and all a(i) where vk has distance 2i1 to vj contains all vertices connected to vk with distance 2i1. (cid:21) (cid:20) vj a(i+1) = LN (cid:21) (cid:18)(cid:20)vj (cid:18) + W2ReLU W1 (cid:21)(cid:19)(cid:19) (cid:20) vj a(i+0.5) = LN (cid:18)(cid:20) vj a(i+0.5) (cid:21) + (cid:20)0n aj (cid:21)(cid:19) , which also contains all vertices connected to vj with distance 2i. That means (a(i+1) )t is precise indicator of whether (s, t) is connected within 2i distance. By induction, we finish the proof and with = log2 + 1 recursion steps, the model can correctly solve reachability on the combined graph + Gctx. Discussion on related theoretical results We provided modified construction from [12], which requires n3 padding tokens that increase the computation complexity to O(n6). However, our construction requires O(n) hidden dimension as the continuous CoT did in [68]. The Θ(n) requirement is necessary because the superposition in latent space needs to (in the worst case) encode Θ(n) nodes information, which can be theoretical limitation. The requirement can be relaxed when there is an upper bound for the maximum number of vertices that some vertex is connected to. Input format In our construction, the input format is the adjacency matrix of the graph. As natural alternative, [68] used sequence with length O(n2) as the input to encode all the different edges. To make LoopLM also work on this setting, some additional induction head mechanism (similar to [68]) is needed to extract all edges and combine them into the adjacency matrix. With slight modification, we can still get the solution with sequential steps O(log D)."
        },
        {
            "title": "C Evaluations",
            "content": "C.1 Evaluation Settings Base Model Evaluation Settings Table 16 details the evaluation settings and frameworks used for the Ouro base models. Table 16 Evaluation settings and benchmark sources for base models. Benchmark Settings Framework General MMLU [80] MMLU-Pro [81] BBH [82] ARC-C [83] HellaSwag [84] Winogrande [85] Math logprobs, 5-shot lm-eval-harness strict match, 5-shot CoT lm-eval-harness strict match, 3-shot CoT lm-eval-harness logprobs, 25-shot lm-eval-harness logprobs, 10-shot lm-eval-harness logprobs, 5-shot lm-eval-harness GSM8k [86] MATH500 [87] strict match, 3-shot CoT lm-eval-harness strict match, 5-shot CoT In-house Code HumanEval [88] HumanEval+ [57] MBPP [89] MBPP+ [57] pass@1 pass@1 pass@1 pass@1 evalplus evalplus evalplus evalplus Reasoning Model Evaluation Settings Table 17 details the evaluation settings and protocol used for the Ouro-Thinking reasoning models, as described in Section 5.2. All reasoning benchmarks utilized an in-house evaluation harness and an LLM-as-judge protocol with fixed rubric. Table 17 Evaluation settings and protocol for reasoning models (Ouro-Thinking). Benchmark Protocol AIME 2024/2025 OlympiadBench GPQA SuperGPQA BeyondAIME HLE In-house harness; LLM-as-judge In-house harness; LLM-as-judge In-house harness; LLM-as-judge In-house harness; LLM-as-judge In-house harness; LLM-as-judge In-house harness; LLM-as-judge Decoding Settings temp=1.0, top_p=0.7 temp=1.0, top_p=0.7 temp=1.0, top_p=0.7 temp=1.0, top_p=0.7 temp=1.0, top_p=0.7 temp=1.0, top_p=0."
        },
        {
            "title": "D Scaling Law for LoopLMs",
            "content": "To further explore the potential of LoopLM, we conduct series of small-scale experiments to investigate the scalability and predictability inherent in LoopLM. Specifically, our work focuses on the following three research questions: RQ1: What is the performance gap between standard models and LoopLM? RQ2: How do recurrent steps impact the total loss and step-wise loss in the context of LoopLM? RQ3: What is the inherent connection between total loss and step-wise loss? D.1 RQ1: What is the performance gap between standard models and LoopLM? To understand the performance gap between standard models and LoopLM, we quantify this difference in terms of benchmark performance. We also observe how this gap varies with changes in recurrent step and model size to guide the further scaling and iteration of LoopLM. 43 Experimental Setup We prepare five model sizes: 53M, 134M, 374M, 778M, and 1.36B. For recurrent steps, we prepare four different depths: 1, 2, 4, and 8. It is worth noting that for standard models, different recurrent steps effectively multiply the number of layers in the model. We evaluate the performance on the following benchmarks: ARC-Challenge [90], ARC-Easy [90], HellaSwag [84], LAMBADA [91], OpenBookQA [92], and PIQA [93]. In all sub-experiments, we train on 20B tokens using the FineWeb-Edu corpus [36]. We present the benchmark performance from the final step. For LoopLM, the recurrent step used for evaluating is the maximum recurrent step. By observing the trends in the curves, we derive the following observations: 1. Whether standard models or LoopLM, the models performance improves with increasing model size and recurrent step. As shown in Figure 13, for all recurrent steps, the benchmark performance of both the LoopLM and Standard models increases as the model size grows, which aligns with the principle of LLMs: larger is better. As shown in Figure 14, except for the LoopLM at 778M and 1.364B, both the LoopLM and Standard models show that benchmark performance increases as the recurrent step increases. This indicates that latent reasoning is indeed useful for both the LoopLM and Standard Transformer. Figure 13 The average benchmark performance of LoopLM and Standard Transformer models under different recurrent steps as model size varies. With recurrent step of 1 (top left), both models have identical architectures, resulting in overlapping curves. Overall, as the model size increases, the benchmark performance improves. The average benchmark score demonstrates the average results of the six benchmarks. 2. Overall, the performance of the standard model exceeds that of LoopLM under the same conditions. This gap increases with the recurrent step and decreases with the model size. Observing Figure 13 and Figure 14, it is clear that the benchmark performance of the Standard model is consistently higher than that of LoopLM, indicating that the Standard model has scoring advantage without considering computational budget. 44 Figure 14 The average benchmark performance of LoopLM and Standard Transformer models under different model sizes as recurrent step varies. Except for the LoopLM at the model size of 778M and 1.364B, in all other cases, the benchmark performance of the model increases with the increase in recurrent steps. Furthermore, we define the benchmark performance gap as the benchmark performance of the Standard model minus that of LoopLM, and this value is positive in all our experiments. As shown in Table 18, as the recurrent step increases, the benchmark performance gap also increases, suggesting that as the number of recurrences rises, the effect of models not sharing parameters gradually surpasses that of models sharing parameters. Besides, we find that the benchmark performance gap generally has negative correlation with model size when the maximum recurrent step is relatively low, meaning that as the model size increases, the performance of LoopLM becomes closer to that of the Standard model, resulting in smaller gap between the two. This trend is particularly consistent when the recurrent step is 4. Table 18 The average benchmark performance gap between LoopLM and Standard models as the recurrent step varies at different model sizes. The gap is defined as (Standard model score - LoopLM score). As the recurrent step increases, the performance gap generally increases. Average Performance Gap Model Size Step 2 170M 340M 680M 1.3B 0.021 0.023 0.015 0.017 Step 4 0.039 0.037 0.026 0.025 D.2 RQ2: How do recurrent step impact the total loss and step-wise loss in the context of LoopLM? In this subsection, we investigate the predictability and generalizability of LoopLM from the perspective of training loss, examining the impact of recurrent step on the trends in total loss and step-wise loss. The experiment is set up in complete consistency with Section D.1, but we focus more on the total loss and step-wise loss during the training process. Here, step-wise loss refers to the loss of the same LoopLM at different recurrent step. Here, we have following variables: model size , training data size D, maximum recurrent step Tm, recurrent step , total loss Lt, and step-wise loss Ls. Following Chinchilla [94], we first attempt to fit the relationship between Lt and N, D, Tm in the form of power law: Lt = + (N + t1)α + (D + t2)β + (Tm + t3)γ The purpose of t1, t2, and t3 is to prevent the variables from exploding in value near zero, allowing the fitting curve to be smoother. We refer to above formula as the Total Loss Scaling Law. First, to validate the 45 predictability of LoopLM, we fit all the data points, and the resulting curve is shown in Figure 15. We find that the actual loss curve and the predicted loss curve are highly consistent, demonstrating the predictability of LoopLM in terms of model size, training data size, and max recurrent step. We quantify the consistency of the scaling law using the coefficient of determination R2. An absolute value of the R2 closer to 1 indicates better fit, with positive values representing positive correlation and negative values representing negative correlation. Fitting the Total Loss Scaling Law using all data points and calculating R2 with all data points, we obtain an R2 value of 0.9596. This confirms the strong correlation between total loss and model size, training data size, and max recurrent step, demonstrating the predictability of the Total Loss Scaling Law. Figure 15 Illustration of the actual loss curve and the loss curve predicted by the scaling law. To demonstrate the predictability of LoopLM, we have used all data points for fitting, proving its predictability in terms of model size, training data size, and max recurrent step. The orange dashed line represents the prediction, while the blue solid line represents the actual loss. In addition to its predictability, we further explore the generalizability of the Total Loss Scaling Law. Predictability refers to the ability of the Scaling Law to fit all data points into unified curve when all data points are available. Generalizability, on the other hand, indicates whether the Scaling Law can predict unseen data points when fitting is done with subset of data points. For example, generalizability tests whether the performance of 14B model can be predicted using the known performances of 1B and 7B models [95]. To verify its generalizability across model size , training data size D, and maximum recurrent step Tm, we have conducted related experiments, details can be found in Appendix E.1. During the LoopLM training process, we compute the cross-entropy loss at each recurrent step, which we refer to as step-wise loss Ls. We aim to explore the relationship between step-wise loss Ls and the current recurrent step , model size , and training data size D. Similarly, we can fit the scaling law between Ls and N, D, , with the formula as follows: Ls = + (N + t1)α + (D + t2)β + (T + t3)γ 46 We refer to the above formula as the Step-wise Loss Scaling Law. We also present the fitting effectiveness from the perspectives of predictability and generalizability. Regarding predictability, we fit all data points. Even with the same recurrent step, the loss curve can vary significantly across different maximum recurrent steps. To ensure the independence of the variable recurrent step , we do not consider the maximum recurrent step in the Step-wise Loss Scaling Law formula and focus solely on the relationship between Ls and N, D, . Therefore, we have total of three major experiments, each representing the fitting of the Step-wise Loss Scaling Law for maximum recurrent steps of 2, 4, and 8. The fitting results of the Step-wise Loss Scaling Law are shown in Figure 16, Figure 17, and Figure 18, which illustrate the trends of the actual and fitted curves for maximum recurrent steps of 2, 4, and 8, respectively. We find that in some cases in Figure 17 and Figure 18, Ls increases with the increase in D. We consider this special case and will discuss it in detail in Section D.3; we will ignore these outlier data points during fitting. The R2 for the three max recurrent steps are 0.8898, 0.8146, and 0.795, respectively. As the maximum recurrent step increases, the increase in the number of data points leads to lower R2 values. The step-wise loss itself is less stable than the total loss, resulting in greater variability. Thus, the obtained R2 values are not as high as those of the Total Loss Scaling Law. However, it is still evident that the scaling law is able to capture the overall trend of the curves, demonstrating the predictability of the Step-wise Loss Scaling Law. The fitting parameter γ of the Step-wise Loss Scaling Law is positive, indicating that Ls decreases as the recurrent step increases. This aligns with our original intent in the design of the recurrence. Besides, we present the generalizability of the Step-wise Loss Scaling Law in Appendix E.2. Figure 16 Illustration of the actual loss curve and the loss curve predicted by the Step-wise Loss Scaling Law when the maximum recurrent step is equal to 2. In summary, both total loss and step-wise loss exhibit strong correlation with N, D, /Tm. The fitting results demonstrate the predictability and generalizability of the Scaling Law for LoopLM. In next section, we will explore the relationship between total loss and step-wise loss in greater depth. D.3 RQ3: What is the inherent connection between total loss and step-wise loss? We first review the training objectives of LoopLM: Lt = Tm(cid:88) = qϕ(z = x) L(T ) β H(qϕ(z x)) L(T ) represents the step-wise loss at the recurrent step . By analyzing the above form, we can see that the 47 Figure 17 Illustration of the actual loss curve and the loss curve predicted by the Step-wise Loss Scaling Law when the maximum recurrent step is equal to 4. 48 Figure 18 Illustration of the actual loss curve and the loss curve predicted by the Step-wise Loss Scaling Law when the maximum recurrent step is equal to 8. 49 total loss consists of two components. The first part is the expected task loss, which is weighted sum of the step-wise loss. The second part is entropy regularization, whose primary purpose is to ensure that the learned gating mechanism qϕ does not converge to specific recurrent step. In our extensive small-scale experiments, we have observed an interesting phenomenon: the exploitation of total loss for shallow step-wise loss. To be specific, as shown in Figure 17 and Figure 18, when the model size is insufficient, the shallow step-wise loss increases with the growing amount of training data. This is an unusual phenomenon, typically, all step-wise losses should decrease as the amount of training data increases. We attempt to explain this phenomenon. In Section D.2, it is mentioned that the step-wise loss decreases with an increasing recurrent step, indicating that deeper recurrent steps result in lower Ls. To minimize the expected task loss, the learned gating mechanism assigns more weight to deeper recurrent steps. However, entropy regularization ensures that the learned gating mechanism does not deviate too much from the prior distribution. When the model size is insufficient, the amount of information it can encode is limited. To further reduce the total loss, this results in an increase in shallow step-wise loss, which in turn allows the weights to favor higher recurrent steps to lower the total loss. Thus, to ensure that the trend of step-wise loss remains normal, larger model size may be more effective for LoopLM. As mentioned in Section D.2, the scaling law for LoopLM is predictable and generalizable for both total loss and step-wise loss. We have: Lt = Et + L(T ) = Es + At (N + t1t)α + As (N + t1s)α + Bt (D + t2t)β + Bs (D + t2s)β + Ct (Tm + t3t)γ Cs (T + t3s)γ The subscripts and represent the fitting parameters for the Step-wise Loss Scaling Law and the Total Loss Scaling Law, respectively. By substituting the Step-wise Loss Scaling Law into the training objectives, we have: Lt = Tm(cid:88) =1 (cid:18) qϕ(z = x) Es + As (N + t1s)α + Bs (D + t2s)β + Cs (T + t3s)γ (cid:19) β H(qϕ(z x)) For the first three terms in L(T ) , the sum of qϕ equals 1, allowing us to factor it out, which gives us: Lt = Es + As (N + t1s)α + Bs (D + t2s)β + Tm(cid:88) =1 qϕ(z = x) Cs (T + t3s)γ β H(qϕ(z x)) As the amount of training data increases, the learned gating mechanism qϕ stabilizes, and we observe that the value of the entropy regularization term becomes relatively low, accounting for approximately 1% to 5% of the total loss. If the form of qϕ gradually stabilizes, we treat it as constant term, and the formula becomes: Lt = Es + As (N + t1s)α + Bs (D + t2s)β + Eother In Section D.2, when considering the Step-wise Loss Scaling Law, we will fix the maximum recurrent step. Once we determine the models maximum recurrent step Tm, the forms of the above formula and the Total Loss Scaling Law are completely consistent, indicating that there is trend consistency in the scaling law between total loss and step-wise loss. We further demonstrate this through practical experiments. We take the situation where the max recurrent step is equal to 4. First, we perform standard fitting of the Step-wise Loss Scaling Law to obtain the fitting parameters Es, As, Bs, Cs, and so on. Next, we observe and record the distribution of qϕ for each 50 Figure 19 Distribution of the learned ponder weights (qϕ(z = x)) for each recurrent step when the maximum recurrent step Tm = 4. These weights were collected during inference on the MMLU benchmark. recurrent step when the maximum recurrent step Tm = 4, as shown in Figure 19. For convenience, we take the average value of qϕ at different recurrent steps and treat it as normal discrete distribution, resulting in the distribution {0.0004, 0.0855, 0.3793, 0.5348}. We then substitute this distribution and the values into the training objective, ignoring the entropy regularization term (after the training stabilizes, it becomes relatively low, for simplicity, we will just ignore it). This leads to fitting formula, and upon substituting the actual fitting data points and D, the computed R2 value is 0.961, with the fitting results illustrated in Figure 20. We can see that the fitting accuracy is high, and the predicted curve closely matches the actual curve, indicating that, under relatively rough estimate, step-wise loss can be transformed into total loss, thus indirectly suggesting an intrinsic connection between the two. Figure 20 Illustration of the actual loss curve and the loss curve predicted by the estimated Scaling Law when the maximum recurrent step is equal to 4."
        },
        {
            "title": "E Details of the Scaling Law for LoopLM",
            "content": "E.1 Generalizability for the Total Loss Scaling Law To demonstrate the generalizability of the Total Loss Scaling Law across model size, training data, and maximum recurrent step, we have conducted relevant experiments. Our evaluation metric is the coefficient of determination R2. To evaluate the fitting effectiveness of the Scaling Law, we calculate the coefficient of determination of all data points. Model Size Generalizability For model size generalizability, our total data points include five different model sizes: 53M, 134M, 374M, 778M, and 1.364B. We select three model sizes as fitting data points, resulting in (cid:0)5 (cid:1) = 10 possible combinations. After fitting, the average R2 across the 10 combinations is 0.9542, which is 3 similar to the result obtained with the full data points, demonstrating the model size generalizability of the Total Loss Scaling Law. Figure 21 illustrates an example. Training Data Generalizability Regarding the training data size, we are primarily interested in whether the Scaling Law can predict model performance as training data increases. Therefore, we typically use the preceding data points to predict future data points. To align with this starting point, we have conducted three sets of experiments, using the current 25%, 50%, and 75% of the data points as fitting data to predict the overall fitting performance.The R2 values for using the first 25%, 50%, and 75% of the data as fitting 51 Figure 21 Illustration of model size generalizability for the Total Loss Scaling Law. The fitting data includes model sizes of 374M, 778M, and 1.364B. The predicted curves for the unseen model sizes of 53M and 134M closely align with the actual curves, demonstrating the generalizability of the Total Loss Scaling Law with respect to model size. 52 points are 0.9385, 0.9609, and 0.962, respectively. It is evident that as the number of data points increases, the consistency between the fitted curves and the actual curves improves. In other words, if you want to predict model performance at larger training sizes, collecting data points closer to those of larger model sizes will yield better prediction results. Max Recurrent Step Generalizability We have conducted total of three different maximum recurrent steps: 2, 4, and 8. To verify the generalizability with respect to maximum recurrent step, we select two of these as fitting data points and perform the fitting, followed by validation on the full data points and calculation of R2. The average R2 for the three sets of experiments is 0.9581, demonstrating the generalizability of the Total Loss Scaling Law with respect to maximum recurrent step. E.2 Generalizability for the Step-wise Loss Scaling Law Following the same approach as in Section E.1, we seek to explore the performance of the Scaling Law on unseen data points, specifically regarding the generalizability of the Scaling Law. In this subsection, we explore the generalizability of the Step-wise Loss Scaling Law from three aspects: model size generalizability, training data generalizability, and recurrent step generalizability. The evaluation metric remains the coefficient of determination R2. To evaluate performance on unseen data points, we will calculate the coefficient of determination using all data points, while fitting will only use subset of the data points. Model Size Generalizability The Scaling Law experiments include five different model sizes: 53M, 134M, 374M, 778M, and 1.364B. To verify the generalizability of model size, we select three of these as fitting data points. In each fitting experiment, the Scaling Law does not have access to the remaining two model size data points during fitting, ensuring the reasonableness and validity of the results through repeated experiments. Specifically, to save on resources, we have conducted experiments only for max recurrent step of 2 and 4, resulting in total of (cid:0)5 (cid:1) 2 = 20 small experiments. The final experimental results show that for max 3 recurrent step of 2, the average R2 value is 0.8815, while for max recurrent step of 4, the average R2 value is 0.797. This difference is not significant compared to the R2 values obtained from the full data points (0.8898 and 0.8146), demonstrating the generalizability of the Step-wise Loss Scaling Law with respect to model size. To illustrate the results more clearly, we show example fitting curves in Figure 22. It is important to note that using only subset of data points for fitting may lead to miscalculations of the Scaling Law on unseen data points. Due to the nature of the power law, if the values are too small, it may result in very large computed value, causing inaccuracies. To ensure the validity of the fitting, we can attempt to adjust the initial fitting values or impose some constraints on the fitting algorithm. For convenience, we adjust the initial fitting values to make the fitting formula effective over broader range of data points. Training Data Generalizability Following Section E.1, to ensure the validity of the fitting, we have selected the first 25%, 50%, and 75% of the data points for fitting. In the case of max recurrent step of 2, the R2 values are 0.8686, 0.8882, and 0.8896, respectively. For max recurrent step of 4, the R2 values are 0.793, 0.813, and 0.8142. It can be observed that as the number of fitting data points increases, the fitting accuracy improves. This aligns with the intuition that fitting with more data points generally yields better results. Additionally, these results are similar to those obtained from fitting with the full data points (0.8898 and 0.8146), demonstrating the generalizability of the Step-wise Loss Scaling Law with respect to training data. Recurrent Step Generalizability In the case of max recurrent step equal to 2, there are only two recurrent step values, making it unreasonable to conduct generalizability experiments. Therefore, we choose to perform experiments with max recurrent step equal to 4. In this situation, we have four different recurrent step values: 1, 2, 3, and 4. We randomly select three of these as fitting data points, resulting in total of (cid:0)4 (cid:1) = 4 3 experiments. The average R2 value obtained from these four experiments is 0.8118, which is similar to the R2 value of 0.8146 obtained from the full data points, demonstrating the generalizability of the Step-wise Loss Scaling Law with respect to recurrent step. Figure 23 presents specific example, showing high degree of consistency between the fitted curve and the actual curve. 53 Figure 22 Illustration of model size generalizability for the Step-wise Loss Scaling Law. The fitting data comprises three medium model sizes: 134M, 374M, and 778M. To verify the fitting consistency of the model on unseen larger model size 1.364B and unseen smaller model size 53M, we can observe that the predicted curves reflect the trends of the actual data points, demonstrating the generalizability of the Step-wise Loss Scaling Law with respect to the model size. 54 Figure 23 Illustration of recurrent step generalizability for the Step-wise Loss Scaling Law. The fitting data includes three different recurrent steps: recurrent step = 1, 2, and 3. At the unseen data points of recurrent step = 4, the predicted curve closely matches the actual curve, demonstrating the generalizability of the Step-wise Loss Scaling Law with respect to recurrent step."
        }
    ],
    "affiliations": [
        "ByteDance Seed",
        "Carnegie Mellon University",
        "Conscium",
        "M-A-P Core Contributors",
        "Mila - Quebec AI Institute",
        "Peking University",
        "Princeton University",
        "UC Santa Cruz",
        "University of Manchester",
        "University of Montreal",
        "University of Pennsylvania"
    ]
}