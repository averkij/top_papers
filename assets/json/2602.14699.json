{
    "paper_title": "Qute: Towards Quantum-Native Database",
    "authors": [
        "Muzhi Chen",
        "Xuanhe Zhou",
        "Wei Zhou",
        "Bangrui Xu",
        "Surui Tang",
        "Guoliang Li",
        "Bingsheng He",
        "Yeye He",
        "Yitong Song",
        "Fan Wu"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "This paper envisions a quantum database (Qute) that treats quantum computation as a first-class execution option. Unlike prior simulation-based methods that either run quantum algorithms on classical machines or adapt existing databases for quantum simulation, Qute instead (i) compiles an extended form of SQL into gate-efficient quantum circuits, (ii) employs a hybrid optimizer to dynamically select between quantum and classical execution plans, (iii) introduces selective quantum indexing, and (iv) designs fidelity-preserving storage to mitigate current qubit constraints. We also present a three-stage evolution roadmap toward quantum-native database. Finally, by deploying Qute on a real quantum processor (origin_wukong), we show that it outperforms a classical baseline at scale, and we release an open-source prototype at https://github.com/weAIDB/Qute."
        },
        {
            "title": "Start",
            "content": "Qute: Towards Quantum-Native Database Muzhi Chen Shanghai Jiao Tong University inefable@sjtu.edu.cn Xuanhe Zhou Shanghai Jiao Tong University zhouxuanhe@sjtu.edu.cn Wei Zhou Shanghai Jiao Tong University wzdb@sjtu.edu.cn Bangrui Xu Shanghai Jiao Tong University dreameter@sjtu.edu.cn Surui Tang Shanghai Jiao Tong University tangsurui@sjtu.edu.cn Guoliang Li Tsinghua University liguoliang@ tsinghua.edu.cn Bingsheng He National University of Singapore dcsheb@nus.edu.sg Yeye He Microsoft Corporation yeyehe@microsoft.com Yitong Song Hong Kong Baptist University ytsong@hkbu.edu.hk Fan Wu Shanghai Jiao Tong University fwu@cs.sjtu.edu.cn 6 2 0 2 6 1 ] . [ 1 9 9 6 4 1 . 2 0 6 2 : r Abstract This paper envisions quantum database (Qute) that treats quantum computation as first-class execution option. Unlike prior simulation-based methods that either run quantum algorithms on classical machines or adapt existing databases for quantum simulation, Qute instead (i) compiles an extended form of SQL into gate-efficient quantum circuits, (ii) employs hybrid optimizer to dynamically select between quantum and classical execution plans, (iii) introduces selective quantum indexing, and (iv) designs fidelity-preserving storage to mitigate current qubit constraints. We also present three-stage evolution roadmap toward quantumnative database. Finally, by deploying Qute on real quantum processor (origin_wukong), we show that it outperforms classical baseline at scale, and we release an open-source prototype at https:// github.com/ weAIDB/ Qute. 1 Introduction Quantum databases aim to leverage quantum computers to accelerate workloads that are increasingly infeasible for classical machines. For example, analytical query processing in columnar OLAP systems often depends on linear scans over unindexed tables [46]. By leveraging entangled qubit superpositions and quantum algorithms such as Grovers search [45], quantum databases can substantially accelerate these queries. Recent research follows two main directions. First, quantum computation for database applies quantum algorithms to classical databases for tasks like query optimization [26, 38], index tuning [17], approximate query processing [43]. However, they remain simulation-based and lack full-stack quantum integration. Second, database for quantum computation leverages classical database techniques to manage quantum workloads, such as encoding quantum circuits in tabular form, but does not consider optimization on the database side [18, 23]. To address these limitations, we pursue an end-to-end quantum-native database, which treats quantum computation not as an isolated accelerator but as first-class execution substrate integrated throughout query parsing, planning, and execution. However, there are four main challenges. First, SQL operators must be reformulated into representations that map naturally to quantum primitives (e.g., superposition, interference). Second, the optimizer must plan across noise-sensitive quantum operators whose latency, success probability, and approximation error differ fundamentally from classical optimizers. Third, the limited qubit budget makes it necessary to selectively probe only small fraction of the dataset Xuanhe Zhou is the corresponding author. Figure 1: Potential Evolution of Quantum Databases. during quantum execution. Finally, quantum-active attributes must be stored in fidelity-preserving formats to maintain high usability. In this paper, we introduce Qute, an integrated quantum database architecture that addresses the above challenges. First, Qute compiles extended SQL queries into quantum-gate efficient circuits via three-tier intermediate representation. Second, it employs hybrid optimizer that combines quantum and classical operators. Third, it offloads costly operators (e.g., similarity joins) onto quantum circuits that encode computation into probability amplitudes. Fourth, to address scale limitations like qubit numbers, Qute introduces selective quantum indexing based on hybrid tree structures enhanced. Fifth, it adopts fidelity-aware data format and storage engine supporting compressed tensor networks. As shown in Figure 1, we envision the development of quantumnative databases across three stages. In the first stage, quantum computing serves as co-processor for classical systems, where data remains in classical memory and only small subsets are loaded into quantum registers for basic tasks like data filtering. This stage lacks index acceleration and relies on rollback mechanisms to maintain correctness under noise. In the second stage, more data can be stored in quantum memory, enabling hybrid classicalquantum indexing and quantum operators such as joins and aggregations. In the third stage, with scalable fault-tolerant hardware, all data (including multimodal formats like video) can reside in quantum memory, enabling fully quantum-native storage, indexing, processing."
        },
        {
            "title": "2 Preliminary\nWe present quantum concepts supporting Qute, including: (1) qubits,\n(2) quantum gates, and (3) quantum circuits.",
            "content": "Qubit. Classical computers encode information as deterministic bits in {0, 1}, and solve computation tasks by explicitly enumerating and evaluating candidate solutions one by one. In contrast, quantum computers encode information using qubits, whose states are not restricted to single deterministic value but can exist as superpositions of the classical basis states 0 and 1. Upon measurement, qubit collapses to definite value of 0 or 1 [32]. Formally, qubit state is ğœ“ = ğ›¼ 0 + ğ›½ 1, where amplitudes ğ›¼ and ğ›½ encode both magnitude and phase, and measurement yields 0 or 1 with probabilities ğ›¼ 2 and ğ›½ 2 satisfying ğ›¼ 2 + ğ›½ 2 = 1. With qubits, numerous candidate solutions can be represented implicitly [2], and appropriate quantum gates and circuits can amplify the probability of desired solutions, thereby reducing search complexity [15]. Quantum Gate. quantum gate is an operation that changes qubit states in controlled way, enabling amplifying correct possibilities while suppressing incorrect ones. Quantum gates are commonly classified into two types: single-qubit gates and multi-qubit gates. (1) Single-qubit gate manipulates the amplitude (e.g., ğ‘‹ -axis and ğ‘Œ -axis rotations and flips) and phase (e.g., ğ‘ -axis rotations) of an individual qubit to achieve operations essential for data representation and quantum computation. For state preparation, (ğ‘–) the Hadamard (H) gate offers uniform initial representation for quantum computation by mapping basis state into an equal superposition of 0 and 1; (ğ‘–ğ‘–) X-axis and Y-axis rotations (i.e., ğ‘…ğ‘‹ (ğœƒ ) and ğ‘…ğ‘Œ (ğœƒ )) encode row values by adjusting the amplitude contributions of qubit between 0 and 1; (ğ‘–ğ‘–ğ‘–) the Pauli-X flip operates qubit between 0 and 1, which is used to mark specific basis states. For phase adjustment, Z-axis rotation gate (i.e., ğ‘…ğ‘ (ğœƒ )) modifies the relative phase between 0 and 1, which determines whether different possibilities reinforce or cancel each other (thereby amplifying the probability of target rows). For value encoding, parameterized rotations ğ‘…ğ›¼ (ğœƒ ), where ğ›¼ {ğ‘‹, ğ‘Œ , ğ‘ }, adjust both magnitudes and phases, allowing numerical information to be embedded [30, 32]. (2) Multi-qubit gate performs conditional operations and create entanglement among qubits, thereby establishing their correlations. Such correlations are essential for quantum parallelism and computational speedups that cannot be achieved on classical computers. Multi-qubit gates can be broadly classified into three categories: (ğ‘–) Controlled gates act on target qubits only when the control qubits are in specific states; (ğ‘–ğ‘–) Entangling gates bind multiple qubits together to create non-classical correlations; (ğ‘–ğ‘–ğ‘–) Permutation gates exchange the states of qubits to rearrange data. For example, Controlled-SWAP (CSWAP) gate, which combines controlled and permutation operations, swaps the states of two target qubits only when the control qubit is in specific state [29]. Quantum Circuit. quantum circuit organizes sequence of quantum gates to implement quantum algorithms and produce the desired results. We use representative quantum circuit (i.e., Grovers Algorithm [16]) to illustrate its potential for accelerating data filtering. Given boolean predicate ğ‘“ : {0, 1} (in the SQL WHERE clause) over dataset of size ğ‘ = X, data filtering identifies all records ğ‘¥ such that ğ‘“ (ğ‘¥) = 1. The circuit begins by uniformly encoding the full dataset via the gate, and then organizes sequence of gates with the following two operators. (1) Oracle (ğ‘¶ğ’‡ ): The oracle acts as predicate evaluator, implemented as quantum operator that encodes the query condition Table 1: Classical vs. Quantum Database Components. Component Classical Database Quantum Database Compiler Operator Plan Optimizer Generate efficient machine code for classic execution (CPUs, GPUs, ...). Perform tuple-at-a-time or vectorized processing (CPU cost ). Select the lowest-cost deterministic execution path. Data Indexing Accelerate lookup operations. Generate circuits executable directly on the quantum backend. Replace tuple scans with amplitude and interference operations. Dynamically speedup vs. noise / success rate. Shrink the candidate set that must be loaded into quantum computer. quantum balance Data Format Byte-addressable and easy to parse. Encode data in qubit states. Storage Engine Ensure durability and efficient I/O. Maintain reconstructable large-scale data with compression techniques. (e.g., ğ‘“ (ğ‘¥) = 1). Applied to superposition ğ‘¥, it marks records satisfying the predicate by phase inversion, i.e., ğ‘‚ ğ‘“ ğ‘¥ = (1) ğ‘“ (ğ‘¥ ) ğ‘¥. (2) Diffusion Operator (ğ‘«): This operator amplifies success probability by reflecting probability amplitudes about their mean, increasing the amplitudes of marked states and suppressing others. It is implemented by applying gates to all qubits, performing multi-qubit phase inversion on 0 0 state, and then reversing the Hadamard transformation, i.e., ğ· = 2 ğ‘  ğ‘  ğ¼ . By iteratively applying the operator ğº = ğ·ğ‘‚ ğ‘“ for ğ‘˜ ğœ‹ 4 ğ‘ /ğ‘€ steps (where ğ‘€ is the matched record count), measurement yields the matched record with high probability. Unlike classical linear scan requiring ğ‘‚ (ğ‘ ) predicate evaluations, the circuit finds matching records using ğ‘‚ ( ğ‘ ) evaluations (i.e., the worst case ğ‘€ = 1), highlighting its advantage for filtering over unindexed data."
        },
        {
            "title": "3 System Overview\nWe present differences between classical and quantum databases\n(Table 1) and we outline the key components of Qute (Figure 2).\nDesign Principles. Quantum databases follow several design prin-\nciples that differ from classical ones. (1) Minimize quantum data\nloading by aggressively shrinking the quantum-active footprint\n(e.g., via selective indexing, pre-filtering, on-demand encoding).\n(2) Leverage amplitude-level parallelism instead of tuple-by-tuple\nprocessing (e.g., reformulating as quantum operators). (3) Adopt\nfidelity-aware optimization strategies (e.g., potential noise in quan-\ntum operators). (4) Maintain hybrid executability by keeping both\nquantum and classical paths viable, thereby resolving hardware\nnoise and resource constraints.\nQuantum SQL Compiler. Qute integrates a quantum-native com-\npilation stack: (1) We handle standard relational operators (e.g.,\nfiltering, aggregation) alongside quantum-friendly functions such\nas sampling-based estimation and probabilistic evaluation, which\ncan be realized using primitives like amplitude estimation [36].\nNote we can automatically generate gate-efficient circuits for each\noperator via a modular circuit generator [33]; (2) We employ a three-\ntier LLVM-style intermediate representation (logical IR, quantum-\nextended IR, and physical circuit IR), supporting stepwise lowering\nfrom declarative SQLs to executable quantum circuits [37]; (3) We\nmaintain a dynamic catalog of rewrite rules that uncovers useful\ntransformations for complex joins, and multi-predicate filter queries\nvia specific quantum features like superposition-enabled probabilis-\ntic branching and interference-based correlation detection.\nQuantum Plan Optimizer. Qute models each quantum operator\nğ‘ using a compact profile (ğ‘‡ğ‘, ğ‘ƒğ‘, ğœ€ğ‘) that summarizes its latency,",
            "content": "2 Quantum Storage Engine. Unlike page-based designs [24], Qute adopts state-centric approach. Quantum-active attributes are stored as compressed tensor networks (TNs), acting as logical pages that support bounded reconstruction and sampling under fidelity constraints. The engine provides fidelity-aware primitives to enable controlled approximation while tracking entropy and noise: LOAD(TN_ID, ğœ–) for approximate access, SAMPLE(TN_ID, ğ‘˜) for bounded sampling, and REFRESH(TN_ID) to restore fidelity when degradation exceeds threshold. Classical metadata is stored separately to ensure recoverability."
        },
        {
            "title": "4.2 Quantum Similarity Join\nSimilarity joins are fundamental in databases and multi-modal data\nretrieval [3, 8, 39, 44]. They aim to retrieve all pairs of vectors from\ntwo datasets whose distances are within a given threshold. The core\noperation of a similarity join is distance computation (e.g., inner\nproduct), which determines the set of vectors that are similar (i.e.,\nwith small distance) to each input vector. Classical machines typi-\ncally incur high costs to compute inner products between vectors\n(e.g., due to repeated dimension-wise multiplication and distance\nevaluations across numerous vector pairs). Instead, Qute encodes\nvectors into quantum states and computes the inner product with-\nout explicitly traversing all dimensions or candidate vector pairs.\nCircuit Design. As illustrated in Figure 3, given two normalized\nvectors (cid:174)ğ‘¥, (cid:174)ğ‘¦ âˆˆ Rğ‘‘ , Qute first encodes them into quantum states\n|ğ‘¥âŸ© and |ğ‘¦âŸ©. Each vector is transformed into a quantum state us-\ning parameterized single-qubit rotations (e.g., ğ‘…ğ‘Œ (ğœƒ )), following\nthe vector-to-state mapping described in Section 3. This encoding\nensures that the inner product between (cid:174)ğ‘¥ and (cid:174)ğ‘¦ is reflected in the",
            "content": "Figure 2: Example Quantum Database System Design. success probability, and approximation error, allowing the optimizer to compare it directly with classical operators. Using these profiles, execution plans embed both quantum and classical realizations of eligible operators, thereby keeping domain choices flexible. At runtime, Qute monitors quality and stability, adapting to noise by increasing shots, switching to more robust circuit variants, or falling back to classical paths when quantum performance degrades. Quantum-Accelerable Operators. Qute offloads costly operations to quantum subroutines that encode computation into probability amplitudes rather than row-wise execution [10, 41]. For instance, for similarity joins, Qute bypasses dimension-wise traversal by encoding vectors into quantum states and estimating their inner products through interference-based overlap. Quantum-Aware Indexing. To address the quantum memory bottleneck, we develop index structures that enable selective quantum probing, meaning that only index entries relevant to the query are probed before allocating quantum resources. We begin with lightweight quantum scans over one-dimensional B+-trees to quickly narrow the candidate set. When this yields only small number of candidates, the remaining work is completed via classical filtering. However, if many candidates persist, we transition to quantum KD-tree that jointly indexes multiple dimensions, enabling more aggressive pruning without exhaustively scanning all rows. Quantum Data Format. (1) Basis Encoding: Core row identifiers like ğ¼ğ·ğ‘Ÿğ‘œğ‘¤ are mapped to computational basis states, enabling uniform superposition and parallel oracle processing. (2) Amplitude Encoding: Data vectors (e.g., embeddings) are encoded into state amplitudes via rotation gates, compressing values into probability distributions aligned with row indices. (3) Control Encoding: Metadata and flags are stored in ancilla qubits that act as control lines, enabling conditional gate execution based on row-level attributes. 3 Table 2: Quantum-Accelerable Relational Operators (ğ‘€ and ğ‘ are total and qualifying row numbers; ğ‘‘ is the vector dimension; ğœ– is precision; ğ‘› and ğ‘ are qubit counts for data and precision registers; ğ‘ is ancilla; ğ‘ is bandwidth; ğ· is the gate depth). Type Operator (SQL) Typical Scenario Candidate Quantum Algorithm Equality Filter WHERE column = value Grover [16] (Search) Filter Range Filter WHERE column > value LIKE WHERE column LIKE val% EXISTS Existence check Equi-join column1 = column2 Join Non-equi join column1 column2 Similarity Join Similarity search Grover [16] (Threshold Oracle) Grover [16] (Prefix-Match Oracle) Grover [16] (Quantum Counting) Grover [16] (Index Probing) Grover [16] (Comparison Oracle) Grover [16] (SWAP Test) Aggregation MIN Global minimum search COUNT Cardinality estimation SUM AVG Total value calculation Mean value calculation DÃ¼rrHÃ¸yer Minimum Finding [9] Amplitude Estimation [6] Normalization + Amplitude Estimation [6] Normalization + Amplitude Estimation [6] Other Sampling Approximate query Amplitude Estimation [6] overlap between the corresponding quantum states. To estimate this overlap, Qute employs the SWAP Test [10], standard quantum subroutine for inner product estimation. Specifically, an ancilla qubit is initialized into uniform superposition using an gate, after which CSWAP operation is applied between the two data registers conditioned on the ancilla. second gate is then applied to the ancilla qubit. Upon measuring the ancilla qubit, the probability of observing outcome 0 is given by Pr[ancilla = 0] = (1+ ğ‘¥ ğ‘¦2)/2. By repeatedly executing the circuit and measuring the ancilla qubit, Qute estimates ğ‘¥ ğ‘¦2 from the empirical measurement frequency. Classical post-processing converts measurement outcomes into approximate inner products for identifying vector pairs."
        },
        {
            "title": "4.3 Quantum Aggregation\nClassical aggregations (e.g., SUM) compute results by iterating\nthrough all qualifying rows and accumulating their values. It incurs\nhigh latency when the qualifying set is large, as it scales linearly\nwith the row volumes. Quantum systems encode information as\nprobability amplitudes, making it infeasible to replicate a classical\naccumulator directly. To address this, Qute reformulates aggrega-\ntion as a probability estimation task so that I/O does not dominate\nend-to-end cost with coherent vector access (e.g. via QRAM). By\nmapping numeric values to the observation probability of a target\nqubit, it utilizes amplitude estimation [6] to compute the global\nsum efficiently without iterating through individual rows.\nCircuit Design. Qute first prepares a uniform superposition over\nall ğ‘ candidate row identifiers. For each row identifier |ğ‘¥âŸ©, the cor-\nresponding value ğ‘£ (ğ‘¥) is accessed and used to control a dedicated\nflag qubit, referred to as the Good qubit. Specifically, a controlled\nrotation is applied so that the probability of the Good qubit being\nmeasured as |1âŸ© is proportional to the normalized value ğ‘£ (ğ‘¥)/ğ‘‰max,",
            "content": "4 Complexity Cost Model Quantum Classical (without index) ğ‘ ) ğ‘ ) ğ‘ ) ğ‘ ) ğ‘‚ ( ğ‘‚ ( ğ‘‚ ( ğ‘‚ ( ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) Qubit Num ğ‘› + ğ‘orc ğ‘› + ğ‘ + ğ‘cmp ğ‘› + ğ‘ + ğ‘pref ğ‘› + ğ‘orc ğ‘‚ ğ‘‚ (cid:16) Gate Depth (per-circuit call) (ğ·orc + ğ·diff ) ğ‘ /ğ‘€ ğ‘‚ (cid:16) (ğ·cmp (ğ‘ ) + ğ·diff ) ğ‘ /ğ‘€ (ğ·pref (ğ‘ ) + ğ·diff ) ğ‘ /ğ‘€ (cid:17) (cid:16) (cid:17) (cid:17) (cid:16) ğ‘‚ (ğ·orc + ğ·diff ) (cid:17) ğ‘ ğ‘‚ ( ğ‘2 ) / probe ğ‘‚ (ğ‘1 ğ‘2 ) ğ‘›2 + ğ‘key + ğ‘orc ğ‘‚ (cid:0)(ğ·idx + ğ·key + ğ·diff (ğ‘›2 ) ) (cid:1) ğ‘2 /probe O( ğ‘2) / probe ğ‘‚ (ğ‘1 ğ‘2 ) ğ‘‚ (ğ‘‘ ğ‘ ) ğ‘‚ ( ğ‘ ) ğ‘›2 + ğ‘key + ğ‘ + ğ‘cmp 2ğ‘ + ğ‘prep + 1 ğ‘‚ (cid:0)(ğ·cmp + ğ·diff (ğ‘›2 ) ) (cid:1) ğ‘2 /probe ğ‘‚ (cid:0)2 ğ·prep (ğ‘‘ ) + ğ‘‚ (ğ‘) (cid:1) ğ‘‚ ( ğ‘ ) ğ‘‚ (1/ğœ– ) ğ‘‚ (1/ğœ– ) ğ‘‚ (1/ğœ– ) ğ‘‚ ( ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘‚ (ğ‘ ) ğ‘› + ğ‘ + ğ‘cmp ğ‘› + ğ‘orc + ğ‘ğœ– (cid:16) ğ‘‚ (ğ·cmp + ğ·diff ) ğ‘‚ ( (ğ·orc + ğ·diff ) (1/ğœ– ) ) ğ‘ (cid:17) ğ‘› +ğ‘ğ‘£ +ğ‘rot +ğ‘ğœ– ğ‘‚ ( (ğ·load + ğ·rot + ğ·diff ) (1/ğœ– ) ) ğ‘› +ğ‘ğ‘£ +ğ‘rot +ğ‘ğœ– ğ‘‚ ( (ğ·load + ğ·rot + ğ·diff ) (1/ğœ– ) ) (cid:16) (cid:17) ğ‘‚ (ğ·orc + ğ·diff ) ğ‘ /ğ‘€ ğ‘› + ğ‘orc where ğ‘‰max is known upper bound on the aggregated values. Intuitively, rows with larger values contribute more strongly to the probability of observing the Good flag. The overall probability of measuring the Good qubit as 1 corresponds to the average of the normalized values across all rows, i.e., ğ‘ƒğ‘Ÿ [Good = 1] = 1 . By ğ‘ estimating using amplitude estimation and scaling it by ğ‘ and ğ‘‰max, Qute recovers the desired result: SUM(ğ‘£) = ğ‘ ğ‘‰max Pr[Good = 1]. (cid:205)ğ‘ 1 ğ‘¥=0 ğ‘£ (ğ‘¥ ) ğ‘‰max"
        },
        {
            "title": "5 Quantum-Aware Index Structure\nDue to limited qubit capacity and circuit depth, existing quantum\ncomputers can encode only a small fraction of data in superpo-\nsition [18], making selective data loading essential. Existing ap-\nproaches load only relevant B+-tree leaf nodes into the quantum\nprocessor, but this strategy generalizes poorly to multi-dimensional\nqueries and suffers significant performance degradation. We there-\nfore propose a quantum-accelerated indexing strategy that narrows\nthe query scope early via lightweight probing, supporting both one-\nand multi-dimensional workloads.",
            "content": "Our strategy integrates quantum probing on selected dimensions with classical post-filtering. For multi-column predicates (Figure 4), we first probe several one-dimensional quantum B+-trees constructed on selected dimensions. This probing identifies nodes that are fully contained in, or partially overlap with, the query range [27]. For example, for the query ğ‘1 : ğ‘‘1 [5, 8], quantum probe returns ğ‘˜1 = 4 tuples satisfying the predicate on ğ‘‘1. Among the result sets returned by all probed B+-trees, we select the smallest one as the candidate set, and denote its size by ğ‘˜ğ‘  . Based on ğ‘˜ğ‘  , we dynamically choose between two strategies. (1) Classical Post-Filtering. If the number of candidates is small (i.e., ğ‘˜ğ‘  = ğ‘‚ (log ğ‘ )), we perform classical verification on the remaining ğ‘‘ 1 dimensions. For query ğ‘1, we further filter the 4 retrieved rows using the secondary predicate ğ‘‘2 [1, 6]. It incurs cost of ğ‘‚ (ğ‘˜ğ‘  (ğ‘‘ 1)), efficient due to the small candidate size. Figure 3: CSWAP-Gate Based Inner Product Calculation. Figure 4: Quantum-Aware Multi-Dimensional Index. (2) Quantum Multi-Divided KD-Tree Search. If ğ‘˜ğ‘  is large, classical filtering becomes less effective. We escalate to quantum multi-divided KD-tree that jointly indexes multiple dimensions. By recursively partitioning the data along different dimensions and applying quantum-assisted probing at each level, this structure significantly reduces the candidate set before verification, making it more suitable for large ğ‘˜ğ‘  scenarios. Additionally, for queries involving disjunctive conditions (e.g., ğ‘‘1 [5, 8] ğ‘‘2 [2, 5]), we independently probe each dimension and combine the resulting superpositions."
        },
        {
            "title": "6 Quantum-Aware Optimizer\nClassical query optimizers rely on deterministic assumptions that\nfail to capture the stochasticity and noise inherent in quantum hard-\nware. Qute addresses this limitation by treating quantum operators\nas probabilistic, accuracy-bounded primitives, thereby shifting the\noptimization goal from pure latency minimization to a robust trade-\noff between speed and reliability.\nEstimation Model. The cost model extends classical optimization\nby treating a quantum operator as a stochastic, accuracy-bounded\nprimitive rather than a deterministic function. The optimizer eval-\nuates each operator using a compact tuple (ğ‘‡ğ‘, ğ‘ƒğ‘, ğœ€ğ‘) that captures\nits latency, success probability, and approximation error, which\nare quantified directly from circuit structure and hardware char-\nacteristics. Each factor is explicitly incorporated into the objective\nfunction, allowing the optimizer to trade off execution speed against\nexpected reliability under real hardware behavior.\nâ€¢ (1) Time Estimation (ğ‘»ğ’’). Execution time is derived from the\ncircuitâ€™s layerized schedule after topology-aware routing. For layers\nğ¿ = {ğ¿1, . . . , ğ¿ğ¾ }, ğ‘‡ğ‘ = (cid:205)ğ¾\n, where ğ‘¡ğ‘” is the\nğ‘˜=1\ncalibrated duration of each gate and ğ‘¡ctrl accounts for control and\nsynchronization overheads between layers. It involves two latency\ncontributors: (i) serialization imposed by limited qubit connectivity\nand (ii) SWAP-induced depth inflation, both of which are used to\nassess whether a quantum operator outperforms the classical ones.\nâ€¢ (2) Noise and Success Probability (ğ‘·ğ’’). Quantum success prob-\nability is estimated as a circuit-level composition of gate errors\n(cid:17)\nand decoherence. For each layer, ğ‘ğ‘˜ =\nwith ğœ–ğ‘” the hardware-reported gate error rates and ğ‘‡ eff",
            "content": "1 (cid:205)ğ‘”ğ¿ğ‘˜ ğ‘¡ğ‘” + ğ‘¡ctrl maxğ‘”ğ¿ğ‘˜ ğ‘¡ğ‘˜ ğ‘‡ eff 2 exp ğœ–ğ‘” (cid:16) (cid:17) (cid:16) (cid:16) (cid:17) 2 an effective , 5 ğ‘ ğ‘ ğ‘˜= coherence bound. The operator-level success probability is approximated by ğ‘ƒğ‘ = (cid:206)ğ¾ ğ‘ğ‘˜ . It ties plan quality directly to circuit depth and layout: deeper or poorly routed circuits incur multiplicative degradation, guiding the optimizer to prune overly fragile plans. (3) Hybrid Execution Error (ğœºğ’’). Each quantum operator is paired with deterministic classical fallback. The optimizer evaluates its expected runtime as E[ğ‘‡ğ‘] = ğ‘ƒğ‘ ğ‘‡ quantum + (1ğ‘ƒğ‘) ğ‘‡ classical , ensuring that incorrect or failed executions do not compromise result correctness. The approximation error ğœ€ğ‘, derived from the operators amplitude, estimation precision, or sampling budget, is incorporated as constraint or penalty depending on the querys accuracy requirements. Parameters are updated using runtime observations, enabling the optimizer to refine plan choices adaptively. By grounding each component of (ğ‘‡ğ‘, ğ‘ƒğ‘, ğœ€ğ‘) in explicit circuit and hardware features, the model provides concrete and actionable basis for quantum-classical plan cost modeling. Hybrid Plan Generation. In Qute, each plan encodes both quantum and classical implementations of selected operators, preserving semantic equivalence while exposing explicit alternatives for cost and quality trade-offs. Importantly, cross-domain coordination costs (e.g., data movement between classical and quantum runtimes) are explicitly incorporated into the optimizers objective function, preventing overly optimistic cost estimates. Furthermore, Qute supports deferred binding of execution-domain choices, allowing the runtime dispatcher to select the most suitable realization based on real-time conditions (e.g., backend calibration state, queue delays). Adaptive Runtime Optimization. To ensure robust execution in the presence of quantum noise and stochastic failures, Qute integrates adaptive runtime optimization as first-class mechanism. When quantum path fails to meet declared quality or latency thresholds, the system dynamically reallocates effort by increasing the number of sampling shots, switching to more robust circuit variants, or falling back to classical computation. Critically, all such adaptations operate under bounded-error semantics: fallback paths are validated for correctness in advance, and all runtime decisions are constrained by the optimizers declared error and latency budgets. This architecture ensures that query results remain trustworthy even when quantum hardware fails unpredictably, allowing Qute to balance optimism with reliability in real deployments."
        },
        {
            "title": "7 Preliminary Results",
            "content": "Prototype Implementation. We implement minimal prototype of Qute that supports database filtering operations in [1]. The classical execution engine handles SQL parsing, query planning, and result reconciliation, while data filtering is offloaded to quantum computing backend. The prototype is implemented using the QPanda3 library (v1.0) and developed on the origin_wukong platform. All quantum circuits are executed on real QPU with 72 qubits and noise. Each quantum experiment is executed with 2000 measurement shots by default, and the results are averaged. Dataset. To evaluate the effectiveness of quantum computing over large-scale data, we construct synthetic dataset with ğ‘ = 240 tuples using random generation method. We consider filter queries of the form SELECT RID FROM WHERE ğœ™ (ğ‘¥), where ğœ™ consists of single-attribute or conjunctive predicates over the generated attributes. Predicate parameters are chosen to control query selectivity, and the selectivity of each predicate is bounded by 2%, with multiple selectivity levels generated within this bound. Evaluation Methods. Given that classical database runtime is highly sensitive to hardware and system optimizations, we use cost-model-based evaluation for fair comparison of algorithmic complexity. Specifically, we evaluate two approaches: (1) classical database baseline, whose performance is estimated using traditional cost model [28]; and (2) Qute, whose performance is measured using actual execution when the data size permits and otherwise estimated using our cost model (Section 6). Results. Figure 5 compares the processing time of Qute and classical database under increasing data scale. For Qute, the measured runtime on small datasets (up to 210) is shown as discrete sample points with Grover error of 8.0%, while the runtime estimated by our cost model is shown as continuous curve. The close agreement between the measured and estimated results indicates that the cost model accurately captures the performance of Qute and can be reliably used for large-scale extrapolation. The estimated performance of the classical database is also reported for comparison. The results reveal clear crossover point at approximately ğ‘ 230. For smaller datasets, the classical database is faster due to lower constant overhead, whereas for larger datasets, Qute consistently outperforms the classical approach. It highlights the scalability advantage of Qute for extreme-scale, unindexed filtering workloads."
        },
        {
            "title": "8 Evolution and Further Directions\nWe classify the evolution of quantum databases into three stages\n(S1-S3) based on data scale and computational capability (Figure 1).\nâ¶ Quantum-Assisted Database. Quantum computing functions\nas a co-processor to classical systems. Due to limited qubits, short\ncoherence times, and high data-loading costs, quantum resources\nare used only for selective, compute-intensive tasks such as full-\ntable scans using Groverâ€™s search. Data remains in classical memory,\nwith quantum execution triggered in real time. There is no index\nacceleration, and fallback mechanisms ensure correctness when\nquantum runs fail or exceed noise thresholds. The primary bottle-\nneck lies in the classical-to-quantum transfer bandwidth.\nâ· Quantum-Centric Database. With improved quantum mem-\nory and loading methods, quantum computing becomes the main",
            "content": "Figure 5: Performance Comparison (Qute vs. Classic). execution engine. Hybrid quantum-classical indexes emerge, enabling selective access to superposition states. fidelity-aware optimizer plans across quantum and classical paths using cost models that account for decoherence, gate latency, and qubit limits. Routing mechanisms dispatch subqueries accordingly. Core operations such as joins and aggregations are implemented using quantum primitives, including SWAP tests and Amplitude Estimation, enabling efficient hybrid execution. â¸ Quantum-Native Database. At this stage, fault-tolerant quantum hardware supports more powerful storage and computation. All data types (including structured, unstructured, multimodal) reside in quantum memory. Advanced data encodings (e.g., vector quantization algorithms) compress and manipulate large datasets directly. Classical components are minimized, and the system achieves fully quantum-native storage, indexing, and processing."
        },
        {
            "title": "10 Conclusion\nThis paper envisions quantum-native databases as a foundational\nshift in data management, in which quantum computation is in-\ntegrated across the full stack, from query parsing to execution.\nWe proposed Qute, a system that addresses key challenges in op-\nerator compilation, hybrid optimization, selective indexing, and\nfidelity-aware storage. Unlike prior simulation-based approaches,\nQute demonstrates a unified design that supports practical quantum\nquery execution. We outlined a three-stage roadmap highlighting\nboth architectural milestones and research opportunities for the\nfuture of quantum data systems.",
            "content": "6 References [1] Qute. (Quantum Database Prototype). https://github.com/weAIDB/Qute [2] Pablo Arrighi and Gilles Dowek. 2012. The Physical Church-Turing Thesis and the Principles of Quantum Theory. Int. J. Found. Comput. Sci. 23, 5 (2012), 11311146. [3] Martin AumÃ¼ller and Matteo Ceccarello. 2022. Implementing Distributed Approximate Similarity Joins using Locality Sensitive Hashing. In EDBT: International Conference on Extending Database Technology. [4] Tim Bittner and Sven Groppe. 2020. Avoiding Blocking by Scheduling Transactions Using Quantum Annealing. In Proceedings of the 24th Symposium on International Database Engineering & Applications (IDEAS). ACM, 110. [5] Tim Bittner and Sven Groppe. 2020. Hardware Accelerating the Optimization of Transaction Schedules via Quantum Annealing by Avoiding Blocking. Open Journal of Cloud Computing 7, 1 (2020), 121. [6] Gilles Brassard, Peter HÃ¸yer, Michele Mosca, and Alain Tapp. 2002. Quantum Amplitude Amplification and Estimation. Contemp. Math. 305 (2002), 5374. [7] Umut Ã‡alikyilmaz, Sven Groppe, Jinghua Groppe, Tobias Winker, Stefan Prestel, Farida Shagieva, Daanish Arya, Florian Preis, and Le Gruenwald. 2023. Opportunities for Quantum Acceleration of Databases: Optimization of Queries and Transaction Schedules. Proc. VLDB Endow. 16, 9 (2023), 23442353. [8] Yanqi Chen, Xiao Yan, Alexandra Meliou, and Eric Lo. 2025. DiskJoin: Large-scale Vector Similarity Join with SSD. ACM SIGMOD 3, 6 (2025), 127. [9] Christoph DÃ¼rr and Peter HÃ¸yer. 1996. Quantum Algorithm for Finding the Minimum. In Proceedings of the 5th International Conference on Quantum Computing and Quantum Communications (QCQC). Springer, Berlin, Heidelberg, 362371. [10] Wang Fang and Qisheng Wang. 2025. Optimal Quantum Algorithm for Estimating Fidelity to Pure State. In ESA (LIPIcs, Vol. 351). Schloss Dagstuhl - LeibnizZentrum fÃ¼r Informatik, 4:14:12. [11] Tobias Fankhauser, Marc E. SolÃ¨r, Rudolf M. FÃ¼chslin, and Kurt Stockinger. 2021. Multiple Query Optimization Using Hybrid Approach of Classical and Quantum Computing. arXiv preprint arXiv:2107.10508 (2021). https://arxiv.org/abs/2107. 10508 [12] Tobias Fankhauser, Marc E. Soler, Rudolf M. FÃ¼chslin, and Kurt Stockinger. 2023. Multiple Query Optimization Using Gate-Based Quantum Computer. IEEE Access 11 (2023), 2306623081. doi:10.1109/ACCESS.2023. [13] Kai Fritsch and Stefanie Scherzinger. 2023. Solving Hard Variants of Database Schema Matching on Quantum Computers. Proceedings of the VLDB Endowment 16, 12 (2023), 39903993. [14] Sven Groppe and Jinghua Groppe. 2021. Optimizing Transaction Schedules on Universal Quantum Computers via Code Generation for Grovers Search Algorithm. In Proceedings of the 25th International Database Engineering & Applications Symposium (IDEAS). ACM, 149156. [15] Lov K. Grover. 1996. Fast Quantum Mechanical Algorithm for Database Search. In STOC. ACM, 212219. [16] Lov K. Grover. 1996. fast quantum mechanical algorithm for database search. In Proceedings of the 28th Annual ACM Symposium on Theory of Computing (STOC). 212219. [17] Le Gruenwald, Rui Zhang, and Jialu Zhou. 2023. Index Tuning with Machine Learning on Quantum Computers for Large-Scale Database Applications. In Proceedings of the VLDB 2023 Workshops. VLDB Endowment. [18] Rihan Hai, Shih-Han Hung, Tim Coopmans, Tim Littau, and Floris Geerts. 2025. Quantum Data Management in the NISQ Era. Proc. VLDB Endow. 18, 6 (2025), 17201729. [19] Rihan Hai, Shih-Han Hung, and Sebastian Feld. 2024. Quantum Data Management: From Theory to Opportunities. In ICDE. IEEE, 53765381. [20] Mohsen Heidari, Ananth Y. Grama, and Wojciech Szpankowski. 2022. Toward Physically Realizable Quantum Neural Networks. In Association for the Advancement of Artificial Intelligence (AAAI). https://www.cs.purdue.edu/homes/spa/ papers/AAAI21.pdf Implementation and training scheme for quantum neural networks. [21] Mohsen Heidari, Arun Padakandla, and Wojciech Szpankowski. 2021. Theoretical Framework for Learning from Quantum Data. In IEEE International Symposium on Information Theory (ISIT). https://arxiv.org/abs/2107.06406 Theoretical foundations for learning from quantum data. [22] Manish Kesarwani and Jayant R. Haritsa. 2024. Index Advisors on Quantum Platforms. Proceedings of the VLDB Endowment 17, 12 (2024). [23] Manish Kesarwani and Jayant R. Haritsa. 2024. Is Quantum-Based SQL Query Execution Viable?. In VLDB Workshops. VLDB.org. [24] Tuodu Li, Gongsheng Yuan, Chang Yao, Meng Shi, Ziyue Wang, Ling Qian, and Jiaheng Lu. 2024. Quantum Storage Design for Tables in RDBMS. In VLDB Workshops. VLDB.org. [25] Tim Littau, Ziyu Li, and Rihan Hai. [n. d.]. Towards Quantum Data Structures for Enhanced Database Performance. VLDB 2024 Workshop 2150 ([n. d.]), 8097. [26] Hanwen Liu, Federico M. Spedalieri, and Ibrahim Sabek. 2025. Demonstration of Q2O: Quantum-augmented Query Optimizer. Proceedings of the VLDB Endowment 18, 12 (2025), 54395443. doi:10.14778/3750601. [27] Hao Liu, Xiaotian You, and Raymond Chi-Wing Wong. 2024. First Tree-like Quantum Data Structure: Quantum B+ Tree. CoRR abs/2405.20416 (2024). [28] Stefan Manegold, Peter Boncz, and Martin Kersten. 2002. Generic database cost models for hierarchical memory systems. In VLDB02: Proceedings of the 28th International Conference on Very Large Databases. Elsevier, 191202. [29] D. Michael Miller, Robert Wille, and Zahra Sasanian. 2011. Elementary Quantum Gate Realizations for Multiple-Control Toffoli Gates. In ISMVL. IEEE Computer Society, 288293. [30] Mikko MÃ¶ttÃ¶nen, Juha J. Vartiainen, Ville Bergholm, and Martti M. Salomaa. 2005. Transformation of quantum states using uniformly controlled rotations. Quantum Inf. Comput. 5, 6 (2005), 467473. [31] Nitin Nayak, Jan Rehfeld, Tobias Winker, Benjamin Warnke, Umut Ã‡alÄ±kyÄ±lmaz, and Sven Groppe. 2023. Constructing Optimal Bushy Join Trees by Solving QUBO Problems on Quantum Hardware and Simulators. In Proceedings of the International Workshop on Big Data in Emergent Distributed Environments (BiDEDE). 17. doi:10.1145/3579142.3594298 [33] [32] Michael A. Nielsen and Isaac L. Chuang. 2016. Quantum Computation and Quantum Information (10th Anniversary edition). Cambridge University Press. Jessica Pointing, Oded Padon, Zhihao Jia, Henry Ma, Auguste Hirth, Jens Palsberg, and Alex Aiken. 2021. Quanto: Optimizing Quantum Circuits with Automatic Generation of Circuit Identities. CoRR abs/2111.11387 (2021). [34] Carla Rieger, Michele Grossi, Gian Giacomo Guerreschi, Sofia Vallecorsa, and Martin Werner. 2024. Operational Framework for Quantum Database. arXiv preprint arXiv:2405.14947 (2024). https://arxiv.org/abs/2405.14947 Defines operations and implementation of quantum data storage and manipulation in quantum database framework. [35] Manuel SchÃ¶nberger, Stefanie Scherzinger, and Wolfgang Mauerer. 2023. Ready to Leap (by Co-Design)? Join Order Optimisation on Quantum Hardware. Proceedings of the ACM on Management of Data 1, 1 (2023), 127. doi:10.1145/3581830 [36] Prasanth Shyamsundar. 2023. Non-Boolean quantum amplitude amplification and quantum mean estimation. Quantum Inf. Process. 22, 12 (2023), 423. [37] Yannick Stade, Lukas Burgholzer, and Robert Wille. 2025. Towards Supporting QIR: Steps for Adopting the Quantum Intermediate Representation. In SC Workshops. ACM, 19071915. Immanuel Trummer and Christoph Koch. 2016. Multiple Query Optimization on the D-Wave 2X Adiabatic Quantum Computer. Proceedings of the VLDB Endowment 9, 9 (2016), 684695. doi:10.14778/2947618.2947622 [38] [39] Nimish Ukey, Guangjian Zhang, Zhengyi Yang, Binghao Li, Wei Li, and Wenjie Zhang. 2023. Efficient continuous kNN join over dynamic high-dimensional data. World Wide Web 26, 6 (2023), 37593794. [40] Martin Vogrin, Rok Vogrin, Sven Groppe, and Jinghua Groppe. 2024. Supervised Learning on Relational Databases with Quantum Graph Neural Networks. In Proceedings of the Second International Workshop on Quantum Data Science and Management (QDSM24). https://www.vldb.org/workshops/2024/proceedings/ QDSM/QDSM.5.pdf [41] Nathan Wiebe, Ashish Kapoor, and Krysta M. Svore. 2015. Quantum algorithms for nearest-neighbor methods for supervised and unsupervised learning. Quantum Inf. Comput. 15, 3&4 (2015), 316356. [42] Tobias Winker, Sven Groppe, Valter Uotila, Zhengtong Yan, Jiaheng Lu, Maja Franz, and Wolfgang Mauerer. 2023. Quantum Machine Learning: Foundation, New Techniques, and Opportunities for Database Research. In Companion of the 2023 International Conference on Management of Data (SIGMOD/PODS). Association for Computing Machinery, 4552. https://doi.org/10.1145/3555041.3589404 [43] Sai Wu, Meng Shi, Dongxiang Zhang, Junbo Zhao, Gongsheng Yuan, and Gang Chen. 2024. When Quantum Computing Meets Database: Hybrid Sampling Framework for Approximate Query Processing. IEEE Trans. Knowl. Data Eng. 36, 12 (2024), 95329546. Jiadong Xie, Jeffrey Xu Yu, and Yingfan Liu. 2025. Fast Approximate Similarity Join in Vector Databases. ACM SIGMOD 3, 3, Article 158 (June 2025), 26 pages. doi:10.1145/ [44] [45] Gongsheng Yuan, Yuxing Chen, Jiaheng Lu, Sai Wu, Zhiwei Ye, Ling Qian, and Gang Chen. 2024. Quantum Computing for Databases: Overview and Challenges. CoRR abs/2405.12511 (2024). [46] Xinyu Zeng, Yulong Hui, Jiahong Shen, Andrew Pavlo, Wes McKinney, and Huanchen Zhang. 2023. An Empirical Evaluation of Columnar Storage Formats. Proc. VLDB Endow. 17, 2 (2023), 148161."
        }
    ],
    "affiliations": [
        "Hong Kong Baptist University",
        "Microsoft Corporation",
        "National University of Singapore",
        "Shanghai Jiao Tong University",
        "Tsinghua University"
    ]
}