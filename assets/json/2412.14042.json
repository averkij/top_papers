{
    "paper_title": "CAD-Recode: Reverse Engineering CAD Code from Point Clouds",
    "authors": [
        "Danila Rukhovich",
        "Elona Dupont",
        "Dimitrios Mallis",
        "Kseniya Cherenkova",
        "Anis Kacem",
        "Djamila Aouada"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Computer-Aided Design (CAD) models are typically constructed by sequentially drawing parametric sketches and applying CAD operations to obtain a 3D model. The problem of 3D CAD reverse engineering consists of reconstructing the sketch and CAD operation sequences from 3D representations such as point clouds. In this paper, we address this challenge through novel contributions across three levels: CAD sequence representation, network design, and dataset. In particular, we represent CAD sketch-extrude sequences as Python code. The proposed CAD-Recode translates a point cloud into Python code that, when executed, reconstructs the CAD model. Taking advantage of the exposure of pre-trained Large Language Models (LLMs) to Python code, we leverage a relatively small LLM as a decoder for CAD-Recode and combine it with a lightweight point cloud projector. CAD-Recode is trained solely on a proposed synthetic dataset of one million diverse CAD sequences. CAD-Recode significantly outperforms existing methods across three datasets while requiring fewer input points. Notably, it achieves 10 times lower mean Chamfer distance than state-of-the-art methods on DeepCAD and Fusion360 datasets. Furthermore, we show that our CAD Python code output is interpretable by off-the-shelf LLMs, enabling CAD editing and CAD-specific question answering from point clouds."
        },
        {
            "title": "Start",
            "content": "4 2 0 2 8 1 ] . [ 1 2 4 0 4 1 . 2 1 4 2 : r CAD-Recode: Reverse Engineering CAD Code from Point Clouds Danila Rukhovich1 danila.rukhovich@uni.lu Elona Dupont1 elona.dupont@uni.lu Dimitrios Mallis1 dimitrios.mallis@uni.lu Kseniya Cherenkova12 kseniya.cherenkova@uni.lu Anis Kacem1 anis.kacem@uni.lu Djamila Aouada1 djamila.aouada@uni.lu 1SnT, University of Luxembourg 2Artec3D, Luxembourg"
        },
        {
            "title": "Abstract",
            "content": "Computer-Aided Design (CAD) models are typically constructed by sequentially drawing parametric sketches and applying CAD operations to obtain 3D model. The problem of 3D CAD reverse engineering consists of reconstructing the sketch and CAD operation sequences from 3D representations such as point clouds. In this paper, we address this challenge through novel contributions across three levels: CAD sequence representation, network design, and dataset. In particular, we represent CAD sketch-extrude sequences as Python code. The proposed CAD-Recode translates point cloud into Python code that, when executed, reconstructs the CAD model. Taking advantage of the exposure of pre-trained Large Language Models (LLMs) to Python code, we leverage relatively small LLM as decoder for CAD-Recode and combine it with lightweight point cloud projector. CAD-Recode is trained solely on proposed synthetic dataset of one million diverse CAD sequences. CAD-Recode significantly outperforms existing methods across three datasets while requiring fewer input points. Notably, it achieves 10 times lower mean Chamfer distance than state-of-the-art methods on DeepCAD and Fusion360 datasets. Furthermore, we show that our CAD Python code output is interpretable by off-the-shelf LLMs, enabling CAD editing and CAD-specific question answering from point clouds. 1. Introduction Computer-Aided Design (CAD) modeling is the standard approach for designing manufactured objects, ranging from furniture to mechanical components [2, 29]. However, creating 3D CAD model is time-consuming task that demands specialized expertise, as the model must not only capture the objects shape but also maintain its functional requirementscommonly referred to as the design intent [3, 26]. To streamline this process, 3D CAD reverse Figure 1. 3D CAD reverse engineering consists of converting point cloud into CAD model (top). Existing methods are constrained by the use of method-specific CAD representations and limited hand-crafted training datasets (a). On the contrary, CAD-Recode employs pre-trained LLM with lightweight projector that translates point clouds into executable Python code and is trained on novel large-scale synthetic dataset (b). engineering aims at generating CAD models directly from 3D scanned objects, offering faster and more accessible pathway to CAD creation [16]. Automated 3D CAD reverse engineering has long history in the fields of computer vision and graphics [12, 42], with goals evolving alongside advancements in the field. These objectives have progressed from identifying CAD parts in 3D point clouds [42] to predicting the sequence of steps designer may take to recreate 3D scanned object in CAD software [20, 33]. This latter goal is particularly appealing, as it aims not only to produce final CAD parametric model but also to capture the design steps behind it, enabling further editing within CAD software [20, 44]. In CAD software, designers typically construct their CAD 1 model as feature-based design sequences, where sequence of 2D sketches is transformed into 3D objects via operations such as extrusion and revolution [46, 49]. Following the release of large CAD datasets [6, 21, 46], recent works have focused on learning feature-based CAD sequences from input point clouds, specifically as sketchextrude sequences [11, 20, 27, 32, 38, 44, 47]. As depicted in Figure 1(a), although varying in methodology, these approaches share common pipeline: (1) crafting CAD sketch-extrude sequence representation, (2) converting raw CAD data [21, 46] into this format, and (3) training dedicated neural networks to output these representations from input point clouds. Despite recent advances in feature-based CAD reverse engineering, key limitations constrain the broader applicability of existing approaches. Firstly, existing methods often use customized CAD representations, such as custom CAD languages [11, 20, 33, 47] or simplified extrusion shapes [27, 38, 44], to facilitate model training. These representations are difficult to interpret, require postprocessing to be compatible with CAD tools, and restrict design capabilities to basic operations. Secondly, these approaches typically rely on training dedicated networks from scratch, with some specifically designed to output languagelike CAD representations [11, 20]. This requires the networks not only to learn the geometry of the point clouds and CAD modeling, but also the syntax of the CAD sequence representation. In this paper, we pose the following question: In view of the recent breakthrough performance of Large Language Models (LLMs), how can their advanced language understanding be leveraged for CAD reverse engineering? To address this question, we base our approach on three (1) LLMs can generate valid Python key observations: code [35, 54], (2) modern CAD software increasingly supports modeling through Python scripting [9], and (3) recent efforts have shown that LLMs can be fine-tuned to process input point clouds [48, 60]. As shown in Figure 1(b), we propose, CAD-Recode, solution for CAD reverse engineering by fine-tuning an LLM to map input point clouds into CAD sketch-extrude sequences represented as Python code. In particular, instead of crafting CAD representation, we base our representation on the Python CadQuery library [9]. This code-based representation is not only interpretable but also inherently allows for incorporating modular CAD features and design practices such as reusing design elements and abstracting low-level design steps (e.g. 3D box to represent four-line sketch of square and its extrusion). To learn the mapping between point clouds and CAD Python code, we fine-tune pre-trained LLM, Qwen2-1.5B [54], augmented with lightweight, trainable point cloud projector. To train CAD-Recode, potential approach could be using existing large-scale sketch-extrude datasets [46, 47] and converting them to Python CadQuery code. However, these datasets exhibit some limitations related to their simplicity and lack of diversity [11, 50]. As solution, we leverage our code representation to automatically synthesize one million dataset of CAD sketchextrude sequences as Python CadQuery code. Unlike existing real CAD datasets, this synthetic dataset comprising valid and diverse CAD models provides an alternative for learning the mapping between point clouds and CAD sketch-extrude sequences in Python code, with full control over included design features in the training. Our contributions can be summarized to: CAD sketch-extrude sequence representation in Python code using CadQuery [9] for CAD reverse engineering. synthetic dataset containing one million diverse and valid CAD sketch-extrude sequences, encoded as Python code in CadQuery format. To the best of our knowledge, this represents the largest available CAD sketch-extrude dataset. We will make this dataset publicly accessible. CAD-Recode, the first LLM-based CAD reverse engineering model designed to predict CAD Python code from point clouds. The model, consisting of pre-trained LLM and point cloud projector is trained end-to-end to generate code that reconstructs the input geometry. improvements over Extensive experiments on three publicly available datasets show that CAD-Recode achieves substantial in CAD reverse engineering. Moreover, we show that CAD-Recode, when operating on point clouds and generating CAD code, can be integrated with an off-the-shelf LLM to perform CAD Question Answering (CAD-QA) and CAD editing from point clouds. state-of-the-art methods 2. Related Works LLM, Point Cloud and CAD: Recent works have explored integrating point clouds with LLMs for various tasks, including 3D generation [55, 61], captioning [15, 17, 48], and question answering [5, 18]. These approaches typically employ complex point cloud encoders, either aligning with CLIP embeddings [30, 52, 53, 60, 63] or directly with LLM feature spaces [48]. Such methods require two-stage training: first pre-training the point cloud encoder, then finetuning with the LLM through instruction-based prompts. In parallel, recent works have started exploring LLMs capabilities in range of CAD-related tasks. ReparamCAD [22] infers shape variations from parametric models and text descriptions, while CADTalk [59] generates semantic descriptions of CAD parts. Query2CAD [1] generates CAD models from text using GPT-4V [35], and SGPBenchmark [37] evaluates LLMs understanding of CAD sketch-extrude sequences using CAD-specific question answering. While Img2CAD [56] attempts CAD reverse en2 gineering from images using GPT-4V [35], it still requires separate transformer for parameter inference. In contrast, CAD-Recode introduces the first approach for point cloud to CAD reconstruction combining point clouds with the sequence modeling capabilities of pre-trained LLMs. CAD Reverse Engineering from Point Cloud: CAD reverse engineering aims to reconstruct parametric CAD models from 3D shapes (e.g., meshes or point clouds) in compatible representation with CAD software. key challenge lies in the choice of this representation. line of works attempts to address sub-problems of the CAD reverse engineering task by focusing on parameter estimation for edges and surface primitives [7, 8, 14, 25, 31, 41, 45, 62] or reconstructing B-Rep construction history [10, 23, 46, 49]. In order to obtain representation that is closer to CAD modelling, several methods [13, 19, 28, 57, 58] use Constructive Solid Geometry (CSG), representing models as compositions of 3D primitives and Boolean operations. While this enables reconstruction, the CSG representation diverges from modern CAD workflows [49]. introduced representation, Recent works have adopted the more CAD-aligned sketch-extrude by DeepCAD [47] for CAD generation [50, 51] or predicting extrusion cylinder [38, 44]. Given the sequential nature of sketch-extrude sequences, methods have explored template-based approach [24] given rounded voxel input representation, and transformer architectures for both autoregressive [20] and non-autoregressive [11, 47] prediction of sketch-extrude sequences from point clouds. The work in [33] combines lightweight pre-trained language model [39] with point cloud encoder using diffusion-based approach. These methods rely on the limited DeepCAD dataset [47], leading to poor cross-dataset performance on Fusion360 [46]. Alternative methods using self-supervised [27] or unsupervised [28] learning still face integration challenges due to their non-standard sketch representations (e.g., signed distance functions). In contrast to these approaches that require full parameter learning of specialized networks for both CAD geometry and representation syntax, we leverage pre-trained LLMs that have been exposed to programming patterns through large-scale training on code repositories. Our method outputs Python code using the CadQuery library [9] that is directly executable and can easily be interpreted. Additionally, we address the data limitation through automated synthesis of large-scale training dataset, enabling full control over design features included during training. 3. CAD Representation as Code Modern feature-based CAD modeling relies on sequences of 2D sketches and operations to create 3D models. Designers first draw geometric primitives (lines, arcs, 3 Sketch 1 Extrude 1 Sketch 2 Extrude (a) Sketch-Extrude sequence SOL Line -25 -25 Line 25 25 Line 25 -25 Line -25 -25 Ext. 0 0 1 0 0 0 7 0 NewBody SOL Circle 0 0 20 SOL Circle 0 0 15 Ext. 0 0 1 0 0 0 -5 0 Union (b) DeepCAD representation import cadquery as cq = cq.Workplane('XY') w.box(50,50,7).union( w.sketch().circle(20).circle(15,mode='s') .finalize().extrude(-5)) (c) Our CadQuery representation Figure 2. Sketch-extrude sequence (top) in DeepCAD representation (middle) and our CadQuery code (bottom). circles) on selected plane, then apply operations like extrusion or revolution to generate 3D geometry [49]. As depicted in Figure 2(a), we focus on the extrusion operation, fundamental CAD operation widely adopted in previous works [20, 47, 50]. Below, we present our CAD representation, highlighting its advantages over existing language-like encodings, and describe our pipeline for generating one million synthetic sketch-extrude sequences. 3.1. CadQuery Code Recent approaches in CAD language modeling [11, 20, 32, 47, 50] encode sketch-extrude sequences as numerical vectors representing features and their parameters as shown in Figure 2(b). However, this representation constrains the modeling to specific CAD practices, lacks interpretability, and requires post-processing for CAD kernel compatibility. We propose using CadQuery [9] Python code to represent sketch-extrude sequences for CAD reverse engineering, offering the following advantages: Modularity of CAD Features and Design Practices: Existing language-based CAD reverse engineering methods rely on custom representations of low-level geometric features (lines, arcs, circles) for sketch construction [40, 47]. This approach inherently limits the range of implementable features and design practices. In contrast, CadQuery provides comprehensive built-in CAD functionality, encompassing both low-level features and higher-level geometries like cylinders and boxes as show in Figure 2(c). Furthermore, its programmatic nature enables variable reuse and code modularity. This allows for reusing common design features or practices across models, as illustrated by the shared circle center coordinates across two circles in Figure 2 (c). This representation naturally accommodates diverse CAD features and design practices without requiring complex custom encodings or post-processing steps. Interpretability and LLM Compatibility: The proposed representation, based on Python and CadQuery syntax, presents an alternative to abstract numerical encodings with improved interpretability. Its code-based format facilitates model editing both programmatically and through CAD software. Importantly, this representation aligns with pretrained LLMs demonstrated proficiency in Python code generation and manipulation. Indeed, state-of-the-art proprietary LLMs like GPT-4 [35] achieve over 90% accuracy on the Python code HumanEval benchmark [4], while even lightweight open-source models such as Qwen2-1.5B [54] show promising code generation capabilities. Hence, this code representation facilitates fine-tuning of pre-trained LLMs for the specific task of reverse engineering point clouds into CAD Python code and opens the doors for new capabilities with off-the-shelf LLMs. 3.2. Proposed Synthetic Dataset Figure 3. Examples of synthetically generated CAD models. Current CAD sketch-extrude reverse engineering methods [11, 20, 32, 33, 47] predominantly rely on CAD datasets collected from CAD model repositories [6, 21, 46], which are often simplified to facilitate model training [44, 47]. Due to the required collection and parsing efforts, the resulting datasets are restricted in scale (e.g., 180 models for DeepCAD [47] and 8 models for Fusion360 [46]). Furthermore, the DeepCAD dataset [47], although relatively large, has been found to contain duplicate samples within the training set [50] and across train-test splits [11], resulting in limited evaluation capabilities and constrained geometric diversity for model training. To address these limitations, we develop synthetic data generation pipeline that leverages CadQuery [9] to generate dataset of one million CAD models in the form of sketchextrude sequences written in Python CadQuery code. Some examples of this dataset are shown in Figure 3. Our proposed pipeline combines random parametric sketch-extrude sequences with topological and geometrical heuristics ensuring the validity and diversity of the resulting CAD models. The modularity of CAD features is incorporated by utilizing both low-level primitives and their abstractions, as well as reusing design elements within the generated sequences. While our synthetic dataset does not include sequences from real CAD models, it offers significant control over the features and design patterns to which the network is exposed during training. An algorithm outlining the steps of this data generation pipeline is provided in the supplementary materials. It is important to note that, in this work, we focus on some modularity aspects (i.e., reusing point coordinates, extrusion planes, and abstracting basic shapes like boxes and cylinders). Further modularity features (e.g., reusing functions corresponding to arbitrary CAD parts, additional CAD operations) can also be integrated in the future by incorporating appropriate validation heuristics. 4. CAD-Recode Building on the introduced CAD code representation and synthetic data outlined in the previous section, this section introduces CAD-Recode, our proposed model for predicting CAD sketch-extrude sequences as code from input point clouds. We formalize the problem of CAD code prediction, describe the architecture of CAD-Recode, and detail its training and inference processes. 4.1. Problem Statement Let us denote the set of all possible code strings as Σ, where each code string is composed of elements from the finite set of alphanumeric characters and operators in the programming language Σ. Let ϕsyn : Σ {True, False} represent the syntactic validation function for Python programming rules (e.g., variable declarations, expression syntax, and statement structure), and ϕcad : Σ {True, False} denote the validation function for CAD-specific rules. The latter includes the syntactic validity of the code w.r.t. to the CAD library, i.e. CadQuery [9], and the geometric validity of the reconstructed model from the code (e.g., an extrusion can only be applied on closed loop of 2D primitives, circle radius cannot be negative). An executable valid CAD model can be formally described by code string C, where = {w Σ ϕsyn(w) ϕcad(w)} , represents the set of all valid CAD codes. This formulation ensures that any code string in satisfies both the syntactic requirements of Python (ϕsyn) and the CAD code validai=1 Rn3 denote an tion rules (ϕcad). Let = {pi}n input point cloud, where each point pi R3 represents 3D Cartesian coordinates. The objective of CAD-Recode is to learn mapping Ψ : Rn3 C, = Ψ(P) , that maps the input point cloud to valid CAD code such that the code, when executed, generates 3D model geometrically approximating P. Figure 4. Overview of CAD-Recode. The pipeline comprises two parts: (1) point cloud projector (marked blue) (2) fine-tuned pretrained LLM (yellow). An input point cloud is processed using (1), and outputs are then passed to an LLM (2), which predicts CAD sketch-extrude sequence in the form of executable Python code. 4.2. Proposed Model Architecture CAD-Recode builds on pre-trained LLMs and their prior exposure to Python code, augmenting these with point cloud processing capabilities and CAD-specific Python code knowledge. As shown in Figure 4, its architecture consists of two components: (1) point cloud projector mapping the 3D point cloud into learnable tokens, and (2) pretrained LLM-based auto-regressive CAD code decoder. p, . . . , qnp Point Cloud Projection Module: CAD-Recode introduces lightweight projection module Ψp that directly maps dense point cloud Rndp , where dp = 6 corresponds to the dimension of point coordinates and surface normals, into sequence of np query tokens ] Rnpdq , of embedding dimension Qp = [q1 dq. The point cloud projector, trained in an end-to-end manner with the CAD code decoder module, consists of four simple components: (1) uniform random sampling to downsample the input point clouds to np points, (2) lexicographic sorting by (z, y, x) coordinates for consistent ordering, (3) Fourier positional encoding [61] of coordinates and concatenating with point normals, and (4) linear layer projecting the encoded coordinates and normals into Qp. LLM as CAD Code Decoder: Our CAD code decoder, denoted as ΨLLM, adapts pre-trained LLM for the specific task of CAD code generation. We leverage the Qwen2-1.5B model [54] as our LLM backbone, chosen for its balanced trade-off between model capacity and computational requirements. The decoders input consists of point query tokens Qp from the point cloud projector, augmented with nt code tokens Qt Rntdq obtained by tokenizing the input code as in [54]. The complete input sequence is denoted as [Qp; Qt] R(np+nt)dq , where semicolon indicates concatenation along the sequence dimension. The LLM decoder generates the CAD code sequence through next-token prediction. As in [54], each predicted token is mapped to symbol from the vocabulary Σ, which includes alphanumeric characters and operators. Overall, CAD-Recode repurposes the LLMs sequence modeling capabilities for the specialized task of translating geometric point clouds into executable CAD code. 4.3. Training and Inference Details Training Strategy: Our training process consists of single stage. The model operates on query tokens of dimension dq = 1536 and processes input point clouds downsampled to np = 256 points. The network is trained on the proposed synthetic dataset, hence exposed to the CAD features and design practices that were included in the data synthesis. The training objective minimizes the Negative Log-Likelihood (NLL) of the target CAD code sequence, using special tokens (<s> and <e>) to demarcate sequence boundaries. The point cloud projector Ψp learns geometric features from scratch, while the pre-trained decoder ΨLLM is fine-tuned for CAD code generation. Inference Strategy: At inference time, the point cloud projector Ψp processes the input point cloud to generate query tokens Qp, which are then fed to the decoder along with the start token <s>. The model autoregressively generates CAD code tokens until producing complete code sequence ending with token <e>. We employ multicandidate approach where we generate ten distinct CAD code candidates, each from different sampling of the input point cloud. For each candidate, we sample points from the predicted CAD model and compute the Chamfer distance w.r.t. the input point cloud. The candidate with the minimum Chamfer distance is selected as the final output. This verification step effectively filters out geometrically inconsistent solutions and invalid CAD codes. 5. Experiments In order to validate the effectiveness of CAD-Recode, we conduct series of experiments across two different scenarios. The first scenario focuses on the reverse engineering task, where the goal is to reconstruct CAD sketch-extrude sequence in Python code from given input point cloud. The second assesses the interpretability and editability of the generated CAD code with proprietary LLM [35]. 5 Method Venue ICCV21 DeepCAD [47] SIGG22 PrismCAD [24] CVPR22 Point2Cyl [44] ECCV22 ExtrudeNet [38] CVPR23 SECAD-Net [27] ICML23 HNC-CAD [51] CIKM23 MultiCAD [32] TransCAD [11] ECCV24 CAD-Diffuser [33] CVPR24 CVPR24 CAD-SIGNet [20] CAD-Recode DeepCAD Dataset Mean CD Med. CD IoU IR Mean CD Med. CD IoU Fusion360 Dataset 42.5 32.3 3.43 0.308 9.64 4.28 4.27 3.37 3.65 8.64 8.09 4.51 3.02 0.283 0.168 46.7 72.1 73.8 40.3 72.9 65.3 65.5 74.3 77.6 87.6 7.1 16.2 3.9 25.3 7.7 5.6 11.5 1.10 1.5 0.9 0. 330 78.6 7.37 0.425 89.2 4.75 4.18 4.95 4.32 36.8 42.2 33.4 3.85 0.48 0.159 39.9 65.3 67.5 37.3 69.0 63.5 60.2 63.2 65.6 83.1 IR 25.2 18.0 3.2 24.9 7.5 7.3 16.5 2.4 1.7 1.6 0.9 Table 1. Comparison of various CAD reverse engineering methods on DeepCAD and Fusion360 datasets. Our CAD-Recode, trained solely on our synthetic dataset, sets new state-of-the-art in both benchmarks on all metrics. 5.1. Reverse Engineering Experimental Setup: CAD-Recode is evaluated on three test datasets: DeepCAD [47] (8046 models), Fusion360 [46] (1725 models), and CC3D [34] (2973 models). Unlike baseline methods which are typically trained on DeepCAD [47], CAD-Recode is trained solely on our synthetic dataset, making all experiments cross-dataset evaluations. The point clouds are obtained by sampling points on the meshes for DeepCAD and Fusion360, while CC3D provides actual 3D scans of CAD models. Implementation details are provided in the supplementary. Metrics: To evaluate the quality of the predicted CAD sketch-extrude sequences, we use three metrics: Chamfer Distance (CD) [20], Intersection over Union (IoU) [33], and Invalidity Ratio (IR) [47]. We report both mean and median CD values computed using 8192 points to assess geometric accuracy. Reported CD values have been multiplied by 103. The IoU is computed from the resulting CAD model meshes and expressed as percentage. The IR indicates the percentage of generated sequences that fail to produce valid CAD model, with values below 1% considered negligible. Note that CAD-Recode aims to predict plausible CAD sketch-extrude sequence that reconstructs the geometry given point cloud and not necessarily approximating the ground-truth parametric sequence. As result, we did not include parameter-level metrics reported in [11, 20, 33]. Results & Analysis: Table 1 presents results on the DeepCAD and Fusion360 datasets, where CAD-Recode establishes new state-of-the-art performance across all metrics. Note that the results of state-of-the-art methods in Table 1 are borrowed from [33], except for CAD-SIGNet [20], MultiCAD [32], TransCAD [11], and DeepCAD [47] which were taken from [20] and [11]. Our method achieves significantly better geometric fidelity with median CD of 0.168 on DeepCAD, 41% improvement over the previous best of 0.283 (CAD-SIGNet [20]). The IoU reaches 87.6%, 10% improvement over the previous best of 77.6%. The improvement in mean CD is particularly significant, where our value of 0.308 is an order of magnitude better than most previous methods. As illustrated in Figure 5, this translates to consistent reconstruction quality, where CAD-Recode reliably produces CAD models that accurately capture the geometry of the ground truth, in contrast to CAD-SIGNet [20] which can generate shapes that deviate significantly from the target geometry. Furthermore, our method achieves the lowest invalidity ratio (IR) of 0.5%, demonstrating high reliability in generating valid CAD code sequences. On the Fusion360 dataset, CAD-Recode achieves median CD of 0.159, 66% improvement over the previous best of 0.48 (CAD-SIGNet [20]). The IoU reaches 83.1%, surpassing the previous best of 69.0% (SECAD-Net [27]) by 14%. Notably, these improvements are even more pronounced than on the DeepCAD dataset. This performance is particularly significant as supervised methods trained on DeepCAD face substantial degradation in cross-dataset setting, exemplified by CAD-SIGNet [20] whose mean CD increases from 3.43 to 7.37. In contrast, our training strategy with synthetic data allows CAD-Recode to maintain consistent performance, with minimal change in mean CD from DeepCAD (0.308) to Fusion360 (0.425), while maintaining low IR of 0.9%. Figure 5 illustrates this consistent reconstruction quality across datasets. In Table 2, we evaluate CAD-Recode on the CC3D dataset, where input point clouds come from 3D scans and contain artifacts such as surface noise, smooth edges, and missing parts. Even under these challenging conditions, our method achieves significant improvements over CADSIGNet [20], with 74% lower median CD and 50% 6 DeepCAD Dataset Fusion360 Dataset CC3D Dataset Point Cloud CAD-SIGNet CAD-Recode GT Figure 5. Qualitative results on the DeepCAD, Fusion360, and CC3D datasets. For each input point cloud (first row), we compare CAD models produced by CAD-SIGNet (second) and our CAD-Recode (third) with ground truth CAD model (bottom row). While CADSIGNet often fails to restore the general shape, CAD-Recode outputs only slightly deviate from ground truth in most cases. Method Mean CD Med. CD IoU IR Method Train size DeepCAD [47] CAD-SIGNet [20] CAD-Recode 14.8 4.76 263 2.90 0.761 12.7 42.6 2.5 64.3 3.3 CAD-SIGNet [20] CAD-Recode Synthetic CD 3.43 1.64 0.523 0.308 160 160 160 1 Table 2. Results on the CC3D dataset, where input point clouds are sampled from real 3D scans. CAD-Recode, trained on synthetic data, significantly outperforms DeepCAD, and CAD-SIGNet. higher IoU, while maintaining comparable IR. From the CC3D qualitative results in Figure 5, CAD-Recode is able to recover geometries that are much closer to the ground truth than current state-of-the-art. However, it can be observed that CAD-Recode still lacks the expressiveness to model complex shapes. This can be attributed to the choice of features and design practices in the synthetic dataset preparation and the size of the input point cloud. Nevertheless, we believe that those issues can be addressed in future works by creating more complex samples in the synthetic dataset, fine-tuning on CC3D dataset, and scaling up the LLM and the point cloud projector. Ablation Study: To evaluate the different components of CAD-Recode, we conduct comprehensive ablation study on the point cloud sampling, the number of input points and model parameters, and the type and amount of training data. To assess the impact of our proposed synthetic training data on performance, we ablate the synthetic dataset, and the amount of data used during training. First, we translated the DeepCAD dataset (160 models) to CadQuery (second row of Table 3). Using identical training data, CAD-Recode achieves mean CD of 1.64, less than half that of CAD-SIGNet [20] (3.43), showcasing the effectiveness of CAD-Recode and the proposed CAD code representation. Training on 160 synthetic dataset further improves performance, reducing the mean CD to 0.523. This Table 3. Ablation of training data on the DeepCAD test set. CAD-Recode scales well with the amount of data, and benefits from using our synthetic data for training. The best performance is achieved when trained on 1 synthetic samples. Method Points # Parameters Encoder Decoder CD CAD-SIGNet [20] 8192 114 6 3.43 CAD-Recode 32 64 128 256 48 48 48 83 0.510 0.5 0.371 0.5 0.5 0.367 1.5 0.308 Table 4. Ablation of network architecture on the DeepCAD test set. The results improve with larger point clouds and larger encoder and decoder models. Even with as few as 32 input points, CAD-Recode outperforms CAD-SIGNet with 8192 input points. demonstrates that the proposed synthetic dataset, even at the same scale of DeepCAD dataset, allows for better performance of CAD-Recode. Finally, scaling to 1 synthetic samples results in substantial improvement in mean CD, demonstrating the benefits of our large-scale synthetic data. Results in Table 4 show the relationship between input point cloud size, model architecture, and reconstruction quality. Our method achieves mean CD of 0.510 with just 32 input points using 0.5 parameter decoder significantly outperforming CAD-SIGNet [20] which requires 256 # Samples CAD-SIGNet [20] CD IR CAD-Recode IR CD 1 5 10 6.81 3.43 2. 4.4 0.9 0.3 0.831 0.388 0.308 4.7 0.6 0.5 Table 5. Ablation of the number of sampled predictions during inference on the DeepCAD test. For both CAD-SIGNet and our CAD-Recode, taking 10 samples allows for 3 lower mean CD and invalidity ratio w.r.t using single sample. times more points (8192) to achieve CD of 3.43. This ability to maintain high performance with 256 times fewer input points demonstrates the effectiveness of CAD-Recode in relating sparse geometric information to its CAD sketchIncreasing the point count to 64 subextrude sequences. stantially improves performance (CD: 0.371). Our best results are achieved with 256 points and larger 1.5 parameter decoder (CD: 0.308). Note that as in previous works [11, 20, 33, 44], the point coordinates are supplied with normals in all experiments, hence providing further hints on the surface of the point cloud. We investigate the effectiveness of our multi-candidate approach that generates multiple CAD code predictions through different point cloud samplings, as described in Section 4.3. As shown in Table 5, increasing the number of candidates from 1 to 5 significantly improves the mean CD (from 0.831 to 0.388) and invalidity ratio (from 4.7% to 0.6%). Further improvements are observed with 10 candidates, achieving CD of 0.308 and IR of 0.5%. For comparison, CAD-SIGNet [20] employs probability-based sampling, yet even with single prediction, our method achieves substantially lower mean CD (0.831 vs 6.81). 5.2. CAD-QA and Editability CAD-QA and LLM Interpretability: CAD SGPBench [37] is benchmark of 1000 CAD-specific Question Answering (CAD-QA) tasks that test LLMs understanding of CAD model geometry from sketch-extrude sequences encoded as in DeepCAD [47]. These questions require analyzing various geometric aspects, such as relative sizes and 3D primitive types. We extend this benchmark to evaluate CAD reverse engineering methods by using point clouds as input instead of CAD sequences. Our evaluation follows two-stage process: first predicting sketch-extrude sequences from point clouds as CadQuery code with CAD-Recode, then using GPT-4o [35] to answer CAD-specific questions. Without requiring additional interpretation hints, our approach achieves 76.5% accuracy on this CAD-QA task  (Table 6)  . For comparison, we evaluate two baseline approaches: CAD-SIGNet [20] and PointLLM [48]. When using CAD-SIGNets output with GPT-4o, even with provided interpretation hints explainMethod CAD-QA Accuracy PointLLM [48] CAD-SIGNet [20] GPT-4o CAD-Recode GPT-4o 42.3 63.2 76. Table 6. Point cloud CAD-specific question answering (CAD-QA) on the SGP-Bench benchmark. Our CAD-Recode supplied with GPT-4o significantly outperforms baseline methods. ing the sequence format, the accuracy reaches only 63.2%. PointLLM, which directly processes point clouds for language tasks, achieves 42.3% accuracy when prompted with the CAD-specific questions. These results demonstrate that CAD-Recode effectively captures CAD geometric information while generating an output in format that proprietary LLMs can naturally interpret and process. Figure 6. Interactive editing of CAD model. Given the code output from CAD-Recode and generic prompt, GPT-4o allows automated and interactive editing of the CAD model. Editing Pipeline: Leveraging the interpretable nature of our code-based output, we present an automated editing pipeline using GPT-4o [35]. Through simple prompt, the system refactors the generated code to expose geometric parameters via interactive sliders, enabling direct manipulation of the reconstructed model. As shown in Figure 6, the resulting code can be directly executed in Python environment to provide an interactive editing interface. Implementation details are provided in the supplementary materials. 6. Conclusion This work rethinks the problem of feature-based CAD reverse engineering by approaching it through pre-trained LLMs taking advantage of CAD Python-based representation. Our key contributions include new CAD code representation for sketch-extrude sequences, millionscale synthetic dataset of diverse CAD programs, and point cloud-to-CAD code model. We demonstrate that CAD-Recode outperforms existing methods by large margin while requiring fewer input points. We also showcase that combining pre-trained LLMs with geometric un8 range 50 to 50 with minimum resolution of 1 unit. We then simplify the sequence using higher level abstractions (rectangle, box, and cylinder) by considering the sequence parameters. Our validation framework includes verification of the absence of inner parts and successful compilation of the generated code from parsing the generated parameters. Figure 7 presents examples of CAD models alongside their corresponding CadQuery Python code from our synthetic dataset. All code examples are directly executable using standard Python interpreter with the CadQuery library. The codes follow consistent three-part structure: (1) necessary library import, (2) definition of sketch planes, and (3) sketch-extrude operations combined through union. C. Further Experimental Results Qualitative Results: Additional qualitative results for the reverse engineering of CAD models from point clouds are presented for DeepCAD (Figure 8), Fusion360 (Figure 9), and CC3D (Figure 10) datasets. As detailed in Section 5.1 of the main paper, CAD-Recode consistently generates shapes that closely approximate the input point cloud geometry, whereas CAD-SIGNet [20] can generate predictions that greatly differ from the input. Code Outputs: Figure 11 illustrates the predicted code sequences and their corresponding reconstructed shapes. The predicted codes have syntax that is consistent with the synthetic training examples, showing that CAD-Recode successfully learns both the features and CAD design patterns established in the synthetic training set. rate The invalidity Predictions: Invalid of CAD-Recode predictions is very low, below 1% on the DeepCAD [47] and Fusion360 [46] datasets, and about 3% on the CC3D [34] dataset. Some examples of invalid code predictions are presented in Figure 12. Invalid predictions happen when the CAD model contains features of dimension smaller than the resolution induced by quantization (Figure 12(a) and (b)) or when the CAD model contains features, such as revolution or B-spline, that are not present in the training dataset (Figure 12(c) and (d))). derstanding enables powerful new workflows, where designers can reconstruct CAD models from point clouds and modify them through natural language. We believe that this work will open new perspectives for CAD reverse engineering. We identify the following interesting future works: (1) further exploiting the modularity of the proposed CAD code representation, (2) scaling up the LLM and the dataset to enable the reverse engineering of more complex CAD models. Acknowledgement: The present project is supported by the National Research Fund, Luxembourg under the BRIDGES2021/IS/16849599/FREE-3D and IF/17052459/CASCADES projects, and by Artec 3D. A. Training Details The CAD-Recode implementation uses Qwen2-1.5B as the LLM decoder. The training configuration employs the AdamW optimizer with learning rate of 104 and weight decay of 0.01, while maintaining other parameters at their default values from the HuggingFace implementation [43], including the cosine learning rate scheduler. The training process is conducted for 100 iterations, incorporating an initial warmup period of 1 iterations. Using distributed setup across 4 NVIDIA H100 GPUs with per-GPU batch size of 8, the complete training process takes approximately 12 hours. For ablation study examining decoder size impact (Section 5.1 of the main paper), we utilize Qwen2-0.5B. B. Synthetic Dataset introduced in Section 3.2 comThe synthetic dataset prises one million valid Python CadQuery code snippets, generated through an automated pipeline leveraging PythonOCC [36] and CadQuery [9]. The generation process consists of two primary components: (1) sketch profile generator (Algorithm 1) that creates valid 2D sketches, and (2) CAD model generator (Algorithm 2) that produces 3D CAD models from these sketches. The sketch generation process combines primitive shapes (circles and rectangles) through boolean operations (union and cut). From each generated sketch, we extract the primitives (lines, arcs, and circles) from both inner and outer loops. Finally, the validity of the generated sketch is ensured through multiple verification steps, including checking that loops do not intersect and verifying that each primitive has length greater than zero. The CAD model generation procedure extrudes the validated sketches and combines them through union operations. The planes on which the sketches lie are randomly generated by choosing one of the three canonical planes translated by random amount. Each resulting model undergoes normalization to fit within unit bounding box centered at the origin. The parameters are quantized so that coordinates of any point on the CAD surface is within the 9 primitive random from {Circle, RotatedRectangle} booleanOperation random from {Union, Cut} compositeShape ApplyOperation(compositeShape, primitive, booleanOperation) Algorithm 1 Generate2DSketch numP rimitives RandInt(3, 8) compositeShape for 1 to numP rimitives do 1: function GENERATE2DSKETCH 2: 3: 4: 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: end function end for boundaryLoops ExtractBoundaryLoops(compositeShape) boundaryComponents for loop boundaryLoops do (edgeSequence, isOuter) AnalyzeBoundary(loop) boundaryComponents.Append((edgeSequence, isOuter)) end for boundaryComponents alidateShapeT opology(boundaryComponents) return boundaryComponents Choose random number of shape primitives Initialize empty shape Build shape by combining primitives Union adds, Cut subtracts Extract shape boundaries Process each boundary loop List of parametric curves (lines, arcs, circles) Ensure valid shape topology Returns list of (edges, boolean) tuples Algorithm 2 GenerateCAD plane RandomSelect(planes) volume ExtrudeSketch(sketch, plane) cadM odel BooleanU nion(cadM odel, volume) 1: function GENERATECAD cadM odel 2: planes GenerateRandomP lanes() 3: sketches Generate2DSketch() 4: for sketch sketches do 5: 6: 7: 8: 9: 10: 11: 12: 13: 14: 15: end function end for cadM odel ormalizeM odel(cadM odel) cadM odel QuantizeP arameters(cadM odel) cadM odel Simplif yCADM odel(cadM odel) cadM odel alidateCADM odel(cadM odel) return cadM odel Initialize empty CAD model Create set of reference planes Get sketches from Algorithm 1 Create 3D volumes from sketches Select random reference plane Create 3D volume by extrusion Add volume to model Ensure the model fits within unit box Discretize model parameters Identify high-level abstractions (rectangle, box, and cylinder) Ensure model topology and generated CadQuery code are valid 10 import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, -16, 0)) = w0.workplane(offset = 16/2).moveTo(-44.5, -5.5).box(9, 89, 16) .union(w0.sketch().segment((-41, 32), (49, 32)).segment((49, 43)) .segment((10, 43)).arc((2, 50), (-5, 43)).segment((-41,43)).close() .assemble().reset() .face(w0.sketch().segment((-2, 43), (8, 43)).segment((8, 44)) .segment((-1, 47)).close().assemble(), mode='s').finalize().extrude(33)) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, -34, 0)) w1 = cq.Workplane('YZ', origin=(13, 0, 0)) = w0.sketch().segment((-21, -29), (11, -32)).segment((12, -21)).segment((15, -10)) .segment((13, -9)).segment((15, 8)).segment((-17, 11)).segment((-18, 0)) .arc((-15, -5), (-15, -11)).arc((-15, -20), (-20, -27)).close() .assemble().finalize().extrude(-16) .union(w0.sketch().push([(6, 6.5)]).rect(12, 43).reset() .face(w0.sketch().segment((2, 5), (3, 2)).segment((11, 6)).segment((9, 9)).close() .assemble(), mode='s').finalize().extrude(15)) .union(w1.sketch().segment((-9, -27), (34, -27)).segment((34, -20)) .arc((37, 25), (3, -5)).arc((3, -6), (4, -7)).segment((-9, -7)).close() .assemble().finalize().extrude(19)) import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, -50)) = w0.sketch().circle(27).circle(14, mode='s').finalize().extrude(100) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, -10, 0)) w1 = cq.Workplane('YZ', origin=(31, 0, 0)) = w0.sketch().push([(-34, -5)]).circle(16).circle(5, mode='s').finalize() .extrude(-27) .union(w1.workplane(offset=-63 / 2).moveTo(11, 24).cylinder(63, 26)) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, -50, 0)) w1 = cq.Workplane('ZX', origin=(0, -50, 0)) = w0.sketch().push([(5, 0)]).circle(21).push([(25, 0)]).rect(2, 2, mode='s') .finalize().extrude(32) .union(w1.workplane(offset=100 / 2).moveTo(-21.5, 0).box(9, 26, 100)) import cadquery as cq w0 = cq.Workplane('YZ', origin=(-16, 0, 0)) = w0.sketch().segment((-50, -31), (-9, -44)).segment((-8, -41)).segment((9, -41)) .segment((9, -42)).segment((50, -42)).segment((50, -22)).segment((19, -22)) .segment((19, -4)).arc((47, 10), (22, 30)).arc((14, 44), (19, 28)).arc((12, 22), (10, 13)).segment((-13, 13)).segment((-13, -33)).segment((-47, -21)) .close().assemble().push([(3.5, -14)]) .rect(15, 16, mode='s').finalize().extrude(32) Figure 7. Synthetic examples from our training dataset. Each row contains CadQuery Python code and corresponding CAD model. Examples contain not only basic line, circle, and arc primitives, but also higher-level abstractions such as rect, box, and cylinder. 11 Point Cloud CAD-SIGNet CAD-Recode GT Point Cloud CAD-SIGNet CAD-Recode GT Point Cloud CAD-SIGNet CAD-Recode GT Figure 8. Qualitative results on the DeepCAD dataset. Figure 9. Qualitative results on the Fusion360 dataset. Figure 10. Qualitative results on the CC3D dataset. 12 import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, -6)) = w0.sketch().segment((-50, 11), (-20, -12)).segment((-30, -46)) .segment((-28, -46)).segment((-20, -40)).segment((-19, -40)) .segment((1, -26)).segment((30, -46)).segment((21, -11)) .segment((50, 11)).segment((13, 12)).segment((0,46)) .segment((-13, 12)).close().assemble().finalize().extrude(12) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, 26, 0)) w1 = cq.Workplane('XY', origin=(0, 0, -25)) = w0.sketch().arc((-10, -2), (-1, -30), (10, -2)).arc((14, 9), (10, 20)) .arc((0, 50), (-10, 20)).arc((-14, 10), (-10, 0)) .close().assemble().finalize().extrude(-53) .union(w1.workplane(offset=50/2).moveTo(-38,9).cylinder(50,12))) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, -1, 0)) w1 = cq.Workplane('XY', origin=(0, 0, -12)) = w0.workplane(offset=-49 / 2).cylinder(49, 7) .union(w1.sketch().segment((-12, -31), (12, -31)).segment((12, -20)) .segment((-12, -20)).segment((-12, -23)).segment((12, -23)).segment((12, -28)) .segment((-12, -28)).close().assemble().reset() .face(w1.sketch().segment((-12, 4), (12, 4)).segment((12, 7)).segment((12, 20)) .segment((-12, 20)).segment((-12, 18)).segment((12, 18)).segment((12, 17)) .segment((12, 6)).segment((-12, 6)).close().assemble()).push([(0, 34.5)]) .rect(24, 3).push([(0, 48.5)]).rect(24, 3).finalize().extrude(24)) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, 22, 0)) = w0.workplane(offset=-44 / 2).cylinder(44, 31) .union(w0.workplane(offset=-19 / 2).cylinder(19, 40)) .union(w0.workplane(offset=-6 / 2).cylinder(6, 50)) import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, 14)) = w0.sketch().push([(-37, 35)]).circle(5).push([(-37, -33)]).circle(5) .push([(40, 35)]).circle(5).push([(41, -33)]).circle(5).finalize().extrude(-38) .union(w0.workplane(offset=10 / 2).box(100, 84, 10)) import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, 10, 0)) w1 = cq.Workplane('XY', origin=(0, 0, 1)) = w0.sketch().segment((-27, -14), (-26, -15)).arc((-17, -25), (-5, -30)) .segment((-4, -31)).segment((-4, -30)).arc((22, -20), (29, 7)).segment((30, 8)) .segment((29, 9)).arc((20, 22), (6, 29)).segment((5, 30)).segment((4, 30)) .arc((-24, 19), (-27, -13)).close().assemble().push([(0, 0)]) .circle(13, mode='s').finalize().extrude(-20) .union(w0.sketch().segment((-50, 9),(-43, 4)).segment((-43, -5)).segment((-46, -7)) .segment((-43, -10)).segment((-43, -17)).segment((-39, -17)).segment((-34, -21)) .segment((-35, -22)).segment((-33, -24)).segment((-32, -37)).segment((-25, -35)) .segment((-8, -49)).segment((-2, -43)).segment((8, -43)).segment((9, -50)) .segment((17, -47)).segment((17, -32)).segment((30, -37)).segment((39, -31)) .segment((37, -27)).segment((40, -24)).segment((38, -21)).segment((40, -17)) .segment((50, -17)).segment((50, -9)).segment((43, -4)).segment((43, 5)) .segment((46, 7)).segment((43, 10)).segment((43, 17)).segment((46, 19)) .segment((43, 22)).segment((43, 29)).segment((39, 29)).segment((34, 34)) .segment((33, 34)).segment((25, 41)).segment((17, 39)).segment((17, 40)) .segment((17, 47)).segment((11, 47)).segment((11, 49)).segment((9, 50)) .segment((8, 47)).segment((-5, 47)).segment((-6, 49)).segment((-25, 45)) .segment((-24, 41)).segment((-27, 38)).segment((-25, 35)).segment((-38, 41)) .segment((-39, 31)).segment((-36, 28)).segment((-43, 28)).segment((-43, 10)) .close().assemble().finalize().extrude(-10)) .union(w1.workplane(offset=49 / 2).moveTo(9, 5).cylinder(49, 5)) Figure 11. CAD-Recode predictions on DeepCAD (top 3 rows), Fusion360 (mid 2 rows), and CC3D (last row) datasets. Each row contains predicted CadQuery Python code and its result after execution in Python interpreter. 13 import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, 43)) w1 = cq.Workplane('YZ', origin=(14, 0, 0)) = w0.sketch().circle(1).circle(1, mode='s').finalize().extrude(-93) .union(w1.workplane(offset=-28 / 2).moveTo(0, 49).cylinder(28, 1)) (a) The ground truth model contains hollow cylinder with formed by two circles of radii smaller than 1. As result, CAD-Recode is not able to predict radii with sufficient precision due to quantization and predicts two identical circles of radius 1 that are subtracted from one another (highlighted in yellow). This results in an invalid sketch as it contains no edge. import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, 0)) = w0.sketch().rect(100, 62).push([(-42, 8.5)]).rect(4, 13, mode='s') .push([(21.5, -15)]).rect(33, 24, mode='s').finalize().extrude(0) (b) As the ground-truth model has thickness less than 1, CAD-Recode predicts an extrusion distance of 0 as quantized approximation (highlighted in yellow), resulting in an invalid CAD model. import cadquery as cq w0 = cq.Workplane('ZX', origin=(0, 1, 0)) w1 = cq.Workplane('XY', origin=(0, 0, 21)) = w0.sketch().arc((-14, -13), (1, -13), (14, -23)).segment((18, -23)) .segment((10, 0)).arc((11, 1), (11, 2)).arc((10, 3), (10, 4)) .arc((6, 10), (7, 17)).arc((6, 20), (6, 23)).arc((5, 24), (5, 25)) .segment((-5, 25)).close().assemble().finalize().extrude(1) .union(w0.sketch().segment((10, 1),(11, -3)).arc((12, -6), (13, -9)) .segment((14, -15)).segment((19, -29)).arc((18, -25), (17, -21)) .arc((12, -10), (13, 2)).close().assemble().finalize().extrude(12)) .union(w1.sketch().arc((-50, -6), (-41, -5), (-33, -4)) .arc((-37, -2), (-39, -2)).arc((-38, -2), (-38, -1)).arc((-33, -1), (-28, -3)).arc((-18, -2), (-8, -1)).arc((-28, -3), (-40, 6)) .arc((-45, 6), (-50, 6)).close().assemble().finalize().extrude(-43)) (c) The ground-truth CAD model is created with B-spline primitives. Since CAD-Recode supports only arc, circle and line primitives, it tries to approximate the solution with multiple arcs, but fails to provide valid CAD model. In particular, the prediction contains an arc constructed from three co-linear points (highlighted in yellow), which raises an error in CadQuery. import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, 40)) w1 = cq.Workplane('YZ', origin=(10, 0, 0)) = w0.sketch().arc((-49, -10), (-47, -12), (-46, -15)).arc((36, 11), (-49, -10)).assemble().reset() .face(w0.sketch().arc((-43, -18), (-39, -28), (-33, -34)).arc((36, 11), (-43, -18)).assemble(), mode='s').finalize().extrude(-80) .union(w1.sketch().arc((-50, -40), (-46, -35), (-42, -29)) .arc((-41, -28), (-41, -27)).arc((-37, -14), (-31, -2)) .arc((-38, -21), (-50, -40)).assemble().finalize().extrude(-19)) (d) The ground-truth CAD model is created with revolution operation. Since CAD-Recode supports only extrusion operation, it tries to approximate the solution with multiple arcs. However, one of the sketch (highlighted in yellow) results in self-intersecting loop, which is not valid face. Figure 12. Examples of invalid predictions. Each row contains the ground-truth CAD model (left) and an invalid predicted CadQuery Python code (right). The CAD models in (a) and (b) are taken from the DeepCAD dataset and the CC3D dataset for (c) and (d). Invalid predictions mostly take place when the ground-truth contains features of very small dimension with respect to the size of the CAD model as in (a) and (b), or when the ground-truth model contains operations other than the ones supported as in (c) and (d). geometric CAD-specific questions. For both CAD-SIGNet and CAD-Recode, the point cloud CAD-QA is done in two step process. First the sketch-extrude is sequence is predicted from each network, then the sequence along with the question is passed through GPT-4o. Note that for CADSIGNet an interpretative hint is provided to provide context on the structure of the sequence. sample output for CADSIGNet and GPT-4o can be found in Figure 15(c), and in Figure 15(d) for CAD-Recode and GPT4-o. As the sequence was incorrectly predicted by CAD-SIGNet the answer to the question is wrong (1 hole), whereas the prediction from CAD-Recode captured better the geometry of the input point cloud leading to correct answer. It is worth noting, that despite not being provided any information about CadQuery Python code in the prompt, GPT-4o is able to breakdown the predicted sequence into its primitive components and provide correct and accurate geometric descriptions. This can be explained by the fact that LLMs are exposed to large amounts of code data during training. As result, the CadQuery Python representation of CAD models is appropriate for F. Editing Pipeline Details We provide more details on the editing pipeline presented in Section 5.2 of the main paper. The goal of this pipeline is to integrate automated editability capabilities to CAD-Recode. To this end, we present simple process using an off-the-shelf LLM, GPT-4o [35]. Starting from an output CAD Python code from CAD-Recode as shown in Figure 16a, we prepare simple and generic prompt (Figure 16b) for the LLM to generate refactored version of the code such that when executed the user can change with the dimensions of each primitive. As seen in Figure 16c, the LLM is able to generate code with comments that describe the different primitives semanticallly and include appropriate variables for the dimensions of each of the primitive, such as the height and the diameter of each cylinder. The code generated by the LLM, can be directly executed in Jupyter notebook with the CadQuery and ipywidgets libraries. Figure 6 of the main paper shows the generated sliders and how can the shape be then edited. This demonstrates that the CAD representation as Python code within reverse engineering scenario opens the door to new applications when combined with LLMs. D. Multi-Candidate Sampling The ablation study in Section 5.1 demonstrates the effectiveness of our multi-candidate sampling strategy during inference. This approach generates multiple plausible solutions by sampling different input point clouds. Figure 13 illustrates the qualitative results from different sampling instances. While CAD-Recode successfully captures the overall geometry across different samplings, fine-grained details may vary in reconstruction quality due to the relatively sparse point cloud input. However, this limitation can be effectively addressed by leveraging multiple sampling iterations to capture different aspects of the input geometry. E. Interpretability and CAD-QA In this section, we provide further details on the CAD-QA experiments reported in Section 5.2 of the main paper. We start by providing more details on the SGP-Bench benchmark [37]. Then, we present results further results and examples of GPT-4o outputs. E.1. Representation and CAD-QA The goal of the SGP-Bench benchmark is to evaluate the spatial-semantic reasoning skills of LLMs from symbolic graphics programs [37]. One aspect of the benchmark is set of 1000 multiple choice questions on 3D CAD models given their corresponding sketch-extrude sequence in the DeepCAD [47] format. An example is depicted in Figure 14. To evaluate the interpretability of our code-based CAD representation, we translated the 1000 questions of SGPBench from the DeepCAD representation (Figure 14(a)) to the CadQuery code format (Figure 14(b)). Using the same protocol as in SGP-Bench [37], and GPT-4o [35], we found that the accuracy on the multiple choice question in CadQuery format is 82.4%. This is about 4% higher than using the DeepCAD format with an interpretative hint. This suggests the proposed code representation provides more structured and naturally LLM-interpretable representation of CAD models. E.2. Point Cloud and CAD-QA In Table 6 of the main paper, the results for point cloud CAD-QA are presented. Figure 15(a) depicts an example of point cloud and question that was used to obtain these results. In this particular question, the task is to deduce the number of holes present in the CAD model given the point cloud as input. Figure 15(b), the answer provided by PointLLM is shown and it can be observed that PointLLM is unable to retrieve the correct answer. It is worth noting that PointLLM is network trained to answer semantic questions about object given its point cloud representation, as result in most cases the network is unable to describe 15 Point Cloud GT CAD-Recode Predictions Figure 13. CAD-Recode predictions from different point cloud sampling on DeepCAD, Fusion360, and CC3D datasets. For each prediction, 256 points are sampled randomly from the input point cloud. Examine the following CAD code carefully to understand the 3D object it generates and answer the question based on your interpretation of the rendered image of that object. SOL; Line:(221,128); Line:(221,223) ;Line:(128,223); Line:(128,128); Ext: One-sided); EOS (128,128,128,32,110,128,98,167,128, Newbody, Hint: the CAD code has the following syntax: CAD code consists of sequence of CAD commands that describe 3D object. The commands fall into two categories: sketch and extrusion. Sketch commands are used to specify closed curves on 2D plane in 3D space. Each closed curve is referred as loop, and one or more loops form closed region called profile. loop always starts with an indicator command <SOL> followed by series of curve commands. All the curves on the loop are in counterclockwise order, beginning with the curve whose starting point is at the most bottom-left. In total, there are three possible curve commands: Line, Arc, and Circle. Line(x, y): line, with x, as line end-point. Arc(x, y, u, f): an arc, with x,y as arc end-point, as sweep angle and as whether it is counter-clockwise, f=0 means it is counter-clockwise, f=1 means it is not counter-clockwise. Circle(x, y, r): circle, with x,y as the center point and as the radius. The extrusion command has two purposes: 1) It extrudes sketch profile from 2D plane into 3D body, and the extrusion type can be either one-sided, symmetric, or two-sided with respect to the profiles sketch plane. 2) The command also specifies (through the parameter in Ext) how to merge the newly extruded 3D body with the previously created shape by one of the boolean operations: either creating new body, or joining, cutting or intersecting with the existing body. Ext(x, y, z, o, p, q, s, e, f, b, u): extrude operation, with x, y, as the sketch plane orientation, o, p, as the sketch plane origin, as the scale of the associated sketch profile, e, as the extrude distances towards both sides, as the type of merge operation (could be New-body operation, join operation, cut operation and intersect operation) and as the extrude type (could be one-sided, symmetric or two-sided). <EOS> means the end of the code. Question: How many faces does the CAD object in the image have? (a) DeepCAD Representation Examine the following CAD code carefully to understand the 3D object it generates and answer the question based on your interpretation of the rendered image of that object. import cadquery as cq def make shape(): plane0 = cq.Plane(origin = (-0.75,-0.1406,0.0),xDir = (1.0,0.0,0.0),normal = (0.0,0.0,1.0)) w0 = cq.Workplane(plane0) face0 = w0.sketch().face(w0.sketch().segment( (0.0, 0.0), (0.7495, 0.0)).segment((0.7495, 0.0), ment((0.7495, 0.7656), (0.0, 0.7656)).segment((0.0, 0.7656), (0.0, 0.0)).assemble(), mode = a).finalize() (0.7495, 0.7656)).segshape0 = face0.extrude(0.3046875, both=False) return shape Question: How many faces does the CAD object in the image have? (b) CadQuery Representation Figure 14. Example of CAD question from SGP-Bench in the DeepCAD representation (b) and using the CadQuery representation (c). When asking the question in CadQuery format no hint is provided, while in DeepCAD format long interpretative hint is required. The choice of answers are A) 6, B) 4, C) 8 and D) 5. The correct answer is A) 6. 16 Question: How many holes does the CAD object in the image have? A) Two, B) Three, C) Four, D) Five Correct Answer: (a) Point cloud and corresponding CAD-specific question The CAD object in the image has five holes. (b) PointLLM output from point cloud To determine the number of holes in the CAD object, lets break down the CAD code step by step: 1. Extrusion Command: Start;Ext:(128,130,128,128,130,128,128,128,NewBody,96); This command sets up an extrusion with specific parameters and indicates that new body will be created. 2. First Loop: Line:(43,0);Arc:(213,0,255,43);Line:(213,85);Arc:(43,85,0,43);EOL; - Line:(43,0) - line from the starting point to (43,0). - Arc:(213,0,255,43) - An arc with midpoint (213,0) and endpoint (255,43). - Line:(213,85) - line from the previous endpoint to (213,85). - Arc:(43,85,0,43) - An arc with midpoint (43,85) and endpoint (0,43). - EOL - End of the loop. This forms closed loop, which is profile for extrusion. 3. Second Loop: Circle:(43,43,43,51);EOL; - Circle:(43,43,43,51) - circle with the most left point at (43,43) and the most top point at (43,51). - EOL - End of the loop. This forms another closed loop, which is another profile for extrusion. 4. End of Sketch and Extrusion: EOF;EOS;End; - EOF - End of face. - EOS - End of sketch. - End - End of the code. From the above analysis, we can see that the CAD object consists of: - One main profile formed by the first loop. - One circular profile formed by the second loop. The circular profile represents hole within the main profile. Since there is only one circular profile, the CAD object has one hole. Answer: (c) GPT-4o output from CAD-SIGNet prediction Lets break down the CAD code step by step to understand the 3D object it generates and determine the number of holes. 1. Workplane Creation: w0 = cq.Workplane(XY, origin=(0,0,1)) This line creates workplane on the XY plane with an origin at (0,0,1). 2. Sketching the Shape: = w0.sketch() This initializes sketch on the workplane. 3. Defining the Shape: .segment((-33,-17),(25,-17)) .segment((25,-16)) .arc((50,0),(25,16)) .segment((25,17)) .segment((-33,17)) .segment((-33,16)) .arc((-50,0),(-33,-16)) .close() These lines define closed shape with segments and arcs. The shape appears to be symmetrical along the Y-axis. 4. Adding Holes: .assemble() .push([(-33,0)]).circle(5, mode=s) .push([(0,0)]).circle(5, mode=s) .push([(33,0)]).circle(5, mode=s) .finalize() These lines add three circles (holes) to the shape at positions (-33,0), (0,0), and (33,0). 5. Extruding the Shape: .extrude(-2) This line extrudes the shape by -2 units, creating 3D object with the defined shape and holes. From the code, we can see that three circles (holes) are added to the shape. Therefore, the CAD object has three holes. Answer: (d) GPT-4o output from CAD-Recode prediction Figure 15. Example of Point cloud CAD-QA (a) and answers provided by PointLLM (b), CADSIGNet and GPT-4o (c) and CAD-Recode and GPT-4o (d). 17 import cadquery as cq w0 = cq.Workplane('XY', origin=(0, 0, 0)) = w0.workplane(offset=-50 / 2).cylinder(50, 50) .union(w0.workplane(offset=50 / 2).cylinder(50, 17)) Refactor the code, add functions and variables that can make the code easier to edit and more interpretable. Add in the code, sliders to edit the size of each primitive: import cadquery as cq w0=cq.Workplane(XY,origin=(0,0,0)) r=w0.workplane(offset=-50/2).cylinder(50,50).union(w0.workplane(offset=50/2).cylinder(50,17)) (a) CAD-Recode output as CadQuery Python code. (b) Prompt for GPT-4o import cadquery as cq from ipywidgets import interact, FloatSlider # Default parameters for the CAD model default_base_diameter = 50 default_base_height = 50 default_top_diameter = 17 default_top_height = 50 def create_cylinder(workplane, diameter, height, offset): \"\"\"Creates cylinder on the specified workplane with given diameter, height, and offset.\"\"\" return workplane.workplane(offset=offset).cylinder(height, diameter / 2) def build_model(base_diameter=default_base_diameter, base_height=default_base_height, top_diameter=default_top_diameter, top_height=default_top_height): \"\"\"Builds the model with adjustable base and top cylinder dimensions.\"\"\" # Initialize the main workplane w0 = cq.Workplane(\"XY\", origin=(0, 0, 0)) # Create base and top cylinders base_cylinder = create_cylinder(w0, base_diameter, base_height, offset=-base_height / 2) top_cylinder = create_cylinder(w0, top_diameter, top_height, offset=base_height / 2) # Union the cylinders model = base_cylinder.union(top_cylinder) return model # Function to display the model interactively with sliders for each cylinder dimension def display_model_with_sliders(): \"\"\"Interactive display function with sliders for base and top cylinder dimensions.\"\"\" # Sliders for base and top cylinder dimensions base_diameter_slider = FloatSlider(value=default_base_diameter, min=10, max=100, step=5, description=\"Base Diameter\") base_height_slider = FloatSlider(value=default_base_height, min=10, max=100, step=5, description=\"Base Height\") top_diameter_slider = FloatSlider(value=default_top_diameter, min=10, max=100, step=5, description=\"Top Diameter\") top_height_slider = FloatSlider(value=default_top_height, min=10, max=100, step=5, description=\"Top Height\") # Update function to apply slider changes @interact( base_diameter=base_diameter_slider, base_height=base_height_slider, top_diameter=top_diameter_slider, top_height=top_height_slider ) def update_model(base_diameter, base_height, top_diameter, top_height): # Build and display the model model = build_model(base_diameter, base_height, top_diameter, top_height) show_object(model) # Use this in CQ-editor or Jupyter environment # Execute the function to show sliders and interactive model display_model_with_sliders() (c) GPT-4o output: executable refactored code with interactive sliders (d) Executed code produces interactive sliders that the designer can use to modify the size of the primitives. Figure 16. Editing pipeline: given predicted code from CAD-Recode from point cloud (a), generic prompt can be constructed to refactor the predicted code to enhance editability (b). The output from GPT-4o-2024-08-06 is shown in (c), and the generated sliders and possible CAD edits are depicted in (d)."
        },
        {
            "title": "References",
            "content": "[1] Akshay Badagabettu, Amir Barati Farimani. models using natural language queries. arXiv:2406.00144, 2024. 2 and Query2cad: Generating cad arXiv preprint Sai Sravan Yarlagadda, [2] Antoine Bri`ere-Cˆote, Louis Rivest, and Roland Maranzana. Comparing 3d cad models: uses, methods, tools and perspectives. Computer-Aided Design and Applications, 9(6): 771794, 2012. 1 [3] Jorge Camba, Manuel Contero, and Pedro Company. Parametric cad modeling: An analysis of strategies for design reusability. Computer-Aided Design, 74:1831, 2016. 1 [4] Mark Chen, Jerry Tworek, Heewoo Jun, Qiming Yuan, Henrique Ponde de Oliveira Pinto, Jared Kaplan, Harri Edwards, Yuri Burda, Nicholas Joseph, Greg Brockman, Alex Ray, Raul Puri, Gretchen Krueger, Michael Petrov, Heidy Khlaaf, Girish Sastry, Pamela Mishkin, Brooke Chan, Scott Gray, Nick Ryder, Mikhail Pavlov, Alethea Power, Lukasz Kaiser, Mohammad Bavarian, Clemens Winter, Philippe Tillet, Felipe Petroski Such, Dave Cummings, Matthias Plappert, Fotios Chantzis, Elizabeth Barnes, Ariel Herbert-Voss, William Hebgen Guss, Alex Nichol, Alex Paino, Nikolas Tezak, Jie Tang, Igor Babuschkin, Suchir Balaji, Shantanu Jain, William Saunders, Christopher Hesse, Andrew N. Carr, Jan Leike, Josh Achiam, Vedant Misra, Evan Morikawa, Alec Radford, Matthew Knight, Miles Brundage, Mira Murati, Katie Mayer, Peter Welinder, Bob McGrew, Dario Amodei, Sam McCandlish, Ilya Sutskever, and Wojciech Zaremba. Evaluating large language models trained on code, 2021. 4 [5] Sijin Chen, Xin Chen, Chi Zhang, Mingsheng Li, Gang Yu, Hao Fei, Hongyuan Zhu, Jiayuan Fan, and Tao Chen. Ll3da: Visual interactive instruction tuning for omni-3d understanding reasoning and planning. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 2642826438, 2024. [6] Kseniya Cherenkova, Djamila Aouada, and Gleb Gusev. Pvdeconv: Point-voxel deconvolution for autoencoding cad construction in 3d. In ICIP, pages 27412745, 2020. 2, 4 [7] Kseniya Cherenkova, Elona Dupont, Anis Kacem, Ilya Arzhannikov, Gleb Gusev, and Djamila Aouada. Sepicnet: Sharp edges recovery by parametric inference of curves in 3d shapes. In CVPRW, pages 27262734, 2023. 3 [8] Kseniya Cherenkova, Elona Dupont, Anis Kacem, Gleb Gusev, and Djamila Aouada. Spelsnet: Surface primitive elements segmentation by b-rep graph structure supervision. NeurIPS, 2024. 3 [9] CADQuery Developers. Cadquery: python paramethttps : / / cadquery . ric cad scripting framework. readthedocs.io/, 2024. Accessed: 2024-10-22. 2, 3, 4, 9 [10] Elona Dupont, Kseniya Cherenkova, Anis Kacem, Sk Aziz Ali, Ilya Aryhannikov, Gleb Gusev, and Djamila Aouada. Cadops-net: Jointly learning cad operation types and steps from boundary-representations. 3DV, 2022. 3 [11] Elona Dupont, Kseniya Cherenkova, Dimitrios Mallis, Gleb Gusev, Anis Kacem, and Djamila Aouada. Transcad: hierarchical transformer for cad sequence inference from point clouds. In ECCV, 2024. 2, 3, 4, 6, 8 [12] David Eggert, Andrew Fitzgibbon, and Robert Fisher. Simultaneous registration of multiple range views for use in reverse engineering of cad models. Computer Vision and Image Understanding, 69(3):253272, 1998. 1 [13] Markus Friedrich, Pierre-Alain Fayolle, Thomas Gabor, and Claudia Linnhoff-Popien. Optimizing evolutionary csg tree extraction. In Proceedings of the Genetic and Evolutionary Computation Conference, pages 11831191, 2019. 3 [14] Haoxiang Guo, Shilin Liu, Hao Pan, Yang Liu, Xin Tong, and Baining Guo. Complexgen: Cad reconstruction by b-rep chain complex generation. ACM TOG, 41(4):118, 2022. 3 [15] Jiaming Han, Kaixiong Gong, Yiyuan Zhang, Jiaqi Wang, Kaipeng Zhang, Dahua Lin, Yu Qiao, Peng Gao, and Xiangyu Yue. Onellm: One framework to align all modalities with language. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 26584 26595, 2024. 2 [16] Robin Helle and Hirpa Lemu. case study on use of 3d scanning for reverse engineering and quality control. Materials Today: Proceedings, 45:52555262, 2021. 1 [17] Yining Hong, Haoyu Zhen, Peihao Chen, Shuhong Zheng, Yilun Du, Zhenfang Chen, and Chuang Gan. 3d-llm: Injecting the 3d world into large language models. NeurIPS, 2023. 2 [18] Yining Hong, Haoyu Zhen, Peihao Chen, Shuhong Zheng, Yilun Du, Zhenfang Chen, and Chuang Gan. 3d-llm: Injecting the 3d world into large language models. Advances in Neural Information Processing Systems, 36:2048220494, 2023. 2 [19] Kacper Kania, Maciej Zieba, and Tomasz Kajdanowicz. Ucsg-net-unsupervised discovering of constructive solid geometry tree. NeurIPS, 2020. [20] Mohammad Sadil Khan, Elona Dupont, Sk Aziz Ali, Kseniya Cherenkova, Anis Kacem, and Djamila Aouada. Cad-signet: Cad language inference from point clouds usIn CVPR, ing layer-wise sketch instance guided attention. pages 47134722, 2024. 1, 2, 3, 4, 6, 7, 8, 9 [21] Sebastian Koch, Albert Matveev, Zhongshi Jiang, Francis Williams, Alexey Artemov, Evgeny Burnaev, Marc Alexa, Denis Zorin, and Daniele Panozzo. Abc: big cad model dataset for geometric deep learning. In CVPR, pages 9601 9611, 2019. 2, 4 [22] Milin Kodnongbua, Benjamin Jones, Maaz Bin Safeer Ahmad, Vladimir Kim, and Adriana Schulz. Reparamcad: Zero-shot cad re-parameterization for interactive manipulaIn SIGGRAPH Asia 2023 Conference Papers, New tion. York, NY, USA, 2023. Association for Computing Machinery. 2 [23] Joseph Lambourne, Karl DD Willis, Pradeep Kumar Jayaraman, Aditya Sanghi, Peter Meltzer, and Hooman Shayani. Brepnet: topological message passing system for solid models. In CVPR, pages 1277312782, 2021. 3 [24] Joseph George Lambourne, Karl Willis, Pradeep Kumar Jayaraman, Longfei Zhang, Aditya Sanghi, and Kamal Rahimi Malekshan. Reconstructing editable prismatic cad from rounded voxel models. 2022. 3, 6 In SIGGRAPH Asia, pages 19, [25] Lingxiao Li, Minhyuk Sung, Anastasia Dubrovina, Li Yi, and Leonidas Guibas. Supervised fitting of geometric primitives to 3d point clouds. In CVPR, pages 26522660, 2019. 3 [26] Ming Li, Frank Langbein, and Ralph Martin. Detecting design intent in approximate cad models using symmetry. Computer-Aided Design, 42(3):183201, 2010. 1 [27] Pu Li, Jianwei Guo, Xiaopeng Zhang, and Dong-Ming Yan. Secad-net: Self-supervised cad reconstruction by learning In CVPR, pages 1681616826, sketch-extrude operations. 2023. 2, 3, 6 [28] Pu Li, Jianwei Guo, Huibin Li, Bedrich Benes, and DongMing Yan. Sfmcad: Unsupervised cad reconstruction by learning sketch-based feature modeling operations. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 46714680, 2024. 3 [29] Fei Liu. Fast industrial product design method and its application based on 3d cad system. Computer-Aided Design and Applications, 18(S3):118128, 2020. 1 [30] Minghua Liu, Ruoxi Shi, Kaiming Kuang, Yinhao Zhu, Xuanlin Li, Shizhong Han, Hong Cai, Fatih Porikli, and Hao Su. Openshape: Scaling up 3d shape representation towards open-world understanding. Advances in neural information processing systems, 36, 2024. 2 [31] Yujia Liu, Stefano DAronco, Konrad Schindler, and Jan Dirk Wegner. Pc2wf: 3d wireframe reconstruction from raw point clouds. ICLR, 2021. [32] Weijian Ma, Minyang Xu, Xueyang Li, and Xiangdong Zhou. Multicad: Contrastive representation learning for In CIKM, multi-modal 3d computer-aided design models. New York, NY, USA, 2023. Association for Computing Machinery. 2, 3, 4, 6 [33] Weijian Ma, Shuaiqi Chen, Yunzhong Lou, Xueyang Li, and Xiangdong Zhou. Draw step by step: Reconstructing cad construction sequences from point clouds via multimodal diffusion. In CVPR, pages 2715427163, 2024. 1, 2, 3, 4, 6, 8 [34] Dimitrios Mallis, Ali Sk Aziz, Elona Dupont, Kseniya Cherenkova, Ahmet Serdar Karadeniz, Mohammad Sadil Khan, Anis Kacem, Gleb Gusev, and Djamila Aouada. Sharp challenge 2023: Solving cad history and parameters recovery from point clouds and 3d scans. overview, datasets, metrics, and baselines. In CVPRW, 2023. 6, 9 [35] OpenAI. Gpt-4 technical report, 2024. 2, 3, 4, 5, 8, 15 [36] Thomas Paviot. Pythonocc - 3d cad/bim/plm/cam framework, 2022. 9 [37] Zeju Qiu, Weiyang Liu, Haiwen Feng, Zhen Liu, Tim Xiao, Katherine Collins, Joshua Tenenbaum, Adrian Weller, Michael Black, and Bernhard Scholkopf. Can large language models understand symbolic graphics programs? arXiv preprint arXiv:2408.08313, 2024. 2, 8, [38] Daxuan Ren, Jianmin Zheng, Jianfei Cai, Jiatong Li, and Junzhe Zhang. Extrudenet: Unsupervised inverse sketchIn ECCV, pages 482498. and-extrude for shape parsing. Springer, 2022. 2, 3, 6 [39] Sanh. Distilbert, distilled version of bert: smaller, faster, cheaper and lighter. arXiv preprint arXiv:1910.01108, 2019. 3 [40] Ari Seff, Wenda Zhou, Nick Richardson, and Ryan Adams. Vitruvion: generative model of parametric cad sketches. In ICLR, 2022. 3 [41] Gopal Sharma, Difan Liu, Subhransu Maji, Evangelos Kalogerakis, Siddhartha Chaudhuri, and Radomır Mˇech. Parsenet: parametric surface fitting network for 3d point clouds. In ECCV, pages 261276. Springer, 2020. 3 [42] Tarek Sobh, Owen, Jaynes, Mohamed Dekhil, and Thomas Henderson. Industrial inspection and reverse enIn Proceedings of 1994 IEEE 2nd CAD-Based gineering. Vision Workshop, pages 228235. IEEE, 1994. 1 [43] Qwen Team. Qwen2-1.5b. https://huggingface. co/Qwen/Qwen2-1.5B, 2024. Accessed: Nov. 2024. [44] Mikaela Angelina Uy, Yen-Yu Chang, Minhyuk Sung, Purvi Goel, Joseph Lambourne, Tolga Birdal, and Leonidas Guibas. Point2cyl: Reverse engineering 3d objects from point clouds to extrusion cylinders. In CVPR, pages 11850 11860, 2022. 1, 2, 3, 4, 6, 8 [45] Xiaogang Wang, Yuelang Xu, Kai Xu, Andrea Tagliasacchi, Bin Zhou, Ali Mahdavi-Amiri, and Hao Zhang. Pienet: Parametric inference of point cloud edges. NeurIPS, 33: 2016720178, 2020. 3 [46] Karl DD Willis, Yewen Pu, Jieliang Luo, Hang Chu, Tao Du, Joseph Lambourne, Armando Solar-Lezama, and Wojciech Matusik. Fusion 360 gallery: dataset and environment for programmatic cad construction from human design sequences. ACM TOG, 40(4):124, 2021. 2, 3, 4, 6, 9 [47] Rundi Wu, Chang Xiao, and Changxi Zheng. Deepcad: deep generative network for computer-aided design models. In CVPR, pages 67726782, 2021. 2, 3, 4, 6, 7, 8, 9, 15 [48] Runsen Xu, Xiaolong Wang, Tai Wang, Yilun Chen, Jiangmiao Pang, and Dahua Lin. Pointllm: Empowering large language models to understand point clouds. In ECCV, 2024. 2, 8 [49] Xianghao Xu, Wenzhe Peng, Chin-Yi Cheng, Karl DD Willis, and Daniel Ritchie. Inferring cad modeling sequences using zone graphs. In CVPR, pages 60626070, 2021. 2, 3 [50] Xiang Xu, Karl DD Willis, Joseph Lambourne, ChinYi Cheng, Pradeep Kumar Jayaraman, and Yasutaka Furukawa. Skexgen: Autoregressive generation of cad construction sequences with disentangled codebooks. In ICML, pages 2469824724. PMLR, 2022. 2, 3, 4 [51] Xiang Xu, Pradeep Kumar Jayaraman, Joseph Lambourne, Karl DD Willis, and Yasutaka Furukawa. Hierarchical neural coding for controllable cad model generation. ICML, 2023. 3, [52] Le Xue, Mingfei Gao, Chen Xing, Roberto Martın-Martın, Jiajun Wu, Caiming Xiong, Ran Xu, Juan Carlos Niebles, and Silvio Savarese. Ulip: Learning unified representation of language, images, and point clouds for 3d understanding. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 11791189, 2023. 2 [53] Le Xue, Ning Yu, Shu Zhang, Artemis Panagopoulou, Junnan Li, Roberto Martın-Martın, Jiajun Wu, Caiming Xiong, 20 for parametric curve extraction from point cloud. In CVPR, pages 1360113610, 2023. 3 [63] Xiangyang Zhu, Renrui Zhang, Bowei He, Ziyu Guo, Ziyao Zeng, Zipeng Qin, Shanghang Zhang, and Peng Gao. Pointclip v2: Prompting clip and gpt for powerful 3d open-world In Proceedings of the IEEE/CVF International learning. Conference on Computer Vision (ICCV), pages 26392650, 2023. 2 Ran Xu, Juan Carlos Niebles, and Silvio Savarese. Ulip-2: Towards scalable multimodal pre-training for 3d understanding. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 27091 27101, 2024. 2 [54] An Yang, Baosong Yang, Binyuan Hui, Bo Zheng, Bowen Yu, Chang Zhou, Chengpeng Li, Chengyuan Li, Dayiheng Liu, Fei Huang, Guanting Dong, Haoran Wei, Huan Lin, Jialong Tang, Jialin Wang, Jian Yang, Jianhong Tu, Jianwei Zhang, Jianxin Ma, Jianxin Yang, Jin Xu, Jingren Zhou, Jinze Bai, Jinzheng He, Junyang Lin, Kai Dang, Keming Lu, Keqin Chen, Kexin Yang, Mei Li, Mingfeng Xue, Na Ni, Pei Zhang, Peng Wang, Ru Peng, Rui Men, Ruize Gao, Runji Lin, Shijie Wang, Shuai Bai, Sinan Tan, Tianhang Zhu, Tianhao Li, Tianyu Liu, Wenbin Ge, Xiaodong Deng, Xiaohuan Zhou, Xingzhang Ren, Xinyu Zhang, Xipin Wei, Xuancheng Ren, Xuejing Liu, Yang Fan, Yang Yao, Yichang Zhang, Yu Wan, Yunfei Chu, Yuqiong Liu, Zeyu Cui, Zhenru Zhang, Zhifang Guo, and Zhihao Fan. Qwen2 technical report, 2024. 2, 4, [55] Fukun Yin, Xin Chen, Chi Zhang, Biao Jiang, Zibo Zhao, Jiayuan Fan, Gang Yu, Taihao Li, and Tao Chen. Shapegpt: 3d shape generation with unified multi-modal language model, 2023. 2 [56] Yang You, Mikaela Angelina Uy, Jiaqi Han, Rahul Thomas, Haotong Zhang, Suya You, and Leonidas Guibas. Img2cad: Reverse engineering 3d cad models from images through arXiv preprint vlm-assisted conditional arXiv:2408.01437, 2024. 2 factorization. [57] Fenggen Yu, Qimin Chen, Maham Tanveer, Ali Mahdavi Amiri, and Hao Zhang. D2csg: Unsupervised learning of compact csg trees with dual complements and dropouts. Advances in Neural Information Processing Systems, 36: 2280722819, 2023. 3 [58] Fenggen Yu, Qimin Chen, Maham Tanveer, Ali Mahdavi Amiri, and Hao Zhang. D2csg: Unsupervised learning of compact csg trees with dual complements and dropouts. Advances in Neural Information Processing Systems, 36, 2024. 3 [59] Haocheng Yuan, Jing Xu, Hao Pan, Adrien Bousseau, Niloy Mitra, and Changjian Li. Cadtalk: An algorithm and benchmark for semantic commenting of cad programs. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 37533762, 2024. [60] Renrui Zhang, Ziyu Guo, Wei Zhang, Kunchang Li, Xupeng Miao, Bin Cui, Yu Qiao, Peng Gao, and Hongsheng Li. Pointclip: Point cloud understanding by clip. In Proceedings of the IEEE/CVF conference on computer vision and pattern recognition, pages 85528562, 2022. 2 [61] Zibo Zhao, Wen Liu, Xin Chen, Xianfang Zeng, Rui Wang, Pei Cheng, BIN FU, Tao Chen, Gang YU, and Shenghua Gao. Michelangelo: Conditional 3d shape generation based on shape-image-text aligned latent representation. In Thirtyseventh Conference on Neural Information Processing Systems, 2023. 2, 5 [62] Xiangyu Zhu, Dong Du, Weikai Chen, Zhiyou Zhao, Yinyu Nie, and Xiaoguang Han. Nerve: Neural volumetric edges"
        }
    ],
    "affiliations": [
        "Artec3D, Luxembourg",
        "SnT, University of Luxembourg"
    ]
}