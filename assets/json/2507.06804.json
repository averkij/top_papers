{
    "paper_title": "Towards Solving More Challenging IMO Problems via Decoupled Reasoning and Proving",
    "authors": [
        "Zhenwen Liang",
        "Linfeng Song",
        "Yang Li",
        "Tao Yang",
        "Feng Zhang",
        "Haitao Mi",
        "Dong Yu"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Automated Theorem Proving (ATP) in formal languages is a foundational challenge for AI. While Large Language Models (LLMs) have driven remarkable progress, a significant gap remains between their powerful informal reasoning capabilities and their weak formal proving performance. Recent studies show that the informal accuracy exceeds 80% while formal success remains below 8% on benchmarks like PutnamBench. We argue this gap persists because current state-of-the-art provers, by tightly coupling reasoning and proving, are trained with paradigms that inadvertently punish deep reasoning in favor of shallow, tactic-based strategies. To bridge this fundamental gap, we propose a novel framework that decouples high-level reasoning from low-level proof generation. Our approach utilizes two distinct, specialized models: a powerful, general-purpose Reasoner to generate diverse, strategic subgoal lemmas, and an efficient Prover to rigorously verify them. This modular design liberates the model's full reasoning potential and bypasses the pitfalls of end-to-end training. We evaluate our method on a challenging set of post-2000 IMO problems, a problem set on which no prior open-source prover has reported success. Our decoupled framework successfully solves 5 of these problems, demonstrating a significant step towards automated reasoning on exceptionally difficult mathematical challenges. To foster future research, we release our full dataset of generated and verified lemmas for a wide range of IMO problems, available at https://tencent-imo.github.io/ ."
        },
        {
            "title": "Start",
            "content": "5 2 0 2 7 ] . [ 1 4 0 8 6 0 . 7 0 5 2 : r a"
        },
        {
            "title": "Towards Solving More Challenging IMO Problems via Decoupled\nReasoning and Proving",
            "content": "Zhenwen Liang, Linfeng Song, Yang Li, Tao Yang, Feng Zhang, Haitao Mi and Dong Yu Tencent AI Lab {zhenwzliang,lfsong,haitaomi}@global.tencent.com"
        },
        {
            "title": "Abstract",
            "content": "Automated Theorem Proving (ATP) in formal languages is foundational challenge for AI. While Large Language Models (LLMs) have driven remarkable progress, significant gap remains between their powerful informal reasoning capabilities and their weak formal proving performance. Recent studies show that the informal accuracy exceeds 80% while formal success remains below 8% on benchmarks like PutnamBench. We argue this gap persists because current state-of-the-art provers, by tightly coupling reasoning and proving, are trained with paradigms that inadvertently punish deep reasoning in favor of shallow, tactic-based strategies. To bridge this fundamental gap, we propose novel framework that decouples high-level reasoning from low-level proof generation. Our approach utilizes two distinct, specialized models: powerful, generalpurpose Reasoner to generate diverse, strategic subgoal lemmas, and an efficient Prover to rigorously verify them. This modular design liberates the models full reasoning potential and bypasses the pitfalls of end-to-end training. We evaluate our method on challenging set of post-2000 IMO problems, problem set on which no prior opensource prover has reported success. Our decoupled framework successfully solves 5 of these problems, demonstrating significant step towards automated reasoning on exceptionally difficult mathematical challenges. To foster future research, we release our full dataset of generated and verified lemmas for wide range of IMO problems, available at https://tencent-imo.github.io/."
        },
        {
            "title": "Introduction",
            "content": "Automated Theorem Proving (ATP) is the task of automatically generating formal proofs for mathematical or logical statements. By translating problems into formal language (e.g., Lean (Moura & Ullrich, 2021) or Isabelle (Paulson, 1994)) and iteratively applying tactics within proof assistants environment, an ATP system can construct machine-verified proofs that guarantee logical correctness. This verifiability makes ATP indispensable for the formal verification of critical software and hardware systems, where every reasoning step must be rigorously checked. ATP has long been foundational challenge in both AI and mathematics, as such systems could leverage massive computational power to help mathematicians evaluate and even solve open conjectures. Recent breakthroughs in large language models (LLMs) have catalyzed rapid progress in ATP. Leveraging techniques such as expert iteration (Polu & Sutskever, 2020), tree search (Li et al., 2024; Wu et al., 2024; Xin et al., 2025; Liang et al., 2025), chain-of-thought reasoning (Xin et al., 2024; Lin et al., 2025), and reinforcement learning, state-of-the-art provers have achieved remarkable performance gains. However, recent research in the LLM reasoning community has exposed significant and widening gap between informal reasoning and formal proving capabilities. For instance, recent evaluation (Dekoninck et al., 2025) on the PutnamBench illustrates this chasm: Top-tier LLMs like Gemini 2.5 Pro can generate informal, natural-language solutions with over 80% accuracy after human verification. In contrast, the best formal prover Deepseek-Prover-V2 671B struggles to solve even 8% of the same problems directly. This highlights critical dilemma for the field: while LLMs possess immense mathematical reasoning power, their informal outputs lack the rigor and machine-verifiable guarantees required for formal correctness. Conversely, formal ATP systems have this guarantee but lack the raw"
        },
        {
            "title": "Technical Report",
            "content": "Figure 1: The overall pipeline of DRP-IMO taking the problem of IMO 2019 P1 as an example. Detailed proofs of the subgoals are omitted for brevity. problem-solving ability to tackle complex challenges. Bridging this gap is arguably the most pressing challenge in modern ATP. To address this, state-of-the-art provers like DeepSeek-Prover-v2 (Ren et al., 2025) and Kimina (Wang et al., 2025) attempt to integrate reasoning and proving. They generate high-level sketches or subgoals before producing the final formal proof. However, we argue that these approaches suffer from fundamental design flaw: by tightly coupling high-level planning and low-level proof generation within single, monolithic model, they inadvertently shackle the models full reasoning potential. Its \"sketching\" is constrained by what its integrated proving component can handle. This inherent limitation prevents them from fully leveraging the powerful informal reasoning capabilities demonstrated on benchmarks like PutnamBench. This, in turn, explains why even these advanced systems still fail on the most difficult problems, such as post-2000 International Mathematical Olympiad (IMO) problems. We identify the root cause of this failure in the prevailing training paradigm: reinforcement learning with verifiable rewards (RLVR). This methodology, used to train models like DeepSeek-Prover-v2 and Kimina, rewards only the final binary success or failure of the generated Lean code. This paradigm is fundamentally misaligned with the goal of bridging the reasoning-proving gap. Instead of rewarding hard-to-define, human-like strategies (the kind that achieve >80% informal success), the RLVR teaches degenerated policy to maximize reward by any means necessary. It is incentivized to suppress its powerful, latent reasoning abilities in favor of heuristically decomposing goals into trivial sub-problems that can be solved by brute-forcing automatic tactics like ring, omega, or try. This over-reliance is not merely shortcut, but symptom of training-induced degradation of its reasoning capabilities, effectively preventing it from generating the insightful decompositions required for truly difficult problems. Based on this diagnosis, we propose new framework built on foundational principle: the decoupling of high-level reasoning from low-level proof generation. We argue that to bridge the chasm between informal insight and formal correctness, the two processes must be handled by distinct, specialized models scheduled with greater flexibility. Our approach leverages powerful, general-purpose LLM as dedicated Reasoner and separate, efficient ATP model as the Prover. This architectural separation liberates the Reasoner to focus exclusively on its strengthgenerating high-level mathematical insights and strategic decompositionswhile the Prover ensures that the"
        },
        {
            "title": "Technical Report",
            "content": "resulting strategy can be grounded in formal, verifiable logic. It is this principled, decoupled bridge that we believe can finally harness the reasoning power of LLMs for formal theorem proving. Our simple yet effective pipeline is illustrated in Figure 1. Given theorem, the Reasoner is first invoked to propose potentially useful lemmas (subgoals), expressed only as formal statements, which act as bridge between high-level strategy and formal proof. Prover module then attempts to verify these proposed lemmas, filtering out any that are unprovable. Finally, the Prover tackles the main theorem, now armed with set of verified lemmas that guide the proof search and significantly reduce its complexity. This contrasts with existing approaches that follow rigid, one-shot \"reasoning-then-proving\" trajectory within single model. We evaluate our approach on challenging set of non-geometry IMO problems from 2000 to 2024. To the best of our knowledge, no existing open-source automated theorem prover has reported success on any problem from this set. In the experiemnts, our method successfully solves 5 of these problems: IMO 2000 Problem 2, IMO 2005 Problem 3, IMO 2011 Problem 3, IMO 2019 Problem 1, and IMO 2020 Problem 2."
        },
        {
            "title": "Data Release",
            "content": "To foster further research and collaboration within both the mathematics and ATP communities, we are releasing comprehensive dataset and project website. While our framework successfully solved 5 IMO problems, our efforts in subgoal generation and verification have yielded much larger collection of high-quality, formally verified lemmas for broad range of post-2000 IMO problems. We believe this resource serves dual purpose: For mathematicians and IMO researchers, this collection of machine-generated lemmas may offer novel perspectives or reveal non-obvious decompositions, potentially inspiring new human-led proof strategies. For the ATP community, our dataset acts as new, challenging benchmark. By providing verified intermediate steps, it allows researchers to focus on solving the remaining difficult lemmas or on the final, complex proof-synthesis stage for problems currently beyond reach. The dataset is publicly available on HuggingFace, and we are committed to its active maintenance and expansion. We welcome community contributions, such as new proofs for existing lemmas or alternative strategic decompositions. The project website, which provides access to the data repository, tracks our ongoing progress, and presents detailed case studies, can be found at https: //tencent-imo.github.io/."
        },
        {
            "title": "2 Related Work",
            "content": "The application of Large Language Models (LLMs) to Automated Theorem Proving has evolved rapidly. Early and some recent approaches leverage the powerful sequence modeling capabilities of LLMs to generate entire formal proofs in single, end-to-end pass. For instance, Baldur (First et al., 2023) generates proofs for Isabelle and incorporates repair mechanism that learns from compiler feedback to correct flawed proofs. Other works, while still operating within largely monolithic framework, introduce internal structure. POETRY (Wang et al., 2024a) employs recursive decomposition strategy to break down complex theorems, and LEGO-Prover (Wang et al., 2024b) hierarchically proves and reuses lemmas to manage intermediate results within its generation process. These methods treat proof generation as sophisticated, structured sequence generation task. In contrast, our work argues that coupling high-level reasoning and low-level proof formalization within single model limits their potential, and we instead advocate for their explicit separation. Recognizing the limitations of direct generation, significant line of research has focused on integrating high-level planning or sketching, mimicking human problem-solving strategies. These 3 1 2 4 5 6 7 8 10 11 12 13 14 16 17 18"
        },
        {
            "title": "Technical Report",
            "content": "import Mathlib import Aesop set_option maxHeartbeats 0 open BigOperators Real Nat Topology Rat theorem amc12b_2002_p7 (a : N) (h 0 : = + 1) (h 2 : * * = 8 * (a + + c)) : ^ 2 + (b ^ 2 + ^ 2) = 77 := by : 0 < 0 < 0 < c) (h 1 : (cid:44) = + 1) (h 3 have hb : = + 1 := have hc : = + 2 := by omega rw [hb, hc] at have h4 : = 4 := by 3 1 .left have h_pos : 0 < := 0 have : 6 := by nlinarith [h 3 < + 2 by omega), show 0 < + 1 by omega, show 0 < + 2 by omega] (cid:44) , mul_pos h_pos (show 0 < + 1 by omega), mul_pos h_pos (show 0 interval_cases <;> omega have ha : = 4 := h4 have hb' : = 5 := by omega have hc' : = 6 := by omega rw [ha, hb', hc'] norm_num Figure 2: Kimina solutions to amc12b_2002_p7. The have statements hb and hc are trivially extended from provided conditions, and statement h4 makes luckily guess that directly leads to the solution. Automatic tactic omega plays central role throughout the proof. methods often generate natural language plan or structured sketch before producing the final proof. Kimina-Prover (Wang et al., 2025) achieves strong results by generating structured reasoning patterns prior to the formal proof. Similarly, DeepSeek-Prover-V2 (Ren et al., 2025), the current state-of-the-art, integrates Chain-of-Thought (CoT) style reasoning to guide its recursive subgoal decomposition pipeline. While these methods represent conceptual step towards our approach by acknowledging the importance of planning, they still tightly couple the planning and proving phases within single model and fixed workflow. Our method fundamentally differs by decoupling these two stages into distinct, specialized models, allowing for more flexible and powerful interaction, such as iterative refinement of lemmas before the final proof attempt. Our work builds upon the high-level philosophy of hierarchical proof generation, sharing conceptual similarities with prior efforts like Draft, Sketch, Prove (Jiang et al., 2023), LEGO-Prover (Wang et al., 2024b), POETRY (Wang et al., 2024a), and Subgoal-XL (Zhao et al., 2024). The most closely related is Draft, Sketch, Prove (Jiang et al., 2023), which also employs multi-stage pipeline: an LLM first drafts an informal proof, an autoformalizer then translates this draft into formal sketch, and finally, an external prover completes the proof. Despite this architectural resemblance, our approach makes critical design choice that diverges significantly. Instead of attempting to autoformalize an entire unstructured natural language proofa process that is itself major research challenge and prone to semantic errorswe task our specialized Reasoner model with more constrained and impactful objective: generating diverse set of formal subgoal statements (lemmas). This design offers two key advantages. First, by focusing on generating strategic lemmas rather than full proof steps, we directly leverage the abstract reasoning strength of powerful LLMs to perform creative and non-trivial problem decomposition, which is essential for solving complex problems like those in the IMO competition. Second, by generating formal statements directly and leaving the proof generation to dedicated Prover, we entirely bypass the fragile and error-prone autoformalization step. This ensures that the bridge between high-level reasoning and formal proving is both robust and precise."
        },
        {
            "title": "3 A Framework for Decoupled Reasoning and Proving",
            "content": "Our methodology is founded on the principle of decoupling high-level strategic reasoning from low-level formal proof generation. This separation allows us to use the best tool for each task: powerful, general-purpose reasoning model for strategic decomposition, and specialized, efficient theorem prover for formal verification. The overall workflow, illustrated in Figure 1, consists of three main stages: subgoal generation, subgoal filtering, and final proof construction."
        },
        {
            "title": "3.1 Stage 1: Strategic Subgoal Generation with a Reasoner",
            "content": "The first stage aims to replicate the most crucial aspect of human mathematical problem-solving: identifying strategic intermediate steps or lemmas. For IMO-level problems, which can require hundreds of proof steps in formal language like Lean, brute-force search is intractable. wellchosen set of lemmas can dramatically prune this search space by decomposing the primary goal into more manageable components. Our central insight is to leverage powerful, general-purpose Large Language Model as dedicated Reasoner, whose sole responsibility is to generate these strategic decompositions. Unlike specialized ATP models trained primarily on code, our Reasoners (e.g., OpenAI-o3, Gemini 2.5, Claude 4 Opus) excel at high-level, semantic understanding and creative problem-solving. We task the Reasoner with generating only the *formal statements of potential lemmas, without their proofs. This deliberate constraint focuses the model on its core strengthstrategic thinkingwhile avoiding the complexities and potential errors of full proof generation. After evaluating several state-of-the-art models, including OpenAI-o3, Claude 4 Opus and Gemini 2.5 Pro, we selected Gemini 2.5 Pro for its superior ability to generate diverse and logically sound subgoals for complex mathematical problems. We use the following prompt, which is designed to encourage deep reasoning before outputting structured Lean statements:"
        },
        {
            "title": "Prompt for Subgoal Generation",
            "content": "You are given very challenging theorem written in Lean 4. This theorem is too difficult to prove directly. Your task is to think step-by-step to devise feasible and complete proof strategy for the theorem, and then decompose the original theorem into sequence of smaller, logically coherent sub-theorems, each of which can be proved more easily. Important instructions: First, reason through and construct valid and complete proof strategy for the original theorem. After the solution path is clear, divide it into intermediate proof steps. Each step should be expressed as separate sub-theorem in Lean 4, following the same syntactic and semantic format as the original theorem. The decomposition should reflect deep understanding of the overall proof structure. Avoid trivial splits such as case analysis or mechanical divide into two cases tactics unless they are genuinely part of the reasoning process. Each sub-theorem must represent meaningful proof milestone essentially condensed logical step from the overall proof strategy. The sub-theorems should be self-contained and provable, and collectively they should imply the original theorem."
        },
        {
            "title": "Technical Report",
            "content": "Output format: brief explanation of your proof strategy (in natural language or Lean comments). list of Lean 4 theorem declarations, each representing sub-theorem, all starting with theorem XXX and ending with := by sorry. Ensure all sub-theorems are expressed using the same formal syntax and conventions as the input theorem. Input Theorem: To reliably extract the generated lemma statements from the models free-form text output, we apply simple yet robust regular expression. This ensures clean handoff to the next stage of the pipeline."
        },
        {
            "title": "Regular Expression for Lemma Extraction",
            "content": "theorem (.*?):= by sorry"
        },
        {
            "title": "3.2 Stage 2: Subgoal Verification and Filtering",
            "content": "The second stage acts as critical filter to ensure that only logically sound and verifiable lemmas are passed to the final stage. This verification step is essential for the overall soundness of our framework. For this task, we employ dedicated Prover model. The key requirement for this Prover is not high-level reasoning, but rather strong tactical execution and efficiency in proving well-defined, modular goals. We selected DeepSeek-Prover-v2 (7B, CoT version) for this role, as it offers state-of-the-art balance of proof success rate and computational efficiency. Each candidate lemma generated in Stage 1 is treated as an independent theorem. The Prover attempts to find proof for it, generating up to candidate proofs. lemma is considered \"verified\" and retained if at least one attempt succeeds. This filtering process is not merely correctness check; it is core component of our decoupled strategy. It allows the Reasoner in Stage 1 to be \"creative\" and even \"speculative,\" proposing diverse ideas without the immediate burden of provability. The Prover then grounds this creativity in formal rigor, effectively selecting the most promising pathways. We set (the number of proof candidates) to 128, value chosen empirically to balance the exploration breadth against computational cost."
        },
        {
            "title": "3.3 Stage 3: Final Proof Construction",
            "content": "In the final stage, the prover attempts to solve the main theorem by leveraging the set of verified lemmas obtained in Stage 2. These lemmas are prepended to the context of the main problem statement, effectively enriching the problem statement with suite of pre-proven, reusable components. This process transforms the original, monolithic proof task into more tractable task of assembling final proof using these intermediate results as foundational building blocks, as illustrated in Figure 1. In the final stage, the prover tries to tackle the main theorem with the aid of the set of verified lemmas from Stage 2. These lemmas are prepended to the context of the main problem statement, effectively enriching the problem with powerful, pre-proven tools. This transforms the original, monolithic challenge into simpler task of assembling final proof using these new building blocks, as illustrated in Figure 1. crucial challenge we identified at this stage was domain shift. We initially hypothesized that the same Prover from Stage 2 (DeepSeek-Prover-v2) would be optimal. However, we observed that this model, when presented with auxiliary lemmas, often struggled to effectively utilize them, likely because its training data did not emphasize this specific pattern of formal proving. It tended to"
        },
        {
            "title": "Technical Report",
            "content": "ignore the provided lemmas and attempt to prove the theorem from scratch, defeating the purpose of our pipeline. This led to key insight: the ability to leverage existing lemmas is distinct skill that not all provers possess equally. After further experimentation, we found that two powerful reasoner models, OpenAI-o3 and Gemini 2.5 Pro, are significantly more adept at integrating and applying the provided lemmas to construct the final proof. This highlights the importance of selecting the right tool for each sub-task in decoupled system. While we use those reasoners for our final results, promising direction for future work is to fine-tune specialized provers like DeepSeek-Prover-v2 on curriculum of problems that explicitly require the use of given lemmas."
        },
        {
            "title": "4 Experiment",
            "content": "We evaluate our approach on challenging problems from the International Mathematical Olympiad (IMO), focusing on non-geometry problems from the years 2000 to 2024. Each annual IMO consists of six problems, typically including one geometry problem. We focus on the non-geometry ones, and our method successfully solves 5 of these problems: IMO 2000 Problem 2, IMO 2005 Problem 3, IMO 2011 Problem 3, IMO 2019 Problem 1, and IMO 2020 Problem 2. We list detailed proofs in Appendix and show current progress on IMO 2024 problems in Appendix A."
        },
        {
            "title": "4.1 Comparing Reasoning Quality in IMO 2019 Problem 1",
            "content": "To evaluate the qualitative difference between reasoning strategies, we analyze how our frameworks Reasoner compares against existing prover-driven approaches when applied to challenging benchmark: IMO 2019 Problem 1. This problem asks to find all functions : satisfying (2a) + 2 (b) = ( (a + b)) for all integers a, b. Our goal is to demonstrate that the reasoning path generated by our decoupled Reasoner-Prover framework leads to principled, structured solution strategy, in stark contrast to prover-only models, which often exhibit brittle or degenerate behavior."
        },
        {
            "title": "4.1.1 Our Reasonerâ€™s Strategic Decomposition",
            "content": "In our framework, the Reasoner is responsible for identifying high-level mathematical structure and generating roadmap of lemmas. On this problem, the Reasoner produces the following structured decomposition: 1. Identify fundamental properties: By strategic instantiation of the functional equation, the Reasoner isolates key identities: prop_f_f_x: ( (x)) = 2 (x) + (0) for all prop_f_2x: (2x) = 2 (x) (0) for all 2. Uncover additive structure: Combining the above, the Reasoner deduces: prop_cauchy_like: (x + y) = (x) + (y) (0) 3. Characterize the function form: Using the Cauchy-like identity, the Reasoner infers: cauchy_implies_linear_form: There exists such that (x) = cx + (0) 4. Constrain the parameters: Plugging this linear form into prop_f_f_x, the Reasoner derives: linear_form_plus_f_f_x_implies_solutions: must be either 0 or 2 5. Verify candidate solutions: Both resulting forms, (x) = 0 and (x) = 2x + c, are verified to satisfy the original equation. This decomposition exhibits genuine mathematical insight: it identifies the functional equations additive structure, abstracts useful intermediate results, and uses them to constrain the solution space efficiently and interpretably."
        },
        {
            "title": "Technical Report",
            "content": "We contrast this with the behavior of current state-of-the-art prover models. Specifically, we sampled three solution attempts from the strongest publicly available model, DeepSeek Prover v2 671B (Ren et al., 2025). These are representative of the general behavior we observed. For brevity, we include only partial code excerpts. The first attempt relies on brute-force enumeration of equations. The model instantiates the functional equation on dozens of inputs, creating large flat pool of algebraic identities, and then invokes tactics such as ring_nf and linarith in hopes of simplification. There is no effort to identify structure or extract reusable intermediate results. The tactic application is purely local and mechanical: := hf 0 0 := hf 0 := hf 0 := hf (-x) have 2 have 3 have 4 have 5 ... have 26 ring_nf at := hf (x + x) (-x) 4 ... h 2 3 26 In the second attempt, the prover tries to assert the final form of the solutionnamely (x) = 2x + (0)without having established why must be linear or what motivates such guess. It implicitly assumes the desired conclusion and attempts to work backward through aggressive simplification. This reveals logical gap: the model never proves the Cauchy-like identity nor justifies why linear form should even be expected. have : = 2 * + 0 := by := hf 0 291 29 have ... ring_nf at <;> linarith ... 291 The third attempt generates an even larger collection of equation instances, trying all possible combinations of inputs into the original functional equation, and then offloads the burden of reasoning onto generic decision procedure like omega. Again, no insight is gained; the solution depends entirely on the capacity of low-level tactics to blindly traverse the search space. have : = 2 * + (f 0 - 2 * 0) := by := hf 0 32 31 have ... have 42 ring_nf at omega := hf 1 (x - 1) ... 32 42 These degenerate strategies are direct consequence of the reward signals guiding the training of prover models. When models are rewarded solely for producing verifiable proofs, they learn to exploit patterns that maximize verification success, not reasoning quality. Brute-force instantiation followed by tactic chains often suffices on simple benchmarks, so models internalize that behavioreven when such strategies fail to scale to Olympiad-level problems. In these more complex settings, the search space is too vast, and the necessary structural insights (such as recognizing the shifted Cauchy identity) cannot be discovered by purely local manipulations. In contrast, our framework deliberately separates the high-level reasoning process from low-level proof verification. The Reasoner is not constrained by the demands of tactic execution or code generation; it operates at the level of abstraction and mathematical insight. By generating chain of semantically meaningful lemmas, it defines proof skeleton that guides the Prover and drastically"
        },
        {
            "title": "Technical Report",
            "content": "reduces the search space. This separation enables the kind of reasoning that mirrors how human mathematicians approach challenging problems: by detecting invariants, proposing transformations, and narrowing the solution space through conceptual understanding. As this case study illustrates, this leads to reasoning that is not only verifiable, but also interpretable, reusable, and robust."
        },
        {
            "title": "4.2 Degradation of Mathematical Reasoning in Specialised Provers",
            "content": "Motivation. central hypothesis of our work is that the prevailing reinforcement learning with verifiable rewards (RLVR) paradigm, while effective for optimizing success rates on specific ATP benchmarks, may inadvertently cause degradation in the models intrinsic mathematical reasoning capabilities. The reward signal, being solely dependent on the formal proofs success, does not explicitly value the quality or correctness of the natural language reasoning that may precede it. To test this hypothesis, we designed an experiment to isolate and measure this potential degradation. Experimental Setup. We compare the performance of specialized prover model with its generalpurpose base model on standard mathematical reasoning benchmarks that do not involve formal proof generation. Specifically, we selected: Base Model: Qwen2.5-Math-7B-Instruct, the foundational model upon which the KiminaProver is built, which is highly capable in general mathematical problem-solving. Prover: Kimina-Prover-Preview-Distill-7B, state-of-the-art prover initialized from Qwen2.5-Math-7B-Instruct and fine-tuned for Lean-based theorem proving. We evaluated both models on the MATH and AIME benchmarks. We found that with appropriate prompting, Kimina-Prover can still generate high-quality solutions to math problems, rather than generating Lean code. This allowed for direct comparison of their problem-solving accuracy. We report the pass@k accuracy for both models on AIME24. Table 1: Performance comparison on general mathematical reasoning benchmarks."
        },
        {
            "title": "Model",
            "content": "Qwen2.5-Math-7B-Instruct (base model) Kimina-Prover-Preview-Distill-7B (prover) Performance Drop (pts)"
        },
        {
            "title": "MATH",
            "content": "AIME24 pass@1 pass@1 pass@4 pass@8 pass@16 83.6% 78.7% -4.9 16.7% 11.0% -5. 33.3% 24.1% -9.2 43.3% 32.0% -11.3 46.7% 40.9% -5. The results, presented in Table 1, provide clear evidence supporting our hypothesis. On both benchmarks, the Kimina-Prover exhibits marked decline in performance compared to its base model. The single-attempt accuracy (pass@1) drops by 4.9 percentage points on MATH and 5.7 points on AIME. Crucially, this performance gap is not an isolated phenomenon but persists robustly across multi-sample evaluations on the challenging AIME dataset. The performance delta remains substantial at pass@4, widens further at pass@8, and is still significant at pass@16. This confirms that the specialization process for formal theorem proving, while boosting performance on ATP tasks, comes at the cost of broader mathematical reasoning skills. This finding strongly motivates our decoupled approach: instead of attempting to force single model to excel at both high-level reasoning and low-level formalization, we should leverage dedicated, un-degraded reasoning model for the former, preserving its full intellectual capacity."
        },
        {
            "title": "4.3 Further Discussions",
            "content": "On the Utilization of External Knowledge: Lemmas vs. have Statements. critical challenge we encountered during the development of our pipeline was the effective integration of verified subgoals into the final proof stage. We observed significant behavioral pattern: when verified"
        },
        {
            "title": "Technical Report",
            "content": "subgoals were provided as standalone lemmas in the context, many state-of-the-art provers, including DeepSeek-Prover-v2, tended to ignore them. Instead of leveraging these pre-proven facts, the models often attempted to prove the main theorem from scratch, indicating form of \"contextual blindness\" or bias towards self-contained proof generation learned during their fine-tuning. The \"contextual blindness\" phenomenon contrasts with using have statement within proof, which forces the model to work with specific, locally-defined fact (Ren et al., 2025; Cao et al., 2025). However, have statements require strict alignment of symbols and definitions with the current proof state, limiting their flexibility. Standalone lemmas, in theory, offer more powerful and flexible mechanism for incorporating external knowledge, as they do not impose such rigid constraints. This flexibility is crucial for solving complex problems where reusing established results is key. Our findings suggest that significant gap exists in the ability of current provers to effectively utilize modular, pre-proven knowledge. crucial direction for future work is therefore to develop or fine-tune provers to specifically excel at this \"proof continuation\" task, enabling them to robustly accept and leverage library of existing theorems and lemmas. Limitations and Failure Analysis. Our analysis on unsolved statements reveals two primary bottlenecks in the current pipeline, highlighting the remaining gap between our automated system and human-level mathematical ingenuity. First, the primary mode of failure is the Provers inability to verify critical, complex lemmas. For many unsolved problems, our Reasoner successfully identified plausible high-level strategy, but the constituent lemmas were simply too difficult for the Prover module to handle. To validate this, we conducted an oracle experiment where we manually proved these bottleneck lemmas (or replaced their proofs with sorry). In this idealized setting, our framework was able to solve significantly larger number of IMO problems. This demonstrates that the performance of the entire pipeline is currently bounded by the raw theorem-proving power of the Prover component. Another potential approach involves further decomposing unresolved lemmas into simpler sub-lemmas to facilitate their proof. Second, we identified fundamental difference in the reasoning style of our Reasoner compared to human mathematicians. Through manual inspection of our Reasoners outputs against official IMO solutions, we observed that human proofs often hinge on single, \"magical\" insight or clever re-framing of the problem that dramatically simplifies the proof. Our Reasoner, reflecting its LLM nature, excels at systematic, step-by-step decomposition and logical deduction. It is proficient at breaking problem down into clear chain of sub-problems but struggles to generate the kind of non-obvious, highly creative leaps that characterize elegant human solutions. This \"ingenuity gap\" represents deeper, more fundamental challenge for LLM-based reasoning and is key bottleneck for our framework on the most difficult problems."
        },
        {
            "title": "5 Conclusion",
            "content": "In this work, we introduce novel framework for automated theorem proving that addresses core limitation in current systems: the degradation of mathematical reasoning ability caused by endto-end RLVR training. Our central contribution is the principle of decoupling strategic reasoning from formal proof generation. We achieve this by delegating high-level strategic thinking to dedicated Reasonera powerful, general-purpose LLM whose nuanced reasoning capabilities are often compromised during specialized prover fine-tuning. This Reasoner formulates its strategy as set of formal subgoal lemmas, providing more general and powerful mechanism for problem decomposition than restrictive in-proof statements. This modular design ensures proof search is guided by coherent, human-like plan. Our evaluation on challenging set of post-2000 IMO problems, where we successfully solved 5 problems previously unsolved by any open-source prover, provides strong evidence for the efficacy of our decoupled approach. We acknowledge that our current evaluation is limited and that the multi-stage nature of our pipeline presents scalability challenges. key priority for future work"
        },
        {
            "title": "Technical Report",
            "content": "is to streamline this pipeline to enable comprehensive evaluation on large-scale benchmarks such as miniF2F and ProofNet. Ultimately, we believe that by separating the art of strategy from the science of verification, our work paves the way for more robust, scalable, and insightful automated reasoning systems capable of tackling the frontiers of mathematics."
        },
        {
            "title": "References",
            "content": "Chenrui Cao, Liangcheng Song, Zenan Li, Xinyi Le, Xian Zhang, Hui Xue, and Fan Yang. Reviving dsp for advanced theorem proving in the era of reasoning models. arXiv preprint arXiv:2506.11487, 2025. Jasper Dekoninck, Ivo Petrov, Kristian Minchev, Mislav Balunovic, Martin Vechev, Miroslav Marinov, Maria Drencheva, Lyuba Konova, Milen Shumanov, Kaloyan Tsvetkov, et al. The open proof corpus: large-scale study of llm-generated mathematical proofs. arXiv preprint arXiv:2506.21621, 2025. Emily First, Markus Rabe, Talia Ringer, and Yuriy Brun. Baldur: Whole-proof generation and repair with large language models. In Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering, pp. 12291241, 2023. Albert Qiaochu Jiang, Sean Welleck, Jin Peng Zhou, Timothee Lacroix, Jiacheng Liu, Wenda Li, Mateja Jamnik, Guillaume Lample, and Yuhuai Wu. Draft, sketch, and prove: Guiding formal theorem provers with informal proofs. In The Eleventh International Conference on Learning Representations, 2023. URL https://openreview.net/forum?id=SMa9EAovKMC. Yang Li, Dong Du, Linfeng Song, Chen Li, Weikang Wang, Tao Yang, and Haitao Mi. Hunyuanprover: scalable data synthesis framework and guided tree search for automated theorem proving. arXiv preprint arXiv:2412.20735, 2024. Zhenwen Liang, Linfeng Song, Yang Li, Tao Yang, Feng Zhang, Haitao Mi, and Dong Yu. Mpsprover: Advancing stepwise theorem proving by multi-perspective search and data curation. arXiv preprint arXiv:2505.10962, 2025. Yong Lin, Shange Tang, Bohan Lyu, Jiayun Wu, Hongzhou Lin, Kaiyu Yang, Jia Li, Mengzhou Xia, Danqi Chen, Sanjeev Arora, et al. Goedel-prover: frontier model for open-source automated theorem proving. arXiv preprint arXiv:2502.07640, 2025. Leonardo de Moura and Sebastian Ullrich. The lean 4 theorem prover and programming language. In Automated DeductionCADE 28: 28th International Conference on Automated Deduction, Virtual Event, July 1215, 2021, Proceedings 28, pp. 625635. Springer, 2021. Lawrence Paulson. Isabelle: generic theorem prover. Springer, 1994. Stanislas Polu and Ilya Sutskever. Generative language modeling for automated theorem proving. arXiv preprint arXiv:2009.03393, 2020. ZZ Ren, Zhihong Shao, Junxiao Song, Huajian Xin, Haocheng Wang, Wanjia Zhao, Liyue Zhang, Zhe Fu, Qihao Zhu, Dejian Yang, et al. Deepseek-prover-v2: Advancing formal mathematical reasoning via reinforcement learning for subgoal decomposition. arXiv preprint arXiv:2504.21801, 2025. Haiming Wang, Huajian Xin, Zhengying Liu, Wenda Li, Yinya Huang, Jianqiao Lu, Zhicheng YANG, Jing Tang, Jian Yin, Zhenguo Li, and Xiaodan Liang. Proving theorems recursively. In The Thirty-eighth Annual Conference on Neural Information Processing Systems, 2024a. URL https://openreview.net/forum?id=yAa5l92TtQ. Haiming Wang, Huajian Xin, Chuanyang Zheng, Zhengying Liu, Qingxing Cao, Yinya Huang, Jing Xiong, Han Shi, Enze Xie, Jian Yin, Zhenguo Li, and Xiaodan Liang. LEGO-prover: Neural theorem proving with growing libraries. In The Twelfth International Conference on Learning Representations, 2024b. URL https://openreview.net/forum?id=3f5PALef5B."
        },
        {
            "title": "Technical Report",
            "content": "Haiming Wang, Mert Unsal, Xiaohan Lin, Mantas Baksys, Junqi Liu, Marco Dos Santos, Flood Sung, Marina Vinyes, Zhenzhe Ying, Zekai Zhu, et al. Kimina-prover preview: Towards large formal reasoning models with reinforcement learning. arXiv preprint arXiv:2504.11354, 2025. Zijian Wu, Suozhi Huang, Zhejian Zhou, Huaiyuan Ying, Jiayu Wang, Dahua Lin, and Kai Chen. Internlm2.5-stepprover: Advancing automated theorem proving via expert iteration on large-scale lean problems. arXiv preprint arXiv:2410.15700, 2024. Huajian Xin, ZZ Ren, Junxiao Song, Zhihong Shao, Wanjia Zhao, Haocheng Wang, Bo Liu, Liyue Zhang, Xuan Lu, Qiushi Du, et al. Deepseek-prover-v1. 5: Harnessing proof assistant feedback for reinforcement learning and monte-carlo tree search. arXiv preprint arXiv:2408.08152, 2024. Ran Xin, Chenguang Xi, Jie Yang, Feng Chen, Hang Wu, Xia Xiao, Yifan Sun, Shen Zheng, and Kai Shen. Bfs-prover: Scalable best-first tree search for llm-based automatic theorem proving. arXiv preprint arXiv:2502.03438, 2025. Xueliang Zhao, Lin Zheng, Haige Bo, Changran Hu, Urmish Thakker, and Lingpeng Kong. Subgoalxl: Subgoal-based expert learning for theorem proving. arXiv preprint arXiv:2408.11172, 2024. Case Studies on IMO 2024 Problems This section provides detailed analysis of our frameworks progress on two problems from the IMO 2024. For each problem, we present the main theorem, summarize the key sub-theorems (lemmas) that our framework successfully generated and proved, and identify the critical remaining steps required to complete the full proof. A.1 Analysis of IMO 2024, Problem 1 A.1.1 Main Theorem The problem asks to prove the equivalence between real number being an even integer and specific divisibility property holding for all positive integers n. theorem imo2024_p1 (a : R) : ( : Z, = 2 * m) : N, 0 < (n : Z) in Finset.Icc 1 n, * (cid:44) := by The proof naturally splits into two directions: Forward Direction (1) (2): If = 2m for some integer m, then the divisibility property holds. Reverse Direction (2) (1): If the divisibility property holds, then must be of the form 2m. A.1.2 Progress Summary and Key Proven Lemmas Our framework has made substantial progress on this problem, most notably by completely proving the forward direction and establishing the crucial strategic lemmas for the reverse direction. Forward Direction: Complete. The framework successfully proved that if is an even integer, the divisibility property holds. This was accomplished through several lemmas, culminating in direct proof of the implication."
        },
        {
            "title": "Technical Report",
            "content": "-- Proved: The forward implication of the main theorem. theorem imo2024_p1_forward_implication (a : R) : ( : Z, = 2 * m) ( : N, 0 < (n : Z) in Finset.Icc 1 n, * a) (cid:44) := by Reverse Direction: Key Strategic Lemmas Proven. For the more challenging reverse direction, our system proved two cornerstone lemmas that are essential to the standard human solution strategy. 1. Periodicity of the Condition: The framework proved that the divisibility property is periodic with period of any even integer. This is powerful strategic result, as it allows reducing the problem for any real number to an equivalent problem for number in bounded interval (e.g., [0, 2]). -- Proved: The divisibility property is periodic by any even integer. theorem divisibility_is_periodic_by_even_integers (a : R) (m : Z) : ( : N, 0 < (n : Z) in Finset.Icc 1 n, * a) ( : N, 0 < (n : Z) in Finset.Icc 1 n, * (a - 2 * m)) := (cid:44) by 2. Special Case for Integers: The system proved that if is an integer satisfying the divisibility property, it must be an even integer. This fully resolves the reverse direction for the specific case where Z. -- Proved: An integer satisfying the property must be even. theorem integer_must_be_even (a : Z) (h_div_int : : N, 0 < (n : Z) in Finset.Icc 1 n, (i : R) (cid:44) Even := by * (a : R)) : A.1.3 Analysis of the Remaining Proof Goal With the forward direction complete and the key periodicity lemma established, the entire proof now hinges on single, final sub-problem. The Final Step: Proving the Base Case for the Periodicity. The established lemmas allow us to reason as follows: Assume real number satisfies the divisibility property. We can find an integer such that = 2m lies in the interval [1, 1]. Due to the proven periodicity, must also satisfy the divisibility property. If we can prove that the only number in [1, 1] satisfying the property is 0, it would imply = 0, which means = 2m, completing the proof. Therefore, the critical missing lemma is to show that for any number [1, 1] (or similar interval like (1, 1]), if it satisfies the property, it must be zero."
        },
        {
            "title": "Critical Missing Lemma",
            "content": "Goal: To prove that if real number in the interval [1, 1] satisfies the universal divisibility condition, then must be 0. theorem univ_divisibility_in_interval_implies_zero (a : R) (ha_bound : Set.Icc (cid:44) (-1) 1) (h_prop : : N, 0 < (n : Z) in Finset.Icc 1 n, * a) : = 0 := by"
        },
        {
            "title": "Technical Report",
            "content": "Successfully proving this final lemma would allow us to connect all the previously established results and formally complete the entire proof for IMO 2024, Problem 1. Our framework has successfully navigated the problem to its final, decisive step. A.2 Analysis of IMO 2024, Problem 2 A.2.1 Main Theorem This problem concerns property of the greatest common divisor (GCD) of two exponential sequences. It asks to prove that the GCD becoming constant for all sufficiently large is equivalent to and both being 1. theorem imo2024_p2 (a : N+) : (a, b) = (1, 1) : N+, : N, Nat.gcd (a^n + b) (b^n + a) = := (cid:44) by The proof structure involves straightforward forward direction and more complex reverse direction, which is typically solved by considering cases. A.2.2 Progress Summary and Key Proven Lemmas Our framework successfully proved the simple forward direction and made significant headway on the reverse direction by proving the special case where = b. Forward Direction: Complete. The framework easily proved that if = 1 and = 1, the GCD sequence is constant. In this case, gcd(1n + 1, 1n + 1) = gcd(2, 2) = 2 for all n, so one can choose = 2 and = 1. -- Proved: The forward implication of the main theorem. theorem imo2024_p2_forward_implication (a : N+) : (a, b) = (1, 1) : N+, : N, Nat.gcd (a^n + b) (b^n + a) = := (cid:44) by Reverse Direction: Special Case = Proven. For the reverse direction, the framework identified and fully proved the crucial sub-case where = b. It correctly deduced that if = and the GCD property holds, then must be 1. The reasoning relies on the fact that if = b, the GCD is gcd(an + a, an + a) = an + a. For this sequence to be constant for N, cannot be greater than 1. -- Proved: If a=b and the GCD property holds, then a=1 and b=1. theorem imo2024_p2_bwd_a_eq_b (a : N+) (h_ab : = b) (h_gcd_const : : N+, : N, Nat.gcd (a^n + b) (b^n + a) = g) : (a, b) = (1, 1) := by This lemma is supported by another proven sub-theorem stating that an exponential sequence like an + cannot be eventually constant if > 1. -- Proved: An exponential sequence is not eventually constant for > 1. theorem exponential_not_eventually_constant (a : N+) : > 1 : N+, : N, a^n + = := by"
        },
        {
            "title": "Technical Report",
            "content": "A.2.3 Analysis of the Remaining Proof Goal With the forward direction and the = case of the reverse direction complete, the entire proof now rests on resolving the case where = b. The Final Step: Proving the Case = Leads to Contradiction. The standard human approach for the case = (without loss of generality, assume > b) is to show that the GCD sequence, dn = gcd(an + b, bn + a), cannot be eventually constant if > 1. common technique involves using properties of the GCD, such as gcd(X, Y) = gcd(X, kX). Applying this here: dn = gcd(an + b, bn + a) = gcd(an + b, bn + bn1(an + b)) which simplifies the second term. The key is to show that if > 1, this sequence cannot be constant for large n. Therefore, the critical missing lemma is to prove by contradiction that if the GCD property holds, the case = is impossible unless = = 1 (which is already covered)."
        },
        {
            "title": "Critical Missing Lemma",
            "content": "Goal: To prove that if = b, the GCD property cannot hold. common way is to show that if > b, the GCD sequence is not constant. -- This lemma is stated to lead to contradiction with the main hypothesis. theorem gcd_is_not_eventually_constant_if_unequal (a : N+) (h_neq : = b) : ( : N+, : N, Nat.gcd (a^n + b) (b^n + a) = g) := by -- more direct approach to prove is: -- if > >= 1, then the sequence is not constant. Or, framing it to directly complete the main proof: -- This lemma, combined with the a=b case, would complete the proof. theorem p2_bwd_dir_a_neq_b (a : N+) : ( : N+, : N, Nat.gcd (a^n + b) (b^n + a) = g) = (cid:44) False := by By proving that the GCD property cannot hold for distinct positive integers and b, our framework would successfully eliminate the only remaining case, thereby completing the proof for IMO 2024, Problem 2. 1 2 3 5 6 7 8"
        },
        {
            "title": "B Solved IMO problems",
            "content": "B.1 IMO 2020 P2 -- Solution to IMO 2020 P2 by DRP-IMO import Mathlib import Aesop set_option maxHeartbeats 0 open BigOperators Real Nat Topology Rat /--Consider four real numbers ( a, b, c, ) and ( ) such that ( 0 < leq leq (cid:44) (cid:44) (cid:44) leq ) and their sum is equal to 1, i.e., ( + + + = 1 ). Prove that the product of the weighted sum ( + 2b + 3c + 4d ) and the sum of their squares ( a^2 + b^2 + c^2 + d^2 ) is less than 1.-/"
        },
        {
            "title": "Technical Report",
            "content": "theorem weighted_sum_times_sum_sq_lt_one (a : R) (hd_pos : 0 < d) (hdc : c) (cid:44) (hcb : b) (hba : a) (h_sum_eq_1 : + + + = 1) : (a + 2*b + 3*c + 4*d) * (a^2 + b^2 + c^2 + d^2) < 1 := by have h_a_lt_one : < 1 := by have 1 have 2 have 3 have 4 nlinarith : + + + = 1 := h_sum_eq_1 : 0 < := by linarith : 0 < := by linarith : 0 < := hd_pos have h_b_lt_one : < 1 := by have 1 have 2 nlinarith : := by linarith : < 1 := h_a_lt_one have h_c_lt_one : < 1 := by have 1 have 2 nlinarith : := by linarith : < 1 := h_b_lt_one have h_d_lt_one : < 1 := by have 1 have 2 nlinarith : := by linarith : < 1 := h_c_lt_one have h_a2_lt_a : a^2 < := by : < 1 := h_a_lt_one : > 0 := by linarith have 1 have 2 nlinarith [sq_pos_of_pos <;> nlinarith ] have h_b2_lt_b : b^2 < := by : < 1 := h_b_lt_one : > 0 := by linarith have 1 have 2 nlinarith [sq_pos_of_pos <;> nlinarith ] 2 have h_c2_lt_c : c^2 < := by : < 1 := h_c_lt_one : > 0 := by linarith have 1 have 2 nlinarith [sq_pos_of_pos <;> nlinarith ] 2 have h_d2_lt_d : d^2 < := by : < 1 := h_d_lt_one : > 0 := hd_pos have 1 have 2 nlinarith [sq_pos_of_pos <;> nlinarith ] have h_sum_sq_lt_one : a^2 + b^2 + c^2 + d^2 < 1 := by nlinarith [h_a2_lt_a, h_b2_lt_b, h_c2_lt_c, h_d2_lt_d] <;> linarith have h_main : (a + 2*b + 3*c + 4*d) * (a^2 + b^2 + c^2 + d^2) < 1 := by have 1 : 0 < + 2 * + 3 * + 4 * := by nlinarith [hd_pos, hcb, hba, hdc, h_sum_eq_1] : ^ 2 + ^ 2 + ^ 2 + ^ 2 < 1 := h_sum_sq_lt_one have 2 nlinarith [h 1 <;> nlinarith , 2 ] 16 12 13 14 15 16 18 19 20 21 22 24 25 26 27 28 30 31 32 33 34 36 37 38 39 40 42 43 44 45 46 48 49 50 51 52 54 55 56 57 58 60 61 62 63 64 66"
        },
        {
            "title": "Technical Report",
            "content": "exact h_main theorem vars_are_in_0_1 (a : R) (hd0 : 0 < d) (hdc : c) (hcb : b) (hba : (cid:44) a) (h1 : + + + = 1) : (0 < < 1) (0 < < 1) (0 < < 1) (0 < < 1) := by have h_a_pos : 0 < := by nlinarith [hdc, hcb, hba, hd0, h1] <;> nlinarith have h_a_lt_1 : < 1 := by have h2 : < 1 := by nlinarith [h1, h_a_pos, hba, hcb, hdc, hd0] exact h2 have h_b_pos : 0 < := by nlinarith [hdc, hcb, hba, hd0, h1] have h_b_lt_1 : < 1 := by have h2 : < 1 := by nlinarith [h1, h_a_pos, h_a_lt_1, hba, hcb, hdc, hd0] exact h2 have h_c_pos : 0 < := by nlinarith [hdc, hcb, hba, hd0, h1] have h_c_lt_1 : < 1 := by have h2 : < 1 := by nlinarith [h1, h_a_pos, h_a_lt_1, h_b_pos, h_b_lt_1, hba, hcb, hdc, hd0] exact h2 have h_d_pos : 0 < := by exact hd0 have h_d_lt_1 : < 1 := by have h2 : < 1 := by nlinarith [h1, h_a_pos, h_a_lt_1, h_b_pos, h_b_lt_1, h_c_pos, h_c_lt_1, hdc, hcb, hba, hd0] (cid:44) exact h2 refine' h_a_pos, h_a_lt_1, h_b_pos, h_b_lt_1, h_c_pos, h_c_lt_1, h_d_pos, (cid:44) h_d_lt_1 theorem imo2020_q2 (a : R) (hd0 : 0 < d) (hdc : c) (hcb : b) (hba : a) (cid:44) (h1 : + + + = 1) : (a + 2 * + 3 * + 4 * d) * (a ^ * ^ * ^ * ^ d) < 1 := by -- strategy: -- 1. apply weighted AM-GM inequality to prove a^a * b^b * c^c * d^d a^2 + b^2 + c^2 + (cid:44) -- 2. ues subgoal 'weighted_sum_times_sum_sq_lt_one' to get (a + 2*b + ...) * (a^2 + b^2 d^2 + ...) < (cid:44) -- 3. combine both results to reach final conclusion -- define let := a^2 + b^2 + c^2 + d^2 -- step 1: apply weighted AM-GM inequality 17 69 71 72 73 74 75 77 78 79 80 81 83 84 85 86 87 89 90 91 92 93 95 96 97 98 99 101 102 103 104 105 107 108 109 110 111 113 114 115 116 117 119"
        },
        {
            "title": "Technical Report",
            "content": "122 123 124 125 126 128 129 130 131 132 134 135 136 137 138 140 141 142 143 144 146 147 148 149 150 152 153 154 155 156 158 159 160 161 162 164 165 166 167 168 170 171 -- we need to prove a^a * b^b * c^c * d^d have h_geom_mean_le_sum_sq : ^ * ^ * ^ * ^ := by -- in order to use the subgoal 'geom_mean_le_arith_mean_weighted', we use Fin 4 as an index type (cid:44) let : Fin 4 := ![a, b, c, d] let : Fin 4 := ![a, b, c, d] -- check AM-GM prerequisite have h_pos_conds : (0 < a) (0 < b) (0 < c) (0 < d) := by have h_all := vars_are_in_0_1 d hd0 hdc hcb hba h1 exact h_all.1.1, h_all.2.1.1, h_all.2.2.1.1, h_all.2.2.2.1 -- 1. non-negative weights have h_weights_nonneg : i, 0 := by intro i; fin_cases <;> simp [w] <;> linarith [h_pos_conds.1, h_pos_conds.2.1, (cid:44) h_pos_conds.2.2.1, h_pos_conds.2.2.2] -- 2. weights sum-up to 1 have h_weights_sum_1 : i, = 1 := by simp [w, Fin.sum_univ_four, h1] -- 3. non-negative values have h_values_nonneg : i, 0 := by intro i; fin_cases <;> simp [z] <;> linarith [h_pos_conds.1, h_pos_conds.2.1, (cid:44) h_pos_conds.2.2.1, h_pos_conds.2.2.2] -- use the subgoal based on AM-GM have h_am_gm := geom_mean_le_arith_mean_weighted (Finset.univ) (fun _ (cid:55) (cid:44) h_weights_nonneg i) h_weights_sum_1 (fun _ (cid:55) h_values_nonneg i) -- transform AM-GM results to the form we want -- `simp` will handle a*a -> a^2 simp only [Fin.prod_univ_four, Fin.sum_univ_four, w, z, pow_two] at h_am_gm -- it will replace 'S' to 'a^2 + b^2 + c^2 + d^2' unfold -- now the target fully matchs 'h_am_gm' exact h_am_gm -- step 2: get results from key lemmas have h_main_ineq : (a + 2 * + 3 * + 4 * d) * < 1 := by exact weighted_sum_times_sum_sq_lt_one d hd0 hdc hcb hba -- step 3 & 4 & 5: assumble final proof calc (a + 2*b + 3*c + 4*d) * (a^a * b^b * c^c * d^d) -- first, use the results from step 1, we need to prove (a + 2*b + ...) is positive -- lemma 'vars_are_in_0_1' guarantees a,b,c,d > 0, thus their weighted sum also > 0 _ (a + 2*b + 3*c + 4*d) * := by apply mul_le_mul_of_nonneg_left h_geom_mean_le_sum_sq have h_pos_conds := vars_are_in_0_1 d hd0 hdc hcb hba h1 linarith [h_pos_conds.1.1, h_pos_conds.2.1.1, h_pos_conds.2.2.1.1, (cid:44) h_pos_conds.2.2.2.1] -- then, use the results from step 2 to finish proving _ < 1 := h_main_ineq"
        },
        {
            "title": "Technical Report",
            "content": "B.2 IMO 2019 P1 -- Solution to IMO 2019 P1 by DRP-IMO import Mathlib import Aesop set_option maxHeartbeats 0 open BigOperators Real Nat Topology Rat def solution_set (f : Z) : Prop := ( : Z, = 0) : Z, : Z, = 2 * + theorem linear_form_plus_f_f_x_implies_solutions (f : Z) (c : Z) (h_f_form : x, = * + 0) (h_f_f_x : x, (f x) = 2 * + 0) : ( x, = 0) ( x, = 2 * + 0) := by have h_c_squared : c^2 = 2 * := by have h1 := h_f_f_x 1 have h2 := h_f_f_x 0 have h3 := h_f_f_x (-1) have h4 := h_f_form 1 have h5 := h_f_form 0 have h6 := h_f_form (-1) have h7 := h_f_form (f 1) have h8 := h_f_form (f 0) have h9 := h_f_form (f (-1)) have h10 := h_f_f_x (f 1) have h11 := h_f_f_x (f 0) have h12 := h_f_f_x (f (-1)) have h13 := h_f_form (c * 1 + 0) have h14 := h_f_form (c * 0 + 0) have h15 := h_f_form (c * (-1) + 0) have h16 := h_f_form (c * (f 1) + 0) have h17 := h_f_form (c * (f 0) + 0) have h18 := h_f_form (c * (f (-1)) + 0) ring_nf at h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 nlinarith [sq_nonneg (c - 2), sq_nonneg (c + 2), sq_nonneg (c - 1), sq_nonneg (c + 1)] have h_c_cases : = 0 = 2 := by have 1 have 2 : ^ 2 = 2 * := h_c_squared : = 0 = 2 := by have 3 linarith : * (c - 2) = 0 := by have 4 : = 0 - 2 = 0 := by apply eq_zero_or_eq_zero_of_mul_eq_zero cases 4 inl 4 with => exact Or.inl => 4 inr 4 have 5 omega : = 2 := by exact Or.inr exact 2 5 have h_main : ( x, = 0) ( x, = 2 * + 0) := by cases h_c_cases with inl h_c_zero => -- Case = 0 19 2 3 4 5 6 8 9 10 11 12 14 15 16 17 18 20 21 22 23 24 26 27 28 29 30 32 33 34 35 36 38 39 40 41 42 44 45 46 47 48 50 51 52 53 54"
        },
        {
            "title": "Technical Report",
            "content": "have h_f_zero : x, = 0 := by intro have := h_f_form 1 simp [h_c_zero] at <;> linarith 1 have h_f_zero_zero : 0 = 0 := by := h_f_f_x 0 := h_f_form 0 := h_f_form (f 0) := h_f_f_x (f 0) have 1 have 2 have 3 have 4 simp [h_f_zero] at <;> (try omega) <;> (try { 2 3 4 nlinarith [h_f_form 0, h_f_form 1, h_f_form (-1), h_f_form (f 0)] }) <;> (try { cases' h_c_cases with h_c_zero h_c_two <;> simp_all [h_c_zero, h_c_two] <;> (try omega) <;> (try nlinarith) <;> (try linarith) }) <;> (try { aesop }) have h_f_zero_all : x, = 0 := by := h_f_zero := h_f_zero 0 := h_f_zero (-1) := h_f_zero 1 intro have 1 have 2 have 3 have 4 simp [h_f_zero_zero] at 1 <;> (try omega) <;> (try nlinarith) <;> (try aesop) <;> (try { 2 3 4 simp_all [h_f_form, h_c_zero] <;> (try omega) <;> (try nlinarith) <;> (try aesop) }) exact Or.inl h_f_zero_all inr h_c_two => -- Case = 2 have h_f_form_two : x, = 2 * + 0 := by intro have 1 simp [h_c_two] at <;> linarith := h_f_form 1 exact Or.inr h_f_form_two exact h_main 20 58 59 60 61 63 64 65 66 67 69 70 71 72 73 75 76 77 78 79 81 82 83 84 85 87 88 89 90 91 93 94 95 96 97 99 100 101 102 103 105 106 107 108 109 111 112 113 114"
        },
        {
            "title": "Technical Report",
            "content": "117 118 119 120 121 123 124 125 126 127 129 130 131 132 133 135 136 137 138 139 141 142 143 144 145 147 148 149 150 151 153 154 155 156 157 159 160 161 162 163 165 166 167 168 169 theorem prop_cauchy_like (f : Z) (h_f_all : b, (2 * a) + 2 * (f b) = (f (a + (cid:44) b))) (h_f_f_x : x, (f x) = 2 * + 0) (h_f_2x : x, (2 * x) = 2 * - 0) (x (cid:44) : Z) : (x + y) = + - 0 := by have h_main : (x + y) = + - 0 := by have h1 := h_f_all (x + y) 0 have h2 := h_f_all have h3 := h_f_all (x + y) have h4 := h_f_all (x + y) have h5 := h_f_2x (x + y) have h6 := h_f_2x have h7 := h_f_2x have h8 := h_f_all 0 (x + y) have h9 := h_f_all 0 have h10 := h_f_all 0 have h11 := h_f_f_x (x + y) have h12 := h_f_f_x have h13 := h_f_f_x have h14 := h_f_all (2 * (x + y)) 0 have h15 := h_f_all (2 * x) 0 have h16 := h_f_all (2 * y) 0 have h17 := h_f_all 0 have h18 := h_f_all 0 have h19 := h_f_all (x + y) (x + y) have h20 := h_f_all have h21 := h_f_all -- Simplify the expressions using the given conditions simp [h_f_2x, mul_add, add_mul, mul_comm, mul_left_comm, mul_assoc] at h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 (cid:44) <;> ring_nf at h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 (cid:44) <;> omega exact h_main theorem prop_f_f_x (f : Z) (h_f_all : b, (2 * a) + 2 * (f b) = (f (a + b))) (cid:44) (x : Z) : (f x) = 2 * + 0 := by have h_main : (f x) = 2 * + 0 := by have h1 := h_f_all 0 have h2 := h_f_all 0 have h3 := h_f_all have h4 := h_f_all (-x) have h5 := h_f_all (-x) have h6 := h_f_all 0 0 have h7 := h_f_all (-2 * x) have h8 := h_f_all (-x) (-x) have h9 := h_f_all 1 have h10 := h_f_all (-1) have h11 := h_f_all 1 have h12 := h_f_all (-1) have h13 := h_f_all 1 0 have h14 := h_f_all (-1) 0 have h15 := h_f_all 0 1 have h16 := h_f_all 0 (-1) have h17 := h_f_all 1 1 have h18 := h_f_all (-1) (-1) -- Simplify the equations to find relationship between f(0) and f(f(0))"
        },
        {
            "title": "Technical Report",
            "content": "simp at h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 ring_nf at h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 -- Use linear arithmetic to solve for the desired result omega exact h_main theorem prop_f_2x (f : Z) (h_f_all : b, (2 * a) + 2 * (f b) = (f (a + b))) (h_f_f_x : x, (f x) = 2 * + 0) (x : Z) : (2 * x) = 2 * - 0 := by have h1 : (f (2 * x)) = 2 * (2 * x) + 0 := by have h1 := h_f_f_x (2 * x) -- Simplify the expression using the given condition h_f_f_x simp at h1 <;> linarith have h2 : (2 * x) + 2 * = (f (2 * x)) := by have h2 := h_f_all -- Simplify the expression using the given condition h_f_all ring_nf at h2 <;> linarith have h3 : (2 * x) + 2 * = 2 * (2 * x) + 0 := by have h3 : (2 * x) + 2 * = (f (2 * x)) := h2 rw [h3] have h4 : (f (2 * x)) = 2 * (2 * x) + 0 := h1 rw [h4] <;> ring <;> omega have h4 : (2 * x) = 2 * - 0 := by have h5 : (2 * x) + 2 * = 2 * (2 * x) + 0 := h3 -- Rearrange the equation to isolate f(2 * x) have h6 : (2 * x) = 2 * - 0 := by -- Solve for f(2 * x) using linear arithmetic linarith exact h6 apply h4 theorem cauchy_implies_linear_form (f : Z) (h_cauchy_like : y, (x + y) = + (cid:44) - 0) : : Z, x, = * + 0 := by have h_main : (c : Z), (x : Z), = * + 0 := by use 1 - 0 intro have h1 : : Z, = (f 1 - 0) * + 0 := by intro induction using Int.induction_on with hz => -- Base case: = 0 simp [h_cauchy_like] <;> ring_nf <;> omega hp ih => -- Inductive step: = + 1 have h2 := h_cauchy_like 1 have h3 := h_cauchy_like 0 (n + 1) have h4 := h_cauchy_like (n + 1) 0 22 172 173 174 175 176 178 179 180 181 182 184 185 186 187 188 190 191 192 193 194 196 197 198 199 200 202 203 204 205 206 208 209 210 211 212 214 215 216 217 218 220 221 222 223 224 226"
        },
        {
            "title": "Technical Report",
            "content": "have h5 := h_cauchy_like 1 0 have h6 := h_cauchy_like 0 1 simp at h2 h3 h4 h5 h6 simp [ih, add_mul, mul_add, mul_one, mul_neg, mul_zero, sub_eq_add_neg] at h2 h3 h4 h5 h6 (cid:44) <;> ring_nf at * <;> omega hn ih => -- Inductive step: = - (n + 1) have h2 := h_cauchy_like (-n - 1) 1 have h3 := h_cauchy_like 0 (-n - 1) have h4 := h_cauchy_like (-n - 1) 0 have h5 := h_cauchy_like 1 0 have h6 := h_cauchy_like 0 1 simp at h2 h3 h4 h5 h6 simp [ih, add_mul, mul_add, mul_one, mul_neg, mul_zero, sub_eq_add_neg] at h2 h3 h4 h5 h6 (cid:44) <;> ring_nf at * <;> omega have h2 := h1 have h3 := h1 1 have h4 := h1 0 simp at h2 h3 h4 <;> linarith exact h_main theorem step6_zero_function_is_solution (f : Z) (h_zero : x, = 0) : ( b, (cid:44) have h_main : b, (2 * a) + 2 * (f b) = (f (a + b)) := by (2 * a) + 2 * (f b) = (f (a + b))) := by intro have h1 : (2 * a) = 0 := by rw [h_zero] <;> simp [h_zero] have h2 : = 0 := by rw [h_zero] <;> simp [h_zero] have h3 : (a + b) = 0 := by rw [h_zero] <;> simp [h_zero] have h4 : (f (a + b)) = 0 := by rw [h_zero] <;> simp [h_zero] -- Simplify the LHS and RHS using the above equalities simp [h1, h2, h3, h4, h_zero] <;> linarith exact h_main theorem step7_linear_function_is_solution (f : Z) (c : Z) (h_lin : x, = 2 * (cid:44) have h_main : b, (2 * a) + 2 * (f b) = (f (a + b)) := by + c) : ( b, (2 * a) + 2 * (f b) = (f (a + b))) := by intro have h1 : (2 * a) = 2 * (2 * a) + := by rw [h_lin] <;> ring have h2 : = 2 * + := by rw [h_lin] <;> ring have h3 : (f (a + b)) = (2 * (a + b) + c) := by have h4 : (a + b) = 2 * (a + b) + := by 23 229 230 232 233 234 235 236 238 239 240 241 242 244 245 246 247 248 250 251 252 253 254 256 257 258 259 260 262 263 264 265 266 268 269 270 271 272 274 275 276 277 278 280 281"
        },
        {
            "title": "Technical Report",
            "content": "rw [h_lin] <;> ring rw [h4] <;> ring have h4 : (f (a + b)) = 2 * (2 * (a + b) + c) + := by rw [h3] rw [h_lin] <;> ring have h5 : (2 * a) + 2 * (f b) = (2 * (2 * a) + c) + 2 * (2 * + c) := by rw [h1, h2] <;> ring have h6 : (2 * a) + 2 * (f b) = 4 * + 4 * + 3 * := by linarith have h7 : (f (a + b)) = 4 * + 4 * + 3 * := by linarith linarith exact h_main theorem imo2019_p (f : Z) : ( : Z, (2 * a) + 2 * = (f (a + b))) solution_set := by constructor intro h_fe have h_ff : x, (f x) = 2 * + 0 := prop_f_f_x h_fe have h_f2 : x, (2 * x) = 2 * - 0 := prop_f_2x h_fe h_ff have h_add : y, (x + y) = + - 0 := prop_cauchy_like h_fe h_ff h_f2 rcases cauchy_implies_linear_form h_add with c, h_lin0 have h_split : ( x, = 0) ( x, = 2 * + 0) := linear_form_plus_f_f_x_implies_solutions h_lin0 h_ff cases h_split with inl h0 => exact Or.inl h0 inr h2 => exact Or.inr 0, h2 intro h_sol cases h_sol with inl h0 => exact step6_zero_function_is_solution inr h_exists => rcases h_exists with c, h_lin exact step7_linear_function_is_solution h_lin B.3 IMO 2011 P3 -- Solution to IMO 2011 P3 by DRP-IMO import Mathlib import Aesop set_option maxHeartbeats open BigOperators Real Nat Topology Rat 24 284 285 286 288 289 290 291 292 294 295 296 297 298 300 301 302 303 304 306 307 308 309 310 312 313 314 315 316 318 319 320 321 322 324 325 326 327 328 2 3 4 5 6"
        },
        {
            "title": "Technical Report",
            "content": "theorem imo2011_p3_lemma1_f_neg_le_self (f : R) (hf : y, (x + y) * + (cid:44) (f x)) : x, < 0 := by have h_main : (x : R), < 0 := by intro hx have h1 : ^ 2 - * 0 := by have h2 := hf (f - x) have h3 := hf (f x) (x - x) have h4 := hf 0 have h5 := hf 0 have h6 := hf have h7 := hf (-x) have h8 := hf (-x) have h9 := hf 0 0 have h10 := hf 1 have h11 := hf 1 have h12 := hf (-1) have h13 := hf (-1) have h14 := hf (f x) have h15 := hf (f x) have h16 := hf (-f x) have h17 := hf (-f x) have h18 := hf (x + x) have h19 := hf (x + x) have h20 := hf (-x) have h21 := hf (-x) have h22 := hf (x - x) have h23 := hf (x - x) have h24 := hf (f + x) have h25 := hf (f + x) have h26 := hf (2 * x) have h27 := hf (2 * x) have h28 := hf (-2 * x) have h29 := hf (-2 * x) -- Normalize the expressions to simplify the inequalities ring_nf at h2 h3 h4 h5 h6 h7 h8 h9 h10 h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 h21 h22 h23 h24 h25 h26 h27 h28 h29 (cid:44) -- Use linear arithmetic to prove the inequality nlinarith [sq_nonneg (f - x), sq_nonneg (f + x), sq_nonneg (f - 2 * x), (cid:44) sq_nonneg (f + 2 * x), sq_nonneg (2 * - x), sq_nonneg (2 * + x)] have h3 : := by by_contra have h4 : > := by linarith have h5 : ^ 2 - * < 0 := by nlinarith [hx, h4] nlinarith exact h3 exact h_main /--Let ( : mathbb{R} to mathbb{R} ) be function such that for all real numbers ( ) and ( ), the inequality ( f(x + y) leq cdot f( (cid:44) x) + f(f(x)) ) holds. Prove that for all real numbers ( ), the inequality ( f(x) leq f(f(x)) ) is true.-/ (cid:44) theorem imo2011_p3_st1 (f : R) (hf : y, (x + y) * + (f x)) : x, (f x) := by have h_main : (x : R), (f x) := by 25 10 12 13 14 15 16 18 19 20 21 22 24 25 26 27 28 30 31 32 33 34 36 37 38 39 40 42 43 44 45 46 48 49 50 51 52 54 55 56 57 58 60 61"
        },
        {
            "title": "Technical Report",
            "content": ":= hf 0 intro have 1 -- Simplify the inequality by substituting = 0 simp at 1 -- Use the simplified inequality to conclude the proof linarith exact h_main /--Consider function ( : mathbb{R} to mathbb{R} ) that satisfies the condition: for all real numbers ( ) and ( ), ( f(x + y) leq (cid:44) cdot f(x) + f(f(x)) ). Prove that for all real numbers ( ), ( f(x) leq 0 ).-/ theorem aux_f_nonpositive (f : R) (hf : y, (x + y) * + (f x)) : x, (cid:44) have h_main : x, 0 := by 0 := by intro by_contra have 1 have 2 have 3 have 4 have 5 have 6 have 7 have 8 have 9 have 10 have 11 have 12 have 13 have 14 have 15 have 16 have 17 have 18 have 19 have 20 have 21 have 22 have have have have have have have have have have have have have have have have 38 norm_num at * <;> (try nlinarith) <;> : > 0 := by linarith := hf (-x) := hf 0 (f x) := hf 0 := hf (-x) := hf (-x) (-x) := hf (f x) := hf (f x) (-f x) := hf (f x) 0 := hf 0 (-f x) := hf (2 * x) := hf (-2 * x) := hf (2 * x) (-x) := hf (2 * x) := hf (-2 * x) := hf (-2 * x) (-x) := hf (f x) := hf (f x) (-x) := hf (f x) := hf (-x) (f x) := hf (-f x) := hf (-x) (-f x) := hf (2 * x) (-f x) := hf (-2 * x) (-f x) := hf (2 * x) (f x) := hf (-2 * x) (f x) := hf (f x) (2 * x) := hf (f x) (-2 * x) := hf (x) := hf (-x) := hf 0 (2 * x) := hf 0 (-2 * x) := hf (2 * x) 0 := hf (-2 * x) 0 := hf (f x) (f x) := hf (-f x) (f x) := hf (f x) (-f x) := hf (-f x) (-f x) 29 30 31 32 23 24 25 33 34 35 28 26 37 36 64 66 67 68 69 70 72 73 74 75 76 78 79 80 81 82 84 85 86 87 88 90 91 92 93 94 96 97 98 99 100 102 103 104 105 106 108 109 110 111 112 114 115 116 117 118"
        },
        {
            "title": "Technical Report",
            "content": "121 122 123 124 125 127 128 129 130 131 133 134 135 136 137 139 140 141 142 143 145 146 147 148 149 151 152 153 154 155 157 158 159 160 161 163 164 165 166 167 169 170 171 (try linarith) <;> (try nlinarith [h , , 1 , h 18 , (cid:44) , 9 30 (try 19 , 20 , 31 32 33 34 , , 2 3 , 21 , 22 , , 4 , 23 , 35 , 5 , , 6 , , 7 , 24 , 25 , 36 37 38 , , 8 9 , 26 ]) <;> 27 , , , 11 , 2 10 28 , , 13 , 14 , , 16 , 17 , nlinarith [hf 0 0, hf 0, hf 0 x, hf (-x), hf (-x) x, hf (x + x) (-x), hf (-x) (x + x), hf (x - x) (x + x), hf (x + x) (x - x)]) <;> (cid:44) (try nlinarith [hf 0 0, hf 0, hf 0 x, hf (-x), hf (-x) x, hf (x + x) (-x), hf (-x) (x + x), hf (x - x) (x + x), hf (x + x) (x - x)]) <;> (cid:44) (try nlinarith [hf 0 0, hf 0, hf 0 x, hf (-x), hf (-x) x, hf (x + x) (-x), hf (-x) (x + (cid:44) x), hf (x - x) (x + x), hf (x + x) (x - x)]) <;> nlinarith exact h_main theorem lemma_final_implication (f : R) (hf : y, (x + y) * + (f x)) (h_f_at_0_is_0 : 0 = 0) (h_f_non_positive : x, 0) : 0, = 0 := by have h_main : (x : R), 0 = 0 := by intro hx have h1 : = 0 := by by_cases hx0 : = 0 -- If = 0, then f(0) = 0 by hypothesis simp [hx0, h_f_at_0_is_0] -- If = 0, then < 0 have hx1 : < 0 := by cases' lt_or_gt_of_ne hx0 with linarith exfalso linarith -- Use the given inequality with = and = -x to derive the desired result have h2 := hf have h3 := hf (-x) have h4 := hf (-x) have h5 := hf 0 have h6 := hf 0 have h7 := hf 0 (-x) have h8 := hf (-x) 0 -- Simplify the inequalities using the given conditions norm_num [h_f_at_0_is_0] at h2 h3 h4 h5 h6 h7 h8 nlinarith [h_f_non_positive x, h_f_non_positive (-x), h_f_non_positive (f x), h_f_non_positive (x + x), h_f_non_positive (x - x), h_f_non_positive 0] exact h1 exact h_main /--Let ( : mathbb{R} to mathbb{R} ) be function satisfying the inequality ( f(x + y) leq cdot f(x) + f(f(x)) ) for all real numbers ( (cid:44) ) and ( ). Suppose that ( f(0) = ) and there exists some ( x_0 ) such that ( (cid:44) f(x_0) = 0 ). Prove that ( geq 0 ), ( f(c) = ), ( f(y) leq ) for all real numbers ( ), and ( f(y) leq cdot + ) for all real numbers ( ).-/ (cid:44) theorem lemma_properties_if_f_has_zero (f : R) (hf : y, (x + y) * + (cid:44) (f x)) (h_f0_eq_c : 0 = c) (hx : 0 0 0 = ( y, c) ( y, * + c) := by , = 0) :"
        },
        {
            "title": "Technical Report",
            "content": "0 0 0 ) have h_c_ge_zero : 0 := by := hx obtain , hx 0 0 0 have h1 := hf ) (-x 0 have h2 := hf 0 (-x ) 0 0 have h3 := hf have h4 := hf 0 0 have h5 := hf (f 0 have h6 := hf 0 (f 0) have h7 := hf (-f 0 have h8 := hf 0 (-f 0) norm_num [h_f0_eq_c, hx <;> (try linarith) <;> (try nlinarith) <;> (try simp_all [h_f0_eq_c, hx 0 (try linarith) <;> (try nlinarith) <;> (try ) 0 0 ] at * ]) <;> + 0), sq_nonneg (x + 0), sq_nonneg (x - 0), - 0), 0 0 nlinarith [sq_nonneg (f 0 ), sq_nonneg (f 0), sq_nonneg (x sq_nonneg (f + 0), sq_nonneg (f 0 0 - 0)]) (cid:44) <;> (try nlinarith [sq_nonneg (f 0 ), sq_nonneg (f 0), sq_nonneg (x 0 (cid:44) sq_nonneg (f + 0), sq_nonneg (f 0 - 0)]) have h_f_c_eq_c : = := by ) := hx 0 (c - 0 , hx obtain 0 0 := hf have 0 1 := hf 0 (c) have 2 := hf (-c) have 3 := hf 0 have 0 4 := hf 0 0 have 5 (f := hf have 0 0 6 := hf 0 (f 0) have 7 := hf ) (-x have 0 0 8 ) have := hf 0 (-x 0 9 simp [h_f0_eq_c, hx ] at 0 1 <;> (try ring_nf at * <;> nlinarith) <;> (try { 3 ) 2 5 7 8 9 nlinarith [sq_nonneg (f 0 }) <;> ), sq_nonneg (c - (try { ), sq_nonneg (c + )] 0 0 0 ), sq_nonneg (c - ), sq_nonneg (c - ), sq_nonneg (c + ), sq_nonneg (c + nlinarith [sq_nonneg (f c)] (cid:44) }) <;> (try { nlinarith [sq_nonneg (f 0 c), sq_nonneg (f 0)] (cid:44) }) <;> (try { nlinarith [sq_nonneg (f 0 ), sq_nonneg (f ), sq_nonneg (f ), sq_nonneg (f 0 0 0 (cid:44) c), sq_nonneg (f 0), sq_nonneg (c - 0 )] 0 ), sq_nonneg (c - ), sq_nonneg (c + 28 173 174 175 176 177 179 180 181 182 183 185 186 187 188 189 191 192 193 194 195 197 198 199 200 201 203 204 205 206 207 209 210 211 212 213 215 216 217 218 219 221 222 223 224"
        },
        {
            "title": "Technical Report",
            "content": "}) <;> (try { nlinarith [sq_nonneg (f 0 ), sq_nonneg (c - ), sq_nonneg (c + ), sq_nonneg (f 0 c), sq_nonneg (f 0), sq_nonneg (c - ), sq_nonneg (f 0 0 - 0 c)] (cid:44) }) have h_f_le_c : y, := by intro have h1 := hf (-y) have h2 := hf (c - y) have h3 := hf 0 (y) have h4 := hf (-c) have h5 := hf 0 have h6 := hf 0 0 have h7 := hf 0 have h8 := hf 0 have h9 := hf (f y) have h10 := hf 0 (f 0) have h11 := hf (-f y) have h12 := hf 0 (-f 0) have h13 := hf (y - c) have h14 := hf 0 (y - c) have h15 := hf (y - c) have h16 := hf (y - c) 0 have h17 := hf (y - c) (f (y - c)) have h18 := hf (y - c) (-f (y - c)) norm_num [h_f0_eq_c, h_f_c_eq_c] at * <;> (try linarith) <;> (try nlinarith) <;> (try { nlinarith [sq_nonneg (f - c), sq_nonneg (f 0), sq_nonneg (c), sq_nonneg (y), sq_nonneg (f - c), sq_nonneg (f y)] (cid:44) }) <;> (try { nlinarith [sq_nonneg (f - c), sq_nonneg (f 0), sq_nonneg (c), sq_nonneg (y), sq_nonneg (f - c), sq_nonneg (f y), h_c_ge_zero] (cid:44) }) <;> (try { nlinarith [sq_nonneg (f - c), sq_nonneg (f 0), sq_nonneg (c), sq_nonneg (y), (cid:44) sq_nonneg (f - c), sq_nonneg (f y), h_c_ge_zero, sq_nonneg (f y)] }) <;> (try { nlinarith [sq_nonneg (f - c), sq_nonneg (f 0), sq_nonneg (c), sq_nonneg (y), sq_nonneg (f - c), sq_nonneg (f y), h_c_ge_zero, sq_nonneg (f (cid:44) - c)] }) have h_f_le_cy_add_c : y, * + := by intro have 1 := h_f_le_c 29 228 229 230 231 232 234 235 236 237 238 240 241 242 243 244 246 247 248 249 250 252 253 254 255 256 258 259 260 261 262 264 265 266 267 268 270 271 272 273 274 276 277 278"
        },
        {
            "title": "Technical Report",
            "content": ":= h_f_le_c 0 := hf 0 := hf 0 := hf (-y) := hf 0 (-y) := hf (c - y) := hf 0 (c) := hf (-c) := hf 0 := hf 0 0 := hf (f y) := hf 0 (f 0) := hf (-f y) := hf 0 (-f 0) := hf (y - c) := hf 0 (y - c) := hf (y - c) := hf (y - c) 0 := hf (y - c) (f (y - c)) := hf (y - c) (-f (y - c)) have 2 have 3 have 4 have 5 have 6 have 7 have 8 have 9 have 10 have 11 have 12 have 13 have 14 have 15 have 16 have 17 have 18 have 19 have 20 have 21 norm_num [h_f0_eq_c, h_f_c_eq_c] at * <;> (try linarith) <;> (try nlinarith) <;> (try { nlinarith [h_c_ge_zero, sq_nonneg (f - c), sq_nonneg (y), sq_nonneg (c - y), sq_nonneg (f + - * y)] (cid:44) }) <;> (try { nlinarith [h_c_ge_zero, sq_nonneg (f - c), sq_nonneg (y), sq_nonneg (c - y), sq_nonneg (f + - * y), sq_nonneg (f - * y)] (cid:44) }) <;> (try { nlinarith [h_c_ge_zero, sq_nonneg (f - c), sq_nonneg (y), sq_nonneg (c - y), sq_nonneg (f + - * y), sq_nonneg (f - * y), sq_nonneg (cid:44) (f - c)] }) <;> (try { cases' le_total 0 with hy hy <;> cases' le_total 0 (f - c) with <;> cases' le_total 0 (c - y) with h' h' <;> nlinarith [h_c_ge_zero, sq_nonneg (f - c), sq_nonneg (y), sq_nonneg (c - y), sq_nonneg (f + - * y), sq_nonneg (f - * y)] (cid:44) }) <;> nlinarith exact h_c_ge_zero, h_f_c_eq_c, h_f_le_c, h_f_le_cy_add_c theorem imo2011_p3 (f : R) (hf : y, (x + y) * + (f x)) : 0, (cid:44) = 0 := by -- Step 1: Prove that is non-positive everywhere. have h_nonpos : x, 0 := aux_f_nonpositive hf 30 281 282 283 284 286 287 288 289 290 292 293 294 295 296 298 299 300 301 302 304 305 306 307 308 310 311 312 313 314 316 317 318 319 320 322 323 324 325 326 328 329 330 331"
        },
        {
            "title": "Technical Report",
            "content": "335 336 337 338 339 341 342 343 344 345 347 348 349 350 351 353 354 355 356 357 359 360 361 362 363 365 366 367 368 369 371 372 373 374 375 377 378 379 380 381 383 384 1 2 3 such that f(x -- Step 2: Prove that there must exist some 0 0 -- We prove this by contradiction. Assume f(x) is never zero. have h_exists_zero : 0 by_contra h_no_zero -- The hypothesis from `by_contra` is `h_no_zero : ( 0 -- We use `push_neg` to convert it into more usable form. push_neg at h_no_zero -- Now, `h_no_zero : (x : R), = 0`. = 0 := by , 0 ) = 0. , = 0)`. -- This, combined with `h_nonpos`, implies f(x) < 0 for all x. have h_always_neg : x, < 0 := fun (cid:55) (h_nonpos x).lt_of_ne (h_no_zero x) -- From this, we can deduce f(0) = f(f(0)). have h_f0_eq_ff0 : 0 = (f 0) := by have h_ff0_neg : (f 0) < 0 := h_always_neg (f 0) have hle : (f 0) 0 := imo2011_p3_lemma1_f_neg_le_self hf (f 0) h_ff0_neg have hge : 0 (f 0) := imo2011_p3_st1 hf 0 linarith -- Now, we use the main inequality to derive contradiction. -- Let = f(0) and = -f(0). specialize hf (f 0) (-f 0) -- Define local lemma for `a + -a = 0` to ensure it's available. have add_neg_self_local : 0 + -f 0 = 0 := by ring -- Rewrite the inequality step-by-step to derive the contradiction. rw [add_neg_self_local] at hf rw [ h_f0_eq_ff0] at hf rw [ h_f0_eq_ff0] at hf -- The inequality is now 0 -(f 0)Â² + 0, which implies 0 -(f 0)Â². have h_contr : 0 -(f 0) ^ 2 := by linarith [hf] -- This is contradiction because f(0) < 0, so -(f 0)Â² < 0. have h_f0_neg : 0 < 0 := h_always_neg 0 have h_sq_pos : 0 < (f 0) ^ 2 := sq_pos_of_ne_zero (ne_of_lt h_f0_neg) linarith -- Step 3: Use the existence of zero to prove f(0) = 0. obtain , hx 0 have h_f0_eq_0 : 0 = 0 := by := h_exists_zero -- lemma gives properties of if it has zero. One is f(0) 0. have h_props := lemma_properties_if_f_has_zero hf rfl have h_f0_nonneg : 0 0 := h_props.1 -- Combining f(0) 0 with f(0) 0 (from h_nonpos) gives f(0) = 0. linarith [h_nonpos 0] , hx 0 0 -- Step 4: Now that we have f(x) 0 and f(0) = 0, apply the final lemma. exact lemma_final_implication hf h_f0_eq_0 h_nonpos B.4 IMO 2005 -- Solution to IMO 2005 P3 by DRP-IMO import Mathlib import Aesop"
        },
        {
            "title": "Technical Report",
            "content": "set_option maxHeartbeats 0 open BigOperators Real Nat Topology Rat theorem inequality_part1_nonnegative (x : R) (hx : > 0) (hy : > 0) (hz : > 0) (cid:44) (h : * * 1) : (x*x - 1/x + y*y - 1/y + z*z - 1/z) / (x*x + y*y + z*z) 0 := by have h_main : x*x + y*y + z*z - (1/x + 1/y + 1/z) 0 := by : 0 < * := by positivity : 0 < * := by positivity : 0 < * := by positivity : 0 < * * := by positivity : 0 < * * * := by positivity : 0 < * * * := by positivity : 0 < * * * := by positivity have 1 have 2 have 3 have 4 have 5 have 6 have 7 field_simp [hx.ne', hy.ne', hz.ne'] rw [le_div_iff -- Use nlinarith to prove the inequality nlinarith [sq_nonneg (x - y), sq_nonneg (x - z), sq_nonneg (y - z), (by positivity)] 0 sq_nonneg (x * - 1), sq_nonneg (x * - 1), sq_nonneg (y * - 1), mul_nonneg (sub_nonneg.mpr h) (sq_nonneg (x - y)), mul_nonneg (sub_nonneg.mpr h) (sq_nonneg (x - z)), mul_nonneg (sub_nonneg.mpr h) (sq_nonneg (y - z)), mul_nonneg (sub_nonneg.mpr h) (sq_nonneg (x * - * z)), mul_nonneg (sub_nonneg.mpr h) (sq_nonneg (x * - * z)), mul_nonneg (sub_nonneg.mpr h) (sq_nonneg (x * - * z))] have h_final : (x*x - 1/x + y*y - 1/y + z*z - 1/z) / (x*x + y*y + z*z) 0 := by : * + * + * - (1 / + 1 / + 1 / z) 0 := h_main : * + * + * > 0 := by positivity : (x * - 1 / + * - 1 / + * - 1 / z) / (x * + * + * z) : * - 1 / + * - 1 / + * - 1 / = (x * + * + * z) - (1 / + 1 / + 1 / z) := by : ((x * + * + * z) - (1 / + 1 / + 1 / z)) / (x * + * + * have 1 have 2 have 3 (cid:44) 0 := by have 4 (cid:44) ring rw [h ] 4 have 5 (cid:44) z) 0 := by apply div_nonneg linarith linarith exact 5 exact 3 exact h_final theorem inequality_part2_nonnegative (x : R) (hx : > 0) (hy : > 0) (hz : > 0) : ((x^5 - x^2)/(x^5 + y^2 + z^2) - (x*x - 1/x)/(x*x + y*y + z*z)) + ((y^5 - y^2)/(y^5 + z^2 + x^2) - (y*y - 1/y)/(y*y + z^2 + x*x)) + ((z^5 - z^2)/(z^5 + x^2 + y^2) - (z*z - 1/z)/(z*z + x*x + y*y)) 0 := by have h_main : ((x^5 - x^2)/(x^5 + y^2 + z^2) - (x*x - 1/x)/(x*x + y*y + z*z)) + ((y^5 - (cid:44) y^2)/(y^5 + z^2 + x^2) - (y*y - 1/y)/(y*y + z^2 + x*x)) + ((z ^5 - z^2)/(z^5 + x^2 + y^2) - (z*z - 1/z)/(z*z + x*x + y*y)) 0 := by have 1 have have : (x^5 - x^2)/(x^5 + y^2 + z^2) - (x*x - 1/x)/(x*x + y*y + z*z) 0 := by 10 11 : 0 < x^5 + y^2 + z^2 := by positivity : 0 < x*x + y*y + z*z := by positivity 32 5 6 7 8 10 11 12 13 14 16 17 18 19 20 22 23 24 25 26 28 29 30 31 32 34 35 36 37 38 40 41 42 43 44 46 47 48 49 50 52 53 54 55"
        },
        {
            "title": "Technical Report",
            "content": "12 13 14 15 : 0 < x^5 := by positivity : 0 < x^3 := by positivity : 0 < x^2 := by positivity : 0 < := by positivity have have have have field_simp rw [le_div_iff 0 ring_nf nlinarith [sq_nonneg (x^3 - x), sq_nonneg (x^2 - 1), sq_nonneg (x - 1), (by positivity), sub_nonneg] mul_nonneg hx.le (sq_nonneg (x^2 - 1)), mul_nonneg hx.le (sq_nonneg (x^3 - x)), mul_nonneg hx.le (sq_nonneg (x^2 - x)), mul_nonneg hx.le (sq_nonneg (x^3 - 1)), mul_nonneg (sq_nonneg (x - 1)) (sq_nonneg (x + 1)), mul_nonneg hx.le (sq_nonneg (cid:44) have (x^2 - 2 * + 1))] : (y^5 - y^2)/(y^5 + z^2 + x^2) - (y*y - 1/y)/(y*y + z^2 + x*x) 0 := by 20 21 22 : 0 < y^5 + z^2 + x^2 := by positivity : 0 < y*y + z^2 + x*x := by positivity : 0 < y^5 := by positivity : 0 < y^3 := by positivity : 0 < y^2 := by positivity : 0 < := by positivity have have have have have have field_simp rw [le_div_iff ring_nf nlinarith [sq_nonneg (y^3 - y), sq_nonneg (y^2 - 1), sq_nonneg (y - 1), (by positivity), sub_nonneg] 23 24 25 mul_nonneg hy.le (sq_nonneg (y^2 - 1)), mul_nonneg hy.le (sq_nonneg (y^3 - y)), mul_nonneg hy.le (sq_nonneg (y^2 - y)), mul_nonneg hy.le (sq_nonneg (y^3 - 1)), mul_nonneg (sq_nonneg (y - 1)) (sq_nonneg (y + 1)), mul_nonneg hy.le (sq_nonneg (cid:44) have 3 (y^2 - 2 * + 1))] : (z^5 - z^2)/(z^5 + x^2 + y^2) - (z*z - 1/z)/(z*z + x*x + y*y) 0 := by 30 31 32 : 0 < z^5 + x^2 + y^2 := by positivity : 0 < z*z + x*x + y*y := by positivity : 0 < z^5 := by positivity : 0 < z^3 := by positivity : 0 < z^2 := by positivity : 0 < := by positivity have have have have have have field_simp rw [le_div_iff ring_nf nlinarith [sq_nonneg (z^3 - z), sq_nonneg (z^2 - 1), sq_nonneg (z - 1), (by positivity), sub_nonneg] 33 34 35 0 mul_nonneg hz.le (sq_nonneg (z^2 - 1)), mul_nonneg hz.le (sq_nonneg (z^3 - z)), mul_nonneg hz.le (sq_nonneg (z^2 - z)), mul_nonneg hz.le (sq_nonneg (z^3 - 1)), mul_nonneg (sq_nonneg (z - 1)) (sq_nonneg (z + 1)), mul_nonneg hz.le (sq_nonneg (cid:44) (z^2 - 2 * + 1))] linarith exact h_main -- The main theorem theorem imo2005_p3 (x : R) (hx : > 0) (hy : > 0) (hz : > 0) (h_prod_ge_1 : * (cid:44) * 1) : (x ^ 5 - ^ 2) / (x ^ 5 + ^ 2 + ^ 2) + (y ^ 5 - ^ 2) / (y ^ 5 + ^ 2 + ^ 2) + (z ^ 5 - ^ 2) / (z ^ 5 + ^ 2 + ^ 2) 0 := by (cid:44) -- Define S_part1 (LHS of inequality_part1_nonnegative) let S_part1 := (x^2 - 1/x + y^2 - 1/y + z^2 - 1/z) / (x^2 + y^2 + z^2) -- Define S_part2 (LHS of inequality_part2_nonnegative) let S_part2 := ((x^5 - x^2)/(x^5 + y^2 + z^2) - (x^2 - 1/x)/(x^2 + y^2 + z^2)) + ((y^5 - y^2)/(y^5 + z^2 + x^2) - (y^2 - 1/y)/(y^2 + z^2 + x^2)) + ((z^5 - z^2)/(z^5 + x^2 + y^2) - (z^2 - 1/z)/(z^2 + x^2 + y^2)) 33 59 60 61 63 64 65 66 67 69 70 71 72 73 75 76 77 78 79 81 82 83 84 85 87 88 89 90 91 93 94 95 96 97 99 100 101 102 103 105 106 107 108 109"
        },
        {
            "title": "Technical Report",
            "content": "-- Prove S_part1 0 using inequality_part1_nonnegative have h_S_part1_nonneg : S_part1 0 := by apply inequality_part1_nonnegative <;> assumption -- Prove S_part2 0 using inequality_part2_nonnegative have h_S_part2_nonneg : S_part2 0 := by apply inequality_part2_nonnegative <;> assumption -- Prove that the original LHS is equal to S_part1 + S_part2 -- We'll prove it as separate fact (have) and then use it. have h_LHS_eq_sum : (x^5 - x^2)/(x^5 + y^2 + z^2) + (y^5 - y^2)/(y^5 + z^2 + x^2) + (z^5 - z^2)/(z^5 + x^ + y^2) = (cid:44) S_part2 + S_part1 := by -- Expand the definitions of S_part1 and S_part2 unfold S_part1 S_part2 -- Normalize denominators which are permutations of each other have h_denom_y : y^2 + z^2 + x^2 = x^2 + y^2 + z^2 := by ac_rfl have h_denom_z : z^2 + x^2 + y^2 = x^2 + y^2 + z^2 := by ac_rfl rw [h_denom_y, h_denom_z] -- The rest is pure algebraic identity, which `ring` can solve. -- It correctly rearranges terms like (a-b)+(c-d)+(e-f) + (b+d+f)/k = a+c+e -- after combining the fractions for S_part1 ring -- Rewrite the goal using the equality we just proved rw [h_LHS_eq_sum] -- The goal is now S_part2 + S_part1 0, which follows from the two parts being (cid:44) exact add_nonneg h_S_part2_nonneg h_S_part1_nonneg non-negative. B.5 IMO 2000 -- Solution to IMO 2000 P2 by DRP-IMO import Mathlib import Aesop set_option maxHeartbeats 0 open BigOperators Real Nat Topology Rat /--Given positive real numbers ( ), ( ), and ( ) such that ( times times = 1 ), prove that there exist positive real numbers ( (cid:44) ), ( ), and ( ) such that ( = frac{x}{y} ), ( = frac{y}{z} ), and ( (cid:44) = frac{z}{x} ).-/ theorem imo2000_p2_existence_of_xyz (a : R) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (cid:44) (habc : * * = 1) : : R, 0 < 0 < 0 < = x/y = y/z = z/x := by have h_main : (x : R), 0 < 0 < 0 < = x/y = y/z = z/x := (cid:44) by refine' a, 1, 1 / b, _, _, _, _, _, _ -- Prove that > 0 linarith -- Prove that 1 > 0 113 114 115 116 117 119 120 121 122 123 125 126 127 128 129 131 132 133 134 135 137 138 139 140 141 1 2 3 4 5 7 8 9 10 11 13 14 15 16 17 19 20 21 22 23 25 26 27 28 29 31 32 33 34 35 37 38 39 40 41 43 44 45 46 47 49 50 51 52 53 55 56 57 58 59 61 62 63 64 65 67 68 69 70"
        },
        {
            "title": "Technical Report",
            "content": "norm_num -- Prove that 1 / > 0 exact div_pos zero_lt_one hb -- Prove that = / 1 field_simp -- Prove that = 1 / (1 / b) field_simp <;> nlinarith -- Prove that = (1 / b) / have 1 have 2 have 3 : = 1 / (a * b) := by : * * = 1 := habc : = 1 / (a * b) := by have 4 field_simp [h 4 nlinarith : * = 0 := by positivity 2 ] at : (1 / : R) / = 1 / (a * b) := by exact 3 have 2 field_simp <;> ring <;> field_simp [ha.ne', hb.ne'] <;> nlinarith rw [h ] at * 1 <;> linarith exact h_main /--Consider three positive real numbers ( ), ( ), and ( ) such that ( > 0 ), ( > 0 ), and ( > 0 ). Prove that the product of th (cid:44) expressions ( (x - + z) ), ( (y - + x) ), and ( (z - + y) ) is less than or equal to the product ( cdot cdot ).-/ (cid:44) theorem schur_like_ineq (x : R) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) : (x - + z) * (y - + x) * (z - + y) * * := by have h_main : (x - + z) * (y - + x) * (z - + y) * * := by nlinarith [sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x), mul_nonneg hx.le hy.le, mul_nonneg hy.le hz.le, mul_nonneg hz.le hx.le, mul_nonneg (sq_nonneg (x - y)) (sq_nonneg (y - z)), mul_nonneg (sq_nonneg (y - z)) (sq_nonneg (z - x)), mul_nonneg (sq_nonneg (z - x)) (sq_nonneg (x - y)), mul_nonneg (sq_nonneg (x - + z)) (sq_nonneg (y - + x)), mul_nonneg (sq_nonneg (y - + x)) (sq_nonneg (z - + y)), mul_nonneg (sq_nonneg (z - + y)) (sq_nonneg (x - + z)), mul_nonneg (sq_nonneg (x + - z)) (sq_nonneg (y + - x)), mul_nonneg (sq_nonneg (y + - x)) (sq_nonneg (z + - y)), mul_nonneg (sq_nonneg (z + - y)) (sq_nonneg (x + - z))] exact h_main /--Consider positive real numbers ( a, b, c, x, y, ) such that ( cdot cdot = 1 ) and ( = frac{x}{y} ), ( = frac{y}{z} ), ( = (cid:44) frac{z}{x} ). Prove that the inequality ((a - 1 + frac{1}{b}) cdot (b - 1 + (cid:44) frac{1}{c}) cdot (c - 1 + frac{1}{a}) leq 1) is equivalent to th inequality ((x - + z) cdot (y - + x) cdot (z - + y) leq cdot cdot z).-/ theorem inequality_equivalence_under_parametrization (a y : R) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (habc : * * = 1) (hx : 0 < x) (hy : 0 < y) (hz : 0 < z) (hax : = / y) (hby : = / z) (hcz : = / x) : (a - 1 + 1 / b) * (b - 1 + 1 / c) * (c - 1 + 1 / a) 1 (x - + z) * (y - + x) * (z - + y) * * := by have h_main : (a - 1 + 1 / b) * (b - 1 + 1 / c) * (c - 1 + 1 / a) = ((x + - y) / y) * (cid:44) ((x + - z) / z) * ((y + - x) / x) := by"
        },
        {
            "title": "Technical Report",
            "content": "have 1 : - 1 + 1 / = (x + - y) / := by ] : = / := by linarith : = / := by linarith have 1 have 2 rw [h , 2 1 field_simp [ha.ne', hb.ne', hx.ne', hy.ne', hz.ne'] <;> ring_nf <;> field_simp [ha.ne', hb.ne', hx.ne', hy.ne', hz.ne'] <;> nlinarith have : - 1 + 1 / = (x + - z) / := by ] : = / := by linarith : = / := by linarith have 1 have 2 rw [h , 2 1 field_simp [ha.ne', hb.ne', hc.ne', hx.ne', hy.ne', hz.ne'] <;> ring_nf <;> field_simp [ha.ne', hb.ne', hc.ne', hx.ne', hy.ne', hz.ne'] <;> nlinarith have 3 : - 1 + 1 / = (y + - x) / := by ] : = / := by linarith : = / := by linarith have 1 have 2 , rw [h 2 1 field_simp [ha.ne', hb.ne', hc.ne', hx.ne', hy.ne', hz.ne'] <;> ring_nf <;> field_simp [ha.ne', hb.ne', hc.ne', hx.ne', hy.ne', hz.ne'] <;> nlinarith ] rw [h 1 <;> field_simp [ha.ne', hb.ne', hc.ne', hx.ne', hy.ne', hz.ne'] <;> ring_nf <;> field_simp [ha.ne', hb.ne', hc.ne', hx.ne', hy.ne', hz.ne'] <;> nlinarith , 3 , have h_equiv : ((x + - y) / y) * ((x + - z) / z) * ((y + - x) / x) 1 (x - + (cid:44) z) * (y - + x) * (z - + y) * * := by : 0 < * := by positivity : 0 < * := by positivity : 0 < * := by positivity : 0 < * * := by positivity have 1 have 2 have 3 have 4 constructor intro have 5 linarith (cid:44) have : ((x + - y) / y) * ((x + - z) / z) * ((y + - x) / x) 1 := by : (x - + z) * (y - + x) * (z - + y) * * := by field_simp at rw [div_le_one (by positivity)] at nlinarith [sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x), 5 5 mul_nonneg hx.le hy.le, mul_nonneg hy.le hz.le, mul_nonneg hz.le hx.le, mul_nonneg (sq_nonneg (x - y)) hz.le, mul_nonneg (sq_nonneg (y - z)) hx.le, mul_nonneg (sq_nonneg (z - x)) hy.le] linarith : (x - + z) * (y - + x) * (z - + y) * * := by linarith : ((x + - y) / y) * ((x + - z) / z) * ((y + - x) / x) 1 := by intro have 5 have 6 field_simp rw [div_le_one (by positivity)] nlinarith [sq_nonneg (x - y), sq_nonneg (y - z), sq_nonneg (z - x), mul_nonneg hx.le hy.le, mul_nonneg hy.le hz.le, mul_nonneg hz.le hx.le, mul_nonneg (sq_nonneg (x - y)) hz.le, mul_nonneg (sq_nonneg (y - z)) hx.le, mul_nonneg (sq_nonneg (z - x)) hy.le] linarith 73 74 75 76 77 79 80 81 82 83 85 86 87 88 89 91 92 93 94 95 97 98 99 100 101 103 104 105 106 107 109 110 111 112 113 115 116 117 118 119 121 122 123 124 125 127 128 129 130 131 133 134 135 136 137 139 140 141 142 143 145 146 147 148 149 151 152 153 154 155 157 158"
        },
        {
            "title": "Technical Report",
            "content": "have h_final : (a - 1 + 1 / b) * (b - 1 + 1 / c) * (c - 1 + 1 / a) 1 (x - + z) * (cid:44) (y - + x) * (z - + y) * * := by rw [h_main] rw [h_equiv] <;> simp_all <;> field_simp <;> ring_nf <;> nlinarith exact h_final theorem imo2000_p2 (a : R) (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) (habc : * * = 1) : (a - 1 + 1 / b) * (b - 1 + 1 / c) * (c - 1 + 1 / a) 1 := by -- 1. Parametrize using positive numbers obtain x, y, z, hx, hy, hz, ha_eq, hb_eq, hc_eq := imo2000_p2_existence_of_xyz ha hb hc habc -- 2. Use an equivalent lemma to transform the goal into the form involving have h_equiv := (inequality_equivalence_under_parametrization (a := a) (b := b) (c := c) (x := x) (y := y) (z := z) ha hb hc habc hx hy hz ha_eq hb_eq hc_eq) -- 3. The Schur-type inequality yields the conclusion on the right-hand side. have hxyz : (x - + z) * (y - + x) * (z - + y) * * := schur_like_ineq hx hy hz -- 4. Derive the original conclusion by reversing the equivalent proposition. exact h_equiv.mpr hxyz"
        }
    ],
    "affiliations": [
        "Tencent AI Lab"
    ]
}