{
    "paper_title": "EVOC2RUST: A Skeleton-guided Framework for Project-Level C-to-Rust Translation",
    "authors": [
        "Chaofan Wang",
        "Tingrui Yu",
        "Jie Wang",
        "Dong Chen",
        "Wenrui Zhang",
        "Yuling Shi",
        "Xiaodong Gu",
        "Beijun Shen"
    ],
    "sections": [
        {
            "title": "Abstract",
            "content": "Rust's compile-time safety guarantees make it ideal for safety-critical systems, creating demand for translating legacy C codebases to Rust. While various approaches have emerged for this task, they face inherent trade-offs: rule-based solutions face challenges in meeting code safety and idiomaticity requirements, while LLM-based solutions often fail to generate semantically equivalent Rust code, due to the heavy dependencies of modules across the entire codebase. Recent studies have revealed that both solutions are limited to small-scale programs. In this paper, we propose EvoC2Rust, an automated framework for converting entire C projects to equivalent Rust ones. EvoC2Rust employs a skeleton-guided translation strategy for project-level translation. The pipeline consists of three evolutionary stages: 1) it first decomposes the C project into functional modules, employs a feature-mapping-enhanced LLM to transform definitions and macros and generates type-checked function stubs, which form a compilable Rust skeleton; 2) it then incrementally translates the function, replacing the corresponding stub placeholder; 3) finally, it repairs compilation errors by integrating LLM and static analysis. Through evolutionary augmentation, EvoC2Rust combines the advantages of both rule-based and LLM-based solutions. Our evaluation on open-source benchmarks and six industrial projects demonstrates EvoC2Rust's superior performance in project-level C-to-Rust translation. On average, it achieves 17.24% and 14.32% improvements in syntax and semantic accuracy over the LLM-based approaches, along with a 96.79% higher code safety rate than the rule-based tools. At the module level, EvoC2Rust reaches 92.25% compilation and 89.53% test pass rates on industrial projects, even for complex codebases and long functions."
        },
        {
            "title": "Start",
            "content": "EVOC2RUST: Skeleton-guided Framework for Project-Level C-to-Rust Translation Chaofan Wang1, Tingrui Yu1, Jie Wang2, Dong Chen2, Wenrui Zhang2, Yuling Shi1, Xiaodong Gu1, Beijun Shen1 1Shanghai Jiao Tong University, Shanghai, China 2Huawei Technologies Co., Ltd {chaofwang, hzfsls, yuling.shi, bjshen, xiaodong.gu}@sjtu.edu.cn, {wangjie451, chendong108, zhangwenrui8}@huawei.com 5 2 0 A 6 ] . [ 1 5 9 2 4 0 . 8 0 5 2 : r AbstractRusts compile-time safety guarantees make it ideal for safety-critical systems, creating demand for translating legacy codebases to Rust. While various approaches have emerged for this task, they face inherent trade-offs: rule-based solutions face challenges in meeting code safety and idiomaticity requirements, while LLM-based solutions often fail to generate semantically equivalent Rust code, due to the heavy dependencies of modules across the entire codebase. Recent studies have revealed that both solutions are limited to small-scale programs. In this paper, we propose EVOC2RUST, an automated framework for converting entire projects to equivalent Rust ones. EVOC2RUST employs skeleton-guided translation strategy for project-level translation. The pipeline consists of three evolutionary stages: 1) it first decomposes the project into functional modules, employs feature-mapping-enhanced LLM to transform definitions and macros and generates type-checked function stubs, which form compilable Rust skeleton; 2) it then incrementally translates the function, replacing the corresponding stub placeholder; 3) finally, it repairs compilation errors by integrating LLM and static analysis. Through evolutionary augmentation, EVOC2RUST combines the advantages of both rule-based and LLM-based solutions. Our evaluation on open-source benchmarks and six industrial projects demonstrates EVOC2RUSTs superior performance in projectlevel C-to-Rust translation. On average, it achieves 17.24% and 14.32% improvements in syntax and semantic accuracy over the LLM-based approaches, along with 96.79% higher code safety rate than the rule-based tools. At the module level, EVOC2RUST reaches 92.25% compilation and 89.53% test pass rates on industrial projects, even for complex codebases and long functions. Index TermsC-to-Rust Conversion, Project-level Code Translation, Skeleton Guided, Feature Mapping, Large Language Models I. INTRODUCTION Translating legacy codebases to alternative Rust projects has become highly demanded task in software engineering [1], [2]. Memory safety vulnerabilities have been the most prevalent category of critical security defects in production systems, accounting for approximately 70% of highseverity vulnerabilities in industry reports from Google and Microsoft [3]. This recognition has driven paradigm shift towards compile-time safety guarantees through safe programming languages [4]. In response, modern system programming language, Rust, has emerged as leading alternative that offers memory safety by enforcing strict ownership and borrowing model at compile time [5]. Corresponding author. Recent work proposes rule-based tools [6][8], which convert code to Rust using primarily syntax-based transformations on terse intermediate representation of compilation. Such translation inherently generates non-idiomatic Rust code with low-level constructs, and also may contain semantic inaccuracies. [9]. Another line of work proposes LLM-based techniques [10][12] to utilize the code comprehension capability of code LLM. Due to the lack of parallel C-Rust training data and significant linguistic differences, these approaches often fail to produce semantically equivalent Rust code [13]. While automated code translation has been extensively investigated [14][16], the translation of C-to-Rust projects poses special challenges: Challenge-1: Substantial linguistic discrepancies for ensuring safety. and Rust differ fundamentally in their safety models. permits loose type checking, unrestricted pointer arithmetic, and manual memory management, whereas Rust enforces strict compile-time type safety, ownership-based memory guarantees, and disciplined reference usage through its borrowing rules. Existing rule-based translators often compromise safety by relying on raw pointers, unsafe blocks, or external functions [9]. While LLM-based approaches can generate code with improved safety, they often lack sufficient context understanding (e.g., variable scope or pointer lifetimes), potentially leading to logical errors or memory safety violations in the translated Rust code [17]. As result, neither rule-based nor LLM-based methods alone reliably meet Rusts stringent safety requirements. Challenge-2: Project-level code dependence. Translating entire projects poses greater challenges than translating isolated functions because the translated Rust project must preserve cross-module dependencies and consistent projectlevel structure [18], [19]. Code LLMs often struggle with such large-scale context, leading to broken references, inconsistent APIs, or incorrect module boundaries [9]. Consequently, existing approaches tend to perform well only on small-scale programs (e.g., 100 LOC) [10], [20], and fall short in realworld project settings. In this work, we propose EVOC2RUST, an automated framework for translating complete projects into equivalent Rust code. To address the linguistic gap and ensure safety (Challenges 1), EVOC2RUST enhances LLMs with safetypreserving mappings across seven core linguistic features, Fig. 1: Overview of EVOC2RUST. including types, macros, functions, operators, syntax structures, globals, and variadic arguments. To enable project-level translation (Challenge 2), EVOC2RUST introduces skeletonguided translation strategy that proceeds in three stages. First, it analyzes the input project to extract high-level metadata and decomposes the project into functional modules, generating compilable Rust skeleton with placeholder functions. Next, incrementally translates these stubs using LLMs augmented with the predefined feature mappings. Finally, it combines LLM with static analysis to iteratively repair compilation errors and refine the output. This evolutionary process effectively blends the strengths of rule-based and learningbased approaches, striking practical balance between correctness and safety in automated C-to-Rust migration. it We evaluate EVOC2RUST on an open-source benchmark called Vivo-Bench [21] and our own collection of six industrial projects called our C2R-Bench. Experimental results show that EVOC2RUST substantially outperforms baselines in C-to-Rust project translation. Compared with the LLM-based methods, EVOC2RUST demonstrates average improvements of 23.72% in compilation pass rate and 23.05% in line acceptance rate, while achieving marginally superior code safety. Compared with rule-based methods, EVOC2RUST yields an average 70.19% higher code safety rate, while achieving competitive compilation pass rate and line acceptance rate. At the module level, EVOC2RUST also reaches 92.25% compilation and 89.53% test pass rates on industrial projects. Our ablation studies further confirm the critical role of each component in EVOC2RUST, with safety-preserving mapping being cornerstone of the approach. The contributions of our work are summarized as follows: We propose novel approach for project-level C-to-Rust code translation, ensuring syntax correctness, semantic equivalence, and memory safety. We define safety-preserving mappings between core linguistic features of and Rust to enhance LLMs safety awareness. We evaluate EVOC2RUST on both open-source and industrial scenarios. Experimental results show that EVOC2RUST outperforms existing baselines, effectively translating projects to correct and safe Rust code. II. APPROACH Figure 1 illustrates the architecture of EVOC2RUST. It contains three key steps: (1) Skeleton construction decomposes the project into modules and constructs Rust project skeleton to assemble the Rust modules (Section II-A); (2) Incremental translation converts each module in the skeleton using safety-preserving linguistic mappings (Section II-B); and (3) Post-generation repair combines LLM-based refinement with static analysis for code optimization (Section II-C). A. Project Skeleton Construction straightforward idea of project-level code translation is to translate each function individually and assemble them into project. However, naively aggregating translated functions often leads to cascading interdependency errors. To address this, EVOC2RUST employs skeleton-guided translation strategy: It constructs compilable Rust project skeleton guided by project metadata and incrementally populates it with translated functions. For given project, EVOC2RUST parses function graphs, definitions structs, and signatures, call [22]. These elements are represented using Tree-sitter filenames, include as statements, macro definitions, type declarations, global identifiers, function signatures, and mapping table between identifier declarations to source files. This metadata is then project metadata, including type as integers prohibit can be between translated conversion). integer-to-pointer to perform type in Rust, between = (uint16_t)b implement corresponding operations in Rust. Since pointers support operations like addition, subtraction, the address-of operator, and subscript access, we implement their corresponding traits in Rust. arrays can decay into pointers, we allow arrays to be cast to pointer types using the cast() method. 2) Type Conversion. We implement CastIntoTyped including conversions trait conversions different and pointer types. We also allow pointer-to-integer conversion For (but translated as example, = b.cast::<u16>(), and pi = (int*)pu can pi = pu.cast::<Ptr<i32>>(). be Since Rust has type inference, we use cast() without explicit types to simulate Cs implicit conversions. During the repair phase, when fixing type errors caused by implicit conversions in C-to-Rust translation, the typeless cast() significantly improves the success rate of LLM optimization. 3) Macro/Function Mapping. For native macros like NULL and __LINE__, we provide corresponding implementations in Rust. For native functions (e.g., malloc, free, memcpy), we implement Rust functions with the same functionality using safe methods rather than directly calling their exact unsafe counterparts (e.g., using unsafe std::ptr::copy to implement memmove). With simple prompting, the LLM learns to follow the rule of translating native functions like name() into c_name!() macros. 4) Syntax Structure Mapping. Since Rusts for loop behaves differently from Cs for loop, direct translation by the LLM might introduce semantic errors. Additionally, Cs do while has no direct equivalent in Rust, and switch differs from Rusts match, which could lead to logical errors. We implement macros like c_for, c_do, and c_switch to replicate the exact syntax and logic of their counterparts, and use prompts to guide the LLM to translate the original syntax into these macros. 5) Operator Mapping. Similarly, we implement Rust verincluding ++, --, &, and sions of C-specific operators, sizeof(). In particular, sizeof() is mapped to two macros: c_sizeof!() and c_sizeofval!() in Rust. The increment and decrement operators are implemented as four functions (covering both prefix and postfix operations) for all integer and pointer types. We instruct the model to translate & not into Rusts reference operators & or &mut, but rather into c_ref!() macro that obtains pointer to the current value. 6) Global Variable Mapping. Using mutable global variables (static mut) in Rust is unsafe, so we define Global<T> type to safely handle global variables. This implementation uses Mutex to ensure thread safety, eliminating the need for unsafe code. We also create global!() macro for lazy initialization. 7) Variadic Argument Mapping. Variadic arguments are primarily used for logging and string formatting operations. Therefore, we define the VaList type as Slice containing references to multiple values implementing the Display trait, 3 Fig. 2: simple illustration of project-level C-to-Rust translation. systematically transformed into Rust equivalents via rulebased conversion. For instance, include dependencies are transformed to Rust use imports, and identifier declarations (e.g., are pub use {Rust_filename}::{identifier_name}) using the declaration-to-file table. into Rust pub use statements converted Based on the converted metadata, EVOC2RUST constructs Rust project skeleton that accurately preserves the structural organization of the original project (see Figure 2). The skeleton consists of Rust constructs automatically translated from definitions, macros, and function signatures. Each function is assigned type-checked dummy counterpart in Rust using its translated signature and the unimplemented!() macro. These placeholders serve as safe stand-ins, allowing the project to compile even before function bodies are translated. This skeleton-guided approach enables function bodies to be translated and inserted incrementally, ensuring contextual correctness and eliminating inter-function dependency errors. As result, the process supports seamless translation, compilation, and repair, even for large-scale projects with complex module interactions. B. Module Translation with Safety-preserving Mapping EVOC2RUST employs an LLM to automatically translate modules into Rust constructs, converting definitions, macros, and function signatures to assemble the skeleton, and then transforming function bodies to populate the placeholder dummy functions within the skeleton. To preserve safety and semantic alignment during translation, EVOC2RUST augments LLMs with comprehensive set of linguistic mappings across seven key categories: 1) Type Mapping. For each type, we establish corresponding Rust type, as summarized in Table I. For instance, we introduce cstr!() macro to ensure all strings obtained through this macro maintain the null-terminated property, preventing inconsistencies in encryption/compression algorithm results. Based on the operations available for each type, we TABLE I: Type Mappings between and Rust Type Array Pointer String Function Pointer File Variadic Argument Type Example Rust Type Rust Example int[N] int * char * (*func) FILE * va_list int a[3] = {1, 2, 3} int *a = &b char *c = \"Hello World!\" typedef int (*MyFunc) (const void *, const void *) FILE *f = fopen(name, \"rb\") va_start(arg_ptr, prev) Array<i32, N> Ptr<i32> Ptr<u8> FuncPtr FilePtr VaList let mut a: Array<i32,3> = arr![1,2,3] let mut a: Ptr<i32> = c_ref!(b) let mut c=cstr!(\"Hello World!\") pub type MyFunc=FuncPtr<fn(Ptr<Void>, Ptr<Void>) -> i32> let mut f=c_fopen!(name, cstr(\"rb\")) (..., prev: ..., arg_ptr: VaList) along with va_format!() macro for string formatting. We also use variadic arguments to implement Rust equivalents of functions like snprintf. These feature mappings are formulated as transformation patterns, each specifying the motivation, consequence, solution, and corresponding code examples, as illustrated in Table II. By distilling expertise from senior practitioners, these patterns encode tacit professional knowledge into explicitly reusable C-to-Rust migration rules. To guide the LLM toward accurate and idiomatic translations, we retrieve the most relevant patterns based on the input code. Specifically, we encode both the input snippet and pattern examples into dense vectors, compute cosine similarity, and select the top-K closest patterns. The retrieved patterns are then injected into the LLM prompt to constrain its output, using the following structured template."
        },
        {
            "title": "Prompt Template for Translating C Modules to Rust",
            "content": "Translate the [macro/definition/function] to Rust. Patterns: {retrieved transformation patterns} Demonstrations: {paired C-to-Rust examples} Source Code: {input source code} C. Post-Generation Repair Finally, EVOC2RUST refines the translated Rust code through compilation-driven, cascading repair process that combines LLM-based repair with syntactic rules. For each code snippet, it generates multiple repair candidates based on compiler feedback, retaining only those that reduce error counts until no further improvements are possible. While rule-based methods optimally handle trivial, welldefined errors and LLMs excel at complex issues, we oblow-level syntax errors (e.g., bracket serve that persistent mismatches) critically impair both repair techniques, especially deterministic rule-based correction. To address this, EVOC2RUST implements three-step repair chain: 1) Bracket Repair: An LLM analyzes compiler output and error messages to correct mismatched brackets and similar syntax issues in the Rust code. The prompt includes instructions, exemplar fault-correction pairs, the erroneous Rust snippet, and its corresponding compilation errors. TABLE II: An Example of Transformation Patterns Rule Name:"
        },
        {
            "title": "Variadic Argument Mapping",
            "content": "Motivation: Rust does not support C-style variadic functions (e.g., va_list). Consequence: Current LLMs cannot directly translate Cs variadic features. Solution: Define VaList type and va_format! macro: pub type VaList<a> = &a [&a dyn Display]; macro_rules! va_format { ... } Example: Code: int snprintf(char *str, size_t size, const char *format, ...) { ... } Rust Code: pub fn snprintf(mut buf: Ptr<u8>, size: usize, format: Ptr<u8>, va: VaList) -> i32 { let mut fmt = format.to_string(); let mut tmp = va_format!(fmt, va); let mut length = tmp.as_bytes().len() as i32; if length > (size - 1) as i32 { length = (size - 1) as i32; } for in 0..length { buf[i] = tmp.as_bytes()[i as usize]; } buf[length as usize] = 0; return length; }"
        },
        {
            "title": "Prompt Template for Bracket Repair",
            "content": "Fix the compilation bugs in the following Rust code with the provided compilation error messages, possibly because of mismatched parentheses. Only fix lines that have unmatched parentheses bugs, dont modify any other code. Demonstrations: {example pairs of incorrect/correct Rust code} Rust Source Code: {input source code} Compilation Error Messages: {input error messages} 2) Rule-Based Repair: We define set of syntax repair rules as regex-based transformation patterns to tackle common syntax-level issues, such as derive macro adjustments, elimination of redundant cast() operations, and resolution of array access patterns like s[s.i] (cause simultaneous mutable and immutable borrow problems). 4 3) LLM Refinement: The final step further employs the LLM to address residual semantic discrepancies and intricate compilation-level issues, such as type inconsistencies, incorrect idiomatic usage, or structural inconsistencies. The prompt contains guidelines, exemplar fault-correction pairs, the erroneous Rust translation, and its compilation information. LLM-direct: baseline approach employing zero-shot LLM prompting for direct C-to-Rust translation. To mitigate its inherent limitations in maintaining project-wide consistency and dependency resolution, we implement this approach within our project skeleton construction framework."
        },
        {
            "title": "Prompt Template for LLM Refinement",
            "content": "Fix the compilation bugs in the following Rust code according to the compilation information: Instruction: {refinement guidelines} Demonstrations: {example pairs of incorrect/correct Rust code} Rust Source Code: {input source code} Compilation Information: {input compilation information} III. EXPERIMENTAL SETUP We conduct experiments to evaluate the effectiveness of EVOC2RUST, aiming to answer the following research questions. RQ1: How effectively does EVOC2RUST translate entire projects to equivalent safe Rust projects? RQ2: What is the module-level conversion accuracy achieved by EVOC2RUST? RQ3: To what extent do key components of EVOC2RUST contribute to its overall performance? A. Comparison Methods We compare EVOC2RUST against three categories of C-to-Rust translation methods: rule-based (C2Rust), LLMbased (Self-Repair and Tymcrat), and hybrid techniques (C2SaferRust). Additionally, we also include direct LLMbased generation without the repository context as baseline. Specifically, we evaluate EVOC2RUST against the following baseline methods: C2Rust [6]: rule-based C-to-Rust translator through AST analysis and manually-defined transformation rules. C2SaferRust [23]: hybrid approach that enhances the C2Rust framework by integrating LLM-based postprocessing, employing test-driven optimization to improve the idiomaticity and safety of generated Rust code. We adopt the original works default configuration, using 5 optimization iterations. Self-Repair [24]: multi-agent self-repair framework for project-scale C-to-Rust translation that performs file-level translation with iterative compilation-testing feedback for automatic error correction. We use the default setting of 3 self-repair rounds per task for both compilerand testdriven repairs. Tymcrat [25]: project-level translation approach that improves translation quality through type migration, generating candidate Rust signatures and iteratively resolving type errors using compiler feedback. We adopt the default configuration of producing 4 candidate signatures per function. All baseline methods are implemented using their officially released code. We replace their original backbone models with DeepSeek-V3 [26] to ensure fair comparison. B. Evaluation Strategy and Metrics We evaluate the performance of C-to-Rust translation at both the project level and module level. Project-level Evaluation. We compare our method against baselines in project-level translation. To simulate real-world scenarios where ground truth implementations are unavailable, we exclude all reference implementations from benchmarks. Our evaluation follows an incremental compilation validation strategy: We begin by constructing skeleton with placeholder Rust modules, then progressively replace these placeholders with translated code while verifying compilation. Any failing modules revert to their original placeholders. We measure the performance of project-level translation using three metrics: Incremental Compilation Pass Rate (ICompRate): The percentage of successfully compiled modules when incrementally integrated into the project skeleton, measuring syntax correctness as defined in [18]. Line Acceptance Rate (AccRate) [27]: Given the difficulty of compiling the entire project, we evaluate how closely the translated code matches the manually corrected version. Precision quantifies unmodified lines in the initial translation, while Recall assesses their retention in the final validated solution. Code Safe Rate (SafeRate) [28]: The percentage of memory-safe statements in the generated Rust code. Module-level Evaluation. We further assess our methods module conversion accuracy through fill-in-the-blank validation strategy: for each module (e.g., Func_C) with known Rust equivalent (e.g., Func_R) in the test set, we remove Func_R from the Rust reference implementation, generate Func_R from Func_C using the translation method, integrate the output into the partial Rust project, and verify correctness through compilation and test cases."
        },
        {
            "title": "We measure the syntactic and semantic correctness of",
            "content": "module-level translation using two metrics: Fill-in Compilation Pass Rate (FCompRate): The percentage of translated modules that successfully compile when replacing the counterparts in the Rust reference implementation. Test Pass Rate (TestRate) [24]: The percentage of translated modules that pass all corresponding test cases when replacing the counterparts in the Rust reference implementation. 5 TABLE III: Statistics of the Datasets Dataset Vivo-Bench C2R-Bench Projects 19 projects avl bzp md5 sha256 rapidlz cmptlz Total Files 38 9 18 2 2 7 25 63 LOC 80917 836 2258 324 280 748 3724 8170 Functions Macros (Functions) 200 29 92 8 9 28 122 29 29 82 20 11 38 166 346 Definitions 95 9 14 1 2 10 27 63 Test Cases 113 121 17 37 12 12 23 222 TABLE IV: Performance in Translating Entire Projects to Rust Across Various Methods Dataset Method ICompRate AccRate Precision Recall SafeRate Vivo-Bench C2R-Bench C2Rust [6] C2SaferRust [23] Self-Repair [24] Tymcrat [25] LLM-direct EVOC2RUST (Ours) C2Rust [6] C2SaferRust [23] Self-Repair [24] Tymcrat [25] LLM-direct EVOC2RUST (Ours) 100 100 84.21 87.35 35.49 100 99.28 99.28 49.21 72.02 56.67 93.84 100 100 92.08 92.11 55.15 99. 98.99 97.47 72.35 77.82 55.65 97.56 100 100 89.24 92.44 51.95 99.86 98.98 97.68 13.79 74.94 52.70 97.34 0 60.00 87.60 97.88 77.09 98.00 1.83 48.24 83.92 95.92 82.43 97.41 C. Datasets We evaluate EVOC2RUST on both the Vivo-Bench [21] open-source dataset and our C2R-Bench collection of six industrial projects. Vivo-Bench, sourced from the 2025 Vivo C-to-Rust Innovation Competition, contains 19 algorithmic projects featuring 200 functions, 95 definitions, and 29 nonfunction macros. These projects consist of 1-3 files, ranging from 33 to 630 LOC per file. Two Rust developers, assisted by LLMs, produced verified translations by correcting errors and adding tests to achieve complete function coverage, yielding 113 top-level test cases. For industrial scenario evaluation, we established C2RBench, benchmark comprising six production-level projects from Huaweis software ecosystem. The selected projects are exclusively single-threaded user-space applications relying solely on standard libraries. These projects feature complex multi-file architectures, with source file sizes ranging from 280 to 3,724 LOC and significant cross-file dependencies. Three senior developers created the reference implementations through LLM-assisted translation, subsequently verifying the Rust outputs by executing 222 top-level test cases."
        },
        {
            "title": "Each project",
            "content": "in both Vivo-Bench [21] and C2R-Bench includes four key components: source code, test cases, Rust test cases. The translations, and corresponding Rust detailed statistics are provided in Table III. programming languages (including and Rust) for enhanced cross-language understanding. For code translation, we configure the model with greedy decoding and max_tokens = 4096. For code analysis, we employ Tree-sitter v0.22.3 [22] for parsing projects and rustc [29] as the Rust compiler. We employ BGE-M3 [30] to generate code embeddings and retrieve the top-10 most similar transformation patterns through cosine similarity. To balance efficiency and effectiveness, we limit repair iterations to 5 rounds for bracket repair and 3 rounds for LLM refinement. To measure line acceptance rates, we establish manuallyverified reference implementations for all evaluated methods. Following rigorous validation protocol, three authors execute complete translations of each projects source code and test suites using the target methods. The generated Rust code undergoes compilation and testing, followed by iterative manual correction assisted by Claude Sonnet 4 [31] until all test cases pass. Finally, three additional engineers perform code review to verify the semantic accuracy of these reference implementations. All experiments are conducted on Linux server running Ubuntu 23.10, equipped with two NVIDIA GeForce RTX 4090 GPUs and CUDA version 12.4. IV. RESULTS AND ANALYSIS A. Main Results (RQ1) D. Implementation Details We implement EVOC2RUST using DeepSeek-V3 [26] as the foundation model, leveraging its extensive pre-training on The main results of EVOC2RUST are presented in Table IV. EVOC2RUST outperforms all baselines on both datasets, achieving the highest combined scores for three metrics. 6 Compared to rule-based and hybrid baselines, EVOC2RUST exhibits significant advantages in generating safe Rust code. While C2Rust and C2SaferRust achieve near-perfect compilation pass rates (e.g., 100% on Vivo-Bench), they tend to produce unsafe code: C2Rust scores merely 0% and 1.83% in code safety on the two datasets, and C2SaferRust, despite LLM-enhanced optimization, reaches only 60% and 48.24%. This confirms that purely syntactic translation, even when augmented with LLM post-processing, cannot reliably satisfy Rusts safety requirements. Our method proactively prevents unsafe code generation by leveraging LLM-based translation augmented by safety-guaranteed feature mappings. Among LLM-based approaches, EVOC2RUST demonstrates consistent superiority across all evaluation metrics. On VivoBench, it surpasses all baselines by 12.65% to 64.51% in compilation success and 7.57% to 46.30% in line acceptance, while maintaining high code safety of 98%. The performance gap widens on C2R-Bench, exhibiting the strong capability of EVOC2RUST in complex projects. It achieves 93.84% compilation success (21.82%44.63% higher than baselines) and over 97% line acceptance. These advantages come from our skeleton-guided, feature mapping-augmented translation approach. Specifically, compared with Self-Repair, EVOC2RUST improves compilation success by 44.63% and line acceptance by 54.38% on C2R-Bench. Self-Repairs file-level processing strategy, which frequently exceeds DeepSeek-V3s 4,096token output limit, introduces critical limitation by causing code truncation and incomplete program generation. EVOC2RUST also achieves 21.82% higher compilation success rate on the more challenging C2R-Bench dataset compared to Tymcrat. While Tymcrat employs diverse signature generation and context enrichment to reduce initial errors, its lack of expert-derived structured translation guidance ultimately constrains its effectiveness in complex scenarios. The LLM-direct approach performs the poorest, with an average compilation success rate of just 46.08% and inferior line acceptance metrics (55.40% precision and 52.33% recall), attributable to inherent C-Rust linguistic divergences and transformer context window constraints. Answer to RQ1. EVOC2RUST consistently outperforms all baseline methods in translating entire projects to Rust, demonstrating the highest combined scores for compilation success, line acceptance, and code safety across both opensource and industrial benchmarks. B. Module-level Translation (RQ2) We further conduct focused evaluation of module-level code translation accuracy, core technical component of EVOC2RUST. The assessment employs both Vivo-Bench and C2R-Bench with two foundation models, DeepSeek-V3 and Qwen3-32B [32], representing different model scales and architectural paradigms. TABLE V: Effectiveness of EVOC2RUST in Module-Level Cto-Rust Translation Dataset Project FCompRate TestRate DeepSeek-V3 Vivo-Bench C2R-Bench Vivo-Bench C2R-Bench 19 projects avl bzp md5 sha256 rapidlz cmptlz Subtotal Qwen3-32B 19 projects avl bzp md5 sha256 rapidlz cmptlz Subtotal 99.07 100.00 95.21 96.55 100.00 96.05 86.98 92. 87.65 97.01 89.36 89.66 90.91 78.95 70.79 80.63 98.50 92.53 92.55 86.21 100.00 92.11 86.35 89.53 84.57 82.09 88.83 89.21 90.91 77.63 68.89 77.91 (a) Vivo-Bench (b) C2R-Bench Fig. 3: Test pass rate distribution across varying code lengths. As illustrated in Table V, EVOC2RUST demonstrates remarkable performance at module granularity. With DeepSeekV3, it achieves 100% compilation and 99.07% test pass rate on Vivo-Bench, and maintains robust performance (92.25% compilation, 89.53% test pass) on C2R-Bench. Even with the smaller Qwen3-32B model (20x fewer parameters), EVOC2RUST still delivers acceptable results (80.63% compilation, 77.91% test pass), demonstrating model-agnostic effectiveness. It is interesting to observe the close alignment between test pass rates and compilation success rates, where successfully 7 TABLE VI: Ablation Results on Key Components of EVOC2RUST Variant Project Level Module Level ICompRate SafeRate FCompRate TestRate EVOC2RUST (Ours) -w/o Repair#3 -w/o Repair#2-3 -w/o Repair#1-3 -w/o Feature Mapping and Repair#193.84 89.57 ( -4.27) 75.24 (-18.60) 74.29 (-19.55) 56.67 (-37.17) 97.41 97.40 ( -0.01) 97.46 ( +0.05) 97.21 ( -0.20) 82.43 (-14.98) 92.25 87.23 ( -5.02) 82.21 (-10.04) 81.06 (-11.19) 33.00 (-59.25) 89.53 85.37 ( -4.16) 80.92 ( -8.61) 79.91 ( -9.62) 30.27 (-59.26) * Repair#1: bracket repair; Repair#2: rule-based repair; Repair#3: LLM refinement. compiled Rust modules usually pass tests. This consistency results from our methods dual mechanisms: feature mapping prevents semantic errors, while compiler-guided repair maintains logically sound error correction. Our evaluation reveals two critical factors affecting translation quality: project complexity and function length. Complex projects with intricate control flows and data dependencies consistently challenge LLMs comprehension capabilities, as demonstrated by our analysis of six industrial projects in C2RBench. For instance, the cmptlz project, featuring complex macros and dependencies, achieves test pass rates of 86.35% and 70.79% across models, while the simpler sha256 project achieves optimal 100% results. Furthermore, function length exhibits strong negative correlation with translation success, as shown in Figure 3. For DeepSeek-V3, test pass rates decrease from 97.46% to 81.13% as the function length grows, while Qwen3-32B shows more pronounced decline from 88.68% to 41.96%. Notably, despite this length-dependent degradation, EVOC2RUST maintains 94.02% average pass rate with DeepSeek-V3, confirming its robustness even for lengthy functions. Answer to RQ2. Our method achieves robust module-level translation (92.25%-100% compilation success, 77.91%- 99.07% test pass) across model scales, confirming its effectiveness in addressing both code complexity and function length challenges. C. Ablation Study (RQ3) the"
        },
        {
            "title": "To assess",
            "content": "contribution of each component in EVOC2RUST and validate our design choices, we perform an ablation study by incrementally removing key components of our method: bracket repair, rule-based repair, LLM refinement, and feature mapping. We evaluate each variant on the C2RBench dataset using DeepSeek-V3 as the base model. As shown in Table VI, each component of EVOC2RUST plays crucial role in the overall effectiveness of the method. Among them, the feature mapping mechanism is the most impactful component. By ablating this mechanism, both ICompRate and FCompRate drop sharply from 74.29% to 56.67% and from 81.06% to 33%, respectively. The impact on semantic correctness is also substantial, with TestRate decreasing from 79.91% to 30.27%. This result highlights its importance in bridging and Rust constructs through predefined trans8 formation patterns that map idioms to safe Rust equivalents where direct counterparts are absent. The cascading repair chain also facilitates C-to-Rust translation. Removing all three repairs (-w/o repair#1-3) results in substantial performance degradation, with ICompRate decreasing by 19.55%, FCompRate by 11.19%, and TestRate by 9.62%. Within this chain, rule-based repair (repair#2) contributes the most, improving compilation pass rate by 9.68% and test pass rate by 4.45% on average. LLM refinement (repair#3) provides an additional 4.27% syntactic and 8.98% semantic gains without compromising code safety. Notably, code safety remains stable around 97% across most ablation variants, attributable to the feature mapping mechanisms encapsulation of low-level operations within verified safe constructs. This design ensures consistent unsafe code proportions, with only minor safety score variations ( 1%). However, unguided generation (without both mapping and repairs) causes safety to drop sharply to 82.43%, demonstrating the essentiality of our mechanism. Answer to RQ3. Each component in EVOC2RUST contributes significantly to its overall performance. The feature mapping mechanism provides safe and reliable basis by bridging C-to-Rust semantic gaps, while the cascading repair chain fixes remaining errors to maximize syntactic and semantic correctness. D. Case Study We use the rb_tree_rotate function, core component of red-black tree, as case study to demonstrate EVOC2RUSTs effectiveness (Figure 4). Its intricate pointer manipulation is representative of low-level code that is challenging to translate safely and correctly, and it highlights common failure modes in other methods. As shown in Figure 4, baseline methods struggle. LLMdirect fails due to project-level interface mismatch, passing raw pointer (*mut) where mutable reference (&mut) is expected. This reveals lack of project-wide context awareness, and its reliance on raw pointers necessitates unsafe blocks, undermining the goal of memory safety. Self-Repair, while attempting more idiomatic and safe translation with Box<T>, introduces function-level ownership error (use of moved value), demonstrating the difficulty of manually refactoring C-style memory management into safe Rust idioms without systematic framework. Fig. 4: case study on translating the rb_tree_rotate function. In contrast, EVOC2RUST generates correct and robust translation. Its success is rooted in our feature mapping that uses unified Ptr<T> smart pointer to maintain C-like pointer semantics with project-wide type consistency. This, combined with flexible .cast() method for type conversions, resolves both the interface mismatch and the ownership issues that cause the other methods to fail. By systematically mapping low-level operations to safe abstraction layer, EVOC2RUST produces correct and entirely safe translation where other approaches cannot. V. DISCUSSION tions, operators, syntax structures, globals, and variadic arguments. Such dynamically-retrieved feature mappings allow the LLM to perform precise one-to-one translations, effectively constraining hallucination. 3) Cascading Post-Generation Repairs. Following LLM translation, EVOC2RUST implements compilation-driven cascading repair mechanism that: (1) iteratively refines the Rust code through guaranteed compilation checks, (2) synergizes LLM-based semantic understanding with rule-based syntactic corrections, and (3) provides an extensible architecture for integrating future repair techniques. A. Why is EVOC2RUST Effective? B. Limitations and Threats to Validity EVOC2RUST synthesizes LLM capabilities, multi-agent collaboration, knowledge augmentation techniques, static program analysis, and rule-based transformations into unified framework for automated C-to-Rust project translation. The effectiveness of EVOC2RUST comes from three key aspects: 1) Skeleton-guided Translation. EVOC2RUST utilizes program analysis to decompose large project into modular components, generates compilable Rust skeleton for module assembly, and performs incremental function-level translation by inserting converted Rust code into the skeletal structure. This skeleton-guided translation strategy facilitates incremental translation that is aligned with the original project structure, compilation, and repair within the LLMs context window limits, while enabling concurrent module translation without being constrained by inter-module dependencies. 2) Feature Mapping. EVOC2RUST bridges the C-to-Rust semantic gap through guided LLM translation with safetyguaranteed feature mappings, covering types, macros, func-"
        },
        {
            "title": "We have identified the following limitations and potential",
            "content": "threats to the validity of our method: Internal Validity. The main internal threat comes from correctness verification, which currently relies on predefined test cases. Adopting more robust validation techniques like fuzzing [33] and self-debugging [34], [35] could enhance test coverage and uncover subtle semantic errors. For line acceptance rate measurement, we use Claude-generated outputs verified by human experts as ground truth. While this manual validation ensures correctness beyond automated testing, it may not scale to larger datasets. Future work should investigate semi-automated verification to balance accuracy and efficiency. External Validity. Two primary threats affect external validity: 1) Generalizability: Although our translation pipeline is designed to support multiple language pairs, the current implementation specifically targets C-to-Rust translation to facilitate whole-project migration research. Additionally, our 9 current evaluation only involves DeepSeek-V3 and Qwen332B models due to resource constraints. However, this choice does not affect the validity of our frameworks evaluation, as the primary focus of this work is the framework architecture rather than model comparison. We explicitly note that expanding the evaluation to include additional models represents important future work. 2) Dataset characteristics: Our evaluation uses both the open-source Vivo-Bench and industrial C2R-Bench; however, these datasets are currently limited to single-threaded, user-level projects with ISO standard library dependencies. Future work should address more complex scenarios involving multithreading, third-party libraries, and kernel-level code. VI. RELATED WORK A. C-to-Rust Translation Existing approaches for automatic C-to-Rust translation fall into three broad categories: rule-based, LLM-based, and hybrid techniques. Rule-based Translation: These approaches perform program transformation by analyzing program syntax and manually designing conversion rules, such as AST-based transformations. The open-source transpiler C2Rust [6] exemplifies this method by leveraging Clangs AST to generate semantically equivalent Rust code. However, it produces nonidiomatic Rust code that utilizes unsafe in almost all function signatures. Recognizing these limitations, subsequent research has developed targeted improvements: Emre et al. [20], [36] incorporated rustc compiler feedback for pointer safety, while Zhang et al. [7] applied static ownership analysis to pointer operations. Ling et al. [28] focused on API safety through source-to-source transformations with pattern matching, and Hong et al. [8], [37][39] addressed specific constructs like Lock APIs, Output Parameters, Unions and I/O API through custom analyses. Furthermore, Han et al. [40] tackled control flow discrepancies via C-style syntactic sugar implementations in Rust, while Fromherz et al. [41] presented formal translation of subset of to safe Rust. However, such approaches require human experts to invest significant time and manual efforts in crafting rules, and the translated target program often suffers from poor readability and safety issues. LLM-based Translation: In recent years, LLMs have shown promise in code translation due to their ability to generate idiomatic code without manually crafted expert rules. Eniser et al. [10] proposed FLOURINE, which employs fuzz testing to verify semantic equivalence between translated Rust and original code without requiring existing test cases; Yang et al. [11] adapted MSWasm-based testing for multi-language (including C) to Rust translation; Nitin et al. [12] integrated static specifications, I/O tests, and natural language descriptions to augment LLM translation; and Farrukh et al. [42] created multi-agent framework with iterative error correction. However, current LLM-based approaches still exhibit lower translation accuracy compared to rule-based methods, largely attributable to the absence of large-scale parallel C-Rust training corpora required to overcome the fundamental semantic disparities between the two languages [13]. Hybrid Techniques: Recent work has demonstrated the complementary benefits of combining rule-based and LLMbased approaches for C-to-Rust translation. Systems like C2SaferRust [23] employ LLM-based post-processing to iteratively refine C2Rusts output, enhancing both safety guarantees and code idiomaticity while preserving functional equivalence through automated validation testing. Building upon these advances, EVOC2RUST introduces novel hybrid framework that synergistically integrates rulebased and LLM-based approaches in two stages. During translation, it utilizes linguistic feature mappings (i.e., transformation rules) to direct the LLM in resolving C-to-Rust it employs semantic discrepancies. At compilation-driven cascading repair mechanism, combining LLM capabilities with static analysis to optimize the quality of generated Rust code. Our method achieves an effective practical balance between translation accuracy and safety guarantees for automated C-to-Rust migration. the repair stage, B. Project-level Code Translation with LLMs While most existing methods focus on small-scale code translation, recent work has begun exploring project-level translation using LLMs. These approaches first decompose the project into dependency-based translation units through program analysis, then translate and reassemble them into runnable Rust projects. Shiraishi et al. [18] pioneered project-level translation, applying project metadata to maintain cross-unit consistency. However, they only focus on compilation success, without ensuring functional equivalence. Syzygy [19] and RustMap [43] translate both functions and associated test cases, and leverage compilation and test feedback to repair the generated Rust code. However, they require complete dependency contexts for the target functions, which cannot always be automatically extracted, sometimes necessitating manual supplementation (e.g., ASK Me mechanism in RustMap). Additionally, their testing and analysis framework limits scalability to code with complicated features and data structures (e.g, complex object structures and circular references) in industry settings. Khatry et al. [24] and Ou et al. [13] developed new benchmarks enabling C/C++ to Rust transpilation evaluation at repository scale, accompanied by techniques such as SelfRepair. However, their approaches depend on annotated Rust function interfaces that are seldom available in industry scenarios. To address this limitation, Hong et al. [25] proposed Tymcrat, novel type inference-based approach for automated function signature translation. Differing from existing approaches that translate modules sequentially following dependency order and require full project contexts, EVOC2RUST introduces skeleton-guided strategy, which first constructs compilable Rust skeleton and then executes incremental function translation. Beyond facilitating concurrent translation, this strategy improves trans10 lation correctness by isolating the LLM from cross-module dependencies and thus reducing translation complexity. VII. CONCLUSION We present EVOC2RUST, novel LLM-powered framework for automated translation of entire projects to Rust. EVOC2RUST employs feature mapping-enhanced LLM to execute skeleton-guided code translation, followed by hybrid error correction that integrates LLM capabilities and static analysis. Across open-source and industrial benchmarks, EVOC2RUST shows consistently superior performance in syntax accuracy, semantic equivalence, and memory safety. Despite recent progress, C-to-Rust translation remains an open challenge, particularly for complex scenarios involving multithreading, third-party libraries, and kernel-level code across diverse domains. To advance the field, we identify two key research directions: (1) developing novel refinement techniques that harness evolving LLM capabilities (e.g., fuzzing [33] and self-debugging [34], [35]), and (2) exploring language models as autonomous agents [44] with multi-step reasoning and reflecting capacities for complex translation tasks. These directions represent promising avenues for future work."
        },
        {
            "title": "REFERENCES",
            "content": "[1] R. Li, B. Wang, T. Li, P. Saxena, and A. Kundu, Translating to Rust: Lessons from user study, in 32nd Annual Network and Distributed System Security Symposium, NDSS 2025, San Diego, California, USA, February 24-28, 2025. The Internet Society, 2025. [2] DARPA-SN-24-89, Translating All TO Rust (TRACTOR), https: //www.darpa.mil/program/translating-all-c-to-rust, 2024. for memory urgent Lord, [3] B. The products, need in https://www.cisa.gov/news-events/news/ safety software urgent-need-memory-safety-software-products, 2023. [4] Office of the National Cyber Director, Back to the building blocks: path toward secure and measurable software, https://www.whitehouse. gov/wp-content/uploads/2024/02/Final-ONCD-Technical-Report.pdf, 2024. [5] A. Williams, Improving memory management, performance with Rust: Why Rust is becoming the programming language of choice for many high-level developers, Commun. ACM, vol. 67, no. 9, pp. 89, 2024. to Rust. [Online]. Available: https: [6] C2Rust: Migrate code //github.com/immunant/c2rust [7] H. Zhang, C. David, Y. Yu, and M. Wang, Ownership guided to Rust translation, in Computer Aided Verification - 35th International Conference, CAV 2023, Paris, France, July 17-22, 2023, Proceedings, Part III, ser. Lecture Notes in Computer Science, vol. 13966. Springer, 2023, pp. 459482. [8] J. Hong and S. Ryu, Concrat: An automatic C-to-Rust lock API translator for concurrent programs, in 45th IEEE/ACM International Conference on Software Engineering, ICSE 2023, Melbourne, Australia, May 14-20, 2023. IEEE, 2023, pp. 716728. [9] R. Pan, A. R. Ibrahimzada, R. Krishna, D. Sankar, L. P. Wassi, M. Merler, B. Sobolev, R. Pavuluri, S. Sinha, and R. Jabbarvand, Lost in translation: study of bugs introduced by large language models while translating code, in Proceedings of the 46th IEEE/ACM International Conference on Software Engineering, ICSE 2024, Lisbon, Portugal, April 14-20, 2024. ACM, 2024, pp. 82:182:13. [10] H. F. Eniser, H. Zhang, C. David, M. Wang, M. Christakis, B. Paulsen, J. Dodds, and D. Kroening, Towards translating real-world code with LLMs: study of translating to Rust, CoRR, vol. abs/2405.11514, 2024. [11] A. Z. H. Yang, Y. Takashima, B. Paulsen, J. Dodds, and D. Kroening, VERT: verified equivalent Rust transpilation with few-shot learning, CoRR, vol. abs/2404.18852, 2024. [12] V. Nitin and B. Ray, SpecTra: Enhancing the code translation ability of language models by generating multi-modal specifications, CoRR, vol. abs/2405.18574, 2024. 11 [13] G. Ou, M. Liu, Y. Chen, X. Peng, and Z. Zheng, Repository-level code translation benchmark targeting Rust, CoRR, vol. abs/2411.13990, 2024. [14] B. Rozi`ere, M. Lachaux, L. Chanussot, and G. Lample, Unsupervised translation of programming languages, in Advances in Neural Information Processing Systems 33: Annual Conference on Neural Information Processing Systems 2020, NeurIPS 2020, December 6-12, 2020, virtual, 2020. [15] M. Zhu, K. Suresh, and C. K. Reddy, Multilingual code snippets training for program translation, in Thirty-Sixth AAAI Conference on Artificial Intelligence. AAAI Press, 2022, pp. 11 78311 790. [16] Z. Yang, F. Liu, Z. Yu, J. W. Keung, J. Li, S. Liu, Y. Hong, X. Ma, Z. Jin, and G. Li, Exploring and unleashing the power of large language models in automated code translation, Proc. ACM Softw. Eng., vol. 1, no. FSE, pp. 15851608, 2024. [17] H. Sim, H. Cho, Y. Go, Z. Fu, A. Shokri, and B. Ravindran, Large Language Model-powered agent for to Rust code translation, CoRR, vol. abs/2505.15858, 2025. [18] M. Shiraishi and T. Shinagawa, Context-aware code segmentation translation using large language models, CoRR, vol. for C-to-Rust abs/2409.10506, 2024. [19] M. Shetty, N. Jain, A. Godbole, S. A. Seshia, and K. Sen, Syzygy: Dual code-test to (safe) Rust translation using LLMs and dynamic analysis, CoRR, vol. abs/2412.14234, 2024. [20] M. Emre, R. Schroeder, K. Dewey, and B. Hardekopf, Translating to safer Rust, Proc. ACM Program. Lang., vol. 5, no. OOPSLA, pp. 129, 2021. [21] Vivo, Benchmark for Vivo C-to-Rust innovation competition, https://atomgit.com/vivoblueos2/vivo blueos contest2 c2rust/tree/ master/01-BlueOS2 Translation/Input/01-Primary, 2025. [22] Tree-sitter: An incremental parsing system for programming tools, https://tree-sitter.github.io/tree-sitter, 2025. [23] V. Nitin, R. Krishna, L. L. do Valle, and B. Ray, C2SaferRust: Transforming projects into safer Rust with neurosymbolic techniques, CoRR, vol. abs/2501.14257, 2025. [24] A. Khatry, R. Zhang, J. Pan, Z. Wang, Q. Chen, G. Durrett, and I. Dillig, CRUST-Bench: comprehensive benchmark for C-to-safeRust transpilation, CoRR, vol. abs/2504.15254, 2025. [25] J. Hong and S. Ryu, Type-migrating C-to-Rust translation using large language model, Empir. Softw. Eng., vol. 30, no. 1, p. 3, 2025. [26] DeepSeek-AI, DeepSeek-V3 model, https://api.deepseek.com, 2025. [27] A. Ziegler, E. Kalliamvakou, X. A. Li, A. Rice, D. Rifkin, S. Simister, G. Sittampalam, and E. Aftandilian, Productivity assessment of neural code completion, in MAPS@PLDI 2022: 6th ACM SIGPLAN International Symposium on Machine Programming, San Diego, CA, USA, 13 June 2022. ACM, 2022, pp. 2129. [28] M. Ling, Y. Yu, H. Wu, Y. Wang, J. R. Cordy, and A. E. Hassan, In Rust we trust - transpiler from unsafe to safer Rust, in 44th IEEE/ACM International Conference on Software Engineering: Companion Proceedings, ICSE Companion 2022, Pittsburgh, PA, USA, May 22-24, 2022. ACM/IEEE, 2022, pp. 354355. [29] The Rust Compiler (rustc), https://doc.rust-lang.org/rustc/, 2025. [30] B. A. of Artificial Intelligence, M3-Embedding: Multi-linguality, multifunctionality, multi-granularity text embeddings through self-knowledge distillation, https://huggingface.co/BAAI/bge-m3, 2025. [31] Anthropic, Claude 4 Technical Report, https://www.anthropic.com/ index/claude-4, 2024. [32] Alibaba, Qwen3-32B Model, https://huggingface.co/Qwen/ Qwen3-32B, 2025. [33] I. B. Kadron, Y. Noller, R. Padhye, T. Bultan, C. S. Pasareanu, and K. Sen, Fuzzing, symbolic execution, and expert guidance for better testing, IEEE Softw., vol. 41, no. 1, pp. 98104, 2024. [34] S. Kang, B. Chen, S. Yoo, and J. Lou, Explainable automated debugging via large language model-driven scientific debugging, Empir. Softw. Eng., vol. 30, no. 2, p. 45, 2025. [35] Y. Shi, S. Wang, C. Wan, and X. Gu, From code to correctness: Closing the last mile of code generation with hierarchical debugging, arXiv preprint arXiv:2410.01215, 2024. [36] M. Emre, P. Boyland, A. Parekh, R. Schroeder, K. Dewey, and B. Hardekopf, Aliasing limits on translating to safe Rust, Proc. ACM Program. Lang., vol. 7, no. OOPSLA1, pp. 551579, 2023. [37] J. Hong and S. Ryu, Dont write, but return: Replacing output parameters with algebraic data types in C-to-Rust translation, Proc. ACM Program. Lang., vol. 8, no. PLDI, pp. 716740, 2024. [38] , To tag, or not to tag: Translating Cs unions to Rusts tagged unions, in Proceedings of the 39th IEEE/ACM International Conference on Automated Software Engineering, ASE 2024, Sacramento, CA, USA, October 27 - November 1, 2024. ACM, 2024, pp. 4052. [39] , Forcrat: Automatic I/O API translation from to Rust via origin and capability analysis, CoRR, vol. abs/2506.01427, 2025. [40] X. Han, B. Hua, Y. Wang, and Z. Zhang, RUSTY: effective to Rust conversion via unstructured control specialization, in 22nd IEEE International Conference on Software Quality, Reliability, and Security, QRS 2022, 2022, pp. 760761. [41] A. Fromherz and J. Protzenko, Compiling to safe Rust, formalized, CoRR, vol. abs/2412.15042, 2024. [42] M. Farrukh, S. Shah, B. Coskun, and M. Polychronakis, SafeTrans: LLM-assisted transpilation from to Rust, CoRR, vol. abs/2505.10708, 2025. [43] X. Cai, J. Liu, X. Huang, Y. Yu, H. Wu, C. Li, B. Wang, I. N. B. Yusuf, and L. Jiang, RustMap: Towards project-scale C-to-Rust migration via program analysis and LLM, CoRR, vol. abs/2503.17741, 2025. [44] X. Wang, Y. Chen, L. Yuan, Y. Zhang, Y. Li, H. Peng, and H. Ji, Executable code actions elicit better LLM agents, in Forty-first International Conference on Machine Learning, ICML 2024, Vienna, Austria, July 21-27, 2024. OpenReview.net, 2024."
        }
    ],
    "affiliations": [
        "Huawei Technologies Co., Ltd",
        "Shanghai Jiao Tong University, Shanghai, China"
    ]
}