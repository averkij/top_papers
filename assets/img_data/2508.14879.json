[
    {
        "header": "Abstract",
        "images": [
            {
                "img": "https://arxiv.org/html/2508.14879/sec/render.jpg",
                "caption": "(a)",
                "position": 159
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/render.jpg",
                "caption": "(a)",
                "position": 162
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/obj5.jpg",
                "caption": "(b)",
                "position": 168
            }
        ]
    },
    {
        "header": "1Introduction",
        "images": [
            {
                "img": "https://arxiv.org/html/2508.14879/x1.png",
                "caption": "Figure 2:Overview of MeshCoder. The input point cloud is first encoded into shape tokens via a shape tokenizer. These tokens are then fed into a large language model (LLM), which autoregressively generates executable code representing part-based 3D structures. The decoded code specifies object‚Äôs name, part identities and names, enabling interpretable and modular reconstruction.",
                "position": 231
            }
        ]
    },
    {
        "header": "2Related Work",
        "images": []
    },
    {
        "header": "3Methodology",
        "images": [
            {
                "img": "https://arxiv.org/html/2508.14879/sec/part3.jpg",
                "caption": "Figure 3:Visualization of basic geometric shape types and their corresponding code. For each shape category, the code shown corresponds to the first example.",
                "position": 291
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/shape_tokenizer.jpg",
                "caption": "Figure 4:Architecture of the shape tokenizer. We first project the point cloud into the triplane and obtain triplane features.\nThe triplane features are patchified and reshaped into a 1D sequence, and fed into transformer blocks to obtain triplane tokens.\nFinally, we use a set of learnable tokens to aggregate information from triplane tokens via cross-attention.",
                "position": 325
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/code_concat.jpg",
                "caption": "Figure 5:Pipeline of object-level code dataset construction using the part-to-code inference model. For each part point cloudùííi{\\bm{q}}_{i}, the code inference module independently predicts its corresponding codeùíöi{\\bm{y}}_{i}. All part codesùíöi{\\bm{y}}_{i}are then concatenated to form the complete object code.\nWe also add meaningful semantic information to the object code following the template shown in the figure.\nThe complete code of the example chair is shown in Figure2.",
                "position": 377
            }
        ]
    },
    {
        "header": "4Experiment",
        "images": [
            {
                "img": "https://arxiv.org/html/2508.14879/sec/result.jpg",
                "caption": "Figure 6:Qualitative comparison of reconstruction performance between MeshCoder and baselines.\nMeshCoder can accurately reconstruct objects with intricate parts and complex structures.",
                "position": 520
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/edit-change.jpg",
                "caption": "Figure 7:Parameter modification in the code conveniently to alter the geometric shape. Left: Change tabletop from square to circular. Right: Make the bathtub shallower.",
                "position": 533
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/edit.jpg",
                "caption": "Figure 8:Mesh resolution adjustment by modifying the resolution parameters in the code.\nThe figure depicts results with progressively increasing resolution from left to right.",
                "position": 536
            },
            {
                "img": "https://arxiv.org/html/2508.14879/",
                "caption": "Figure 9:The pipeline of conducting experiments on shape understanding.",
                "position": 544
            }
        ]
    },
    {
        "header": "5Limitations",
        "images": []
    },
    {
        "header": "6Conclusion",
        "images": []
    },
    {
        "header": "References",
        "images": [
            {
                "img": "https://arxiv.org/html/2508.14879/sec/trans_and_bridge.jpg",
                "caption": "Figure 10:A schematic illustration of the principles of Translation and Bridge Loop. In the Translation module, the wireframe of the resulting mesh is shown as a cross-sectional circle is translated along a yellow trajectory. In the Bridge Loop module, the wireframe of the mesh is constructed by connecting the vertices of two 2D shapes.",
                "position": 1052
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/unique.jpg",
                "caption": "Figure 11:The Fill Grid type, Spoon type and Fork type in basic shape code library",
                "position": 1066
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/primitive_example.jpg",
                "caption": "Figure 12:Examples of Primitive and complete code. And the code corresponds to the first two objects shown in the figure.",
                "position": 1079
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/translation_example.jpg",
                "caption": "Figure 13:Examples of Translation and complete code. And the code corresponds to the first two objects shown in the figure.",
                "position": 1083
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/bool_example.jpg",
                "caption": "Figure 14:Examples of Boolean and complete code. And the code corresponds to the first two objects shown in the figure.",
                "position": 1087
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/bridge_example.jpg",
                "caption": "Figure 15:Examples of Bridge Loop and complete code. And the code corresponds to the first two objects shown in the figure.",
                "position": 1091
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/array_example.jpg",
                "caption": "Figure 16:Examples of Array and complete code. And the code corresponds to the first two objects shown in the figure.",
                "position": 1095
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/full_code_concat.jpg",
                "caption": "Figure 17:A complete code example of converting part codes into a full object program.",
                "position": 1118
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/architecture.jpg",
                "caption": "Figure 18:Detailed configuration of the shape tokenizer.",
                "position": 1128
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/dish.png",
                "caption": "Figure 19:Experiments on how GPT-4o can understand shape through given dishwasher code.",
                "position": 2053
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/offf.jpg",
                "caption": "Figure 20:Experiments on how GPT-4o can understand shape through given office chair code.",
                "position": 2057
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/celll.jpg",
                "caption": "Figure 21:Experiments on how GPT-4o can understand shape through given cell shelf code.",
                "position": 2061
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/code_primitive.jpg",
                "caption": "Figure 22:Implementation of the function for creating primitives",
                "position": 2066
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/code_curve.jpg",
                "caption": "Figure 23:Implementation of the function for creating curves",
                "position": 2071
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/sofa_example.jpg",
                "caption": "Figure 24:An example of sofa. The input is a point cloud of a sofa, and the figure shows the code inferred by the object-to-code inference model, as well as the resulting mesh generated by executing the inferred code.",
                "position": 2075
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/bathtub_example.jpg",
                "caption": "Figure 25:An example of bathtub. The input is a point cloud of a bathtub, and the figure shows the code inferred by the object-to-code inference model, as well as the resulting mesh generated by executing the inferred code.",
                "position": 2079
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/toilet_example.jpg",
                "caption": "Figure 26:An example of toilet. The input is a point cloud of a toilet, and the figure shows the code inferred by the object-to-code inference model, as well as the resulting mesh generated by executing the inferred code.",
                "position": 2083
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/edit-chair.jpg",
                "caption": "Figure 27:By modifying thescaleparameters of thelegandarmparts, we adjust their thickness. The highlighted sections indicate the changes made.",
                "position": 2087
            },
            {
                "img": "https://arxiv.org/html/2508.14879/sec/edit-plate.jpg",
                "caption": "Figure 28:By modifying theresolutionparameter, we change its resolution. The highlighted sections indicate the changes made.",
                "position": 2092
            }
        ]
    },
    {
        "header": "Appendix AAppendix of MeshCoder: LLM-Powered Structured Mesh Code Generation from Point Clouds",
        "images": []
    }
]