[
    {
        "header": "Abstract",
        "images": [
            {
                "img": "https://arxiv.org/html/2506.14606/extracted/6549414/assets/gg-logo.png",
                "caption": "",
                "position": 83
            }
        ]
    },
    {
        "header": "1Introduction",
        "images": []
    },
    {
        "header": "2Background and Related Work",
        "images": []
    },
    {
        "header": "3GuaranteedGuess",
        "images": [
            {
                "img": "https://arxiv.org/html/2506.14606/x1.png",
                "caption": "Figure 1:GGSystem Overview. A two-stage transpilation pipeline from x86 to ARM/RISC-V. Left: Data is sourced from Stackv2 and AnghaBench, deduplicated, and compiled using both GCC and Clang to generate paired assembly (x86↔↔\\leftrightarrow↔ARM) from C/C++. Right: A specialized LLM (GGGuesser), trained with tokenizer extension and inferenced with RoPE extrapolation, predicts target ISA code. Predictions are evaluated via unit tests and symbolic analysis on benchmarks like HumanEval and BringupBench. The system emphasizes functional correctness, architectural alignment, and near-native performance.",
                "position": 219
            }
        ]
    },
    {
        "header": "4Experiments and Evaluation",
        "images": [
            {
                "img": "https://arxiv.org/html/2506.14606/x2.png",
                "caption": "Figure 2:Token counts by ISA and benchmark; BringUpBench is substantially longer than HumanEval.",
                "position": 521
            }
        ]
    },
    {
        "header": "5Results and Analysis",
        "images": [
            {
                "img": "https://arxiv.org/html/2506.14606/x3.png",
                "caption": "Figure 3:Comparison of execution time, energy consumption, and memory usage across Rosetta,GG, and native binaries.",
                "position": 687
            },
            {
                "img": "https://arxiv.org/html/2506.14606/x4.png",
                "caption": "(a)Opcode shift distribution in ARMv8",
                "position": 704
            },
            {
                "img": "https://arxiv.org/html/2506.14606/x4.png",
                "caption": "(a)Opcode shift distribution in ARMv8",
                "position": 707
            },
            {
                "img": "https://arxiv.org/html/2506.14606/x5.png",
                "caption": "(b)CHRF similarity scores",
                "position": 712
            }
        ]
    },
    {
        "header": "6Conclusion",
        "images": []
    },
    {
        "header": "7Limitations",
        "images": []
    },
    {
        "header": "References",
        "images": [
            {
                "img": "https://arxiv.org/html/2506.14606/x6.png",
                "caption": "Figure 5:Impact of scaling and quantization on Qwen2.5-Coder 1.5B variant evaluated using thecode coveragemetric on HumanEval with -O0 compiler optimization.",
                "position": 1619
            }
        ]
    },
    {
        "header": "Appendix AAppendix",
        "images": []
    }
]