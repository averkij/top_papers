[
    {
        "header": "Abstract",
        "images": []
    },
    {
        "header": "1Introduction",
        "images": [
            {
                "img": "https://arxiv.org/html/2601.19362/x1.png",
                "caption": "Figure 1:Collective communications introduces per-layer synchronization barriers in FSDP.",
                "position": 110
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x2.png",
                "caption": "Figure 2:On-demand communications relaxes the synchronization barriers to minibatch end.",
                "position": 113
            }
        ]
    },
    {
        "header": "2Background",
        "images": [
            {
                "img": "https://arxiv.org/html/2601.19362/x3.png",
                "caption": "Figure 3:all-gatherandreduce-scatter",
                "position": 130
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x4.png",
                "caption": "Figure 4:Communication pattern of FSDP within a microbatch. The left panel shows forward communication (all-gatherparameters), and the right shows backward communication (all-gatherparameters &reduce-scattergradients). AG =all-gather; RS =reduce-scatter.",
                "position": 139
            }
        ]
    },
    {
        "header": "3On-demand Communications",
        "images": [
            {
                "img": "https://arxiv.org/html/2601.19362/x5.png",
                "caption": "Figure 5:gatherandscatter-accumulate.",
                "position": 172
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x6.png",
                "caption": "Figure 6:The architecture of FSDP with ODC, in which FSDP can be seen as a decentralized parameter server, with server part and worker part highlighted in this figure.",
                "position": 178
            }
        ]
    },
    {
        "header": "4Simplified Load Balancing with ODC",
        "images": []
    },
    {
        "header": "5Evaluations",
        "images": [
            {
                "img": "https://arxiv.org/html/2601.19362/x7.png",
                "caption": "Figure 7:Sequence length distributions of evaluation datasets.",
                "position": 230
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x8.png",
                "caption": "Figure 8:Samples per second on SFT datasets (LongAlign and SWE-Smith) across different model scales and minibatch sizes.\nODC consistently improves throughput over Collectives in both un-packed (LocalSort) and packed (LB-Micro, LB-Mini) scenarios.",
                "position": 243
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x9.png",
                "caption": "Figure 9:Samples per second on RL with AIME prompts. In addition to the methods in Section5.1, we also evaluate the default load balancing algorithm in verl, denoted asNative. LB-Micro is substantially faster than Native, underscoring its effectiveness as a strong baseline.",
                "position": 247
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x10.png",
                "caption": "Figure 10:Acceleration ratio of ODC compared to collective with LB-Micro in parametric study.",
                "position": 297
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x11.png",
                "caption": "Figure 11:Benchmarking communication primitives against collectives. Within a node, ODC has a comparable performance with collective. But significantly slower than collective cross node.",
                "position": 304
            }
        ]
    },
    {
        "header": "6Discussion",
        "images": []
    },
    {
        "header": "7Conclusion",
        "images": []
    },
    {
        "header": "Reproducibility Statement",
        "images": []
    },
    {
        "header": "References",
        "images": []
    },
    {
        "header": "Appendix ALLM Usage Statement",
        "images": []
    },
    {
        "header": "Appendix BImplementation Details of ODC",
        "images": []
    },
    {
        "header": "Appendix CSequence Packing Strategies Used in Experiment",
        "images": []
    },
    {
        "header": "Appendix DCommunication Volume Comparison",
        "images": []
    },
    {
        "header": "Appendix EZeRO++ Style Hybrid Sharding",
        "images": [
            {
                "img": "https://arxiv.org/html/2601.19362/x12.png",
                "caption": "Figure 12:Comparing ODC with Collectives using hybrid sharding.",
                "position": 1195
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x13.png",
                "caption": "Figure 13:Memory consumption of ODC in hybrid and full sharding.",
                "position": 1201
            },
            {
                "img": "https://arxiv.org/html/2601.19362/x14.png",
                "caption": "Figure 14:Training loss curves on 8k samples from LongAlign with a 1.5B model. ODC and Collective produce almost identical loss curves.",
                "position": 1204
            }
        ]
    },
    {
        "header": "Appendix FConvergency Verification",
        "images": []
    },
    {
        "header": "Appendix GDetailed Experiment Data",
        "images": []
    }
]