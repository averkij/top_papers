[
    {
        "header": "Abstract",
        "images": []
    },
    {
        "header": "1Introduction",
        "images": []
    },
    {
        "header": "2Pioneer Experiment",
        "images": [
            {
                "img": "https://arxiv.org/html/2501.01054/x1.png",
                "caption": "Figure 1:Scaling the quantities of unit tests for majority voting leads to improvements in performance across different policy models and reward models. Policy refers to the model that produces code solutions, while reward denotes the model that generates unit tests.",
                "position": 241
            },
            {
                "img": "https://arxiv.org/html/2501.01054/x2.png",
                "caption": "Figure 2:The correlation between the quantities of unit tests and the performance on different unit test generators (reward model) with200200200200candidate code solutions.",
                "position": 244
            },
            {
                "img": "https://arxiv.org/html/2501.01054/x3.png",
                "caption": "Figure 3:The improvements of best-of-N performance on problems of different difficulties.\nQuintile 1 (easiest) has the highest pass rate, while Quintile 2 (hardest) has the lowest pass rate.\nScaling the quantity of unit tests significantly improves the accuracy on more complex problems.",
                "position": 316
            }
        ]
    },
    {
        "header": "3Towards Efficient and High-Quality Unit Test Scaling",
        "images": [
            {
                "img": "https://arxiv.org/html/2501.01054/x4.png",
                "caption": "Figure 4:Overview for efficient and high-quality unit test scaling. First, we train a lightweight unit test generator based on high-quality synthetic data. Subsequently, we employ dynamic unit test scaling to further improve efficiency.",
                "position": 362
            }
        ]
    },
    {
        "header": "4Experiments",
        "images": [
            {
                "img": "https://arxiv.org/html/2501.01054/x5.png",
                "caption": "Figure 5:The performance of three different unit test generators (reward model) on different quantities of unit tests, while employing Llama3-8B as the policy model.",
                "position": 749
            },
            {
                "img": "https://arxiv.org/html/2501.01054/x6.png",
                "caption": "Figure 6:Best-of-N performance comparison under unit test scaling with three computation budget allocation strategies: dynamic allocation with gold pass rate, dynamic allocation with predicted pass rate, and equal allocation.",
                "position": 752
            },
            {
                "img": "https://arxiv.org/html/2501.01054/x7.png",
                "caption": "Figure 7:The effects of data size.",
                "position": 925
            }
        ]
    },
    {
        "header": "5Related Work",
        "images": []
    },
    {
        "header": "6Conclusion",
        "images": []
    },
    {
        "header": "7Limitations",
        "images": []
    },
    {
        "header": "References",
        "images": []
    },
    {
        "header": "Appendix ALicense",
        "images": []
    },
    {
        "header": "Appendix BMore Results of Unit Test Scaling",
        "images": [
            {
                "img": "https://arxiv.org/html/2501.01054/x8.png",
                "caption": "Figure 8:The performance gain of scaling the number of unit tests on problems of different difficulties across various policy model and reward model.\nOverall, increasing the number of unit tests yields greater performance improvements on more challenging problems, particularly when employing Llama3.1-70B as the policy model.",
                "position": 1585
            }
        ]
    },
    {
        "header": "Appendix CExperiment Settings and Baselines",
        "images": []
    },
    {
        "header": "Appendix DMetrics for Assessing Unit Test Quality",
        "images": [
            {
                "img": "https://arxiv.org/html/2501.01054/x9.png",
                "caption": "Figure 9:An example of the training data for the unit test generator.",
                "position": 1917
            }
        ]
    },
    {
        "header": "Appendix EPrompt for Data Synthetic Pipeline",
        "images": []
    }
]