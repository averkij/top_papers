
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 12 papers. September 23.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            flex: 1 0 auto;
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 0 20px 0;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .article-content {
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
        }
        body.dark-theme>div>main>article {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article {
            background-color: #fff;
        }
        body.dark-theme>div>main>article:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 0px;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
                margin: 0 -20px;
            }
            footer {
                margin-top: -20px;
            }
            article {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">23 сентября</span> | <span id="title-articles-count">12 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item" id="nav-prev"><a href="/d/2024-09-20.html">⬅️ <span id="prev-date">20.09</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-09-24.html">➡️ <span id="next-date">24.09</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2024-09.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '23 сентября', 'en': 'September 23', 'zh': '9月23日'};
        let feedDateNext = {'ru': '24.09', 'en': '09/24', 'zh': '9月24日'};
        let feedDatePrev = {'ru': '20.09', 'en': '09/20', 'zh': '9月20日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2409.13346', 'title': 'Imagine yourself: Tuning-Free Personalized Image Generation', 'url': 'https://huggingface.co/papers/2409.13346', 'abstract': "Diffusion models have demonstrated remarkable efficacy across various image-to-image tasks. In this research, we introduce Imagine yourself, a state-of-the-art model designed for personalized image generation. Unlike conventional tuning-based personalization techniques, Imagine yourself operates as a tuning-free model, enabling all users to leverage a shared framework without individualized adjustments. Moreover, previous work met challenges balancing identity preservation, following complex prompts and preserving good visual quality, resulting in models having strong copy-paste effect of the reference images. Thus, they can hardly generate images following prompts that require significant changes to the reference image, \\eg, changing facial expression, head and body poses, and the diversity of the generated images is low. To address these limitations, our proposed method introduces 1) a new synthetic paired data generation mechanism to encourage image diversity, 2) a fully parallel attention architecture with three text encoders and a fully trainable vision encoder to improve the text faithfulness, and 3) a novel coarse-to-fine multi-stage finetuning methodology that gradually pushes the boundary of visual quality. Our study demonstrates that Imagine yourself surpasses the state-of-the-art personalization model, exhibiting superior capabilities in identity preservation, visual quality, and text alignment. This model establishes a robust foundation for various personalization applications. Human evaluation results validate the model's SOTA superiority across all aspects (identity preservation, text faithfulness, and visual appeal) compared to the previous personalization models.", 'score': 67, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': 'cd0a322cf520de60', 'data': {'categories': ['#cv', '#training', '#alignment', '#diffusion', '#architecture', '#synthetic'], 'emoji': '🖼️', 'ru': {'title': 'Революция в персонализированной генерации изображений без тонкой настройки', 'desc': 'В статье представлена модель Imagine yourself для персонализированной генерации изображений. В отличие от методов тонкой настройки, эта модель не требует индивидуальной подстройки для каждого пользователя. Авторы предлагают новый механизм генерации синтетических парных данных, полностью параллельную архитектуру внимания и многоэтапную методологию обучения. Результаты показывают превосходство Imagine yourself над существующими моделями в сохранении идентичности, визуальном качестве и соответствии текстовым запросам.'}, 'en': {'title': 'Personalized Image Generation Without Individual Tuning', 'desc': "This paper presents 'Imagine yourself', a cutting-edge diffusion model for personalized image generation that does not require individual tuning. It addresses the limitations of previous models by introducing a synthetic paired data generation mechanism to enhance image diversity and a parallel attention architecture to improve text alignment. The model employs a novel coarse-to-fine multi-stage finetuning approach to enhance visual quality while maintaining identity preservation. Human evaluations confirm that 'Imagine yourself' outperforms existing personalization models in identity preservation, text faithfulness, and overall visual appeal."}, 'zh': {'title': '个性化图像生成的新突破', 'desc': '扩散模型在图像生成任务中表现出色。本研究提出了一种名为"Imagine yourself"的先进模型，旨在实现个性化图像生成。与传统的调优个性化技术不同，该模型无需个性化调整，允许所有用户在共享框架下使用。此外，我们的方法通过新颖的合成配对数据生成机制、全并行注意力架构和逐步细化的多阶段调优方法，克服了以往模型在身份保留、文本一致性和视觉质量方面的挑战。'}}}, {'id': 'https://huggingface.co/papers/2409.13592', 'title': 'YesBut: A High-Quality Annotated Multimodal Dataset for evaluating Satire Comprehension capability of Vision-Language Models', 'url': 'https://huggingface.co/papers/2409.13592', 'abstract': 'Understanding satire and humor is a challenging task for even current Vision-Language models. In this paper, we propose the challenging tasks of Satirical Image Detection (detecting whether an image is satirical), Understanding (generating the reason behind the image being satirical), and Completion (given one half of the image, selecting the other half from 2 given options, such that the complete image is satirical) and release a high-quality dataset YesBut, consisting of 2547 images, 1084 satirical and 1463 non-satirical, containing different artistic styles, to evaluate those tasks. Each satirical image in the dataset depicts a normal scenario, along with a conflicting scenario which is funny or ironic. Despite the success of current Vision-Language Models on multimodal tasks such as Visual QA and Image Captioning, our benchmarking experiments show that such models perform poorly on the proposed tasks on the YesBut Dataset in Zero-Shot Settings w.r.t both automated as well as human evaluation. Additionally, we release a dataset of 119 real, satirical photographs for further research. The dataset and code are available at https://github.com/abhi1nandy2/yesbut_dataset.', 'score': 48, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': '63915fb63f61f8bf', 'data': {'categories': ['#dataset', '#cv', '#interpretability', '#benchmark', '#games', '#open_source', '#multimodal'], 'emoji': '🎭', 'ru': {'title': 'Компьютер учится понимать сатиру в изображениях', 'desc': 'Статья представляет новые задачи в области компьютерного зрения и обработки естественного языка: обнаружение, понимание и дополнение сатирических изображений. Авторы создали датасет YesBut, содержащий 2547 изображений (1084 сатирических и 1463 несатирических) различных художественных стилей. Эксперименты показали, что современные мультимодальные модели плохо справляются с этими задачами в режиме zero-shot. Также был выпущен дополнительный набор из 119 реальных сатирических фотографий для дальнейших исследований.'}, 'en': {'title': 'Decoding Satire: A New Challenge for Vision-Language Models', 'desc': 'This paper addresses the difficulty of understanding satire and humor in images using Vision-Language models. It introduces three tasks: Satirical Image Detection, Understanding the satire, and Completion of satirical images. The authors present a new dataset called YesBut, which includes 2547 images to evaluate these tasks, highlighting the contrast between normal and satirical scenarios. Benchmarking results reveal that existing models struggle with these tasks, indicating a gap in their ability to comprehend humor and irony in visual content.'}, 'zh': {'title': '揭示讽刺的挑战与机遇', 'desc': '理解讽刺和幽默对当前的视觉-语言模型来说是一个具有挑战性的任务。本文提出了三个任务：讽刺图像检测、理解讽刺原因和图像补全，并发布了一个高质量的数据集YesBut，包含2547张图像。尽管现有的视觉-语言模型在多模态任务上表现良好，但在YesBut数据集的基准测试中，这些模型在零样本设置下的表现却很差。我们还发布了119张真实的讽刺照片数据集，以供进一步研究。'}}}, {'id': 'https://huggingface.co/papers/2409.13598', 'title': 'Prithvi WxC: Foundation Model for Weather and Climate', 'url': 'https://huggingface.co/papers/2409.13598', 'abstract': 'Triggered by the realization that AI emulators can rival the performance of traditional numerical weather prediction models running on HPC systems, there is now an increasing number of large AI models that address use cases such as forecasting, downscaling, or nowcasting. While the parallel developments in the AI literature focus on foundation models -- models that can be effectively tuned to address multiple, different use cases -- the developments on the weather and climate side largely focus on single-use cases with particular emphasis on mid-range forecasting. We close this gap by introducing Prithvi WxC, a 2.3 billion parameter foundation model developed using 160 variables from the Modern-Era Retrospective Analysis for Research and Applications, Version 2 (MERRA-2). Prithvi WxC employs an encoder-decoder-based architecture, incorporating concepts from various recent transformer models to effectively capture both regional and global dependencies in the input data. The model has been designed to accommodate large token counts to model weather phenomena in different topologies at fine resolutions. Furthermore, it is trained with a mixed objective that combines the paradigms of masked reconstruction with forecasting. We test the model on a set of challenging downstream tasks namely: Autoregressive rollout forecasting, Downscaling, Gravity wave flux parameterization, and Extreme events estimation. The pretrained model with 2.3 billion parameters, along with the associated fine-tuning workflows, has been publicly released as an open-source contribution via Hugging Face.', 'score': 37, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': 'a0a84f660d5ff945', 'data': {'categories': ['#science', '#dataset', '#cv', '#training', '#transfer_learning', '#open_source', '#small_models', '#architecture'], 'emoji': '🌦️', 'ru': {'title': 'Универсальная ИИ-модель для прогнозирования погоды и климата', 'desc': 'Статья представляет Prithvi WxC - фундаментальную модель с 2,3 миллиардами параметров для прогнозирования погоды и климата. Модель использует архитектуру энкодер-декодер и обучена на 160 переменных из реанализа MERRA-2. Prithvi WxC может решать различные задачи, включая прогнозирование, даунскейлинг и оценку экстремальных событий. Модель и связанные с ней рабочие процессы доступны в открытом доступе через Hugging Face.'}, 'en': {'title': 'Revolutionizing Weather Forecasting with AI Foundation Models', 'desc': 'This paper introduces Prithvi WxC, a large foundation model designed for weather and climate applications, featuring 2.3 billion parameters. It utilizes an encoder-decoder architecture inspired by transformer models to effectively capture both regional and global dependencies in weather data. The model is trained on a diverse dataset from MERRA-2 and is capable of handling large token counts for fine-resolution weather phenomena modeling. It has been tested on various challenging tasks, including forecasting and downscaling, and is available as an open-source resource for further research.'}, 'zh': {'title': '基础模型助力天气预测新纪元', 'desc': '本论文介绍了一种名为Prithvi WxC的基础模型，具有23亿个参数，旨在解决天气和气候预测问题。该模型使用160个变量，基于现代时代回顾分析（MERRA-2）数据，采用编码器-解码器架构，能够有效捕捉输入数据的区域和全球依赖关系。Prithvi WxC设计用于处理大规模的标记数量，以在不同地形上以高分辨率模拟天气现象。模型经过混合目标训练，结合了掩蔽重建和预测的范式，并在多个下游任务上进行了测试。'}}}, {'id': 'https://huggingface.co/papers/2409.13216', 'title': 'MuCodec: Ultra Low-Bitrate Music Codec', 'url': 'https://huggingface.co/papers/2409.13216', 'abstract': 'Music codecs are a vital aspect of audio codec research, and ultra low-bitrate compression holds significant importance for music transmission and generation. Due to the complexity of music backgrounds and the richness of vocals, solely relying on modeling semantic or acoustic information cannot effectively reconstruct music with both vocals and backgrounds. To address this issue, we propose MuCodec, specifically targeting music compression and reconstruction tasks at ultra low bitrates. MuCodec employs MuEncoder to extract both acoustic and semantic features, discretizes them with RVQ, and obtains Mel-VAE features via flow-matching. The music is then reconstructed using a pre-trained MEL-VAE decoder and HiFi-GAN. MuCodec can reconstruct high-fidelity music at ultra low (0.35kbps) or high bitrates (1.35kbps), achieving the best results to date in both subjective and objective metrics. Code and Demo: https://xuyaoxun.github.io/MuCodec_demo/.', 'score': 22, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': '82a6af61f8a6c886', 'data': {'categories': ['#open_source', '#audio', '#optimization', '#architecture'], 'emoji': '🎵', 'ru': {'title': 'Революция в сжатии музыки: высокое качество при сверхнизких битрейтах', 'desc': 'MuCodec - это новый подход к сжатию музыки при сверхнизких битрейтах. Он использует MuEncoder для извлечения акустических и семантических признаков, которые затем дискретизируются с помощью RVQ и преобразуются в признаки Mel-VAE. Реконструкция музыки выполняется предобученным декодером MEL-VAE и HiFi-GAN. MuCodec достигает наилучших результатов при битрейтах 0.35-1.35 кбит/с по субъективным и объективным метрикам.'}, 'en': {'title': 'MuCodec: High-Fidelity Music Compression at Ultra Low Bitrates', 'desc': 'This paper introduces MuCodec, a novel approach for music compression and reconstruction at ultra low bitrates. It addresses the challenge of effectively reconstructing music that includes both vocals and complex backgrounds by utilizing a combination of acoustic and semantic feature extraction. MuCodec employs a MuEncoder to gather these features, which are then processed using Residual Vector Quantization (RVQ) and flow-matching to obtain Mel-VAE features. The final music reconstruction is achieved through a pre-trained MEL-VAE decoder and HiFi-GAN, demonstrating superior performance in both subjective and objective evaluations at bitrates as low as 0.35kbps.'}, 'zh': {'title': 'MuCodec：超低比特率音乐重建的创新解决方案', 'desc': '音乐编解码器在音频编解码研究中非常重要，超低比特率压缩对音乐传输和生成具有重要意义。由于音乐背景的复杂性和人声的丰富性，仅依靠建模语义或声学信息无法有效重建同时包含人声和背景的音乐。为了解决这个问题，我们提出了MuCodec，专门针对超低比特率下的音乐压缩和重建任务。MuCodec通过MuEncoder提取声学和语义特征，使用RVQ进行离散化，并通过流匹配获得Mel-VAE特征，最终利用预训练的MEL-VAE解码器和HiFi-GAN重建高保真音乐。'}}}, {'id': 'https://huggingface.co/papers/2409.12941', 'title': 'Fact, Fetch, and Reason: A Unified Evaluation of Retrieval-Augmented Generation', 'url': 'https://huggingface.co/papers/2409.12941', 'abstract': "Large Language Models (LLMs) have demonstrated significant performance improvements across various cognitive tasks. An emerging application is using LLMs to enhance retrieval-augmented generation (RAG) capabilities. These systems require LLMs to understand user queries, retrieve relevant information, and synthesize coherent and accurate responses. Given the increasing real-world deployment of such systems, comprehensive evaluation becomes crucial. To this end, we propose FRAMES (Factuality, Retrieval, And reasoning MEasurement Set), a high-quality evaluation dataset designed to test LLMs' ability to provide factual responses, assess retrieval capabilities, and evaluate the reasoning required to generate final answers. While previous work has provided datasets and benchmarks to evaluate these abilities in isolation, FRAMES offers a unified framework that provides a clearer picture of LLM performance in end-to-end RAG scenarios. Our dataset comprises challenging multi-hop questions that require the integration of information from multiple sources. We present baseline results demonstrating that even state-of-the-art LLMs struggle with this task, achieving 0.40 accuracy with no retrieval. The accuracy is significantly improved with our proposed multi-step retrieval pipeline, achieving an accuracy of 0.66 (>50% improvement). We hope our work will help bridge evaluation gaps and assist in developing more robust and capable RAG systems.", 'score': 20, 'issue_id': 1, 'pub_date': '2024-09-19', 'pub_date_card': {'ru': '19 сентября', 'en': 'September 19', 'zh': '9月19日'}, 'hash': 'dc5c06fd6d7625ca', 'data': {'categories': ['#science', '#reasoning', '#dataset', '#rag', '#interpretability', '#benchmark'], 'emoji': '🧠', 'ru': {'title': 'FRAMES: Комплексная оценка LLM в задачах RAG', 'desc': 'Статья представляет FRAMES - набор данных для оценки языковых моделей (LLM) в задачах извлечения и генерации информации (RAG). FRAMES тестирует способность моделей давать фактические ответы, оценивает возможности поиска и рассуждения при генерации ответов. Набор данных состоит из сложных многоэтапных вопросов, требующих интеграции информации из нескольких источников. Результаты показывают, что даже современные LLM испытывают трудности с этой задачей, но предложенный авторами многоэтапный конвейер поиска значительно улучшает точность.'}, 'en': {'title': 'Enhancing LLMs with FRAMES for Better RAG Performance', 'desc': "This paper discusses the use of Large Language Models (LLMs) to improve retrieval-augmented generation (RAG) systems, which combine information retrieval and text generation. The authors introduce FRAMES, a new evaluation dataset that measures LLMs' factual accuracy, retrieval effectiveness, and reasoning skills in generating responses. Unlike previous benchmarks that assessed these abilities separately, FRAMES provides a comprehensive framework for evaluating LLM performance in real-world scenarios. The results show that while current LLMs perform poorly without retrieval, their accuracy significantly improves when using a multi-step retrieval approach."}, 'zh': {'title': '提升检索增强生成系统的评估能力', 'desc': '大型语言模型（LLMs）在各种认知任务中表现出显著的性能提升。本文提出了一种新的评估数据集FRAMES，旨在测试LLMs在检索增强生成（RAG）系统中的能力，包括提供事实性回答、评估检索能力和推理能力。FRAMES数据集包含具有挑战性的多跳问题，需要整合来自多个来源的信息。我们的实验结果表明，尽管当前最先进的LLMs在没有检索的情况下准确率仅为0.40，但通过我们提出的多步骤检索管道，准确率提高至0.66，超过50%的提升。'}}}, {'id': 'https://huggingface.co/papers/2409.13591', 'title': 'Portrait Video Editing Empowered by Multimodal Generative Priors', 'url': 'https://huggingface.co/papers/2409.13591', 'abstract': 'We introduce PortraitGen, a powerful portrait video editing method that achieves consistent and expressive stylization with multimodal prompts. Traditional portrait video editing methods often struggle with 3D and temporal consistency, and typically lack in rendering quality and efficiency. To address these issues, we lift the portrait video frames to a unified dynamic 3D Gaussian field, which ensures structural and temporal coherence across frames. Furthermore, we design a novel Neural Gaussian Texture mechanism that not only enables sophisticated style editing but also achieves rendering speed over 100FPS. Our approach incorporates multimodal inputs through knowledge distilled from large-scale 2D generative models. Our system also incorporates expression similarity guidance and a face-aware portrait editing module, effectively mitigating degradation issues associated with iterative dataset updates. Extensive experiments demonstrate the temporal consistency, editing efficiency, and superior rendering quality of our method. The broad applicability of the proposed approach is demonstrated through various applications, including text-driven editing, image-driven editing, and relighting, highlighting its great potential to advance the field of video editing. Demo videos and released code are provided in our project page: https://ustc3dv.github.io/PortraitGen/', 'score': 15, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': 'bdf416584245d302', 'data': {'categories': ['#video', '#optimization', '#games', '#open_source', '#architecture', '#multimodal', '#3d'], 'emoji': '🎥', 'ru': {'title': 'PortraitGen: Революция в редактировании портретных видео с помощью 3D гауссовых полей и нейронных текстур', 'desc': 'PortraitGen - это метод редактирования портретных видео, обеспечивающий согласованную и выразительную стилизацию с помощью мультимодальных подсказок. Он использует динамическое 3D гауссово поле для обеспечения структурной и временной согласованности кадров. Метод включает механизм нейронной гауссовой текстуры для сложного стилевого редактирования и быстрого рендеринга. PortraitGen интегрирует знания из крупномасштабных 2D генеративных моделей и включает модули для сохранения выражения лица и улучшения качества редактирования.'}, 'en': {'title': 'Revolutionizing Portrait Video Editing with PortraitGen', 'desc': 'PortraitGen is a novel method for editing portrait videos that focuses on maintaining consistency and expressiveness through multimodal prompts. It overcomes challenges in traditional editing methods by utilizing a unified dynamic 3D Gaussian field, which ensures both structural and temporal coherence across video frames. The introduction of a Neural Gaussian Texture mechanism allows for advanced style editing while achieving high rendering speeds of over 100 frames per second. Extensive experiments validate its effectiveness in editing efficiency, rendering quality, and broad applicability in various editing tasks such as text-driven and image-driven editing.'}, 'zh': {'title': 'PortraitGen：高效一致的肖像视频编辑新方法', 'desc': '本文介绍了一种名为PortraitGen的强大肖像视频编辑方法，能够通过多模态提示实现一致且富有表现力的风格化。传统的肖像视频编辑方法在三维和时间一致性方面常常面临挑战，且在渲染质量和效率上表现不足。为了解决这些问题，我们将肖像视频帧提升到统一的动态三维高斯场，从而确保帧之间的结构和时间一致性。此外，我们设计了一种新颖的神经高斯纹理机制，不仅支持复杂的风格编辑，还能实现超过100FPS的渲染速度。'}}}, {'id': 'https://huggingface.co/papers/2409.13690', 'title': 'Colorful Diffuse Intrinsic Image Decomposition in the Wild', 'url': 'https://huggingface.co/papers/2409.13690', 'abstract': 'Intrinsic image decomposition aims to separate the surface reflectance and the effects from the illumination given a single photograph. Due to the complexity of the problem, most prior works assume a single-color illumination and a Lambertian world, which limits their use in illumination-aware image editing applications. In this work, we separate an input image into its diffuse albedo, colorful diffuse shading, and specular residual components. We arrive at our result by gradually removing first the single-color illumination and then the Lambertian-world assumptions. We show that by dividing the problem into easier sub-problems, in-the-wild colorful diffuse shading estimation can be achieved despite the limited ground-truth datasets. Our extended intrinsic model enables illumination-aware analysis of photographs and can be used for image editing applications such as specularity removal and per-pixel white balancing.', 'score': 12, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': '49e7d3ade160e4b6', 'data': {'categories': ['#optimization', '#dataset', '#cv', '#graphs'], 'emoji': '🖼️', 'ru': {'title': 'Декомпозиция изображений для анализа освещения и редактирования фото', 'desc': 'Статья посвящена декомпозиции изображений на составляющие: отражательную способность поверхности и эффекты освещения. Авторы предлагают метод разделения входного изображения на диффузное альбедо, цветное диффузное затенение и зеркальный остаток. Подход постепенно устраняет ограничения предыдущих работ, связанные с однородным освещением и ламбертовским отражением. Результаты позволяют проводить анализ освещения на фотографиях и применять их для редактирования изображений.'}, 'en': {'title': 'Revolutionizing Image Editing with Advanced Intrinsic Decomposition', 'desc': 'This paper presents a method for intrinsic image decomposition, which separates an image into its surface reflectance and illumination effects. Unlike previous approaches that relied on single-color lighting and Lambertian surfaces, this method tackles the problem by breaking it down into simpler components: diffuse albedo, colorful diffuse shading, and specular residuals. By relaxing the assumptions of uniform illumination, the authors demonstrate that it is possible to estimate colorful shading in real-world images, even with limited training data. The proposed model enhances the ability to perform illumination-aware image editing tasks, such as removing specularity and adjusting colors on a per-pixel basis.'}, 'zh': {'title': '分离光照与反射，提升图像编辑能力', 'desc': '内在图像分解的目标是从单张照片中分离出表面反射率和光照效果。以往的研究大多假设单一颜色的光照和朗伯世界，这限制了其在光照感知图像编辑中的应用。我们的方法将输入图像分解为漫反射反照率、丰富的漫反射阴影和镜面残余成分。通过逐步去除单一颜色光照和朗伯假设，我们的扩展内在模型实现了光照感知的照片分析，并可用于图像编辑应用，如去除镜面反射和逐像素白平衡。'}}}, {'id': 'https://huggingface.co/papers/2409.13648', 'title': 'V^3: Viewing Volumetric Videos on Mobiles via Streamable 2D Dynamic Gaussians', 'url': 'https://huggingface.co/papers/2409.13648', 'abstract': 'Experiencing high-fidelity volumetric video as seamlessly as 2D videos is a long-held dream. However, current dynamic 3DGS methods, despite their high rendering quality, face challenges in streaming on mobile devices due to computational and bandwidth constraints. In this paper, we introduce V3(Viewing Volumetric Videos), a novel approach that enables high-quality mobile rendering through the streaming of dynamic Gaussians. Our key innovation is to view dynamic 3DGS as 2D videos, facilitating the use of hardware video codecs. Additionally, we propose a two-stage training strategy to reduce storage requirements with rapid training speed. The first stage employs hash encoding and shallow MLP to learn motion, then reduces the number of Gaussians through pruning to meet the streaming requirements, while the second stage fine tunes other Gaussian attributes using residual entropy loss and temporal loss to improve temporal continuity. This strategy, which disentangles motion and appearance, maintains high rendering quality with compact storage requirements. Meanwhile, we designed a multi-platform player to decode and render 2D Gaussian videos. Extensive experiments demonstrate the effectiveness of V3, outperforming other methods by enabling high-quality rendering and streaming on common devices, which is unseen before. As the first to stream dynamic Gaussians on mobile devices, our companion player offers users an unprecedented volumetric video experience, including smooth scrolling and instant sharing. Our project page with source code is available at https://authoritywang.github.io/v3/.', 'score': 9, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': '6754c4dc77bfb7a4', 'data': {'categories': ['#video', '#training', '#inference', '#optimization', '#games', '#open_source', '#multimodal', '#3d'], 'emoji': '📱', 'ru': {'title': 'Стриминг объемного видео на мобильных устройствах', 'desc': 'Статья представляет V3 (Viewing Volumetric Videos) - новый подход к стримингу динамических гауссовых сплатов на мобильных устройствах. Авторы предлагают рассматривать динамические 3DGS как 2D видео, что позволяет использовать аппаратные видеокодеки. Применяется двухэтапная стратегия обучения: сначала используется хэш-кодирование и неглубокая MLP для изучения движения, затем производится прореживание гауссианов. Второй этап настраивает другие атрибуты гауссианов с помощью остаточной энтропийной потери и временной потери для улучшения временной непрерывности.'}, 'en': {'title': 'Stream High-Quality Volumetric Videos Seamlessly on Mobile!', 'desc': 'This paper presents V3, a new method for streaming high-quality volumetric videos on mobile devices. It addresses the limitations of current dynamic 3D Gaussian streaming methods by treating them like 2D videos, allowing the use of efficient hardware video codecs. The authors introduce a two-stage training strategy that optimizes storage and improves rendering quality by separating motion from appearance. Extensive tests show that V3 significantly enhances the user experience by enabling smooth playback and quick sharing of volumetric content on common devices.'}, 'zh': {'title': '移动设备上的高质量体积视频流媒体体验', 'desc': '本论文介绍了一种名为V3的新方法，旨在实现高质量的移动设备体积视频渲染。我们将动态3D高斯视为2D视频，从而利用硬件视频编解码器来解决流媒体传输中的计算和带宽限制。通过两阶段的训练策略，我们有效减少了存储需求，同时保持了高渲染质量。实验结果表明，V3在常见设备上实现了高质量的渲染和流媒体传输，提供了前所未有的体积视频体验。'}}}, {'id': 'https://huggingface.co/papers/2409.13449', 'title': 'Minstrel: Structural Prompt Generation with Multi-Agents Coordination for Non-AI Experts', 'url': 'https://huggingface.co/papers/2409.13449', 'abstract': 'LLMs have demonstrated commendable performance across diverse domains. Nevertheless, formulating high-quality prompts to assist them in their work poses a challenge for non-AI experts. Existing research in prompt engineering suggests somewhat scattered optimization principles and designs empirically dependent prompt optimizers. Unfortunately, these endeavors lack a structural design, incurring high learning costs and it is not conducive to the iterative updating of prompts, especially for non-AI experts. Inspired by structured reusable programming languages, we propose LangGPT, a structural prompt design framework. Furthermore, we introduce Minstrel, a multi-generative agent system with reflection to automate the generation of structural prompts. Experiments and the case study illustrate that structural prompts generated by Minstrel or written manually significantly enhance the performance of LLMs. Furthermore, we analyze the ease of use of structural prompts through a user survey in our online community.', 'score': 8, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': '0e0e0cdbcc3fa527', 'data': {'categories': ['#survey', '#optimization', '#plp', '#agents', '#architecture', '#story_generation'], 'emoji': '🧠', 'ru': {'title': 'Структурные промпты: новый подход к управлению языковыми моделями', 'desc': 'Исследователи предлагают LangGPT - структурный фреймворк для разработки промптов, вдохновленный языками программирования. Они также представляют Minstrel - мульти-генеративную агентскую систему для автоматической генерации структурных промптов. Эксперименты показывают, что структурные промпты, созданные Minstrel или написанные вручную, значительно улучшают производительность языковых моделей. Опрос пользователей подтверждает удобство использования структурных промптов.'}, 'en': {'title': 'Empowering Non-Experts with Structured Prompt Design for LLMs', 'desc': 'This paper addresses the challenge of creating effective prompts for large language models (LLMs), particularly for users without AI expertise. It critiques existing prompt engineering methods for their lack of structure and high learning costs, which hinder iterative improvements. The authors introduce LangGPT, a framework for structured prompt design, and Minstrel, a system that automates the generation of these structured prompts. Experimental results show that using structural prompts improves LLM performance, and user feedback indicates that these prompts are easier to use.'}, 'zh': {'title': '结构化提示，助力LLMs更强大', 'desc': '本论文提出了一种名为LangGPT的结构化提示设计框架，旨在帮助非人工智能专家更好地使用大型语言模型（LLMs）。我们还介绍了Minstrel，一个多生成代理系统，能够自动生成结构化提示，从而简化提示工程的过程。实验结果表明，通过Minstrel生成的结构化提示或手动编写的提示，显著提高了LLMs的性能。最后，我们通过用户调查分析了结构化提示的易用性，显示出其在实际应用中的优势。'}}}, {'id': 'https://huggingface.co/papers/2409.13689', 'title': 'Temporally Aligned Audio for Video with Autoregression', 'url': 'https://huggingface.co/papers/2409.13689', 'abstract': 'We introduce V-AURA, the first autoregressive model to achieve high temporal alignment and relevance in video-to-audio generation. V-AURA uses a high-framerate visual feature extractor and a cross-modal audio-visual feature fusion strategy to capture fine-grained visual motion events and ensure precise temporal alignment. Additionally, we propose VisualSound, a benchmark dataset with high audio-visual relevance. VisualSound is based on VGGSound, a video dataset consisting of in-the-wild samples extracted from YouTube. During the curation, we remove samples where auditory events are not aligned with the visual ones. V-AURA outperforms current state-of-the-art models in temporal alignment and semantic relevance while maintaining comparable audio quality. Code, samples, VisualSound and models are available at https://v-aura.notion.site', 'score': 7, 'issue_id': 1, 'pub_date': '2024-09-20', 'pub_date_card': {'ru': '20 сентября', 'en': 'September 20', 'zh': '9月20日'}, 'hash': 'f810134380d44eae', 'data': {'categories': ['#video', '#audio', '#dataset', '#graphs', '#benchmark', '#games', '#open_source', '#architecture', '#multimodal'], 'emoji': '🎬', 'ru': {'title': 'Синхронизированный звук из видео: новый уровень генерации аудио', 'desc': 'В статье представлена модель V-AURA - первая авторегрессионная модель для генерации аудио по видео с высокой временной синхронизацией и релевантностью. Модель использует экстрактор визуальных признаков с высокой частотой кадров и стратегию кросс-модального слияния аудио-визуальных признаков. Авторы также предлагают новый датасет VisualSound с высокой аудио-визуальной релевантностью. V-AURA превосходит современные модели по временной синхронизации и семантической релевантности при сопоставимом качестве звука.'}, 'en': {'title': 'V-AURA: Bridging Video and Audio with Precision', 'desc': 'V-AURA is a novel autoregressive model designed for generating audio from video with high accuracy in timing and relevance. It employs a high-framerate visual feature extractor and a unique cross-modal feature fusion technique to effectively capture detailed visual movements, ensuring that the generated audio aligns well with the visual content. The paper also introduces VisualSound, a new benchmark dataset that enhances audio-visual relevance by filtering out misaligned samples from the existing VGGSound dataset. V-AURA demonstrates superior performance compared to existing models in both temporal alignment and semantic relevance, while also maintaining high audio quality.'}, 'zh': {'title': 'V-AURA：视频到音频生成的新突破', 'desc': 'V-AURA是首个自回归模型，能够在视频到音频生成中实现高时间对齐和相关性。它使用高帧率的视觉特征提取器和跨模态音视频特征融合策略，捕捉细粒度的视觉运动事件，确保精确的时间对齐。此外，我们提出了VisualSound，这是一个具有高音视频相关性的基准数据集，基于VGGSound视频数据集，包含从YouTube提取的真实样本。V-AURA在时间对齐和语义相关性方面超越了当前最先进的模型，同时保持了相当的音频质量。'}}}, {'id': 'https://huggingface.co/papers/2409.11276', 'title': 'Hackphyr: A Local Fine-Tuned LLM Agent for Network Security Environments', 'url': 'https://huggingface.co/papers/2409.11276', 'abstract': "Large Language Models (LLMs) have shown remarkable potential across various domains, including cybersecurity. Using commercial cloud-based LLMs may be undesirable due to privacy concerns, costs, and network connectivity constraints. In this paper, we present Hackphyr, a locally fine-tuned LLM to be used as a red-team agent within network security environments. Our fine-tuned 7 billion parameter model can run on a single GPU card and achieves performance comparable with much larger and more powerful commercial models such as GPT-4. Hackphyr clearly outperforms other models, including GPT-3.5-turbo, and baselines, such as Q-learning agents in complex, previously unseen scenarios. To achieve this performance, we generated a new task-specific cybersecurity dataset to enhance the base model's capabilities. Finally, we conducted a comprehensive analysis of the agents' behaviors that provides insights into the planning abilities and potential shortcomings of such agents, contributing to the broader understanding of LLM-based agents in cybersecurity contexts", 'score': 6, 'issue_id': 1, 'pub_date': '2024-09-17', 'pub_date_card': {'ru': '17 сентября', 'en': 'September 17', 'zh': '9月17日'}, 'hash': 'eb8622fef1dd25fe', 'data': {'categories': ['#dataset', '#security', '#training', '#optimization', '#agents', '#small_models', '#synthetic'], 'emoji': '🛡️', 'ru': {'title': 'Локальная языковая модель бросает вызов гигантам в кибербезопасности', 'desc': 'Исследователи представили Hackphyr - локально дообученную языковую модель для использования в качестве агента красной команды в сетевой безопасности. Модель с 7 миллиардами параметров работает на одной GPU и показывает результаты, сравнимые с более крупными коммерческими моделями. Для улучшения возможностей базовой модели был создан специализированный набор данных по кибербезопасности. Проведен комплексный анализ поведения агентов, что способствует лучшему пониманию применения языковых моделей в контексте кибербезопасности.'}, 'en': {'title': 'Hackphyr: A Local LLM for Enhanced Cybersecurity Defense', 'desc': "This paper introduces Hackphyr, a locally fine-tuned large language model (LLM) designed for use as a red-team agent in cybersecurity. Unlike commercial cloud-based models, Hackphyr addresses privacy and cost concerns while maintaining high performance. The model, with 7 billion parameters, runs efficiently on a single GPU and competes effectively with larger models like GPT-4. Additionally, the authors created a new cybersecurity dataset to improve the model's training, and they analyzed the agent's behavior to understand its planning capabilities and limitations in complex scenarios."}, 'zh': {'title': 'Hackphyr：本地微调的网络安全红队代理', 'desc': '本论文介绍了一种名为Hackphyr的本地微调大型语言模型（LLM），旨在网络安全环境中作为红队代理。该模型拥有70亿个参数，可以在单个GPU上运行，其性能与更大更强的商业模型（如GPT-4）相当。Hackphyr在复杂且未见过的场景中明显优于其他模型，包括GPT-3.5-turbo和Q学习代理。为了提升模型能力，我们生成了一个新的任务特定的网络安全数据集，并对代理的行为进行了全面分析，以深入理解LLM在网络安全中的应用。'}}}, {'id': 'https://huggingface.co/papers/2409.11393', 'title': 'LLM-Agent-UMF: LLM-based Agent Unified Modeling Framework for Seamless Integration of Multi Active/Passive Core-Agents', 'url': 'https://huggingface.co/papers/2409.11393', 'abstract': "The integration of tools in LLM-based agents overcame the difficulties of standalone LLMs and traditional agents' limited capabilities. However, the conjunction of these technologies and the proposed enhancements in several state-of-the-art works followed a non-unified software architecture resulting in a lack of modularity. Indeed, they focused mainly on functionalities and overlooked the definition of the component's boundaries within the agent. This caused terminological and architectural ambiguities between researchers which we addressed in this paper by proposing a unified framework that establishes a clear foundation for LLM-based agents' development from both functional and software architectural perspectives.   Our framework, LLM-Agent-UMF (LLM-based Agent Unified Modeling Framework), clearly distinguishes between the different components of an agent, setting LLMs, and tools apart from a newly introduced element: the core-agent, playing the role of the central coordinator of the agent which comprises five modules: planning, memory, profile, action, and security, the latter often neglected in previous works. Differences in the internal structure of core-agents led us to classify them into a taxonomy of passive and active types. Based on this, we proposed different multi-core agent architectures combining unique characteristics of various individual agents.   For evaluation purposes, we applied this framework to a selection of state-of-the-art agents, thereby demonstrating its alignment with their functionalities and clarifying the overlooked architectural aspects. Moreover, we thoroughly assessed four of our proposed architectures by integrating distinctive agents into hybrid active/passive core-agents' systems. This analysis provided clear insights into potential improvements and highlighted the challenges involved in the combination of specific agents.", 'score': 2, 'issue_id': 1, 'pub_date': '2024-09-17', 'pub_date_card': {'ru': '17 сентября', 'en': 'September 17', 'zh': '9月17日'}, 'hash': 'ff5765ca9944c56e', 'data': {'categories': ['#agi', '#optimization', '#agents', '#alignment', '#architecture'], 'emoji': '🤖', 'ru': {'title': 'Унифицированная архитектура для создания интеллектуальных агентов нового поколения', 'desc': "Статья представляет унифицированную архитектуру для агентов на основе больших языковых моделей (LLM). Авторы вводят понятие 'core-agent' как центрального координатора с пятью модулями: планирование, память, профиль, действие и безопасность. Предложена таксономия пассивных и активных типов core-agent. Разработанная структура, LLM-Agent-UMF, позволяет четко разграничить компоненты агента и устранить терминологические неясности."}, 'en': {'title': 'Unifying LLM-Based Agents for Clarity and Modularity', 'desc': 'This paper addresses the challenges faced by LLM-based agents due to the lack of a unified software architecture, which has led to confusion among researchers. It introduces the LLM-Agent-UMF, a framework that clearly defines the components of LLM-based agents, including a new core-agent that coordinates various modules such as planning and security. The authors classify core-agents into passive and active types, allowing for the development of multi-core agent architectures that leverage the strengths of different agents. By applying this framework to existing agents, the paper demonstrates its effectiveness in clarifying functionalities and architectural aspects, while also identifying areas for improvement.'}, 'zh': {'title': '统一框架，提升智能体能力', 'desc': '本文提出了一种统一的框架，名为LLM-Agent-UMF，用于改进基于大型语言模型（LLM）的智能体的开发。该框架清晰地区分了智能体的不同组件，包括LLM、工具和核心智能体，后者作为中央协调者，包含规划、记忆、个人资料、行动和安全五个模块。我们还根据核心智能体的内部结构将其分类为被动型和主动型，并提出了不同的多核心智能体架构。通过对现有智能体的评估，验证了该框架与其功能的一致性，并明确了被忽视的架构方面。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (2)', '#agents (3)', '#agi (1)', '#alignment (2)', '#architecture (7)', '#audio (2)', '#benchmark (3)', '#cv (4)', '#data', '#dataset (6)', '#diffusion (1)', '#ethics', '#games (4)', '#graphs (2)', '#hallucinations', '#healthcare', '#inference (1)', '#interpretability (2)', '#leakage', '#long_context', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal (4)', '#open_source (6)', '#optimization (7)', '#plp (1)', '#rag (1)', '#reasoning (1)', '#rl', '#rlhf', '#robotics', '#science (2)', '#security (1)', '#small_models (2)', '#story_generation (1)', '#survey (1)', '#synthetic (2)', '#training (4)', '#transfer_learning (1)', '#video (3)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="background-digit">${index + 1}</div>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-09-23 09:00',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2024-09-23 09:00')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2024-09-23 09:00')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    