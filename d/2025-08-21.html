
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 17 papers. August 21.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">21 августа</span> | <span id="title-articles-count">17 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-08-20.html">⬅️ <span id="prev-date">20.08</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-08-22.html">➡️ <span id="next-date">22.08</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-08.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '21 августа', 'en': 'August 21', 'zh': '8月21日'};
        let feedDateNext = {'ru': '22.08', 'en': '08/22', 'zh': '8月22日'};
        let feedDatePrev = {'ru': '20.08', 'en': '08/20', 'zh': '8月20日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2508.13491', 'title': 'From Scores to Skills: A Cognitive Diagnosis Framework for Evaluating\n  Financial Large Language Models', 'url': 'https://huggingface.co/papers/2508.13491', 'abstract': 'FinCDM, a cognitive diagnosis framework, evaluates financial LLMs at the knowledge-skill level using a comprehensive dataset, revealing hidden knowledge gaps and supporting more trustworthy model development.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have shown promise for financial applications, yet their suitability for this high-stakes domain remains largely unproven due to inadequacies in existing benchmarks. Existing benchmarks solely rely on score-level evaluation, summarizing performance with a single score that obscures the nuanced understanding of what models truly know and their precise limitations. They also rely on datasets that cover only a narrow subset of financial concepts, while overlooking other essentials for real-world applications. To address these gaps, we introduce FinCDM, the first cognitive diagnosis evaluation framework tailored for financial LLMs, enabling the evaluation of LLMs at the knowledge-skill level, identifying what financial skills and knowledge they have or lack based on their response patterns across skill-tagged tasks, rather than a single aggregated number. We construct CPA-QKA, the first cognitively informed financial evaluation dataset derived from the Certified Public Accountant (CPA) examination, with comprehensive coverage of real-world accounting and financial skills. It is rigorously annotated by domain experts, who author, validate, and annotate questions with high inter-annotator agreement and fine-grained knowledge labels. Our extensive experiments on 30 proprietary, open-source, and domain-specific LLMs show that FinCDM reveals hidden knowledge gaps, identifies under-tested areas such as tax and regulatory reasoning overlooked by traditional benchmarks, and uncovers behavioral clusters among models. FinCDM introduces a new paradigm for financial LLM evaluation by enabling interpretable, skill-aware diagnosis that supports more trustworthy and targeted model development, and all datasets and evaluation scripts will be publicly released to support further research.', 'score': 53, 'issue_id': 5463, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '467cc61595abe622', 'authors': ['Ziyan Kuang', 'Feiyu Zhu', 'Maowei Jiang', 'Yanzhao Lai', 'Zelin Wang', 'Zhitong Wang', 'Meikang Qiu', 'Jiajia Huang', 'Min Peng', 'Qianqian Xie', 'Sophia Ananiadou'], 'affiliations': ['Beijing University of Financial Technology', 'Center for the Study of Language and Information, Wuhan University', 'Computer Science, University of Manchester', 'Computer and Cyber Sciences, Augusta University', 'School of Artificial Intelligence, Wuhan University', 'School of Computer Science, Nanjing Audit University', 'Southwest Jiaotong University'], 'pdf_title_img': 'assets/pdf/title_img/2508.13491.jpg', 'data': {'categories': ['#open_source', '#benchmark', '#dataset', '#interpretability', '#science'], 'emoji': '💹', 'ru': {'title': 'FinCDM: Точная диагностика финансовых ИИ-моделей', 'desc': 'FinCDM - это новая система оценки больших языковых моделей (LLM) в финансовой сфере на уровне знаний и навыков. Она использует комплексный набор данных CPA-QKA, основанный на экзамене для сертифицированных бухгалтеров. FinCDM выявляет скрытые пробелы в знаниях моделей и определяет недостаточно протестированные области, такие как налоговое и нормативное обоснование. Эта система поддерживает более надежную и целенаправленную разработку моделей для финансовой отрасли.'}, 'en': {'title': 'Unlocking Financial Knowledge Gaps in LLMs with FinCDM', 'desc': 'FinCDM is a novel cognitive diagnosis framework designed to evaluate financial Large Language Models (LLMs) at a detailed knowledge-skill level. Unlike traditional benchmarks that provide a single performance score, FinCDM analyzes response patterns across skill-tagged tasks to identify specific financial skills and knowledge gaps in models. It utilizes the CPA-QKA dataset, which is meticulously annotated by experts to cover a wide range of real-world financial concepts. This approach not only reveals hidden deficiencies in LLMs but also promotes more reliable and targeted development of financial AI systems.'}, 'zh': {'title': '金融模型评估的新视角', 'desc': 'FinCDM是一个认知诊断框架，专门用于评估金融领域的大型语言模型（LLMs），通过知识-技能层面进行评估。它利用CPA-QKA数据集，涵盖真实世界的会计和金融技能，帮助识别模型的知识缺口和不足之处。与传统的单一评分评估不同，FinCDM能够揭示模型在特定金融技能上的表现，提供更细致的分析。该框架的推出为金融LLM的评估开辟了新的思路，促进了更可靠的模型开发。'}}}, {'id': 'https://huggingface.co/papers/2508.14460', 'title': 'DuPO: Enabling Reliable LLM Self-Verification via Dual Preference\n  Optimization', 'url': 'https://huggingface.co/papers/2508.14460', 'abstract': "DuPO is a dual learning framework that generates annotation-free feedback using a generalized duality, enhancing performance across various tasks without relying on costly labels.  \t\t\t\t\tAI-generated summary \t\t\t\t We present DuPO, a dual learning-based preference optimization framework that generates annotation-free feedback via a generalized duality. DuPO addresses two key limitations: Reinforcement Learning with Verifiable Rewards (RLVR)'s reliance on costly labels and applicability restricted to verifiable tasks, and traditional dual learning's restriction to strictly dual task pairs (e.g., translation and back-translation). Specifically, DuPO decomposes a primal task's input into known and unknown components, then constructs its dual task to reconstruct the unknown part using the primal output and known information (e.g., reversing math solutions to recover hidden variables), broadening applicability to non-invertible tasks. The quality of this reconstruction serves as a self-supervised reward to optimize the primal task, synergizing with LLMs' ability to instantiate both tasks via a single model. Empirically, DuPO achieves substantial gains across diverse tasks: it enhances the average translation quality by 2.13 COMET over 756 directions, boosts the mathematical reasoning accuracy by an average of 6.4 points on three challenge benchmarks, and enhances performance by 9.3 points as an inference-time reranker (trading computation for accuracy). These results position DuPO as a scalable, general, and annotation-free paradigm for LLM optimization.", 'score': 52, 'issue_id': 5464, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': 'f6256079a48ef757', 'pdf_title_img': 'img/title_stub.png', 'data': {'categories': ['#machine_translation', '#rlhf', '#reasoning', '#optimization', '#training', '#rl'], 'emoji': '🔄', 'ru': {'title': 'DuPO: Оптимизация без аннотаций через двойственность', 'desc': 'DuPO - это фреймворк двойного обучения, который генерирует обратную связь без аннотаций, используя обобщенную двойственность. Он преодолевает ограничения предыдущих подходов, расширяя применимость на неинвертируемые задачи. DuPO разбивает входные данные основной задачи на известные и неизвестные компоненты, а затем конструирует двойственную задачу для восстановления неизвестной части. Качество этой реконструкции служит самоконтролируемым вознаграждением для оптимизации основной задачи, что позволяет достичь значительных улучшений в различных задачах, включая перевод и математические рассуждения.'}, 'en': {'title': 'Annotation-Free Learning with DuPO: A New Era in Task Optimization', 'desc': 'DuPO is a novel dual learning framework that generates feedback without the need for expensive annotations, leveraging a generalized duality approach. It overcomes limitations of existing methods by allowing for the decomposition of tasks into known and unknown components, enabling the reconstruction of unknown parts from known information. This self-supervised feedback acts as a reward to optimize the primary task, making it applicable to a wider range of tasks beyond traditional dual pairs. Empirical results show that DuPO significantly improves performance in translation and mathematical reasoning tasks, demonstrating its effectiveness as a scalable solution for optimizing large language models.'}, 'zh': {'title': 'DuPO：无注释反馈的双重学习框架', 'desc': 'DuPO是一种基于双重学习的框架，能够生成无注释的反馈，利用广义对偶性来提升多种任务的性能，而无需依赖昂贵的标签。它解决了强化学习与可验证奖励（RLVR）对标签的依赖和传统双重学习仅限于严格的双任务对的局限性。DuPO通过将原始任务的输入分解为已知和未知部分，构建其对偶任务以重建未知部分，从而扩展到不可逆任务。通过这种自监督奖励，DuPO在多个任务上实现了显著的性能提升，展示了其作为无注释的LLM优化范式的潜力。'}}}, {'id': 'https://huggingface.co/papers/2508.11987', 'title': 'FutureX: An Advanced Live Benchmark for LLM Agents in Future Prediction', 'url': 'https://huggingface.co/papers/2508.11987', 'abstract': "FutureX is a dynamic, live benchmark for evaluating LLM agents in future prediction tasks, addressing challenges in real-time updates and data contamination.  \t\t\t\t\tAI-generated summary \t\t\t\t Future prediction is a complex task for LLM agents, requiring a high level of analytical thinking, information gathering, contextual understanding, and decision-making under uncertainty. Agents must not only gather and interpret vast amounts of dynamic information but also integrate diverse data sources, weigh uncertainties, and adapt predictions based on emerging trends, just as human experts do in fields like politics, economics, and finance. Despite its importance, no large-scale benchmark exists for evaluating agents on future prediction, largely due to challenges in handling real-time updates and retrieving timely, accurate answers. To address this, we introduce FutureX, a dynamic and live evaluation benchmark specifically designed for LLM agents performing future prediction tasks. FutureX is the largest and most diverse live benchmark for future prediction, supporting real-time daily updates and eliminating data contamination through an automated pipeline for question gathering and answer collection. We evaluate 25 LLM/agent models, including those with reasoning, search capabilities, and integration of external tools such as the open-source Deep Research Agent and closed-source Deep Research models. This comprehensive evaluation assesses agents' adaptive reasoning and performance in dynamic environments. Additionally, we provide in-depth analyses of agents' failure modes and performance pitfalls in future-oriented tasks, including the vulnerability to fake web pages and the temporal validity. Our goal is to establish a dynamic, contamination-free evaluation standard that drives the development of LLM agents capable of performing at the level of professional human analysts in complex reasoning and predictive thinking.", 'score': 46, 'issue_id': 5463, 'pub_date': '2025-08-16', 'pub_date_card': {'ru': '16 августа', 'en': 'August 16', 'zh': '8月16日'}, 'hash': '122aab80ab15c823', 'authors': ['Zhiyuan Zeng', 'Jiashuo Liu', 'Siyuan Chen', 'Tianci He', 'Yali Liao', 'Jinpeng Wang', 'Zaiyuan Wang', 'Yang Yang', 'Lingyue Yin', 'Mingren Yin', 'Zhenwei Zhu', 'Tianle Cai', 'Zehui Chen', 'Jiecao Chen', 'Yantao Du', 'Xiang Gao', 'Jiacheng Guo', 'Liang Hu', 'Jianpeng Jiao', 'Xiangsheng Li', 'Jingkai Liu', 'Shuang Ni', 'Zhoufutu Wen', 'Ge Zhang', 'Kaiyuan Zhang', 'Xin Zhou', 'Jose Blanchet', 'Xipeng Qiu', 'Mengdi Wang', 'Wenhao Huang'], 'affiliations': ['ByteDance', 'Fudan University', 'Princeton University', 'Stanford University'], 'pdf_title_img': 'assets/pdf/title_img/2508.11987.jpg', 'data': {'categories': ['#agents', '#survey', '#benchmark', '#reasoning'], 'emoji': '🔮', 'ru': {'title': 'FutureX: Живой бенчмарк для оценки прогнозирования будущего ИИ-агентами', 'desc': 'FutureX - это динамический живой бенчмарк для оценки агентов на основе больших языковых моделей (LLM) в задачах прогнозирования будущего. Он решает проблемы обновления данных в реальном времени и исключает загрязнение данных. FutureX оценивает 25 моделей LLM/агентов, включая те, которые обладают способностями к рассуждению, поиску и интеграции внешних инструментов. Бенчмарк анализирует режимы отказа агентов и проблемы производительности в задачах, ориентированных на будущее.'}, 'en': {'title': 'FutureX: Elevating LLM Agents to Expert Predictors', 'desc': 'FutureX is a novel benchmark designed to evaluate large language model (LLM) agents on their ability to predict future events. It addresses the challenges of real-time data updates and the risk of data contamination, which have hindered previous evaluation efforts. By providing a dynamic and automated pipeline for question and answer collection, FutureX allows for daily updates and ensures the integrity of the data used for assessments. This benchmark not only evaluates the reasoning and adaptability of various LLM models but also highlights their weaknesses in handling complex predictive tasks, aiming to enhance their performance to match that of human experts.'}, 'zh': {'title': 'FutureX：未来预测的动态评估基准', 'desc': 'FutureX是一个动态的实时基准，用于评估大型语言模型（LLM）代理在未来预测任务中的表现。它解决了实时更新和数据污染等挑战，支持每日更新并通过自动化流程消除数据污染。该基准评估了25种LLM/代理模型，重点考察它们在动态环境中的适应性推理和性能。我们的目标是建立一个动态、无污染的评估标准，推动LLM代理在复杂推理和预测思维方面的发展。'}}}, {'id': 'https://huggingface.co/papers/2508.14879', 'title': 'MeshCoder: LLM-Powered Structured Mesh Code Generation from Point Clouds', 'url': 'https://huggingface.co/papers/2508.14879', 'abstract': 'MeshCoder reconstructs complex 3D objects from point clouds into editable Blender Python scripts, enhancing shape-to-code reconstruction and 3D shape understanding through a multimodal large language model.  \t\t\t\t\tAI-generated summary \t\t\t\t Reconstructing 3D objects into editable programs is pivotal for applications like reverse engineering and shape editing. However, existing methods often rely on limited domain-specific languages (DSLs) and small-scale datasets, restricting their ability to model complex geometries and structures. To address these challenges, we introduce MeshCoder, a novel framework that reconstructs complex 3D objects from point clouds into editable Blender Python scripts. We develop a comprehensive set of expressive Blender Python APIs capable of synthesizing intricate geometries. Leveraging these APIs, we construct a large-scale paired object-code dataset, where the code for each object is decomposed into distinct semantic parts. Subsequently, we train a multimodal large language model (LLM) that translates 3D point cloud into executable Blender Python scripts. Our approach not only achieves superior performance in shape-to-code reconstruction tasks but also facilitates intuitive geometric and topological editing through convenient code modifications. Furthermore, our code-based representation enhances the reasoning capabilities of LLMs in 3D shape understanding tasks. Together, these contributions establish MeshCoder as a powerful and flexible solution for programmatic 3D shape reconstruction and understanding.', 'score': 25, 'issue_id': 5463, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': '78801534603cc68a', 'authors': ['Bingquan Dai', 'Li Ray Luo', 'Qihong Tang', 'Jie Wang', 'Xinyu Lian', 'Hao Xu', 'Minghan Qin', 'Xudong Xu', 'Bo Dai', 'Haoqian Wang', 'Zhaoyang Lyu', 'Jiangmiao Pang'], 'affiliations': ['AI Thrust, HKUST(GZ), Guangzhou, China', 'Beijing Institute of Technology, Beijing, China', 'Harbin Institute of Technology, Shenzhen, China', 'Shanghai Artificial Intelligence Laboratory, Shanghai, China', 'Tsinghua University, Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2508.14879.jpg', 'data': {'categories': ['#multimodal', '#dataset', '#synthetic', '#3d', '#reasoning'], 'emoji': '🧊', 'ru': {'title': 'От облака точек к коду: MeshCoder открывает новые возможности 3D-реконструкции', 'desc': 'MeshCoder - это новая система, которая преобразует сложные 3D-объекты из облаков точек в редактируемые скрипты Python для Blender. Она использует мультимодальную большую языковую модель (LLM) для перевода 3D облака точек в исполняемый код Blender Python. MeshCoder превосходит существующие методы в задачах реконструкции формы в код и улучшает понимание 3D-форм с помощью LLM. Система позволяет интуитивно редактировать геометрию и топологию объектов через удобные модификации кода.'}, 'en': {'title': 'Transforming 3D Shapes into Editable Code with MeshCoder', 'desc': 'MeshCoder is a framework that converts complex 3D objects from point clouds into editable Blender Python scripts, improving the process of shape-to-code reconstruction. It addresses limitations of existing methods that use narrow domain-specific languages and small datasets, which hinder the modeling of intricate geometries. By creating a large-scale dataset that pairs 3D objects with their corresponding code, MeshCoder trains a multimodal large language model to effectively translate point clouds into executable scripts. This innovative approach not only enhances performance in reconstruction tasks but also allows for intuitive editing of 3D shapes through code, thereby improving the understanding of 3D structures.'}, 'zh': {'title': 'MeshCoder：将3D物体转化为可编辑代码的创新框架', 'desc': 'MeshCoder 是一个新框架，可以将复杂的 3D 物体从点云重建为可编辑的 Blender Python 脚本。这种方法通过开发一套全面的 Blender Python API，能够合成复杂的几何形状。我们还构建了一个大规模的配对物体-代码数据集，使得每个物体的代码可以分解为不同的语义部分。通过训练多模态的大型语言模型，MeshCoder 在形状到代码的重建任务中表现出色，并且通过代码修改实现了直观的几何和拓扑编辑。'}}}, {'id': 'https://huggingface.co/papers/2508.14811', 'title': "Tinker: Diffusion's Gift to 3D--Multi-View Consistent Editing From\n  Sparse Inputs without Per-Scene Optimization", 'url': 'https://huggingface.co/papers/2508.14811', 'abstract': 'Tinker is a framework for high-fidelity 3D editing using pretrained diffusion models, enabling multi-view consistency with minimal per-scene training.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce Tinker, a versatile framework for high-fidelity 3D editing that operates in both one-shot and few-shot regimes without any per-scene finetuning. Unlike prior techniques that demand extensive per-scene optimization to ensure multi-view consistency or to produce dozens of consistent edited input views, Tinker delivers robust, multi-view consistent edits from as few as one or two images. This capability stems from repurposing pretrained diffusion models, which unlocks their latent 3D awareness. To drive research in this space, we curate the first large-scale multi-view editing dataset and data pipeline, spanning diverse scenes and styles. Building on this dataset, we develop our framework capable of generating multi-view consistent edited views without per-scene training, which consists of two novel components: (1) Referring multi-view editor: Enables precise, reference-driven edits that remain coherent across all viewpoints. (2) Any-view-to-video synthesizer: Leverages spatial-temporal priors from video diffusion to perform high-quality scene completion and novel-view generation even from sparse inputs. Through extensive experiments, Tinker significantly reduces the barrier to generalizable 3D content creation, achieving state-of-the-art performance on editing, novel-view synthesis, and rendering enhancement tasks. We believe that Tinker represents a key step towards truly scalable, zero-shot 3D editing. Project webpage: https://aim-uofa.github.io/Tinker', 'score': 23, 'issue_id': 5463, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': '148e6ade70f23987', 'authors': ['Canyu Zhao', 'Xiaoman Li', 'Tianjian Feng', 'Zhiyue Zhao', 'Hao Chen', 'Chunhua Shen'], 'affiliations': ['Zhejiang University of Technology, China', 'Zhejiang University, China'], 'pdf_title_img': 'assets/pdf/title_img/2508.14811.jpg', 'data': {'categories': ['#optimization', '#dataset', '#diffusion', '#3d'], 'emoji': '🎨', 'ru': {'title': 'Tinker: Революция в 3D-редактировании без дополнительного обучения', 'desc': 'Tinker - это фреймворк для высокоточного 3D-редактирования с использованием предобученных диффузионных моделей. Он обеспечивает согласованность между несколькими ракурсами без необходимости длительного обучения для каждой сцены. Tinker использует скрытое 3D-понимание предобученных диффузионных моделей для создания согласованных изменений по всем ракурсам на основе всего одного-двух изображений. Фреймворк включает в себя редактор с привязкой к нескольким ракурсам и синтезатор видео с любого ракурса, что позволяет выполнять высококачественное заполнение сцены и генерацию новых ракурсов даже при ограниченных входных данных.'}, 'en': {'title': 'Revolutionizing 3D Editing with Minimal Training', 'desc': 'Tinker is a framework designed for high-quality 3D editing that utilizes pretrained diffusion models to achieve multi-view consistency with minimal training. It allows users to make edits based on just one or two images, eliminating the need for extensive scene-specific optimization. The framework includes innovative components like a referring multi-view editor for coherent edits across different perspectives and an any-view-to-video synthesizer for generating new views and completing scenes. Tinker aims to simplify the process of creating 3D content, making it more accessible and efficient for users.'}, 'zh': {'title': 'Tinker：简化3D编辑的革命性框架', 'desc': 'Tinker是一个高保真3D编辑框架，利用预训练的扩散模型实现多视角一致性，且只需最少的场景训练。与以往需要大量场景优化的技术不同，Tinker能够从一到两张图像中生成稳健的多视角一致编辑。该框架的核心在于重新利用预训练的扩散模型，解锁其潜在的3D感知能力。通过构建首个大规模多视角编辑数据集，Tinker显著降低了通用3D内容创作的门槛，推动了零-shot 3D编辑的研究。'}}}, {'id': 'https://huggingface.co/papers/2508.14111', 'title': 'From AI for Science to Agentic Science: A Survey on Autonomous\n  Scientific Discovery', 'url': 'https://huggingface.co/papers/2508.14111', 'abstract': 'Agentic Science leverages large language models, multimodal systems, and integrated platforms to enable autonomous scientific discovery across various domains, encompassing hypothesis generation, experimental design, execution, analysis, and iterative refinement.  \t\t\t\t\tAI-generated summary \t\t\t\t Artificial intelligence (AI) is reshaping scientific discovery, evolving from specialized computational tools into autonomous research partners. We position Agentic Science as a pivotal stage within the broader AI for Science paradigm, where AI systems progress from partial assistance to full scientific agency. Enabled by large language models (LLMs), multimodal systems, and integrated research platforms, agentic AI shows capabilities in hypothesis generation, experimental design, execution, analysis, and iterative refinement -- behaviors once regarded as uniquely human. This survey provides a domain-oriented review of autonomous scientific discovery across life sciences, chemistry, materials science, and physics. We unify three previously fragmented perspectives -- process-oriented, autonomy-oriented, and mechanism-oriented -- through a comprehensive framework that connects foundational capabilities, core processes, and domain-specific realizations. Building on this framework, we (i) trace the evolution of AI for Science, (ii) identify five core capabilities underpinning scientific agency, (iii) model discovery as a dynamic four-stage workflow, (iv) review applications across the above domains, and (v) synthesize key challenges and future opportunities. This work establishes a domain-oriented synthesis of autonomous scientific discovery and positions Agentic Science as a structured paradigm for advancing AI-driven research.', 'score': 20, 'issue_id': 5467, 'pub_date': '2025-08-18', 'pub_date_card': {'ru': '18 августа', 'en': 'August 18', 'zh': '8月18日'}, 'hash': 'e00899484f92bfce', 'authors': ['Jiaqi Wei', 'Yuejin Yang', 'Xiang Zhang', 'Yuhan Chen', 'Xiang Zhuang', 'Zhangyang Gao', 'Dongzhan Zhou', 'Guangshuai Wang', 'Zhiqiang Gao', 'Juntai Cao', 'Zijie Qiu', 'Xuming He', 'Qiang Zhang', 'Chenyu You', 'Shuangjia Zheng', 'Ning Ding', 'Wanli Ouyang', 'Nanqing Dong', 'Yu Cheng', 'Siqi Sun', 'Lei Bai', 'Bowen Zhou'], 'affiliations': ['Fudan University', 'Lingang Laboratory', 'Shanghai Artificial Intelligence Laboratory', 'Shanghai Jiaotong University', 'Stony Brook University', 'The Chinese University of Hong Kong', 'Tongji University', 'Tsinghua University', 'University of British Columbia', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2508.14111.jpg', 'data': {'categories': ['#healthcare', '#survey', '#science', '#multimodal', '#agents'], 'emoji': '🧪', 'ru': {'title': 'ИИ как автономный научный исследователь', 'desc': "Статья представляет концепцию 'Агентной науки', которая использует большие языковые модели, мультимодальные системы и интегрированные платформы для автономного научного открытия. Авторы рассматривают эволюцию ИИ в науке от специализированных вычислительных инструментов до полноценных исследовательских партнеров. В работе предлагается комплексная структура, объединяющая фундаментальные возможности, основные процессы и реализации в конкретных областях. Статья охватывает применение агентной науки в биологии, химии, материаловедении и физике."}, 'en': {'title': 'Empowering AI for Autonomous Scientific Discovery', 'desc': 'Agentic Science is a new approach that uses advanced AI tools, like large language models and multimodal systems, to conduct scientific research independently. It allows AI to take on roles such as generating hypotheses, designing experiments, and analyzing results, which were traditionally done by humans. This paper reviews how AI can fully engage in scientific processes across various fields, including life sciences and physics. By creating a framework that connects different aspects of AI in science, the authors highlight the evolution of AI capabilities and the future potential for autonomous research.'}, 'zh': {'title': '代理科学：人工智能驱动的自主研究新阶段', 'desc': '代理科学利用大型语言模型、多模态系统和集成平台，促进各领域的自主科学发现，包括假设生成、实验设计、执行、分析和迭代优化。人工智能正在从专门的计算工具演变为自主研究伙伴，代理科学是这一进程中的重要阶段。通过建立一个全面的框架，本文将过程导向、自主导向和机制导向的观点统一起来，探讨了科学代理的五个核心能力。最后，本文回顾了在生命科学、化学、材料科学和物理学等领域的应用，提出了关键挑战和未来机遇。'}}}, {'id': 'https://huggingface.co/papers/2508.14704', 'title': 'MCP-Universe: Benchmarking Large Language Models with Real-World Model\n  Context Protocol Servers', 'url': 'https://huggingface.co/papers/2508.14704', 'abstract': 'MCP-Universe is a comprehensive benchmark designed to evaluate large language models in realistic tasks through interaction with real-world MCP servers, addressing challenges like long-horizon reasoning and unfamiliar tool spaces.  \t\t\t\t\tAI-generated summary \t\t\t\t The Model Context Protocol has emerged as a transformative standard for connecting large language models to external data sources and tools, rapidly gaining adoption across major AI providers and development platforms. However, existing benchmarks are overly simplistic and fail to capture real application challenges such as long-horizon reasoning and large, unfamiliar tool spaces. To address this critical gap, we introduce MCP-Universe, the first comprehensive benchmark specifically designed to evaluate LLMs in realistic and hard tasks through interaction with real-world MCP servers. Our benchmark encompasses 6 core domains spanning 11 different MCP servers: Location Navigation, Repository Management, Financial Analysis, 3D Design, Browser Automation, and Web Searching. To ensure rigorous evaluation, we implement execution-based evaluators, including format evaluators for agent format compliance, static evaluators for time-invariant content matching, and dynamic evaluators that automatically retrieve real-time ground truth for temporally sensitive tasks. Through extensive evaluation of leading LLMs, we find that even SOTA models such as GPT-5 (43.72%), Grok-4 (33.33%) and Claude-4.0-Sonnet (29.44%) exhibit significant performance limitations. In addition, our benchmark poses a significant long-context challenge for LLM agents, as the number of input tokens increases rapidly with the number of interaction steps. Moreover, it introduces an unknown-tools challenge, as LLM agents often lack familiarity with the precise usage of the MCP servers. Notably, enterprise-level agents like Cursor cannot achieve better performance than standard ReAct frameworks. Beyond evaluation, we open-source our extensible evaluation framework with UI support, enabling researchers and practitioners to seamlessly integrate new agents and MCP servers while fostering innovation in the rapidly evolving MCP ecosystem.', 'score': 14, 'issue_id': 5472, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': 'a97c7b1995faedf2', 'authors': ['Ziyang Luo', 'Zhiqi Shen', 'Wenzhuo Yang', 'Zirui Zhao', 'Prathyusha Jwalapuram', 'Amrita Saha', 'Doyen Sahoo', 'Silvio Savarese', 'Caiming Xiong', 'Junnan Li'], 'affiliations': ['Salesforce AI Research'], 'pdf_title_img': 'assets/pdf/title_img/2508.14704.jpg', 'data': {'categories': ['#agents', '#benchmark', '#long_context', '#open_source', '#3d', '#reasoning'], 'emoji': '🧠', 'ru': {'title': 'MCP-Universe: Реалистичная оценка языковых моделей в сложном мире MCP', 'desc': 'MCP-Universe - это комплексный бенчмарк для оценки больших языковых моделей в реалистичных задачах через взаимодействие с реальными MCP-серверами. Он охватывает 6 основных доменов и 11 различных MCP-серверов, включая навигацию, управление репозиториями и финансовый анализ. Бенчмарк использует исполняемые оценщики для обеспечения строгой оценки, включая форматные, статические и динамические оценщики. Результаты показывают, что даже современные модели, такие как GPT-5 и Grok-4, имеют значительные ограничения производительности в этих сложных задачах.'}, 'en': {'title': 'MCP-Universe: Elevating LLM Evaluation to Real-World Challenges', 'desc': "MCP-Universe is a new benchmark created to test large language models (LLMs) on real-world tasks by interacting with actual Model Context Protocol (MCP) servers. It addresses important challenges like long-horizon reasoning, where models need to think ahead over many steps, and the use of unfamiliar tools that they haven't encountered before. The benchmark includes six key areas such as location navigation and financial analysis, and it uses various evaluators to ensure accurate assessments of model performance. Our findings show that even the best models struggle with these complex tasks, highlighting the need for better training and evaluation methods in the field of AI."}, 'zh': {'title': 'MCP-Universe：评估大型语言模型的新标准', 'desc': 'MCP-Universe是一个全面的基准测试，旨在通过与真实的MCP服务器互动来评估大型语言模型在现实任务中的表现。该基准测试解决了长期推理和不熟悉工具空间等挑战，涵盖了六个核心领域和11个不同的MCP服务器。通过执行基于评估的评估器，我们能够严格评估模型的性能，发现即使是最先进的模型在面对复杂任务时也存在显著的性能限制。此外，我们还开源了可扩展的评估框架，支持研究人员和从业者集成新的代理和MCP服务器。'}}}, {'id': 'https://huggingface.co/papers/2508.14896', 'title': 'Quantization Meets dLLMs: A Systematic Study of Post-training\n  Quantization for Diffusion LLMs', 'url': 'https://huggingface.co/papers/2508.14896', 'abstract': 'A systematic study on quantizing diffusion large language models identifies challenges and evaluates state-of-the-art methods across various configurations to improve deployment on edge devices.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in diffusion large language models (dLLMs) have introduced a promising alternative to autoregressive (AR) LLMs for natural language generation tasks, leveraging full attention and denoising-based decoding strategies. However, the deployment of these models on edge devices remains challenging due to their massive parameter scale and high resource demands. While post-training quantization (PTQ) has emerged as a widely adopted technique for compressing AR LLMs, its applicability to dLLMs remains largely unexplored. In this work, we present the first systematic study on quantizing diffusion-based language models. We begin by identifying the presence of activation outliers, characterized by abnormally large activation values that dominate the dynamic range. These outliers pose a key challenge to low-bit quantization, as they make it difficult to preserve precision for the majority of values. More importantly, we implement state-of-the-art PTQ methods and conduct a comprehensive evaluation across multiple task types and model variants. Our analysis is structured along four key dimensions: bit-width, quantization method, task category, and model type. Through this multi-perspective evaluation, we offer practical insights into the quantization behavior of dLLMs under different configurations. We hope our findings provide a foundation for future research in efficient dLLM deployment. All codes and experimental setups will be released to support the community.', 'score': 13, 'issue_id': 5464, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': '0f5b442adf5565a9', 'authors': ['Haokun Lin', 'Haobo Xu', 'Yichen Wu', 'Ziyu Guo', 'Renrui Zhang', 'Zhichao Lu', 'Ying Wei', 'Qingfu Zhang', 'Zhenan Sun'], 'affiliations': ['City University of Hong Kong', 'Harvard University', 'NLPR & MAIS, Institute of Automation, CAS', 'The Chinese University of Hong Kong', 'Tsinghua University', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2508.14896.jpg', 'data': {'categories': ['#optimization', '#training', '#inference', '#diffusion', '#open_source'], 'emoji': '🔬', 'ru': {'title': 'Квантование диффузионных ЯМ: вызовы и решения', 'desc': 'Это исследование посвящено квантованию диффузионных больших языковых моделей (dLLMs) для их развертывания на устройствах с ограниченными ресурсами. Авторы выявили проблему выбросов активации, которые затрудняют низкобитное квантование. Они провели систематическую оценку современных методов пост-тренировочного квантования (PTQ) для dLLMs по различным параметрам. Результаты анализа предоставляют практические рекомендации по квантованию dLLMs в разных конфигурациях.'}, 'en': {'title': 'Optimizing Diffusion Models for Edge Deployment', 'desc': 'This paper investigates the challenges of quantizing diffusion large language models (dLLMs) to make them suitable for deployment on edge devices. It highlights the issue of activation outliers that complicate low-bit quantization, affecting the precision of model performance. The authors evaluate various state-of-the-art post-training quantization (PTQ) methods across different configurations, including bit-width and task types. Their findings aim to guide future research and improve the efficiency of dLLMs in practical applications.'}, 'zh': {'title': '高效量化扩散语言模型的探索', 'desc': '本研究系统地探讨了扩散大型语言模型（dLLMs）的量化问题，识别了在边缘设备上部署时面临的挑战。我们发现激活异常值的存在，这些异常值的激活值异常大，影响了低位量化的精度。通过实施最先进的后训练量化（PTQ）方法，我们对多种任务类型和模型变体进行了全面评估。我们的研究为未来高效部署dLLMs提供了基础，并将发布所有代码和实验设置以支持社区。'}}}, {'id': 'https://huggingface.co/papers/2508.14444', 'title': 'NVIDIA Nemotron Nano 2: An Accurate and Efficient Hybrid\n  Mamba-Transformer Reasoning Model', 'url': 'https://huggingface.co/papers/2508.14444', 'abstract': 'Nemotron-Nano-9B-v2, a hybrid Mamba-Transformer model, enhances reasoning workload throughput and accuracy by replacing self-attention layers with Mamba-2 layers and using the Minitron strategy for compression.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce Nemotron-Nano-9B-v2, a hybrid Mamba-Transformer language model designed to increase throughput for reasoning workloads while achieving state-of-the-art accuracy compared to similarly-sized models. Nemotron-Nano-9B-v2 builds on the Nemotron-H architecture, in which the majority of the self-attention layers in the common Transformer architecture are replaced with Mamba-2 layers, to achieve improved inference speed when generating the long thinking traces needed for reasoning. We create Nemotron-Nano-9B-v2 by first pre-training a 12-billion-parameter model (Nemotron-Nano-12B-v2-Base) on 20 trillion tokens using an FP8 training recipe. After aligning Nemotron-Nano-12B-v2-Base, we employ the Minitron strategy to compress and distill the model with the goal of enabling inference on up to 128k tokens on a single NVIDIA A10G GPU (22GiB of memory, bfloat16 precision). Compared to existing similarly-sized models (e.g., Qwen3-8B), we show that Nemotron-Nano-9B-v2 achieves on-par or better accuracy on reasoning benchmarks while achieving up to 6x higher inference throughput in reasoning settings like 8k input and 16k output tokens. We are releasing Nemotron-Nano-9B-v2, Nemotron-Nano12B-v2-Base, and Nemotron-Nano-9B-v2-Base checkpoints along with the majority of our pre- and post-training datasets on Hugging Face.', 'score': 13, 'issue_id': 5464, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': '2e036dcc418a9ee0', 'authors': ['NVIDIA', ':', 'Aarti Basant', 'Abhijit Khairnar', 'Abhijit Paithankar', 'Abhinav Khattar', 'Adi Renduchintala', 'Adithya Renduchintala', 'Aditya Malte', 'Akhiad Bercovich', 'Akshay Hazare', 'Alejandra Rico', 'Aleksander Ficek', 'Alex Kondratenko', 'Alex Shaposhnikov', 'Ali Taghibakhshi', 'Amelia Barton', 'Ameya Sunil Mahabaleshwarkar', 'Amy Shen', 'Andrew Tao', 'Ann Guan', 'Anna Shors', 'Anubhav Mandarwal', 'Arham Mehta', 'Arun Venkatesan', 'Ashton Sharabiani', 'Ashwath Aithal', 'Ashwin Poojary', 'Ayush Dattagupta', 'Balaram Buddharaju', 'Banghua Zhu', 'Barnaby Simkin', 'Bilal Kartal', 'Bita Darvish Rouhani', 'Bobby Chen', 'Boris Ginsburg', 'Brandon Norick', 'Brian Yu', 'Bryan Catanzaro', 'Charles Wang', 'Charlie Truong', 'Chetan Mungekar', 'Chintan Patel', 'Chris Alexiuk', 'Christian Munley', 'Christopher Parisien', 'Dan Su', 'Daniel Afrimi', 'Daniel Korzekwa', 'Daniel Rohrer', 'Daria Gitman', 'David Mosallanezhad', 'Deepak Narayanan', 'Dima Rekesh', 'Dina Yared', 'Dmytro Pykhtar', 'Dong Ahn', 'Duncan Riach', 'Eileen Long', 'Elliott Ning', 'Eric Chung', 'Erick Galinkin', 'Evelina Bakhturina', 'Gargi Prasad', 'Gerald Shen', 'Haim Elisha', 'Harsh Sharma', 'Hayley Ross', 'Helen Ngo', 'Herman Sahota', 'Hexin Wang', 'Hoo Chang Shin', 'Hua Huang', 'Iain Cunningham', 'Igor Gitman', 'Ivan Moshkov', 'Jaehun Jung', 'Jan Kautz', 'Jane Polak Scowcroft', 'Jared Casper', 'Jimmy Zhang', 'Jinze Xue', 'Jocelyn Huang', 'Joey Conway', 'John Kamalu', 'Jonathan Cohen', 'Joseph Jennings', 'Julien Veron Vialard', 'Junkeun Yi', 'Jupinder Parmar', 'Kari Briski', 'Katherine Cheung', 'Katherine Luna', 'Keith Wyss', 'Keshav Santhanam', 'Kezhi Kong', 'Krzysztof Pawelec', 'Kumar Anik', 'Kunlun Li', 'Kushan Ahmadian', 'Lawrence McAfee', 'Laya Sleiman', 'Leon Derczynski', 'Luis Vega', 'Maer Rodrigues de Melo', 'Makesh Narsimhan Sreedhar', 'Marcin Chochowski', 'Mark Cai', 'Markus Kliegl', 'Marta Stepniewska-Dziubinska', 'Matvei Novikov', 'Mehrzad Samadi', 'Meredith Price', 'Meriem Boubdir', 'Michael Boone', 'Michael Evans', 'Michal Bien', 'Michal Zawalski', 'Miguel Martinez', 'Mike Chrzanowski', 'Mohammad Shoeybi', 'Mostofa Patwary', 'Namit Dhameja', 'Nave Assaf', 'Negar Habibi', 'Nidhi Bhatia', 'Nikki Pope', 'Nima Tajbakhsh', 'Nirmal Kumar Juluru', 'Oleg Rybakov', 'Oleksii Hrinchuk', 'Oleksii Kuchaiev', 'Oluwatobi Olabiyi', 'Pablo Ribalta', 'Padmavathy Subramanian', 'Parth Chadha', 'Pavlo Molchanov', 'Peter Dykas', 'Peter Jin', 'Piotr Bialecki', 'Piotr Januszewski', 'Pradeep Thalasta', 'Prashant Gaikwad', 'Prasoon Varshney', 'Pritam Gundecha', 'Przemek Tredak', 'Rabeeh Karimi Mahabadi', 'Rajen Patel', 'Ran El-Yaniv', 'Ranjit Rajan', 'Ria Cheruvu', 'Rima Shahbazyan', 'Ritika Borkar', 'Ritu Gala', 'Roger Waleffe', 'Ruoxi Zhang', 'Russell J. Hewett', 'Ryan Prenger', 'Sahil Jain', 'Samuel Kriman', 'Sanjeev Satheesh', 'Saori Kaji', 'Sarah Yurick', 'Saurav Muralidharan', 'Sean Narenthiran', 'Seonmyeong Bak', 'Sepehr Sameni', 'Seungju Han', 'Shanmugam Ramasamy', 'Shaona Ghosh', 'Sharath Turuvekere Sreenivas', 'Shelby Thomas', 'Shizhe Diao', 'Shreya Gopal', 'Shrimai Prabhumoye', 'Shubham Toshniwal', 'Shuoyang Ding', 'Siddharth Singh', 'Siddhartha Jain', 'Somshubra Majumdar', 'Stefania Alborghetti', 'Syeda Nahida Akter', 'Terry Kong', 'Tim Moon', 'Tomasz Hliwiak', 'Tomer Asida', 'Tony Wang', 'Twinkle Vashishth', 'Tyler Poon', 'Udi Karpas', 'Vahid Noroozi', 'Venkat Srinivasan', 'Vijay Korthikanti', 'Vikram Fugro', 'Vineeth Kalluru', 'Vitaly Kurin', 'Vitaly Lavrukhin', 'Wasi Uddin Ahmad', 'Wei Du', 'Wonmin Byeon', 'Ximing Lu', 'Xin Dong', 'Yashaswi Karnati', 'Yejin Choi', 'Yian Zhang', 'Ying Lin', 'Yonggan Fu', 'Yoshi Suhara', 'Zhen Dong', 'Zhiyu Li', 'Zhongbo Zhu', 'Zijia Chen'], 'affiliations': ['NVIDIA'], 'pdf_title_img': 'assets/pdf/title_img/2508.14444.jpg', 'data': {'categories': ['#dataset', '#reasoning', '#optimization', '#training', '#inference', '#open_source', '#architecture'], 'emoji': '🧠', 'ru': {'title': 'Nemotron-Nano-9B-v2: Быстрее думай, лучше рассуждай', 'desc': 'Nemotron-Nano-9B-v2 - это гибридная модель языка, сочетающая архитектуры Mamba и Transformer. Она заменяет слои самовнимания на слои Mamba-2 для повышения скорости вывода при генерации длинных цепочек рассуждений. Модель была предобучена на 20 триллионах токенов, а затем сжата с использованием стратегии Minitron. Nemotron-Nano-9B-v2 демонстрирует сопоставимую или лучшую точность на тестах рассуждений по сравнению с аналогичными моделями, обеспечивая при этом до 6 раз более высокую производительность.'}, 'en': {'title': 'Boosting Reasoning Speed and Accuracy with Nemotron-Nano-9B-v2', 'desc': 'Nemotron-Nano-9B-v2 is a new hybrid Mamba-Transformer model that improves the speed and accuracy of reasoning tasks. It replaces traditional self-attention layers with Mamba-2 layers, which enhances inference speed for generating complex reasoning outputs. The model is pre-trained on a massive dataset and uses the Minitron strategy for effective compression, allowing it to handle large input sizes efficiently. As a result, Nemotron-Nano-9B-v2 achieves superior performance compared to similar models, offering up to 6 times higher throughput in reasoning scenarios.'}, 'zh': {'title': '提升推理效率与准确性的混合模型', 'desc': 'Nemotron-Nano-9B-v2是一种混合型Mamba-Transformer模型，旨在提高推理工作负载的吞吐量和准确性。该模型通过用Mamba-2层替换传统Transformer架构中的自注意力层，显著提升了推理速度。我们首先在20万亿个标记上预训练了一个120亿参数的模型，然后使用Minitron策略对其进行压缩和蒸馏，以支持在单个NVIDIA A10G GPU上进行128k标记的推理。与同类模型相比，Nemotron-Nano-9B-v2在推理基准测试中表现出相当或更好的准确性，同时在推理设置中实现了高达6倍的吞吐量提升。'}}}, {'id': 'https://huggingface.co/papers/2508.14160', 'title': 'RynnEC: Bringing MLLMs into Embodied World', 'url': 'https://huggingface.co/papers/2508.14160', 'abstract': 'RynnEC, a video multimodal large language model with a region-centric approach, achieves state-of-the-art performance in object property understanding, segmentation, and spatial reasoning, using an egocentric video pipeline and a region-centered benchmark.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce RynnEC, a video multimodal large language model designed for embodied cognition. Built upon a general-purpose vision-language foundation model, RynnEC incorporates a region encoder and a mask decoder, enabling flexible region-level video interaction. Despite its compact architecture, RynnEC achieves state-of-the-art performance in object property understanding, object segmentation, and spatial reasoning. Conceptually, it offers a region-centric video paradigm for the brain of embodied agents, providing fine-grained perception of the physical world and enabling more precise interactions. To mitigate the scarcity of annotated 3D datasets, we propose an egocentric video based pipeline for generating embodied cognition data. Furthermore, we introduce RynnEC-Bench, a region-centered benchmark for evaluating embodied cognitive capabilities. We anticipate that RynnEC will advance the development of general-purpose cognitive cores for embodied agents and facilitate generalization across diverse embodied tasks. The code, model checkpoints, and benchmark are available at: https://github.com/alibaba-damo-academy/RynnEC', 'score': 8, 'issue_id': 5463, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '258b579ad840bfef', 'authors': ['Ronghao Dang', 'Yuqian Yuan', 'Yunxuan Mao', 'Kehan Li', 'Jiangpin Liu', 'Zhikai Wang', 'Xin Li', 'Fan Wang', 'Deli Zhao'], 'affiliations': ['DAMO Academy, Alibaba Group', 'Hupan Lab', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2508.14160.jpg', 'data': {'categories': ['#optimization', '#benchmark', '#multimodal', '#agents', '#video', '#3d', '#games', '#agi', '#reasoning'], 'emoji': '🤖', 'ru': {'title': 'RynnEC: Новый уровень понимания видео для воплощенного ИИ', 'desc': 'RynnEC - это мультимодальная языковая модель большого масштаба для видео, использующая эгоцентрический подход к обработке регионов изображения. Модель достигает передовых результатов в понимании свойств объектов, сегментации и пространственных рассуждениях благодаря специальному конвейеру обработки эгоцентрического видео. RynnEC использует кодировщик регионов и декодер масок, что позволяет гибко взаимодействовать с видео на уровне отдельных областей. Для оценки когнитивных способностей модели авторы также представили специализированный набор тестов RynnEC-Bench.'}, 'en': {'title': 'RynnEC: Revolutionizing Embodied Cognition in Video Understanding', 'desc': 'RynnEC is a video multimodal large language model that focuses on understanding and interacting with objects in a spatial context. It uses a region-centric approach, which allows it to analyze video content at a detailed level, enhancing its ability to understand object properties and perform segmentation tasks. The model is built on a vision-language foundation and employs a region encoder and mask decoder for effective video interaction. By introducing an egocentric video pipeline and a dedicated benchmark, RynnEC aims to improve embodied cognition in AI, making it more adept at navigating and interpreting the physical world.'}, 'zh': {'title': 'RynnEC：具身认知的新视角', 'desc': 'RynnEC是一种视频多模态大语言模型，采用区域中心的方法，专注于物体属性理解、分割和空间推理。它基于通用的视觉-语言基础模型，结合区域编码器和掩码解码器，实现灵活的区域级视频交互。尽管架构紧凑，RynnEC在多个任务上表现出色，提供了对物理世界的细致感知。该模型还引入了基于自我中心视频的数据生成管道，以解决标注3D数据集稀缺的问题，并推出了RynnEC-Bench基准，用于评估具身认知能力。'}}}, {'id': 'https://huggingface.co/papers/2508.11408', 'title': 'On-Policy RL Meets Off-Policy Experts: Harmonizing Supervised\n  Fine-Tuning and Reinforcement Learning via Dynamic Weighting', 'url': 'https://huggingface.co/papers/2508.11408', 'abstract': "CHORD integrates supervised fine-tuning and reinforcement learning by dynamically weighting off-policy and on-policy data to improve model stability and performance.  \t\t\t\t\tAI-generated summary \t\t\t\t Supervised Fine-Tuning (SFT) and Reinforcement Learning (RL) are two prominent post-training paradigms for refining the capabilities and aligning the behavior of Large Language Models (LLMs). Existing approaches that integrate SFT and RL often face the risk of disrupting established model patterns and inducing overfitting to expert data. To address this, we present a novel investigation into the unified view of SFT and RL through an off-policy versus on-policy lens. We propose CHORD, a framework for the Controllable Harmonization of On- and Off-Policy Reinforcement Learning via Dynamic Weighting, which reframes SFT not as a separate stage but as a dynamically weighted auxiliary objective within the on-policy RL process. Based on an analysis of off-policy expert data's influence at both holistic and granular levels, we incorporate a dual-control mechanism in CHORD. Specifically, the framework first employs a global coefficient to holistically guide the transition from off-policy imitation to on-policy exploration, and then applies a token-wise weighting function that enables granular learning from expert tokens, which preserves on-policy exploration and mitigates disruption from off-policy data. We conduct extensive experiments on widely used benchmarks, providing empirical evidence that CHORD achieves a stable and efficient learning process. By effectively harmonizing off-policy expert data with on-policy exploration, CHORD demonstrates significant improvements over baselines. We release the implementation at https://github.com/modelscope/Trinity-RFT/tree/main/examples/mix_chord to inspire further research.", 'score': 4, 'issue_id': 5469, 'pub_date': '2025-08-15', 'pub_date_card': {'ru': '15 августа', 'en': 'August 15', 'zh': '8月15日'}, 'hash': 'fc29fb14c94c18eb', 'authors': ['Wenhao Zhang', 'Yuexiang Xie', 'Yuchang Sun', 'Yanxi Chen', 'Guoyin Wang', 'Yaliang Li', 'Bolin Ding', 'Jingren Zhou'], 'affiliations': ['Alibaba Group'], 'pdf_title_img': 'assets/pdf/title_img/2508.11408.jpg', 'data': {'categories': ['#rlhf', '#rl', '#training', '#optimization', '#benchmark'], 'emoji': '🎼', 'ru': {'title': 'Гармоничное объединение обучения с учителем и с подкреплением для больших языковых моделей', 'desc': 'Статья представляет новый метод CHORD для интеграции обучения с учителем и обучения с подкреплением в контексте больших языковых моделей. CHORD динамически взвешивает офф-полиси и он-полиси данные, что позволяет улучшить стабильность и производительность модели. Метод использует глобальный коэффициент для перехода от имитации к исследованию, а также токен-специфичную функцию взвешивания. Эксперименты показывают, что CHORD достигает значительных улучшений по сравнению с базовыми методами.'}, 'en': {'title': "Harmonizing Learning: CHORD's Dynamic Integration of SFT and RL", 'desc': "CHORD is a new framework that combines supervised fine-tuning (SFT) and reinforcement learning (RL) to enhance the performance of large language models. It addresses the common issue of model instability and overfitting by dynamically adjusting the influence of off-policy and on-policy data during training. By treating SFT as a flexible part of the RL process, CHORD allows for better integration of expert data while maintaining effective exploration. The framework's dual-control mechanism ensures that learning is both stable and efficient, leading to improved outcomes in various benchmarks."}, 'zh': {'title': '动态加权，提升模型稳定性与性能', 'desc': 'CHORD框架通过动态加权的方式，将监督微调（SFT）和强化学习（RL）结合起来，以提高模型的稳定性和性能。该方法将SFT视为在强化学习过程中动态加权的辅助目标，而不是一个独立的阶段。CHORD采用双重控制机制，首先通过全局系数引导从离策略模仿到在策略探索的过渡，然后通过逐标记加权函数实现对专家标记的细粒度学习。实验结果表明，CHORD在多个基准测试中表现出显著的学习稳定性和效率提升。'}}}, {'id': 'https://huggingface.co/papers/2508.13680', 'title': 'ViExam: Are Vision Language Models Better than Humans on Vietnamese\n  Multimodal Exam Questions?', 'url': 'https://huggingface.co/papers/2508.13680', 'abstract': 'VLMs perform poorly on Vietnamese educational assessments, with state-of-the-art models achieving lower accuracy than human test-takers, and cross-lingual prompting does not significantly improve performance.  \t\t\t\t\tAI-generated summary \t\t\t\t Vision language models (VLMs) demonstrate remarkable capabilities on English multimodal tasks, but their performance on low-resource languages with genuinely multimodal educational content remains largely unexplored. In this work, we test how VLMs perform on Vietnamese educational assessments, investigating whether VLMs trained predominantly on English data can handle real-world cross-lingual multimodal reasoning. Our work presents the first comprehensive evaluation of VLM capabilities on multimodal Vietnamese exams through proposing ViExam, a benchmark containing 2,548 multimodal questions. We find that state-of-the-art VLMs achieve only 57.74% while open-source models achieve 27.70% mean accuracy across 7 academic domains, including Mathematics, Physics, Chemistry, Biology, Geography, Driving Test, and IQ Test. Most VLMs underperform average human test-takers (66.54%), with only the thinking VLM o3 (74.07%) exceeding human average performance, yet still falling substantially short of human best performance (99.60%). Cross-lingual prompting with English instructions while maintaining Vietnamese content fails to improve performance, decreasing accuracy by 1 percentage point for SOTA VLMs. Human-in-the-loop collaboration can partially improve VLM performance by 5 percentage points. Code and data are available at: https://vi-exam.github.io.', 'score': 3, 'issue_id': 5469, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '22f47e31363b1059', 'authors': ['Vy Tuong Dang', 'An Vo', 'Quang Tau', 'Duc Dm', 'Daeyoung Kim'], 'affiliations': ['KAIST'], 'pdf_title_img': 'assets/pdf/title_img/2508.13680.jpg', 'data': {'categories': ['#low_resource', '#open_source', '#benchmark', '#multilingual', '#dataset'], 'emoji': '🇻🇳', 'ru': {'title': 'VLM отстают от людей на вьетнамских образовательных тестах', 'desc': 'Исследование оценивает производительность визуально-языковых моделей (VLM) на вьетнамских образовательных тестах. Создан бенчмарк ViExam, содержащий 2,548 мультимодальных вопросов по 7 академическим областям. Результаты показывают, что современные VLM достигают точности только 57.74%, что ниже среднего результата человека (66.54%). Кросс-языковые подсказки на английском не улучшают производительность моделей.'}, 'en': {'title': 'Bridging the Gap: VLMs Struggle with Vietnamese Education', 'desc': 'This paper evaluates the performance of Vision Language Models (VLMs) on Vietnamese educational assessments, revealing that these models struggle significantly compared to human test-takers. The study introduces ViExam, a benchmark with 2,548 multimodal questions across various academic domains, highlighting that state-of-the-art VLMs achieve only 57.74% accuracy. Despite attempts to enhance performance through cross-lingual prompting, results show a decline in accuracy, indicating that VLMs trained on English data are not effectively handling Vietnamese content. The findings suggest that while human-in-the-loop strategies can improve outcomes, VLMs still fall short of human performance, emphasizing the need for better adaptation to low-resource languages.'}, 'zh': {'title': '越南教育评估中的视觉语言模型表现不佳', 'desc': '本研究探讨了视觉语言模型（VLMs）在越南教育评估中的表现，发现这些模型在处理低资源语言的多模态内容时效果不佳。尽管在英语多模态任务上表现出色，但在越南的多模态考试中，最先进的模型仅达到57.74%的准确率，远低于人类考生的66.54%。我们提出了ViExam基准，包含2548个多模态问题，以全面评估VLM在越南教育中的能力。研究还发现，跨语言提示并未显著提高模型性能，反而使准确率下降。'}}}, {'id': 'https://huggingface.co/papers/2508.12594', 'title': 'FLARE: Fast Low-rank Attention Routing Engine', 'url': 'https://huggingface.co/papers/2508.12594', 'abstract': 'FLARE, a linear complexity self-attention mechanism, improves scalability and accuracy for large unstructured meshes and neural PDE surrogates.  \t\t\t\t\tAI-generated summary \t\t\t\t The quadratic complexity of self-attention limits its applicability and scalability on large unstructured meshes. We introduce Fast Low-rank Attention Routing Engine (FLARE), a linear complexity self-attention mechanism that routes attention through fixed-length latent sequences. Each attention head performs global communication among N tokens by projecting the input sequence onto a fixed length latent sequence of M ll N tokens using learnable query tokens. By routing attention through a bottleneck sequence, FLARE learns a low-rank form of attention that can be applied at O(NM) cost. FLARE not only scales to unprecedented problem sizes, but also delivers superior accuracy compared to state-of-the-art neural PDE surrogates across diverse benchmarks. We also release a new additive manufacturing dataset to spur further research. Our code is available at https://github.com/vpuri3/FLARE.py.', 'score': 2, 'issue_id': 5478, 'pub_date': '2025-08-18', 'pub_date_card': {'ru': '18 августа', 'en': 'August 18', 'zh': '8月18日'}, 'hash': 'fe9ac6b4069fae4d', 'authors': ['Vedant Puri', 'Aditya Joglekar', 'Kevin Ferguson', 'Yu-hsuan Chen', 'Yongjie Jessica Zhang', 'Levent Burak Kara'], 'affiliations': ['Mechanical Engineering, Carnegie Mellon University, Pittsburgh, PA 15213, USA'], 'pdf_title_img': 'assets/pdf/title_img/2508.12594.jpg', 'data': {'categories': ['#open_source', '#architecture', '#benchmark', '#dataset', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'FLARE: эффективное внимание для масштабных задач машинного обучения', 'desc': 'Статья представляет FLARE - механизм самовнимания с линейной сложностью, который улучшает масштабируемость и точность для больших неструктурированных сеток и нейронных суррогатов дифференциальных уравнений в частных производных (PDE). FLARE маршрутизирует внимание через последовательности фиксированной длины, что позволяет обрабатывать большие объемы данных с меньшими вычислительными затратами. Этот подход превосходит современные методы по точности на различных тестах. Авторы также представили новый набор данных для аддитивного производства для дальнейших исследований в этой области.'}, 'en': {'title': 'FLARE: Scalable Self-Attention for Large-Scale Problems', 'desc': 'FLARE is a new self-attention mechanism designed to handle large unstructured meshes efficiently. Unlike traditional self-attention, which has quadratic complexity, FLARE operates with linear complexity by using fixed-length latent sequences. This allows it to manage global communication among tokens more effectively while maintaining high accuracy. Additionally, FLARE demonstrates improved performance over existing neural PDE surrogates and introduces a new dataset for additive manufacturing research.'}, 'zh': {'title': 'FLARE：高效的自注意力机制', 'desc': 'FLARE是一种线性复杂度的自注意力机制，旨在提高大规模非结构化网格和神经偏微分方程代理模型的可扩展性和准确性。传统的自注意力机制由于其二次复杂度，限制了在大规模数据上的应用。FLARE通过固定长度的潜在序列来路由注意力，从而实现O(NM)的计算成本，显著提高了效率。该方法在多个基准测试中表现出优越的准确性，并且我们还发布了一个新的增材制造数据集以促进进一步研究。'}}}, {'id': 'https://huggingface.co/papers/2508.14568', 'title': 'Leuvenshtein: Efficient FHE-based Edit Distance Computation with Single\n  Bootstrap per Cell', 'url': 'https://huggingface.co/papers/2508.14568', 'abstract': 'An optimized algorithm reduces the computational cost of edit distance calculations within Fully Homomorphic Encryption, achieving significant performance improvements over existing methods.  \t\t\t\t\tAI-generated summary \t\t\t\t This paper presents a novel approach to calculating the Levenshtein (edit) distance within the framework of Fully Homomorphic Encryption (FHE), specifically targeting third-generation schemes like TFHE. Edit distance computations are essential in applications across finance and genomics, such as DNA sequence alignment. We introduce an optimised algorithm that significantly reduces the cost of edit distance calculations called Leuvenshtein. This algorithm specifically reduces the number of programmable bootstraps (PBS) needed per cell of the calculation, lowering it from approximately 94 operations -- required by the conventional Wagner-Fisher algorithm -- to just 1. Additionally, we propose an efficient method for performing equality checks on characters, reducing ASCII character comparisons to only 2 PBS operations. Finally, we explore the potential for further performance improvements by utilising preprocessing when one of the input strings is unencrypted. Our Leuvenshtein achieves up to 278times faster performance compared to the best available TFHE implementation and up to 39times faster than an optimised implementation of the Wagner-Fisher algorithm. Moreover, when offline preprocessing is possible due to the presence of one unencrypted input on the server side, an additional 3times speedup can be achieved.', 'score': 1, 'issue_id': 5472, 'pub_date': '2025-08-20', 'pub_date_card': {'ru': '20 августа', 'en': 'August 20', 'zh': '8月20日'}, 'hash': '35c61f400b940676', 'authors': ['Wouter Legiest', "Jan-Pieter D'Anvers", 'Bojan Spasic', 'Nam-Luc Tran', 'Ingrid Verbauwhede'], 'affiliations': ['COSIC, KU Leuven', 'Society for Worldwide Interbank Financial Telecommunication (Swift)'], 'pdf_title_img': 'assets/pdf/title_img/2508.14568.jpg', 'data': {'categories': ['#inference', '#math', '#data', '#optimization'], 'emoji': '🔐', 'ru': {'title': 'Революционное ускорение вычисления расстояния Левенштейна в гомоморфной криптографии', 'desc': 'Статья представляет новый подход к вычислению расстояния Левенштейна в рамках полностью гомоморфной криптографии (FHE). Авторы разработали оптимизированный алгоритм Leuvenshtein, который значительно снижает количество операций программируемого бутстрапа (PBS) на ячейку расчета. Предложенный метод достигает производительности до 278 раз быстрее по сравнению с лучшей доступной реализацией TFHE. Кроме того, исследователи изучили возможности дальнейшего повышения производительности за счет предварительной обработки, когда одна из входных строк не зашифрована.'}, 'en': {'title': 'Revolutionizing Edit Distance with Leuvenshtein in FHE', 'desc': 'This paper introduces an optimized algorithm for calculating the Levenshtein (edit) distance within Fully Homomorphic Encryption (FHE), focusing on third-generation schemes like TFHE. The proposed algorithm, named Leuvenshtein, significantly reduces the number of programmable bootstraps (PBS) required for each calculation cell, dropping from 94 operations to just 1. It also enhances character equality checks, minimizing ASCII comparisons to only 2 PBS operations. Overall, Leuvenshtein demonstrates up to 278 times faster performance than existing TFHE implementations and offers additional speed improvements with preprocessing when one input is unencrypted.'}, 'zh': {'title': '优化算法提升同态加密下编辑距离计算效率', 'desc': '本文提出了一种在完全同态加密（FHE）框架下计算Levenshtein（编辑）距离的新方法，特别针对第三代方案如TFHE。我们引入了一种优化算法Leuvenshtein，显著降低了编辑距离计算的成本，将传统Wagner-Fisher算法所需的约94次可编程引导操作减少到仅1次。此外，我们还提出了一种高效的方法来进行字符的相等性检查，将ASCII字符比较减少到仅2次PBS操作。通过利用预处理，当输入字符串之一未加密时，我们的算法在性能上实现了高达278倍的加速。'}}}, {'id': 'https://huggingface.co/papers/2508.14187', 'title': 'Local Scale Equivariance with Latent Deep Equilibrium Canonicalizer', 'url': 'https://huggingface.co/papers/2508.14187', 'abstract': 'A deep equilibrium canonicalizer (DEC) enhances local scale equivariance in deep networks, improving performance and consistency on ImageNet.  \t\t\t\t\tAI-generated summary \t\t\t\t Scale variation is a fundamental challenge in computer vision. Objects of the same class can have different sizes, and their perceived size is further affected by the distance from the camera. These variations are local to the objects, i.e., different object sizes may change differently within the same image. To effectively handle scale variations, we present a deep equilibrium canonicalizer (DEC) to improve the local scale equivariance of a model. DEC can be easily incorporated into existing network architectures and can be adapted to a pre-trained model. Notably, we show that on the competitive ImageNet benchmark, DEC improves both model performance and local scale consistency across four popular pre-trained deep-nets, e.g., ViT, DeiT, Swin, and BEiT. Our code is available at https://github.com/ashiq24/local-scale-equivariance.', 'score': 1, 'issue_id': 5465, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '2c40f3bf2246afa6', 'authors': ['Md Ashiqur Rahman', 'Chiao-An Yang', 'Michael N. Cheng', 'Lim Jun Hao', 'Jeremiah Jiang', 'Teck-Yian Lim', 'Raymond A. Yeh'], 'affiliations': ['DSO National Laboratories', 'Department of Computer Science, Purdue University'], 'pdf_title_img': 'assets/pdf/title_img/2508.14187.jpg', 'data': {'categories': ['#cv', '#benchmark', '#architecture'], 'emoji': '🔍', 'ru': {'title': 'Повышение устойчивости нейросетей к изменениям масштаба объектов', 'desc': 'Статья представляет глубокий эквилибриумный канонизатор (DEC) для улучшения локальной масштабной эквивариантности в глубоких нейронных сетях. DEC решает проблему вариации масштаба объектов в компьютерном зрении, которая влияет на эффективность распознавания. Метод легко интегрируется в существующие архитектуры и может быть адаптирован к предобученным моделям. Эксперименты на ImageNet показывают, что DEC улучшает как производительность, так и локальную масштабную согласованность для популярных архитектур, включая ViT, DeiT, Swin и BEiT.'}, 'en': {'title': 'Enhancing Scale Consistency in Deep Learning with DEC', 'desc': 'The paper introduces a method called Deep Equilibrium Canonicalizer (DEC) that enhances local scale equivariance in deep learning models. Scale variation is a significant issue in computer vision, as objects of the same class can appear in different sizes due to their distance from the camera. DEC addresses this challenge by improving how models respond to these local scale changes, leading to better performance and consistency. The method can be integrated into existing architectures and has shown to improve results on the ImageNet benchmark across several popular pre-trained networks.'}, 'zh': {'title': '提升深度网络的局部尺度等变性', 'desc': '深平衡规范化器（DEC）增强了深度网络的局部尺度等变性，从而提高了在ImageNet上的性能和一致性。尺度变化是计算机视觉中的一个基本挑战，同一类物体可能具有不同的大小。DEC能够有效处理这些局部尺度变化，并且可以轻松地集成到现有的网络架构中。我们的实验表明，DEC在多个流行的预训练深度网络上都能显著提升模型性能和局部尺度一致性。'}}}, {'id': 'https://huggingface.co/papers/2508.10137', 'title': 'mSCoRe: a Multilingual and Scalable Benchmark for Skill-based\n  Commonsense Reasoning', 'url': 'https://huggingface.co/papers/2508.10137', 'abstract': "A multilingual benchmark evaluates the reasoning skills of large language models across different languages and cultures, revealing their limitations in nuanced commonsense understanding.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advancements in reasoning-reinforced Large Language Models (LLMs) have shown remarkable capabilities in complex reasoning tasks. However, the mechanism underlying their utilization of different human reasoning skills remains poorly investigated, especially for multilingual commonsense reasoning that involves everyday knowledge across different languages and cultures. To address this gap, we propose a Multilingual and Scalable Benchmark for Skill-based Commonsense Reasoning (mSCoRe). Our benchmark incorporates three key components that are designed to systematically evaluate LLM's reasoning capabilities, including: (1) a novel taxonomy of reasoning skills that enables fine-grained analysis of models' reasoning processes, (2) a robust data synthesis pipeline tailored specifically for commonsense reasoning evaluation, and (3) a complexity scaling framework allowing task difficulty to scale dynamically alongside future improvements in LLM abilities. Extensive experiments on eights state-of-the-art LLMs of varying sizes and training approaches demonstrate that mSCoRe remains significantly challenging for current models, particularly at higher complexity levels. Our results reveal the limitations of such reasoning-reinforced models when confronted with nuanced multilingual general and cultural commonsense. We further provide detailed analysis on the models' reasoning processes, suggesting future directions for improving multilingual commonsense reasoning capabilities.", 'score': 1, 'issue_id': 5466, 'pub_date': '2025-08-13', 'pub_date_card': {'ru': '13 августа', 'en': 'August 13', 'zh': '8月13日'}, 'hash': '453de98ba64e303d', 'authors': ['Nghia Trung Ngo', 'Franck Dernoncourt', 'Thien Huu Nguyen'], 'affiliations': ['Adobe Research, USA', 'Department of Computer Science, University of Oregon, Eugene, OR, USA'], 'pdf_title_img': 'assets/pdf/title_img/2508.10137.jpg', 'data': {'categories': ['#survey', '#benchmark', '#multilingual', '#reasoning'], 'emoji': '🌍', 'ru': {'title': 'Многоязычный тест раскрывает пробелы в здравом смысле ИИ', 'desc': 'Предложен многоязычный эталонный тест mSCoRe для оценки навыков рассуждений больших языковых моделей (LLM) в разных языках и культурах. Тест включает таксономию навыков рассуждений, конвейер синтеза данных и масштабируемую структуру сложности задач. Эксперименты на восьми современных LLM показали значительные трудности моделей, особенно на высоких уровнях сложности. Результаты выявили ограничения моделей в понимании нюансов многоязычного здравого смысла.'}, 'en': {'title': 'Enhancing Multilingual Reasoning in AI Models', 'desc': 'This paper introduces a new benchmark called mSCoRe, designed to evaluate the reasoning skills of large language models (LLMs) in a multilingual context. It features a unique taxonomy of reasoning skills for detailed analysis, a data synthesis pipeline for commonsense reasoning, and a framework to adjust task difficulty as LLMs improve. The study shows that current LLMs struggle with nuanced commonsense understanding across different languages and cultures, especially at higher complexity levels. The findings highlight the need for further advancements in multilingual reasoning capabilities for AI models.'}, 'zh': {'title': '多语言常识推理能力的评估与提升', 'desc': '这篇论文提出了一个多语言和可扩展的基准测试，旨在评估大型语言模型在不同语言和文化中的推理能力。研究发现，尽管这些模型在复杂推理任务上表现出色，但在细微的常识理解方面仍存在局限性。基准测试包括三大核心组件，帮助系统性地评估模型的推理能力。通过对八种不同规模和训练方法的最先进模型进行广泛实验，结果显示当前模型在高复杂度任务中面临显著挑战。'}}}, {'id': 'https://huggingface.co/papers/2508.13745', 'title': 'Refining Contrastive Learning and Homography Relations for Multi-Modal\n  Recommendation', 'url': 'https://huggingface.co/papers/2508.13745', 'abstract': 'A novel framework, REARM, enhances multi-modal recommender systems by refining contrastive learning and homography relations, improving feature representation and user-item interaction mining.  \t\t\t\t\tAI-generated summary \t\t\t\t Multi-modal recommender system focuses on utilizing rich modal information ( i.e., images and textual descriptions) of items to improve recommendation performance. The current methods have achieved remarkable success with the powerful structure modeling capability of graph neural networks. However, these methods are often hindered by sparse data in real-world scenarios. Although contrastive learning and homography ( i.e., homogeneous graphs) are employed to address the data sparsity challenge, existing methods still suffer two main limitations: 1) Simple multi-modal feature contrasts fail to produce effective representations, causing noisy modal-shared features and loss of valuable information in modal-unique features; 2) The lack of exploration of the homograph relations between user interests and item co-occurrence results in incomplete mining of user-item interplay.   To address the above limitations, we propose a novel framework for REfining multi-modAl contRastive learning and hoMography relations (REARM). Specifically, we complement multi-modal contrastive learning by employing meta-network and orthogonal constraint strategies, which filter out noise in modal-shared features and retain recommendation-relevant information in modal-unique features. To mine homogeneous relationships effectively, we integrate a newly constructed user interest graph and an item co-occurrence graph with the existing user co-occurrence and item semantic graphs for graph learning. The extensive experiments on three real-world datasets demonstrate the superiority of REARM to various state-of-the-art baselines. Our visualization further shows an improvement made by REARM in distinguishing between modal-shared and modal-unique features. Code is available https://github.com/MrShouxingMa/REARM{here}.', 'score': 0, 'issue_id': 5467, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': 'fc6507087d3e99bc', 'authors': ['Shouxing Ma', 'Yawen Zeng', 'Shiqing Wu', 'Guandong Xu'], 'affiliations': ['Faculty of Data Science City University of Macau, Macau SAR, China', 'Hunan University, Changsha, China', 'The Education University of Hong Kong, Hong Kong SAR, China', 'University of Technology Sydney, Sydney, Australia'], 'pdf_title_img': 'assets/pdf/title_img/2508.13745.jpg', 'data': {'categories': ['#dataset', '#multimodal', '#graphs', '#optimization', '#games'], 'emoji': '🎯', 'ru': {'title': 'Точные рекомендации через улучшенное мультимодальное обучение', 'desc': 'REARM - это новая система для улучшения мультимодальных рекомендательных систем. Она использует усовершенствованное контрастивное обучение и гомографические отношения для улучшения представления признаков и анализа взаимодействия пользователей с элементами. REARM применяет мета-сеть и ортогональные ограничения для фильтрации шума в общих признаках модальностей и сохранения релевантной информации в уникальных признаках. Система также интегрирует графы интересов пользователей и совместного появления элементов для более эффективного обучения на графах.'}, 'en': {'title': 'Enhancing Recommendations with REARM: A New Approach to Multi-Modal Learning', 'desc': 'The paper introduces REARM, a new framework designed to enhance multi-modal recommender systems by improving contrastive learning and homography relations. It addresses two main issues: ineffective representation from simple multi-modal contrasts and incomplete mining of user-item interactions. By using meta-networks and orthogonal constraints, REARM filters out noise and retains important information from unique features. The framework also integrates various graphs to better capture user interests and item co-occurrences, leading to superior performance in recommendation tasks.'}, 'zh': {'title': '提升多模态推荐系统的REARM框架', 'desc': '本文提出了一种新颖的框架REARM，旨在增强多模态推荐系统的性能。通过改进对比学习和同质关系，REARM能够更好地提取特征表示和挖掘用户与物品之间的互动。该框架采用元网络和正交约束策略，有效过滤噪声特征，保留与推荐相关的信息。实验结果表明，REARM在多个真实数据集上优于现有的最先进方法。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (4)', '#agents (4)', '#agi (1)', '#alignment', '#architecture (3)', '#audio', '#benchmark (9)', '#cv (1)', '#data (1)', '#dataset (7)', '#diffusion (2)', '#ethics', '#games (2)', '#graphs (1)', '#hallucinations', '#healthcare (1)', '#inference (3)', '#interpretability (1)', '#leakage', '#long_context (1)', '#low_resource (1)', '#machine_translation (1)', '#math (1)', '#multilingual (2)', '#multimodal (4)', '#open_source (6)', '#optimization (9)', '#plp', '#rag', '#reasoning (7)', '#rl (2)', '#rlhf (2)', '#robotics', '#science (2)', '#security', '#small_models', '#story_generation', '#survey (3)', '#synthetic (1)', '#training (4)', '#transfer_learning', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-08-21 19:09',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-08-21 19:09')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-08-21 19:09')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    