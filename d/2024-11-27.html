
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 18 papers. November 27.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            flex: 1 0 auto;
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 0 20px 0;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .article-content {
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
        }
        body.dark-theme>div>main>article {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article {
            background-color: #fff;
        }
        body.dark-theme>div>main>article:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 0px;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
                margin: 0 -20px;
            }
            footer {
                margin-top: -20px;
            }
            article {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">27 ноября</span> | <span id="title-articles-count">18 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item" id="nav-prev"><a href="/d/2024-11-26.html">⬅️ <span id="prev-date">26.11</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-11-28.html">➡️ <span id="next-date">28.11</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2024-11.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '27 ноября', 'en': 'November 27', 'zh': '11月27日'};
        let feedDateNext = {'ru': '28.11', 'en': '11/28', 'zh': '11月28日'};
        let feedDatePrev = {'ru': '26.11', 'en': '11/26', 'zh': '11月26日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2411.17465', 'title': 'ShowUI: One Vision-Language-Action Model for GUI Visual Agent', 'url': 'https://huggingface.co/papers/2411.17465', 'abstract': 'Building Graphical User Interface (GUI) assistants holds significant promise for enhancing human workflow productivity. While most agents are language-based, relying on closed-source API with text-rich meta-information (e.g., HTML or accessibility tree), they show limitations in perceiving UI visuals as humans do, highlighting the need for GUI visual agents. In this work, we develop a vision-language-action model in digital world, namely ShowUI, which features the following innovations: (i) UI-Guided Visual Token Selection to reduce computational costs by formulating screenshots as an UI connected graph, adaptively identifying their redundant relationship and serve as the criteria for token selection during self-attention blocks; (ii) Interleaved Vision-Language-Action Streaming that flexibly unifies diverse needs within GUI tasks, enabling effective management of visual-action history in navigation or pairing multi-turn query-action sequences per screenshot to enhance training efficiency; (iii) Small-scale High-quality GUI Instruction-following Datasets by careful data curation and employing a resampling strategy to address significant data type imbalances. With above components, ShowUI, a lightweight 2B model using 256K data, achieves a strong 75.1% accuracy in zero-shot screenshot grounding. Its UI-guided token selection further reduces 33% of redundant visual tokens during training and speeds up the performance by 1.4x. Navigation experiments across web Mind2Web, mobile AITW, and online MiniWob environments further underscore the effectiveness and potential of our model in advancing GUI visual agents. The models are available at https://github.com/showlab/ShowUI.', 'score': 43, 'issue_id': 803, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '372a78043d62af12', 'authors': ['Kevin Qinghong Lin', 'Linjie Li', 'Difei Gao', 'Zhengyuan Yang', 'Shiwei Wu', 'Zechen Bai', 'Weixian Lei', 'Lijuan Wang', 'Mike Zheng Shou'], 'affiliations': ['Microsoft', 'Show Lab, National University of Singapore'], 'pdf_title_img': 'assets/pdf/title_img/2411.17465.jpg', 'data': {'categories': ['#training', '#data', '#games', '#optimization', '#cv', '#agents', '#graphs', '#dataset'], 'emoji': '🖥️', 'ru': {'title': 'ShowUI: Революция в создании интеллектуальных графических интерфейсов', 'desc': 'Статья представляет ShowUI - модель для создания графических пользовательских интерфейсов (GUI) с использованием искусственного интеллекта. Модель использует инновационный подход к выбору визуальных токенов на основе структуры интерфейса, что позволяет снизить вычислительные затраты. ShowUI объединяет зрение, язык и действия в потоковом режиме, что делает ее эффективной для различных задач GUI. Модель достигает точности 75.1% при нулевом обучении в задаче локализации элементов на скриншотах, используя всего 256 тысяч примеров для обучения.'}, 'en': {'title': 'Empowering GUI Assistants with Visual Intelligence', 'desc': "This paper introduces ShowUI, a vision-language-action model designed to improve GUI assistant capabilities by better understanding visual elements. It innovates with UI-Guided Visual Token Selection to optimize computational efficiency by treating screenshots as connected graphs, which helps in selecting relevant visual tokens. Additionally, it employs Interleaved Vision-Language-Action Streaming to manage visual-action history effectively, enhancing the model's ability to handle complex GUI tasks. The model demonstrates strong performance with a 75.1% accuracy in zero-shot screenshot grounding and significantly reduces redundant visual tokens during training, showcasing its potential in advancing GUI visual agents."}, 'zh': {'title': '提升GUI助手效率的视觉-语言-行动模型', 'desc': '本研究提出了一种新的视觉-语言-行动模型，名为ShowUI，旨在提升图形用户界面（GUI）助手的效率。该模型通过UI引导的视觉标记选择，减少了计算成本，并在自注意力模块中优化了标记选择过程。ShowUI还实现了交错的视觉-语言-行动流，灵活处理GUI任务中的多样需求，提高了训练效率。通过精心的数据整理和重采样策略，ShowUI在零样本截图定位中达到了75.1%的准确率，展示了其在GUI视觉代理领域的潜力。'}}}, {'id': 'https://huggingface.co/papers/2411.17116', 'title': 'Star Attention: Efficient LLM Inference over Long Sequences', 'url': 'https://huggingface.co/papers/2411.17116', 'abstract': 'Inference with Transformer-based Large Language Models (LLMs) on long sequences is both costly and slow due to the quadratic complexity of the self-attention mechanism. We introduce Star Attention, a two-phase block-sparse approximation that improves computational efficiency by sharding attention across multiple hosts while minimizing communication overhead. In the first phase, the context is processed using blockwise-local attention across hosts, in parallel. In the second phase, query and response tokens attend to all prior cached tokens through sequence-global attention. Star Attention integrates seamlessly with most Transformer-based LLMs trained with global attention, reducing memory requirements and inference time by up to 11x while preserving 95-100% of accuracy.', 'score': 24, 'issue_id': 802, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '12194d270104d50f', 'authors': ['Shantanu Acharya', 'Fei Jia', 'Boris Ginsburg'], 'affiliations': ['NVIDIA'], 'pdf_title_img': 'assets/pdf/title_img/2411.17116.jpg', 'data': {'categories': ['#long_context', '#inference', '#optimization', '#architecture'], 'emoji': '⭐', 'ru': {'title': 'Звездное внимание: ускорение LLM без потери точности', 'desc': 'Статья представляет метод Star Attention для улучшения эффективности вычислений в трансформерных моделях большого языка (LLM) при работе с длинными последовательностями. Метод использует двухфазное блочно-разреженное приближение, распределяя внимание между несколькими узлами и минимизируя накладные расходы на коммуникацию. Star Attention сочетает локальное блочное внимание на первой фазе и глобальное внимание на второй фазе. Этот подход позволяет снизить требования к памяти и время вывода до 11 раз при сохранении 95-100% точности.'}, 'en': {'title': 'Boosting Efficiency in Long Sequence Processing with Star Attention', 'desc': "This paper presents Star Attention, a new method designed to enhance the efficiency of Transformer-based Large Language Models (LLMs) when processing long sequences. It addresses the high computational cost and slow inference times caused by the traditional self-attention mechanism's quadratic complexity. Star Attention operates in two phases: first, it uses blockwise-local attention to process context in parallel across multiple hosts, and then it applies sequence-global attention for query and response tokens. This approach significantly reduces memory usage and inference time by up to 11 times while maintaining a high level of accuracy, making it a valuable advancement in the field of machine learning."}, 'zh': {'title': '星际注意力：提升长序列推理效率的创新方法', 'desc': '本文介绍了一种名为星际注意力（Star Attention）的新方法，旨在提高基于变换器的大型语言模型（LLM）在长序列上的推理效率。该方法通过在多个主机之间分片注意力，采用两阶段的块稀疏近似，显著降低了计算成本。第一阶段使用块局部注意力并行处理上下文，第二阶段则通过全局注意力处理查询和响应标记。星际注意力与大多数使用全局注意力训练的变换器模型无缝集成，能够将内存需求和推理时间减少多达11倍，同时保持95-100%的准确率。'}}}, {'id': 'https://huggingface.co/papers/2411.16819', 'title': 'Pathways on the Image Manifold: Image Editing via Video Generation', 'url': 'https://huggingface.co/papers/2411.16819', 'abstract': "Recent advances in image editing, driven by image diffusion models, have shown remarkable progress. However, significant challenges remain, as these models often struggle to follow complex edit instructions accurately and frequently compromise fidelity by altering key elements of the original image. Simultaneously, video generation has made remarkable strides, with models that effectively function as consistent and continuous world simulators. In this paper, we propose merging these two fields by utilizing image-to-video models for image editing. We reformulate image editing as a temporal process, using pretrained video models to create smooth transitions from the original image to the desired edit. This approach traverses the image manifold continuously, ensuring consistent edits while preserving the original image's key aspects. Our approach achieves state-of-the-art results on text-based image editing, demonstrating significant improvements in both edit accuracy and image preservation.", 'score': 21, 'issue_id': 808, 'pub_date': '2024-11-25', 'pub_date_card': {'ru': '25 ноября', 'en': 'November 25', 'zh': '11月25日'}, 'hash': '4c5f3c4f6e2e545b', 'authors': ['Noam Rotstein', 'Gal Yona', 'Daniel Silver', 'Roy Velich', 'David Bensaïd', 'Ron Kimmel'], 'affiliations': ['Technion - Israel Institute of Technology'], 'pdf_title_img': 'assets/pdf/title_img/2411.16819.jpg', 'data': {'categories': ['#diffusion', '#video', '#cv', '#multimodal'], 'emoji': '🎬', 'ru': {'title': 'Редактирование изображений через призму видео: новый взгляд на старую задачу', 'desc': 'Эта статья предлагает новый подход к редактированию изображений с использованием моделей генерации видео. Авторы переосмысливают процесс редактирования как временной, создавая плавный переход от исходного изображения к отредактированному. Этот метод позволяет сохранить ключевые аспекты оригинального изображения и обеспечивает более точное выполнение сложных инструкций по редактированию. Результаты показывают значительное улучшение как в точности редактирования, так и в сохранении исходного изображения по сравнению с существующими методами.'}, 'en': {'title': 'Seamless Image Editing through Video Model Integration', 'desc': 'This paper addresses the challenges in image editing using diffusion models, which often fail to accurately follow complex instructions and can distort important image features. The authors propose a novel approach that combines image editing with video generation by treating image editing as a temporal process. By leveraging pretrained video models, they create smooth transitions from the original image to the edited version, ensuring that key elements are preserved. Their method achieves state-of-the-art performance in text-based image editing, significantly enhancing both the accuracy of edits and the fidelity of the original image.'}, 'zh': {'title': '图像编辑与视频生成的完美结合', 'desc': '本文提出了一种将图像编辑与视频生成相结合的方法。我们将图像编辑重新定义为一个时间过程，利用预训练的视频模型实现从原始图像到目标编辑的平滑过渡。通过这种方法，我们能够在保持原始图像关键特征的同时，确保编辑的一致性。实验结果表明，我们的方法在基于文本的图像编辑任务中达到了最先进的效果，显著提高了编辑的准确性和图像的保真度。'}}}, {'id': 'https://huggingface.co/papers/2411.17686', 'title': 'Rethinking Token Reduction in MLLMs: Towards a Unified Paradigm for Training-Free Acceleration', 'url': 'https://huggingface.co/papers/2411.17686', 'abstract': "To accelerate the inference of heavy Multimodal Large Language Models (MLLMs), this study rethinks the current landscape of training-free token reduction research. We regret to find that the critical components of existing methods are tightly intertwined, with their interconnections and effects remaining unclear for comparison, transfer, and expansion. Therefore, we propose a unified ''filter-correlate-compress'' paradigm that decomposes the token reduction into three distinct stages within a pipeline, maintaining consistent design objectives and elements while allowing for unique implementations. We additionally demystify the popular works and subsume them into our paradigm to showcase its universality. Finally, we offer a suite of methods grounded in the paradigm, striking a balance between speed and accuracy throughout different phases of the inference. Experimental results across 10 benchmarks indicate that our methods can achieve up to an 82.4% reduction in FLOPs with a minimal impact on performance, simultaneously surpassing state-of-the-art training-free methods. Our project page is at https://ficoco-accelerate.github.io/.", 'score': 14, 'issue_id': 805, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '968244e861534e4a', 'authors': ['Yuhang Han', 'Xuyang Liu', 'Pengxiang Ding', 'Donglin Wang', 'Honggang Chen', 'Qingsen Yan', 'Siteng Huang'], 'affiliations': ['DAMO Academy, Alibaba Group', 'Northwestern Polytechnical University', 'Sichuan University', 'Westlake University'], 'pdf_title_img': 'assets/pdf/title_img/2411.17686.jpg', 'data': {'categories': ['#optimization', '#inference', '#benchmark', '#multimodal'], 'emoji': '🚀', 'ru': {'title': 'Ускорение MLLM: новая парадигма сокращения токенов', 'desc': "Данная статья представляет новый подход к ускорению вывода мультимодальных больших языковых моделей (MLLM). Авторы предлагают унифицированную парадигму 'фильтрация-корреляция-сжатие' для сокращения токенов, разделяя процесс на три отдельных этапа. Исследование демонстрирует, как существующие методы вписываются в эту парадигму, и предлагает набор новых методов, балансирующих между скоростью и точностью. Экспериментальные результаты показывают сокращение FLOPS до 82.4% при минимальном влиянии на производительность, превосходя современные методы без дополнительного обучения."}, 'en': {'title': 'Streamlining Inference: The Filter-Correlate-Compress Paradigm for MLLMs', 'desc': "This paper introduces a new approach to improve the efficiency of Multimodal Large Language Models (MLLMs) during inference by proposing a 'filter-correlate-compress' paradigm. This framework breaks down the token reduction process into three clear stages, allowing for better understanding and implementation of each component. The authors analyze existing methods and integrate them into their unified approach, demonstrating its broad applicability. Their experiments show that this new method can significantly reduce computational load while maintaining high performance, outperforming current leading techniques."}, 'zh': {'title': '加速推理，优化多模态模型的令牌减少', 'desc': '本研究旨在加速重型多模态大型语言模型（MLLMs）的推理过程，重新审视无训练的令牌减少研究现状。我们发现现有方法的关键组件紧密相连，其相互关系和效果不明确，难以进行比较和扩展。因此，我们提出了一个统一的“过滤-关联-压缩”范式，将令牌减少分解为三个独立的阶段，保持设计目标的一致性，同时允许独特的实现方式。实验结果表明，我们的方法在不同推理阶段之间实现了速度和准确性的平衡，能够在性能影响最小的情况下，达到高达82.4%的FLOPs减少，超越了现有的无训练方法。'}}}, {'id': 'https://huggingface.co/papers/2411.15296', 'title': 'MME-Survey: A Comprehensive Survey on Evaluation of Multimodal LLMs', 'url': 'https://huggingface.co/papers/2411.15296', 'abstract': 'As a prominent direction of Artificial General Intelligence (AGI), Multimodal Large Language Models (MLLMs) have garnered increased attention from both industry and academia. Building upon pre-trained LLMs, this family of models further develops multimodal perception and reasoning capabilities that are impressive, such as writing code given a flow chart or creating stories based on an image. In the development process, evaluation is critical since it provides intuitive feedback and guidance on improving models. Distinct from the traditional train-eval-test paradigm that only favors a single task like image classification, the versatility of MLLMs has spurred the rise of various new benchmarks and evaluation methods. In this paper, we aim to present a comprehensive survey of MLLM evaluation, discussing four key aspects: 1) the summarised benchmarks types divided by the evaluation capabilities, including foundation capabilities, model self-analysis, and extented applications; 2) the typical process of benchmark counstruction, consisting of data collection, annotation, and precautions; 3) the systematic evaluation manner composed of judge, metric, and toolkit; 4) the outlook for the next benchmark. This work aims to offer researchers an easy grasp of how to effectively evaluate MLLMs according to different needs and to inspire better evaluation methods, thereby driving the progress of MLLM research.', 'score': 13, 'issue_id': 804, 'pub_date': '2024-11-22', 'pub_date_card': {'ru': '22 ноября', 'en': 'November 22', 'zh': '11月22日'}, 'hash': 'f83b02f1623b605b', 'authors': ['Chaoyou Fu', 'Yi-Fan Zhang', 'Shukang Yin', 'Bo Li', 'Xinyu Fang', 'Sirui Zhao', 'Haodong Duan', 'Xing Sun', 'Ziwei Liu', 'Liang Wang', 'Caifeng Shan', 'Ran He'], 'affiliations': ['Nanjing University', 'Institute of Automation, Chinese Academy of Science', 'University of Science and Technology of China', 'Nanyang Technological University', 'Shanghai AI Laboratory'], 'pdf_title_img': 'assets/pdf/title_img/2411.15296.jpg', 'data': {'categories': ['#benchmark', '#agi', '#survey', '#multimodal'], 'emoji': '🧠', 'ru': {'title': 'Комплексный подход к оценке мультимодальных языковых моделей', 'desc': 'Эта статья представляет собой обзор методов оценки мультимодальных больших языковых моделей (MLLM). Авторы рассматривают четыре ключевых аспекта: типы бенчмарков, процесс их создания, систематический подход к оценке и перспективы будущих бенчмарков. Особое внимание уделяется важности оценки для развития MLLM, которые сочетают возможности обработки естественного языка с восприятием других модальностей. Цель работы - помочь исследователям эффективно оценивать MLLM и стимулировать разработку улучшенных методов оценки.'}, 'en': {'title': 'Evaluating the Future of Multimodal AI', 'desc': 'This paper surveys the evaluation methods for Multimodal Large Language Models (MLLMs), which are advanced AI systems capable of understanding and generating content across different types of data, like text and images. It categorizes various benchmarks based on their evaluation capabilities, such as foundational skills and application breadth. The authors outline the typical process for creating these benchmarks, including data collection and annotation, and discuss the systematic approach to evaluation involving judges, metrics, and toolkits. The goal is to provide insights that help researchers effectively assess MLLMs and inspire improvements in evaluation techniques, ultimately advancing the field of MLLM research.'}, 'zh': {'title': '全面评估多模态大型语言模型的未来', 'desc': '多模态大型语言模型（MLLMs）是人工通用智能（AGI）的重要方向，近年来受到广泛关注。这些模型在预训练大型语言模型的基础上，进一步发展了多模态感知和推理能力，例如根据流程图编写代码或根据图像创作故事。评估在模型开发过程中至关重要，它提供了直观的反馈和改进指导。本文旨在全面调查MLLM的评估，讨论评估能力、基准构建过程、系统评估方式及未来基准展望等四个关键方面。'}}}, {'id': 'https://huggingface.co/papers/2411.14740', 'title': 'TEXGen: a Generative Diffusion Model for Mesh Textures', 'url': 'https://huggingface.co/papers/2411.14740', 'abstract': 'While high-quality texture maps are essential for realistic 3D asset rendering, few studies have explored learning directly in the texture space, especially on large-scale datasets. In this work, we depart from the conventional approach of relying on pre-trained 2D diffusion models for test-time optimization of 3D textures. Instead, we focus on the fundamental problem of learning in the UV texture space itself. For the first time, we train a large diffusion model capable of directly generating high-resolution texture maps in a feed-forward manner. To facilitate efficient learning in high-resolution UV spaces, we propose a scalable network architecture that interleaves convolutions on UV maps with attention layers on point clouds. Leveraging this architectural design, we train a 700 million parameter diffusion model that can generate UV texture maps guided by text prompts and single-view images. Once trained, our model naturally supports various extended applications, including text-guided texture inpainting, sparse-view texture completion, and text-driven texture synthesis. Project page is at http://cvmi-lab.github.io/TEXGen/.', 'score': 12, 'issue_id': 803, 'pub_date': '2024-11-22', 'pub_date_card': {'ru': '22 ноября', 'en': 'November 22', 'zh': '11月22日'}, 'hash': '79b09429e72c3c18', 'authors': ['Xin Yu', 'Ze Yuan', 'Yuan-Chen Guo', 'Ying-Tian Liu', 'JianHui Liu', 'Yangguang Li', 'Yan-Pei Cao', 'Ding Liang', 'Xiaojuan Qi'], 'affiliations': ['Beihang University, China', 'The University of Hong Kong, Hong Kong', 'Tsinghua University, China', 'VAST, China'], 'pdf_title_img': 'assets/pdf/title_img/2411.14740.jpg', 'data': {'categories': ['#3d', '#games', '#architecture', '#cv', '#diffusion'], 'emoji': '🎨', 'ru': {'title': 'Революция в генерации 3D-текстур: обучение диффузионной модели прямо в UV-пространстве', 'desc': 'Статья представляет новый подход к генерации текстурных карт для 3D-объектов. Авторы обучили крупную диффузионную модель, способную напрямую создавать высококачественные текстуры в UV-пространстве. Предложена масштабируемая архитектура нейронной сети, сочетающая свёрточные слои на UV-картах с слоями внимания на облаках точек. Обученная модель может генерировать текстуры на основе текстовых подсказок и изображений с одного ракурса, а также поддерживает задачи инпейнтинга и дополнения текстур.'}, 'en': {'title': 'Revolutionizing 3D Textures: Direct Learning in UV Space', 'desc': 'This paper presents a novel approach to generating high-quality texture maps for 3D assets by directly learning in the UV texture space. Unlike traditional methods that use pre-trained 2D models, the authors introduce a large diffusion model that generates textures in a feed-forward manner. They propose a scalable network architecture that combines convolutional operations on UV maps with attention mechanisms on point clouds, enabling efficient learning. The resulting model, with 700 million parameters, can create UV texture maps based on text prompts and single-view images, and supports various applications like texture inpainting and synthesis.'}, 'zh': {'title': '直接在UV纹理空间中生成高质量纹理图', 'desc': '本研究提出了一种新的方法，直接在UV纹理空间中学习高质量的纹理图。我们训练了一个大型扩散模型，能够以前馈方式生成高分辨率的纹理图，而不是依赖于预训练的2D扩散模型。该模型具有7亿个参数，能够根据文本提示和单视图图像生成UV纹理图。我们的架构设计结合了卷积和注意力层，使得在高分辨率UV空间中的学习更加高效，并支持多种扩展应用。'}}}, {'id': 'https://huggingface.co/papers/2411.17673', 'title': 'SketchAgent: Language-Driven Sequential Sketch Generation', 'url': 'https://huggingface.co/papers/2411.17673', 'abstract': 'Sketching serves as a versatile tool for externalizing ideas, enabling rapid exploration and visual communication that spans various disciplines. While artificial systems have driven substantial advances in content creation and human-computer interaction, capturing the dynamic and abstract nature of human sketching remains challenging. In this work, we introduce SketchAgent, a language-driven, sequential sketch generation method that enables users to create, modify, and refine sketches through dynamic, conversational interactions. Our approach requires no training or fine-tuning. Instead, we leverage the sequential nature and rich prior knowledge of off-the-shelf multimodal large language models (LLMs). We present an intuitive sketching language, introduced to the model through in-context examples, enabling it to "draw" using string-based actions. These are processed into vector graphics and then rendered to create a sketch on a pixel canvas, which can be accessed again for further tasks. By drawing stroke by stroke, our agent captures the evolving, dynamic qualities intrinsic to sketching. We demonstrate that SketchAgent can generate sketches from diverse prompts, engage in dialogue-driven drawing, and collaborate meaningfully with human users.', 'score': 10, 'issue_id': 804, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': 'e1660475c1d9b813', 'authors': ['Yael Vinker', 'Tamar Rott Shaham', 'Kristine Zheng', 'Alex Zhao', 'Judith E Fan', 'Antonio Torralba'], 'affiliations': ['MIT', 'Stanford University'], 'pdf_title_img': 'assets/pdf/title_img/2411.17673.jpg', 'data': {'categories': ['#multimodal', '#agents'], 'emoji': '✏️', 'ru': {'title': 'SketchAgent: диалоговое рисование с помощью языковых моделей', 'desc': 'В статье представлен SketchAgent - метод генерации эскизов, управляемый языком. Он позволяет пользователям создавать и модифицировать эскизы через диалоговое взаимодействие, используя мультимодальные языковые модели без дополнительного обучения. SketchAgent использует интуитивно понятный язык рисования, который переводится в векторную графику, создавая эскиз штрих за штрихом. Система демонстрирует способность генерировать эскизы по различным запросам и эффективно сотрудничать с пользователями.'}, 'en': {'title': 'SketchAgent: Conversational Sketching Made Easy!', 'desc': 'This paper presents SketchAgent, a novel method for generating sketches using a language-driven approach. It allows users to create and modify sketches through interactive conversations without needing any prior training. The system utilizes large language models to interpret a simple sketching language, converting string-based commands into vector graphics. By drawing incrementally, SketchAgent captures the fluid and dynamic essence of human sketching, enabling effective collaboration between the user and the AI.'}, 'zh': {'title': 'SketchAgent：通过对话生成动态草图', 'desc': '本研究介绍了一种名为SketchAgent的草图生成方法，它利用语言驱动的方式，允许用户通过对话互动来创建、修改和完善草图。该方法不需要训练或微调，而是利用现成的多模态大型语言模型的顺序特性和丰富的先验知识。SketchAgent使用一种直观的草图语言，通过上下文示例引入模型，使其能够通过基于字符串的动作进行“绘图”。通过逐笔绘制，我们的代理捕捉了草图固有的动态特性，并能够从多样的提示中生成草图，与用户进行有意义的合作。'}}}, {'id': 'https://huggingface.co/papers/2411.17467', 'title': 'Learning 3D Representations from Procedural 3D Programs', 'url': 'https://huggingface.co/papers/2411.17467', 'abstract': 'Self-supervised learning has emerged as a promising approach for acquiring transferable 3D representations from unlabeled 3D point clouds. Unlike 2D images, which are widely accessible, acquiring 3D assets requires specialized expertise or professional 3D scanning equipment, making it difficult to scale and raising copyright concerns. To address these challenges, we propose learning 3D representations from procedural 3D programs that automatically generate 3D shapes using simple primitives and augmentations.   Remarkably, despite lacking semantic content, the 3D representations learned from this synthesized dataset perform on par with state-of-the-art representations learned from semantically recognizable 3D models (e.g., airplanes) across various downstream 3D tasks, including shape classification, part segmentation, and masked point cloud completion. Our analysis further suggests that current self-supervised learning methods primarily capture geometric structures rather than high-level semantics.', 'score': 7, 'issue_id': 803, 'pub_date': '2024-11-25', 'pub_date_card': {'ru': '25 ноября', 'en': 'November 25', 'zh': '11月25日'}, 'hash': 'de7061420b319a85', 'authors': ['Xuweiyi Chen', 'Zezhou Cheng'], 'affiliations': ['University of Virginia'], 'pdf_title_img': 'assets/pdf/title_img/2411.17467.jpg', 'data': {'categories': ['#3d', '#dataset', '#transfer_learning', '#synthetic'], 'emoji': '🧊', 'ru': {'title': 'Самообучение 3D-представлениям без семантики: геометрия важнее смысла', 'desc': 'Статья представляет новый подход к самообучению для получения трехмерных представлений из немаркированных облаков точек. Авторы предлагают использовать процедурные 3D-программы для автоматической генерации форм из простых примитивов. Несмотря на отсутствие семантического содержания, полученные представления показывают результаты на уровне современных методов. Исследование также указывает, что текущие методы самообучения в основном фиксируют геометрические структуры, а не высокоуровневую семантику.'}, 'en': {'title': 'Unlocking 3D Learning with Procedural Generation', 'desc': 'This paper discusses a new method for self-supervised learning to create useful 3D representations from unlabeled 3D point clouds. The authors highlight the difficulty of obtaining 3D data due to the need for specialized equipment and the associated copyright issues. They propose using procedural 3D programs that generate shapes from basic building blocks, allowing for scalable data generation. The results show that these representations, although generated without semantic meaning, perform comparably to those derived from labeled 3D models in various tasks like shape classification and segmentation.'}, 'zh': {'title': '自监督学习：从程序化生成中获取3D表示', 'desc': '自监督学习是一种有前景的方法，可以从未标记的3D点云中获取可转移的3D表示。与2D图像不同，获取3D资产需要专业知识或专业的3D扫描设备，这使得其难以扩展并引发版权问题。为了解决这些挑战，我们提出从程序化3D程序中学习3D表示，这些程序使用简单的原始体和增强技术自动生成3D形状。值得注意的是，尽管缺乏语义内容，但从合成数据集中学习的3D表示在各种下游3D任务中表现与从语义可识别的3D模型（如飞机）学习的最先进表示相当。'}}}, {'id': 'https://huggingface.co/papers/2411.17451', 'title': 'VLRewardBench: A Challenging Benchmark for Vision-Language Generative Reward Models', 'url': 'https://huggingface.co/papers/2411.17451', 'abstract': "Vision-language generative reward models (VL-GenRMs) play a crucial role in aligning and evaluating multimodal AI systems, yet their own evaluation remains under-explored. Current assessment methods primarily rely on AI-annotated preference labels from traditional VL tasks, which can introduce biases and often fail to effectively challenge state-of-the-art models. To address these limitations, we introduce VL-RewardBench, a comprehensive benchmark spanning general multimodal queries, visual hallucination detection, and complex reasoning tasks. Through our AI-assisted annotation pipeline combining sample selection with human verification, we curate 1,250 high-quality examples specifically designed to probe model limitations. Comprehensive evaluation across 16 leading large vision-language models, demonstrates VL-RewardBench's effectiveness as a challenging testbed, where even GPT-4o achieves only 65.4% accuracy, and state-of-the-art open-source models such as Qwen2-VL-72B, struggle to surpass random-guessing. Importantly, performance on VL-RewardBench strongly correlates (Pearson's r > 0.9) with MMMU-Pro accuracy using Best-of-N sampling with VL-GenRMs. Analysis experiments uncover three critical insights for improving VL-GenRMs: (i) models predominantly fail at basic visual perception tasks rather than reasoning tasks; (ii) inference-time scaling benefits vary dramatically by model capacity; and (iii) training VL-GenRMs to learn to judge substantially boosts judgment capability (+14.7% accuracy for a 7B VL-GenRM). We believe VL-RewardBench along with the experimental insights will become a valuable resource for advancing VL-GenRMs.", 'score': 6, 'issue_id': 813, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '646be90925e52606', 'authors': ['Lei Li', 'Yuancheng Wei', 'Zhihui Xie', 'Xuqing Yang', 'Yifan Song', 'Peiyi Wang', 'Chenxin An', 'Tianyu Liu', 'Sujian Li', 'Bill Yuchen Lin', 'Lingpeng Kong', 'Qi Liu'], 'affiliations': ['AI2', 'HKU', 'PKU', 'SCUT', 'SJTU', 'UW'], 'pdf_title_img': 'assets/pdf/title_img/2411.17451.jpg', 'data': {'categories': ['#optimization', '#hallucinations', '#reasoning', '#benchmark', '#multimodal', '#alignment'], 'emoji': '🧠', 'ru': {'title': 'VL-RewardBench: новый стандарт оценки визуально-языковых моделей вознаграждения', 'desc': 'Статья представляет VL-RewardBench - новый бенчмарк для оценки генеративных моделей вознаграждения для визуально-языковых задач (VL-GenRMs). Авторы создали набор из 1250 высококачественных примеров, охватывающих различные аспекты мультимодальных запросов и рассуждений. Оценка 16 ведущих крупных визуально-языковых моделей показала эффективность VL-RewardBench как сложного тестового набора. Анализ результатов выявил ключевые проблемы и направления для улучшения VL-GenRMs.'}, 'en': {'title': 'VL-RewardBench: Elevating Evaluation for Vision-Language Models', 'desc': 'This paper introduces VL-RewardBench, a new benchmark designed to evaluate vision-language generative reward models (VL-GenRMs). The benchmark addresses the limitations of current evaluation methods that rely on biased AI-annotated preference labels. By curating 1,250 high-quality examples, VL-RewardBench effectively challenges state-of-the-art models and reveals their weaknesses in visual perception and reasoning tasks. The findings suggest that improving the training of VL-GenRMs can significantly enhance their judgment capabilities, making this benchmark a valuable tool for future research.'}, 'zh': {'title': '提升视觉-语言模型评估的全新基准', 'desc': '视觉-语言生成奖励模型（VL-GenRMs）在对齐和评估多模态人工智能系统中起着重要作用，但其自身的评估仍然未被充分探索。目前的评估方法主要依赖于传统视觉-语言任务的AI标注偏好标签，这可能引入偏见，并且往往无法有效挑战最先进的模型。为了解决这些局限性，我们引入了VL-RewardBench，这是一个涵盖一般多模态查询、视觉幻觉检测和复杂推理任务的综合基准。通过结合样本选择和人工验证的AI辅助注释流程，我们策划了1250个高质量示例，专门设计用于探测模型的局限性。'}}}, {'id': 'https://huggingface.co/papers/2411.15411', 'title': 'FINECAPTION: Compositional Image Captioning Focusing on Wherever You Want at Any Granularity', 'url': 'https://huggingface.co/papers/2411.15411', 'abstract': 'The advent of large Vision-Language Models (VLMs) has significantly advanced multimodal tasks, enabling more sophisticated and accurate reasoning across various applications, including image and video captioning, visual question answering, and cross-modal retrieval. Despite their superior capabilities, VLMs struggle with fine-grained image regional composition information perception. Specifically, they have difficulty accurately aligning the segmentation masks with the corresponding semantics and precisely describing the compositional aspects of the referred regions.   However, compositionality - the ability to understand and generate novel combinations of known visual and textual components - is critical for facilitating coherent reasoning and understanding across modalities by VLMs. To address this issue, we propose FINECAPTION, a novel VLM that can recognize arbitrary masks as referential inputs and process high-resolution images for compositional image captioning at different granularity levels. To support this endeavor, we introduce COMPOSITIONCAP, a new dataset for multi-grained region compositional image captioning, which introduces the task of compositional attribute-aware regional image captioning.   Empirical results demonstrate the effectiveness of our proposed model compared to other state-of-the-art VLMs. Additionally, we analyze the capabilities of current VLMs in recognizing various visual prompts for compositional region image captioning, highlighting areas for improvement in VLM design and training.', 'score': 6, 'issue_id': 803, 'pub_date': '2024-11-23', 'pub_date_card': {'ru': '23 ноября', 'en': 'November 23', 'zh': '11月23日'}, 'hash': '54aae052c8dc586b', 'authors': ['Hang Hua', 'Qing Liu', 'Lingzhi Zhang', 'Jing Shi', 'Zhifei Zhang', 'Yilin Wang', 'Jianming Zhang', 'Jiebo Luo'], 'affiliations': ['Adobe Research', 'University of Rochester'], 'pdf_title_img': 'assets/pdf/title_img/2411.15411.jpg', 'data': {'categories': ['#training', '#multimodal', '#games', '#cv', '#dataset', '#reasoning'], 'emoji': '🔬', 'ru': {'title': 'Новый подход к композиционному описанию изображений с помощью усовершенствованных мультимодальных языковых моделей', 'desc': 'В статье представлена новая модель FINECAPTION, способная распознавать произвольные маски и обрабатывать изображения высокого разрешения для композиционного описания изображений на разных уровнях детализации. Авторы также представили новый датасет COMPOSITIONCAP для многоуровневого композиционного описания регионов изображений. Эмпирические результаты демонстрируют эффективность предложенной модели по сравнению с другими современными мультимодальными языковыми моделями. В работе также проанализированы возможности существующих моделей в распознавании различных визуальных подсказок для композиционного описания регионов изображений.'}, 'en': {'title': 'Enhancing Compositional Understanding in Vision-Language Models', 'desc': 'This paper introduces FINECAPTION, a new Vision-Language Model (VLM) designed to enhance compositional image captioning by accurately recognizing and processing arbitrary segmentation masks. The model addresses the challenge of aligning image regions with their corresponding semantics, which is crucial for generating coherent captions. To facilitate this, the authors present COMPOSITIONCAP, a dataset that focuses on multi-grained region compositional image captioning, allowing for a deeper understanding of visual attributes. Empirical results show that FINECAPTION outperforms existing VLMs, while also identifying areas for further improvement in VLM capabilities.'}, 'zh': {'title': '提升视觉语言模型的组合能力', 'desc': '本文介绍了一种新的视觉语言模型FINECAPTION，旨在提高多模态任务中的图像区域组合信息感知能力。尽管现有的大型视觉语言模型在图像和视频描述等任务中表现出色，但它们在精确对齐分割掩码和语义方面存在困难。FINECAPTION能够识别任意掩码作为参考输入，并处理高分辨率图像，以实现不同粒度级别的组合图像描述。我们还提出了一个新数据集COMPOSITIONCAP，以支持多粒度区域组合图像描述任务，实验结果表明该模型在性能上优于其他先进的视觉语言模型。'}}}, {'id': 'https://huggingface.co/papers/2411.16856', 'title': 'SAR3D: Autoregressive 3D Object Generation and Understanding via Multi-scale 3D VQVAE', 'url': 'https://huggingface.co/papers/2411.16856', 'abstract': 'Autoregressive models have demonstrated remarkable success across various fields, from large language models (LLMs) to large multimodal models (LMMs) and 2D content generation, moving closer to artificial general intelligence (AGI). Despite these advances, applying autoregressive approaches to 3D object generation and understanding remains largely unexplored. This paper introduces Scale AutoRegressive 3D (SAR3D), a novel framework that leverages a multi-scale 3D vector-quantized variational autoencoder (VQVAE) to tokenize 3D objects for efficient autoregressive generation and detailed understanding. By predicting the next scale in a multi-scale latent representation instead of the next single token, SAR3D reduces generation time significantly, achieving fast 3D object generation in just 0.82 seconds on an A6000 GPU. Additionally, given the tokens enriched with hierarchical 3D-aware information, we finetune a pretrained LLM on them, enabling multimodal comprehension of 3D content. Our experiments show that SAR3D surpasses current 3D generation methods in both speed and quality and allows LLMs to interpret and caption 3D models comprehensively.', 'score': 5, 'issue_id': 804, 'pub_date': '2024-11-25', 'pub_date_card': {'ru': '25 ноября', 'en': 'November 25', 'zh': '11月25日'}, 'hash': '953bc387802b7daf', 'authors': ['Yongwei Chen', 'Yushi Lan', 'Shangchen Zhou', 'Tengfei Wang', 'XIngang Pan'], 'affiliations': ['S-Lab, Nanyang Technological University', 'Shanghai Artificial Intelligence Laboratory'], 'pdf_title_img': 'assets/pdf/title_img/2411.16856.jpg', 'data': {'categories': ['#multimodal', '#3d', '#architecture', '#games', '#agi'], 'emoji': '🧊', 'ru': {'title': 'SAR3D: Быстрая генерация и глубокое понимание 3D объектов', 'desc': 'Статья представляет новый фреймворк SAR3D для генерации и понимания 3D объектов с использованием авторегрессионного подхода. SAR3D использует многомасштабный 3D векторно-квантованный вариационный автоэнкодер для токенизации 3D объектов. Это позволяет значительно ускорить генерацию 3D объектов до 0.82 секунд на GPU A6000. Кроме того, дообучение предобученной языковой модели на полученных токенах позволяет достичь мультимодального понимания 3D контента.'}, 'en': {'title': 'Revolutionizing 3D Generation with SAR3D!', 'desc': 'This paper presents Scale AutoRegressive 3D (SAR3D), a new framework designed for generating and understanding 3D objects using autoregressive models. It utilizes a multi-scale 3D vector-quantized variational autoencoder (VQVAE) to tokenize 3D objects, which allows for faster and more efficient generation. By predicting the next scale in a multi-scale latent representation, SAR3D significantly reduces the time required for 3D object generation. The framework also enhances large language models (LLMs) with the ability to comprehend and caption 3D content, outperforming existing methods in both speed and quality.'}, 'zh': {'title': '快速高效的3D物体生成与理解', 'desc': '自回归模型在多个领域取得了显著成功，包括大型语言模型和多模态模型。然而，将自回归方法应用于3D物体生成和理解的研究仍然相对较少。本文提出了一种新框架——规模自回归3D（SAR3D），利用多尺度3D向量量化变分自编码器（VQVAE）对3D物体进行标记，从而实现高效的自回归生成和详细理解。实验表明，SAR3D在速度和质量上均优于现有的3D生成方法，并使大型语言模型能够全面理解和描述3D模型。'}}}, {'id': 'https://huggingface.co/papers/2411.17223', 'title': 'DreamMix: Decoupling Object Attributes for Enhanced Editability in Customized Image Inpainting', 'url': 'https://huggingface.co/papers/2411.17223', 'abstract': 'Subject-driven image inpainting has emerged as a popular task in image editing alongside recent advancements in diffusion models. Previous methods primarily focus on identity preservation but struggle to maintain the editability of inserted objects. In response, this paper introduces DreamMix, a diffusion-based generative model adept at inserting target objects into given scenes at user-specified locations while concurrently enabling arbitrary text-driven modifications to their attributes. In particular, we leverage advanced foundational inpainting models and introduce a disentangled local-global inpainting framework to balance precise local object insertion with effective global visual coherence. Additionally, we propose an Attribute Decoupling Mechanism (ADM) and a Textual Attribute Substitution (TAS) module to improve the diversity and discriminative capability of the text-based attribute guidance, respectively. Extensive experiments demonstrate that DreamMix effectively balances identity preservation and attribute editability across various application scenarios, including object insertion, attribute editing, and small object inpainting. Our code is publicly available at https://github.com/mycfhs/DreamMix.', 'score': 5, 'issue_id': 802, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '56eb0ccceda40f61', 'authors': ['Yicheng Yang', 'Pengxiang Li', 'Lu Zhang', 'Liqian Ma', 'Ping Hu', 'Siyu Du', 'Yunzhi Zhuge', 'Xu Jia', 'Huchuan Lu'], 'affiliations': ['Dalian University of Technology', 'University of Electronic Science and Technology of China', 'ZMO AI'], 'pdf_title_img': 'assets/pdf/title_img/2411.17223.jpg', 'data': {'categories': ['#diffusion', '#multimodal', '#open_source', '#cv'], 'emoji': '🎨', 'ru': {'title': 'DreamMix: Вставка и редактирование объектов на изображениях с помощью текста', 'desc': 'DreamMix - это генеративная модель на основе диффузии для вставки объектов в изображения. Она позволяет не только сохранять идентичность объектов, но и редактировать их атрибуты с помощью текстовых запросов. Модель использует усовершенствованный подход к инпейнтингу, сочетающий локальную и глобальную обработку. Также в DreamMix применяется механизм разделения атрибутов и модуль текстовой подстановки атрибутов для улучшения разнообразия и точности управления свойствами объектов.'}, 'en': {'title': 'DreamMix: Seamless Object Insertion and Attribute Editing in Images', 'desc': 'This paper presents DreamMix, a novel diffusion-based generative model designed for subject-driven image inpainting. Unlike previous methods that prioritize identity preservation, DreamMix allows users to insert objects into images at specified locations while also enabling modifications to their attributes through text prompts. The model employs a disentangled local-global inpainting framework to ensure that inserted objects blend well with the overall scene. Additionally, it introduces mechanisms for attribute decoupling and textual attribute substitution to enhance the diversity and effectiveness of text-based guidance for editing.'}, 'zh': {'title': 'DreamMix：智能图像修复与属性编辑的完美结合', 'desc': '本文介绍了一种名为DreamMix的扩散生成模型，旨在实现目标对象在指定场景中的插入，同时允许用户对其属性进行文本驱动的修改。与以往方法不同，DreamMix不仅关注身份保留，还能保持插入对象的可编辑性。我们采用了先进的基础修复模型，并引入了局部-全局分离修复框架，以平衡精确的局部对象插入和有效的全局视觉一致性。此外，本文还提出了属性解耦机制和文本属性替换模块，以提高基于文本的属性指导的多样性和区分能力。'}}}, {'id': 'https://huggingface.co/papers/2411.16173', 'title': 'SALOVA: Segment-Augmented Long Video Assistant for Targeted Retrieval and Routing in Long-Form Video Analysis', 'url': 'https://huggingface.co/papers/2411.16173', 'abstract': 'Despite advances in Large Multi-modal Models, applying them to long and untrimmed video content remains challenging due to limitations in context length and substantial memory overhead. These constraints often lead to significant information loss and reduced relevance in the model responses. With the exponential growth of video data across web platforms, understanding long-form video is crucial for advancing generalized intelligence. In this paper, we introduce SALOVA: Segment-Augmented LOng Video Assistant, a novel video-LLM framework designed to enhance the comprehension of lengthy video content through targeted retrieval process. We address two main challenges to achieve it: (i) We present the SceneWalk dataset, a high-quality collection of 87.8K long videos, each densely captioned at the segment level to enable models to capture scene continuity and maintain rich descriptive context. (ii) We develop robust architectural designs integrating dynamic routing mechanism and spatio-temporal projector to efficiently retrieve and process relevant video segments based on user queries. Our framework mitigates the limitations of current video-LMMs by allowing for precise identification and retrieval of relevant video segments in response to queries, thereby improving the contextual relevance of the generated responses. Through extensive experiments, SALOVA demonstrates enhanced capability in processing complex long-form videos, showing significant capability to maintain contextual integrity across extended sequences.', 'score': 3, 'issue_id': 805, 'pub_date': '2024-11-25', 'pub_date_card': {'ru': '25 ноября', 'en': 'November 25', 'zh': '11月25日'}, 'hash': 'a5ec8ffe17a0004a', 'authors': ['Junho Kim', 'Hyunjun Kim', 'Hosu Lee', 'Yong Man Ro'], 'affiliations': ['Integrated Vision and Language Lab, KAIST, South Korea'], 'pdf_title_img': 'assets/pdf/title_img/2411.16173.jpg', 'data': {'categories': ['#architecture', '#video', '#long_context', '#multimodal', '#dataset'], 'emoji': '🎥', 'ru': {'title': 'SALOVA: умный помощник для анализа длинных видео', 'desc': 'SALOVA - это новая система для обработки длинных видео с помощью больших мультимодальных моделей. Она решает проблему ограничений контекста и памяти при анализе длинных видео путем целевого извлечения релевантных сегментов. Система использует датасет SceneWalk с 87.8 тысячами длинных видео, размеченных на уровне сегментов. SALOVA применяет механизм динамической маршрутизации и пространственно-временной проектор для эффективной обработки запросов пользователей.'}, 'en': {'title': 'Enhancing Long Video Comprehension with SALOVA', 'desc': 'This paper presents SALOVA, a new framework designed to improve the understanding of long videos using large multi-modal models. It addresses the challenges of context length and memory overhead that often lead to information loss in video analysis. SALOVA utilizes the SceneWalk dataset, which contains 87.8K long videos with detailed segment-level captions, allowing models to better capture scene continuity. Additionally, it incorporates a dynamic routing mechanism and spatio-temporal projector to efficiently retrieve relevant video segments, enhancing the contextual relevance of model responses.'}, 'zh': {'title': '提升长视频理解的智能助手', 'desc': '尽管大型多模态模型取得了进展，但在处理长视频内容时仍面临挑战，主要是由于上下文长度和内存开销的限制。这些限制常常导致信息丢失和模型响应的相关性降低。为了解决这个问题，本文提出了SALOVA：一种新的视频-大语言模型框架，旨在通过目标检索过程增强对长视频内容的理解。我们引入了SceneWalk数据集和动态路由机制，以提高模型在处理复杂长视频时的能力，确保生成的响应在上下文上更具相关性。'}}}, {'id': 'https://huggingface.co/papers/2411.17691', 'title': 'Low-Bit Quantization Favors Undertrained LLMs: Scaling Laws for Quantized LLMs with 100T Training Tokens', 'url': 'https://huggingface.co/papers/2411.17691', 'abstract': "We reveal that low-bit quantization favors undertrained large language models (LLMs) by observing that models with larger sizes or fewer training tokens experience less quantization-induced degradation (QiD) when applying low-bit quantization, whereas smaller models with extensive training tokens suffer significant QiD. To gain deeper insights into this trend, we study over 1500 quantized LLM checkpoints of various sizes and at different training levels (undertrained or fully trained) in a controlled setting, deriving scaling laws for understanding the relationship between QiD and factors such as the number of training tokens, model size and bit width.   With the derived scaling laws, we propose a novel perspective that we can use QiD to measure an LLM's training levels and determine the number of training tokens required for fully training LLMs of various sizes. Moreover, we use the scaling laws to predict the quantization performance of different-sized LLMs trained with 100 trillion tokens. Our projection shows that the low-bit quantization performance of future models, which are expected to be trained with over 100 trillion tokens, may NOT be desirable. This poses a potential challenge for low-bit quantization in the future and highlights the need for awareness of a model's training level when evaluating low-bit quantization research. To facilitate future research on this problem, we release all the 1500+ quantized checkpoints used in this work at https://huggingface.co/Xu-Ouyang.", 'score': 3, 'issue_id': 804, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '3dfc643e242c0247', 'authors': ['Xu Ouyang', 'Tao Ge', 'Thomas Hartvigsen', 'Zhisong Zhang', 'Haitao Mi', 'Dong Yu'], 'affiliations': ['Tencent AI Lab', 'University of Virginia'], 'pdf_title_img': 'assets/pdf/title_img/2411.17691.jpg', 'data': {'categories': ['#low_resource', '#dataset', '#open_source', '#inference'], 'emoji': '🧠', 'ru': {'title': 'Квантование раскрывает тайны обучения языковых моделей', 'desc': 'Исследование показывает, что квантование с низким битрейтом менее вредно для недообученных больших языковых моделей (LLM), чем для полностью обученных. Авторы изучили более 1500 квантованных чекпоинтов LLM разных размеров и уровней обучения, выведя законы масштабирования для понимания связи между деградацией от квантования и такими факторами, как количество токенов обучения, размер модели и битовая ширина. На основе этих законов предложен новый подход к измерению уровня обучения LLM и определению необходимого количества токенов для полного обучения моделей разных размеров. Исследование также прогнозирует, что производительность квантования будущих моделей, обученных на более чем 100 триллионах токенов, может оказаться неудовлетворительной.'}, 'en': {'title': 'Understanding Low-Bit Quantization Impact on LLMs', 'desc': "This paper investigates how low-bit quantization affects large language models (LLMs) based on their training levels and sizes. It finds that larger models or those with fewer training tokens are less impacted by quantization-induced degradation (QiD), while smaller models with extensive training suffer more. The authors analyze over 1500 quantized LLM checkpoints to derive scaling laws that relate QiD to model size and training tokens. They also predict that future models trained with 100 trillion tokens may face challenges with low-bit quantization performance, emphasizing the importance of understanding a model's training level in quantization research."}, 'zh': {'title': '低位量化与模型训练水平的关系', 'desc': '本研究揭示了低位量化对未充分训练的大型语言模型（LLMs）的影响。我们发现，较大模型或训练样本较少的模型在应用低位量化时，量化引起的降级（QiD）较小，而小模型即使经过大量训练样本也会遭受显著的QiD。通过分析1500多个不同大小和训练水平的量化LLM检查点，我们推导出了一些规律，以理解QiD与训练样本数量、模型大小和位宽之间的关系。我们的研究表明，未来训练超过100万亿个样本的模型在低位量化性能上可能面临挑战，因此在评估低位量化研究时，需要关注模型的训练水平。'}}}, {'id': 'https://huggingface.co/papers/2411.16801', 'title': 'Controllable Human Image Generation with Personalized Multi-Garments', 'url': 'https://huggingface.co/papers/2411.16801', 'abstract': 'We present BootComp, a novel framework based on text-to-image diffusion models for controllable human image generation with multiple reference garments. Here, the main bottleneck is data acquisition for training: collecting a large-scale dataset of high-quality reference garment images per human subject is quite challenging, i.e., ideally, one needs to manually gather every single garment photograph worn by each human. To address this, we propose a data generation pipeline to construct a large synthetic dataset, consisting of human and multiple-garment pairs, by introducing a model to extract any reference garment images from each human image. To ensure data quality, we also propose a filtering strategy to remove undesirable generated data based on measuring perceptual similarities between the garment presented in human image and extracted garment. Finally, by utilizing the constructed synthetic dataset, we train a diffusion model having two parallel denoising paths that use multiple garment images as conditions to generate human images while preserving their fine-grained details. We further show the wide-applicability of our framework by adapting it to different types of reference-based generation in the fashion domain, including virtual try-on, and controllable human image generation with other conditions, e.g., pose, face, etc.', 'score': 2, 'issue_id': 815, 'pub_date': '2024-11-25', 'pub_date_card': {'ru': '25 ноября', 'en': 'November 25', 'zh': '11月25日'}, 'hash': 'ef40f6dd8c1ccd32', 'authors': ['Yisol Choi', 'Sangkyung Kwak', 'Sihyun Yu', 'Hyungwon Choi', 'Jinwoo Shin'], 'affiliations': ['KAIST', 'OMNIOUS.AI'], 'pdf_title_img': 'assets/pdf/title_img/2411.16801.jpg', 'data': {'categories': ['#data', '#diffusion', '#synthetic', '#cv', '#dataset'], 'emoji': '👚', 'ru': {'title': 'BootComp: Генерация изображений людей с контролируемой одеждой без ручного сбора данных', 'desc': "В статье представлен BootComp - новый фреймворк для генерации изображений людей с контролируемой одеждой, основанный на диффузионных моделях преобразования текста в изображение. Авторы предлагают конвейер для создания синтетического набора данных, состоящего из пар 'человек-несколько предметов одежды', используя модель для извлечения эталонных изображений одежды из каждого изображения человека. Для обеспечения качества данных применяется стратегия фильтрации, основанная на измерении перцептивного сходства между одеждой на изображении человека и извлеченной одеждой. Обученная на этом наборе данных диффузионная модель имеет два параллельных пути шумоподавления, использующих несколько изображений одежды в качестве условий для генерации изображений людей."}, 'en': {'title': 'Revolutionizing Fashion with Synthetic Human Image Generation', 'desc': 'BootComp is a new framework that uses text-to-image diffusion models to generate human images with specific garments. The challenge it addresses is the difficulty of collecting a large dataset of high-quality garment images for each individual. To solve this, BootComp creates a synthetic dataset by extracting garment images from human photos and filtering out low-quality data. The framework allows for the generation of detailed human images based on multiple garment references and can be adapted for various applications in the fashion industry, such as virtual try-ons.'}, 'zh': {'title': 'BootComp：可控的人物图像生成新框架', 'desc': '我们提出了BootComp，这是一个基于文本到图像扩散模型的框架，用于可控的人物图像生成，支持多种参考服装。主要的瓶颈在于数据获取，收集每个人体的高质量参考服装图像数据集非常具有挑战性。为了解决这个问题，我们提出了一种数据生成管道，通过引入模型从每个人体图像中提取参考服装图像，构建一个大型合成数据集。最后，我们利用构建的合成数据集训练了一个扩散模型，具有两个并行去噪路径，能够在保留细节的同时生成带有多种服装条件的人物图像。'}}}, {'id': 'https://huggingface.co/papers/2411.14721', 'title': 'MolReFlect: Towards In-Context Fine-grained Alignments between Molecules and Texts', 'url': 'https://huggingface.co/papers/2411.14721', 'abstract': 'Molecule discovery is a pivotal research field, impacting everything from the medicines we take to the materials we use. Recently, Large Language Models (LLMs) have been widely adopted in molecule understanding and generation, yet the alignments between molecules and their corresponding captions remain a significant challenge. Previous endeavours often treat the molecule as a general SMILES string or molecular graph, neglecting the fine-grained alignments between the molecular sub-structures and the descriptive textual phrases, which are crucial for accurate and explainable predictions. In this case, we introduce MolReFlect, a novel teacher-student framework designed to contextually perform the molecule-caption alignments in a fine-grained way. Our approach initially leverages a larger teacher LLM to label the detailed alignments by directly extracting critical phrases from molecule captions or SMILES strings and implying them to corresponding sub-structures or characteristics. To refine these alignments, we propose In-Context Selective Reflection, which retrieves previous extraction results as context examples for teacher LLM to reflect and lets a smaller student LLM select from in-context reflection and previous extraction results. Finally, we enhance the learning process of the student LLM through Chain-of-Thought In-Context Molecule Tuning, integrating the fine-grained alignments and the reasoning processes within the Chain-of-Thought format. Our experimental results demonstrate that MolReFlect enables LLMs like Mistral-7B to significantly outperform the previous baselines, achieving SOTA performance on the ChEBI-20 dataset. This advancement not only enhances the generative capabilities of LLMs in the molecule-caption translation task, but also contributes to a more explainable framework.', 'score': 2, 'issue_id': 811, 'pub_date': '2024-11-22', 'pub_date_card': {'ru': '22 ноября', 'en': 'November 22', 'zh': '11月22日'}, 'hash': '7b85c924ec519ef3', 'authors': ['Jiatong Li', 'Yunqing Liu', 'Wei Liu', 'Jingdi Le', 'Di Zhang', 'Wenqi Fan', 'Dongzhan Zhou', 'Yuqiang Li', 'Qing Li'], 'affiliations': ['Shanghai AI Lab', 'Shanghai Jiao Tong University', 'The Hong Kong Polytechnic University'], 'pdf_title_img': 'assets/pdf/title_img/2411.14721.jpg', 'data': {'categories': ['#alignment', '#multimodal', '#dataset', '#interpretability', '#reasoning', '#training'], 'emoji': '🧪', 'ru': {'title': 'MolReFlect: Точное соответствие молекул и текста с помощью LLM', 'desc': 'Статья представляет MolReFlect - новый метод для улучшения соответствия между молекулами и их текстовыми описаниями с использованием больших языковых моделей (LLM). Авторы предлагают подход учитель-ученик, где большая модель-учитель выделяет ключевые фразы и соотносит их с подструктурами молекул, а меньшая модель-ученик уточняет эти соответствия. Метод включает в себя контекстную селективную рефлексию и обучение с использованием цепочки рассуждений. Эксперименты показывают, что MolReFlect значительно превосходит предыдущие подходы на датасете ChEBI-20, улучшая генеративные способности LLM в задаче перевода между молекулами и их описаниями.'}, 'en': {'title': 'Enhancing Molecule-Caption Alignment with MolReFlect', 'desc': 'This paper presents MolReFlect, a new framework that improves the alignment between molecules and their descriptive captions using Large Language Models (LLMs). It addresses the challenge of fine-grained alignments by employing a teacher-student model where a larger LLM guides a smaller one in understanding molecular sub-structures and their corresponding textual descriptions. The method includes In-Context Selective Reflection to refine alignments and Chain-of-Thought In-Context Molecule Tuning to enhance the learning process. Experimental results show that MolReFlect achieves state-of-the-art performance on the ChEBI-20 dataset, making LLMs more effective and explainable in molecule-caption tasks.'}, 'zh': {'title': 'MolReFlect：提升分子与描述对齐的智能框架', 'desc': '分子发现是一个重要的研究领域，影响着我们所用的药物和材料。本文提出了一种新的教师-学生框架MolReFlect，旨在细致地对分子与其对应的描述进行对齐。我们的方法利用大型语言模型（LLM）来标记详细的对齐信息，并通过上下文选择性反思来优化这些对齐。实验结果表明，MolReFlect显著提升了LLM在分子-描述翻译任务中的表现，提供了更具解释性的框架。'}}}, {'id': 'https://huggingface.co/papers/2411.16754', 'title': 'Visual Counter Turing Test (VCT^2): Discovering the Challenges for AI-Generated Image Detection and Introducing Visual AI Index (V_AI)', 'url': 'https://huggingface.co/papers/2411.16754', 'abstract': 'The proliferation of AI techniques for image generation, coupled with their increasing accessibility, has raised significant concerns about the potential misuse of these images to spread misinformation. Recent AI-generated image detection (AGID) methods include CNNDetection, NPR, DM Image Detection, Fake Image Detection, DIRE, LASTED, GAN Image Detection, AIDE, SSP, DRCT, RINE, OCC-CLIP, De-Fake, and Deep Fake Detection. However, we argue that the current state-of-the-art AGID techniques are inadequate for effectively detecting contemporary AI-generated images and advocate for a comprehensive reevaluation of these methods. We introduce the Visual Counter Turing Test (VCT^2), a benchmark comprising ~130K images generated by contemporary text-to-image models (Stable Diffusion 2.1, Stable Diffusion XL, Stable Diffusion 3, DALL-E 3, and Midjourney 6). VCT^2 includes two sets of prompts sourced from tweets by the New York Times Twitter account and captions from the MS COCO dataset. We also evaluate the performance of the aforementioned AGID techniques on the VCT^2 benchmark, highlighting their ineffectiveness in detecting AI-generated images. As image-generative AI models continue to evolve, the need for a quantifiable framework to evaluate these models becomes increasingly critical. To meet this need, we propose the Visual AI Index (V_AI), which assesses generated images from various visual perspectives, including texture complexity and object coherence, setting a new standard for evaluating image-generative AI models. To foster research in this domain, we make our https://huggingface.co/datasets/anonymous1233/COCO_AI and https://huggingface.co/datasets/anonymous1233/twitter_AI datasets publicly available.', 'score': 1, 'issue_id': 805, 'pub_date': '2024-11-24', 'pub_date_card': {'ru': '24 ноября', 'en': 'November 24', 'zh': '11月24日'}, 'hash': 'cbbd14594d775cab', 'authors': ['Nasrin Imanpour', 'Shashwat Bajpai', 'Subhankar Ghosh', 'Sainath Reddy Sankepally', 'Abhilekh Borah', 'Hasnat Md Abdullah', 'Nishoak Kosaraju', 'Shreyas Dixit', 'Ashhar Aziz', 'Shwetangshu Biswas', 'Vinija Jain', 'Aman Chadha', 'Amit Sheth', 'Amitava Das'], 'affiliations': ['Amazon AI, USA', 'Amazon GenAI, USA', 'BITS Pilani Hyderabad Campus, India', 'Carnegie Mellon University, USA', 'IIIT Delhi, India', 'International Institute of Information Technology, India', 'Manipal University Jaipur, India', 'National Institute of Technology Silchar, India', 'Stanford University, USA', 'Texas A&M University, USA', 'University of South Carolina, USA', 'Vishwakarma Institute of Information Technology, India', 'Washington State University, USA'], 'pdf_title_img': 'assets/pdf/title_img/2411.16754.jpg', 'data': {'categories': ['#open_source', '#cv', '#benchmark', '#security', '#ethics', '#dataset'], 'emoji': '🕵️', 'ru': {'title': 'Новый подход к выявлению ИИ-генерированных изображений', 'desc': 'В статье рассматривается проблема обнаружения изображений, сгенерированных искусственным интеллектом (ИИ), в контексте распространения дезинформации. Авторы представляют новый бенчмарк Visual Counter Turing Test (VCT^2), содержащий около 130 тысяч изображений, созданных современными моделями text-to-image. Исследование показывает неэффективность существующих методов обнаружения ИИ-генерированных изображений на этом бенчмарке. Предлагается новый стандарт оценки моделей генерации изображений - Visual AI Index (V_AI), учитывающий различные визуальные аспекты.'}, 'en': {'title': 'Rethinking AI Image Detection: Introducing VCT² and V_AI', 'desc': 'This paper discusses the challenges of detecting AI-generated images, which have become more prevalent and accessible. It critiques existing AI-generated image detection (AGID) methods, asserting that they are insufficient for identifying modern images created by advanced models. The authors introduce the Visual Counter Turing Test (VCT^2), a new benchmark with around 130,000 images to evaluate the effectiveness of current AGID techniques. Additionally, they propose the Visual AI Index (V_AI) to provide a comprehensive framework for assessing image quality from multiple visual aspects, aiming to improve the evaluation of generative AI models.'}, 'zh': {'title': '提升AI图像检测，构建新标准！', 'desc': '随着人工智能图像生成技术的普及，滥用这些图像传播虚假信息的风险日益增加。现有的人工智能生成图像检测方法（AGID）如CNNDetection和Deep Fake Detection等，已被证明在检测现代AI生成图像方面效果不佳。为此，本文提出了视觉反图灵测试（VCT^2），该基准包含约13万张由最新文本到图像模型生成的图像，并评估了现有AGID技术在此基准上的表现。我们还提出了视觉人工智能指数（V_AI），为评估图像生成AI模型提供了新的标准，强调了从多个视觉角度评估生成图像的重要性。'}}}, {'id': 'https://huggingface.co/papers/2411.17383', 'title': 'AnchorCrafter: Animate CyberAnchors Saling Your Products via Human-Object Interacting Video Generation', 'url': 'https://huggingface.co/papers/2411.17383', 'abstract': 'The automatic generation of anchor-style product promotion videos presents promising opportunities in online commerce, advertising, and consumer engagement. However, this remains a challenging task despite significant advancements in pose-guided human video generation. In addressing this challenge, we identify the integration of human-object interactions (HOI) into pose-guided human video generation as a core issue. To this end, we introduce AnchorCrafter, a novel diffusion-based system designed to generate 2D videos featuring a target human and a customized object, achieving high visual fidelity and controllable interactions. Specifically, we propose two key innovations: the HOI-appearance perception, which enhances object appearance recognition from arbitrary multi-view perspectives and disentangles object and human appearance, and the HOI-motion injection, which enables complex human-object interactions by overcoming challenges in object trajectory conditioning and inter-occlusion management. Additionally, we introduce the HOI-region reweighting loss, a training objective that enhances the learning of object details. Extensive experiments demonstrate that our proposed system outperforms existing methods in preserving object appearance and shape awareness, while simultaneously maintaining consistency in human appearance and motion. Project page: https://cangcz.github.io/Anchor-Crafter/', 'score': 1, 'issue_id': 803, 'pub_date': '2024-11-26', 'pub_date_card': {'ru': '26 ноября', 'en': 'November 26', 'zh': '11月26日'}, 'hash': '8deec5510490c901', 'authors': ['Ziyi Xu', 'Ziyao Huang', 'Juan Cao', 'Yong Zhang', 'Xiaodong Cun', 'Qing Shuai', 'Yuchen Wang', 'Linchao Bao', 'Jintao Li', 'Fan Tang'], 'affiliations': ['Great Bay University', 'Institute of Computing Technology, Chinese Academy of Sciences', 'Meituan', 'Tencent'], 'pdf_title_img': 'assets/pdf/title_img/2411.17383.jpg', 'data': {'categories': ['#training', '#video', '#cv', '#diffusion'], 'emoji': '🎬', 'ru': {'title': 'AnchorCrafter: ИИ создает реалистичные промо-видео с взаимодействием человека и товара', 'desc': 'Статья представляет AnchorCrafter - новую систему на основе диффузии для генерации видео с взаимодействием человека и объекта. Система решает проблему интеграции взаимодействий человека с объектами в генерацию видео на основе поз. AnchorCrafter использует инновационные подходы HOI-appearance perception и HOI-motion injection для улучшения распознавания внешнего вида объекта и управления сложными взаимодействиями. Эксперименты показывают, что система превосходит существующие методы в сохранении внешнего вида объекта при поддержании согласованности внешнего вида и движений человека.'}, 'en': {'title': 'Revolutionizing Product Promotion with AnchorCrafter!', 'desc': 'This paper presents AnchorCrafter, a new system for generating promotional videos that feature a person interacting with a product. It focuses on improving how humans and objects are represented together in videos by using advanced techniques in pose-guided video generation. The system introduces two main innovations: one that improves how objects are recognized from different angles and another that allows for realistic interactions between humans and objects. The results show that AnchorCrafter produces videos with better object appearance and human motion consistency compared to existing methods.'}, 'zh': {'title': '锚点风格视频生成的新突破', 'desc': '本论文提出了一种名为AnchorCrafter的新型扩散系统，旨在自动生成锚点风格的产品推广视频。该系统通过整合人-物交互（HOI）来提升基于姿态的人类视频生成效果，解决了复杂的人-物交互问题。我们提出了HOI-外观感知和HOI-运动注入两个关键创新，前者改善了物体外观的识别，后者则增强了人-物交互的复杂性。实验结果表明，AnchorCrafter在物体外观和形状保持方面优于现有方法，同时保持了人类外观和运动的一致性。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (3)', '#agents (2)', '#agi (2)', '#alignment (2)', '#architecture (4)', '#audio', '#benchmark (4)', '#cv (8)', '#data (2)', '#dataset (8)', '#diffusion (5)', '#ethics (1)', '#games (4)', '#graphs (1)', '#hallucinations (1)', '#healthcare', '#inference (3)', '#interpretability (1)', '#leakage', '#long_context (2)', '#low_resource (1)', '#machine_translation', '#math', '#multilingual', '#multimodal (10)', '#open_source (3)', '#optimization (4)', '#plp', '#rag', '#reasoning (3)', '#rl', '#rlhf', '#robotics', '#science', '#security (1)', '#small_models', '#story_generation', '#survey (1)', '#synthetic (2)', '#training (4)', '#transfer_learning (1)', '#video (3)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="background-digit">${index + 1}</div>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-11-27 18:14',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2024-11-27 18:14')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2024-11-27 18:14')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    