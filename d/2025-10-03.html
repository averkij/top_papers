
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 13 papers. October 3.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">3 октября</span> | <span id="title-articles-count">13 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-10-02.html">⬅️ <span id="prev-date">02.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-10-06.html">➡️ <span id="next-date">06.10</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-10.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'};
        let feedDateNext = {'ru': '06.10', 'en': '10/06', 'zh': '10月6日'};
        let feedDatePrev = {'ru': '02.10', 'en': '10/02', 'zh': '10月2日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2510.00446', 'title': 'LongCodeZip: Compress Long Context for Code Language Models', 'url': 'https://huggingface.co/papers/2510.00446', 'abstract': 'LongCodeZip is a code compression framework for LLMs that uses dual-stage compression to reduce context size without degrading performance, improving efficiency in code intelligence applications.  \t\t\t\t\tAI-generated summary \t\t\t\t Code generation under long contexts is becoming increasingly critical as Large Language Models (LLMs) are required to reason over extensive information in the codebase. While recent advances enable code LLMs to process long inputs, high API costs and generation latency remain substantial bottlenecks. Existing context pruning techniques, such as LLMLingua, achieve promising results for general text but overlook code-specific structures and dependencies, leading to suboptimal performance in programming tasks. In this paper, we propose LongCodeZip, a novel plug-and-play code compression framework designed specifically for code LLMs. LongCodeZip employs a dual-stage strategy: (1) coarse-grained compression, which identifies and ranks function-level chunks using conditional perplexity with respect to the instruction, retaining only the most relevant functions; and (2) fine-grained compression, which segments retained functions into blocks based on perplexity and selects an optimal subset under an adaptive token budget to maximize relevance. Evaluations across multiple tasks, including code completion, summarization, and question answering, show that LongCodeZip consistently outperforms baseline methods, achieving up to a 5.6x compression ratio without degrading task performance. By effectively reducing context size while preserving essential information, LongCodeZip enables LLMs to better scale to real-world, large-scale code scenarios, advancing the efficiency and capability of code intelligence applications.', 'score': 27, 'issue_id': 6221, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': 'b9bb4e93a2d263ea', 'authors': ['Yuling Shi', 'Yichun Qian', 'Hongyu Zhang', 'Beijun Shen', 'Xiaodong Gu'], 'affiliations': ['Chongqing University, Chongqing, China', 'Shanghai Jiao Tong University, Shanghai, China', 'Stanford University, Stanford, CA, USA'], 'pdf_title_img': 'assets/pdf/title_img/2510.00446.jpg', 'data': {'categories': ['#training', '#long_context', '#data', '#optimization', '#plp'], 'emoji': '🗜️', 'ru': {'title': 'Умное сжатие кода для больших языковых моделей', 'desc': 'LongCodeZip — это специализированный фреймворк для сжатия программного кода при работе с LLM, использующий двухэтапную стратегию компрессии. На первом этапе система выполняет грубую фильтрацию на уровне функций, ранжируя их по условной перплексии относительно инструкции и оставляя наиболее релевантные. На втором этапе происходит тонкая компрессия: оставшиеся функции сегментируются на блоки, из которых выбирается оптимальное подмножество в рамках адаптивного токен-бюджета. Метод достигает степени сжатия до 5.6x без потери качества на задачах генерации, суммаризации и ответов на вопросы по коду, превосходя общие методы сжатия текста вроде LLMLingua.'}, 'en': {'title': 'Efficient Code Compression for LLMs with LongCodeZip', 'desc': 'LongCodeZip is a specialized framework designed to compress code for Large Language Models (LLMs) while maintaining performance. It utilizes a dual-stage compression approach, first applying coarse-grained compression to identify and prioritize relevant function-level chunks based on their importance. Then, it employs fine-grained compression to further refine these functions into optimal segments, ensuring that only the most pertinent information is retained. This method significantly reduces context size, achieving up to a 5.6x compression ratio, which enhances the efficiency of code-related tasks without sacrificing output quality.'}, 'zh': {'title': '提升代码智能的压缩效率', 'desc': 'LongCodeZip 是一个专为大型语言模型（LLMs）设计的代码压缩框架，采用双阶段压缩策略来减少上下文大小而不降低性能。它首先通过条件困惑度对函数级块进行粗粒度压缩，保留最相关的函数；然后进行细粒度压缩，根据困惑度将保留的函数分块，并在自适应令牌预算下选择最佳子集。通过在代码补全、摘要和问答等多个任务上的评估，LongCodeZip 显示出显著优于基线方法的性能，压缩比高达 5.6 倍。该框架有效减少了上下文大小，同时保留了关键信息，从而提升了代码智能应用的效率和能力。'}}}, {'id': 'https://huggingface.co/papers/2510.02297', 'title': 'Interactive Training: Feedback-Driven Neural Network Optimization', 'url': 'https://huggingface.co/papers/2510.02297', 'abstract': 'Interactive Training is a framework that allows real-time, feedback-driven intervention during neural network training, improving stability and adaptability.  \t\t\t\t\tAI-generated summary \t\t\t\t Traditional neural network training typically follows fixed, predefined optimization recipes, lacking the flexibility to dynamically respond to instabilities or emerging training issues. In this paper, we introduce Interactive Training, an open-source framework that enables real-time, feedback-driven intervention during neural network training by human experts or automated AI agents. At its core, Interactive Training uses a control server to mediate communication between users or agents and the ongoing training process, allowing users to dynamically adjust optimizer hyperparameters, training data, and model checkpoints. Through three case studies, we demonstrate that Interactive Training achieves superior training stability, reduced sensitivity to initial hyperparameters, and improved adaptability to evolving user needs, paving the way toward a future training paradigm where AI agents autonomously monitor training logs, proactively resolve instabilities, and optimize training dynamics.', 'score': 9, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': 'a5b5b6a9b4ca0924', 'authors': ['Wentao Zhang', 'Yang Young Lu', 'Yuntian Deng'], 'affiliations': ['University of Waterloo', 'University of Wisconsin-Madison'], 'pdf_title_img': 'assets/pdf/title_img/2510.02297.jpg', 'data': {'categories': ['#training', '#open_source', '#optimization'], 'emoji': '🎮', 'ru': {'title': 'Интерактивное обучение нейросетей с вмешательством в реальном времени', 'desc': 'В статье представлен Interactive Training — фреймворк для обучения нейросетей с возможностью вмешательства в реальном времени. В отличие от традиционного подхода с фиксированными параметрами оптимизации, система позволяет экспертам или AI-агентам динамически изменять гиперпараметры оптимизатора, обучающие данные и чекпоинты модели во время тренировки. Три практических исследования показали улучшение стабильности обучения, снижение чувствительности к начальным гиперпараметрам и лучшую адаптивность к меняющимся требованиям. Авторы видят будущее в автономных AI-агентах, которые будут мониторить логи обучения и проактивно устранять проблемы.'}, 'en': {'title': 'Empowering Neural Networks with Real-Time Interactive Training', 'desc': 'This paper presents Interactive Training, a novel framework that enhances neural network training by allowing real-time interventions. It addresses the limitations of traditional training methods, which often lack the flexibility to adapt to issues as they arise. The framework facilitates communication between users or AI agents and the training process, enabling dynamic adjustments to hyperparameters, training data, and model checkpoints. The results from case studies show that Interactive Training leads to better stability, less sensitivity to initial settings, and greater adaptability to user requirements.'}, 'zh': {'title': '实时反馈，提升训练灵活性', 'desc': '互动训练是一种框架，允许在神经网络训练过程中进行实时的反馈驱动干预，从而提高训练的稳定性和适应性。传统的神经网络训练通常遵循固定的优化流程，缺乏动态应对不稳定性或新出现问题的灵活性。本文介绍的互动训练框架，支持人类专家或自动化AI代理在训练过程中进行实时干预，用户可以动态调整优化器超参数、训练数据和模型检查点。通过三个案例研究，我们展示了互动训练在训练稳定性、对初始超参数的敏感性降低以及对用户需求的适应性提高方面的优势。'}}}, {'id': 'https://huggingface.co/papers/2510.01591', 'title': 'CLUE: Non-parametric Verification from Experience via Hidden-State\n  Clustering', 'url': 'https://huggingface.co/papers/2510.01591', 'abstract': "Hidden states in Large Language Models encode correctness as a separable signature, enabling a minimalist verifier (CLUE) to outperform text-level and confidence-based methods in reranking and accuracy.  \t\t\t\t\tAI-generated summary \t\t\t\t Assessing the quality of Large Language Model (LLM) outputs presents a critical challenge. Previous methods either rely on text-level information (e.g., reward models, majority voting), which can overfit to superficial cues, or on calibrated confidence from token probabilities, which would fail on less-calibrated models. Yet both of these signals are, in fact, partial projections of a richer source of information: the model's internal hidden states. Early layers, closer to token embeddings, preserve semantic and lexical features that underpin text-based judgments, while later layers increasingly align with output logits, embedding confidence-related information. This paper explores hidden states directly as a unified foundation for verification. We show that the correctness of a solution is encoded as a geometrically separable signature within the trajectory of hidden activations. To validate this, we present Clue (Clustering and Experience-based Verification), a deliberately minimalist, non-parametric verifier. With no trainable parameters, CLUE only summarizes each reasoning trace by an hidden state delta and classifies correctness via nearest-centroid distance to ``success'' and ``failure'' clusters formed from past experience. The simplicity of this method highlights the strength of the underlying signal. Empirically, CLUE consistently outperforms LLM-as-a-judge baselines and matches or exceeds modern confidence-based methods in reranking candidates, improving both top-1 and majority-vote accuracy across AIME 24/25 and GPQA. As a highlight, on AIME 24 with a 1.5B model, CLUE boosts accuracy from 56.7% (majority@64) to 70.0% (top-maj@16).", 'score': 9, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '5fb07bdb1a94a1b3', 'authors': ['Zhenwen Liang', 'Ruosen Li', 'Yujun Zhou', 'Linfeng Song', 'Dian Yu', 'Xinya Du', 'Haitao Mi', 'Dong Yu'], 'affiliations': ['Tencent AI Lab', 'University of Notre Dame', 'University of Texas at Dallas'], 'pdf_title_img': 'assets/pdf/title_img/2510.01591.jpg', 'data': {'categories': ['#rlhf', '#training', '#reasoning', '#interpretability'], 'emoji': '🎯', 'ru': {'title': 'Скрытые состояния LLM как геометрический детектор правильности ответов', 'desc': 'Исследователи обнаружили, что скрытые состояния (hidden states) в больших языковых моделях содержат геометрически отделимую сигнатуру корректности ответа. Они разработали CLUE — минималистичный непараметрический верификатор, который классифицирует правильность решений по расстоянию до кластеров успешных и неуспешных примеров из прошлого опыта. Метод использует только дельту скрытых состояний без обучаемых параметров, что подчеркивает силу внутреннего сигнала модели. CLUE превосходит методы на основе текста и confidence-based подходы в задачах ранжирования, повышая точность с 56.7% до 70.0% на датасете AIME 24.'}, 'en': {'title': 'Unlocking Hidden States for Accurate LLM Verification', 'desc': 'This paper investigates how hidden states in Large Language Models (LLMs) can be used to assess the correctness of model outputs more effectively than traditional methods. It introduces CLUE, a minimalist verifier that leverages the geometric separability of hidden activations to classify outputs as correct or incorrect without needing trainable parameters. By summarizing reasoning traces with hidden state deltas and using nearest-centroid distance to classify correctness, CLUE demonstrates superior performance over existing text-level and confidence-based approaches. The results show significant improvements in accuracy, highlighting the potential of hidden states as a rich source of information for verification tasks.'}, 'zh': {'title': '利用隐藏状态提升语言模型的验证准确性', 'desc': '这篇论文探讨了大型语言模型（LLM）内部隐藏状态如何编码正确性，并提出了一种名为CLUE的简约验证器。CLUE利用隐藏状态的几何可分离特征，能够在重排序和准确性方面超越传统的文本级和基于置信度的方法。通过对隐藏状态的直接分析，CLUE不需要可训练参数，仅通过总结推理轨迹的隐藏状态变化来进行分类。实验结果表明，CLUE在多个基准测试中表现优异，显著提高了模型的准确性。'}}}, {'id': 'https://huggingface.co/papers/2510.01444', 'title': 'VOGUE: Guiding Exploration with Visual Uncertainty Improves Multimodal\n  Reasoning', 'url': 'https://huggingface.co/papers/2510.01444', 'abstract': 'VOGUE, a method that shifts exploration to the visual input space by quantifying policy sensitivity to visual perturbations, enhances multimodal reasoning in large language models.  \t\t\t\t\tAI-generated summary \t\t\t\t Reinforcement learning with verifiable rewards (RLVR) improves reasoning in large language models (LLMs) but struggles with exploration, an issue that still persists for multimodal LLMs (MLLMs). Current methods treat the visual input as a fixed, deterministic condition, overlooking a critical source of ambiguity and struggling to build policies robust to plausible visual variations. We introduce VOGUE (Visual Uncertainty Guided Exploration), a novel method that shifts exploration from the output (text) to the input (visual) space. By treating the image as a stochastic context, VOGUE quantifies the policy\'s sensitivity to visual perturbations using the symmetric KL divergence between a "raw" and "noisy" branch, creating a direct signal for uncertainty-aware exploration. This signal shapes the learning objective via an uncertainty-proportional bonus, which, combined with a token-entropy bonus and an annealed sampling schedule, effectively balances exploration and exploitation. Implemented within GRPO on two model scales (Qwen2.5-VL-3B/7B), VOGUE boosts pass@1 accuracy by an average of 2.6% on three visual math benchmarks and 3.7% on three general-domain reasoning benchmarks, while simultaneously increasing pass@4 performance and mitigating the exploration decay commonly observed in RL fine-tuning. Our work shows that grounding exploration in the inherent uncertainty of visual inputs is an effective strategy for improving multimodal reasoning.', 'score': 6, 'issue_id': 6221, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '827fe718c8df2c9c', 'authors': ['Rui Liu', 'Dian Yu', 'Tong Zheng', 'Runpeng Dai', 'Zongxia Li', 'Wenhao Yu', 'Zhenwen Liang', 'Linfeng Song', 'Haitao Mi', 'Pratap Tokekar', 'Dong Yu'], 'affiliations': ['Tencent AI Lab, Bellevue, WA', 'University of Maryland, College Park', 'University of North Carolina, Chapel Hill'], 'pdf_title_img': 'assets/pdf/title_img/2510.01444.jpg', 'data': {'categories': ['#training', '#multimodal', '#rl', '#games', '#reasoning'], 'emoji': '🔍', 'ru': {'title': 'Исследование через визуальную неопределённость для мультимодального обучения', 'desc': 'Статья представляет метод VOGUE, который улучшает обучение с подкреплением для мультимодальных LLM за счёт переноса исследования (exploration) из текстового пространства в визуальное. Вместо того чтобы рассматривать изображение как фиксированный вход, метод трактует его как стохастический контекст и измеряет чувствительность политики к визуальным возмущениям через симметричную KL-дивергенцию. Полученный сигнал неопределённости используется как бонус в функции обучения, что помогает балансировать исследование и эксплуатацию. Эксперименты на моделях Qwen2.5-VL показали улучшение точности на 2.6% для математических задач и 3.7% для общих задач рассуждения.'}, 'en': {'title': 'Enhancing Multimodal Reasoning through Visual Uncertainty Exploration', 'desc': 'The paper introduces VOGUE, a method that enhances multimodal reasoning in large language models by focusing on the visual input space. It addresses the exploration challenges in reinforcement learning with verifiable rewards by quantifying how sensitive a policy is to changes in visual inputs. VOGUE treats images as stochastic contexts, using symmetric KL divergence to measure policy sensitivity and create an uncertainty-aware exploration signal. This approach leads to improved accuracy in reasoning tasks by balancing exploration and exploitation through an uncertainty-proportional bonus and other techniques.'}, 'zh': {'title': '基于视觉不确定性的探索提升多模态推理', 'desc': 'VOGUE是一种新方法，通过量化策略对视觉扰动的敏感性，将探索转移到视觉输入空间，从而增强大型语言模型的多模态推理能力。该方法将图像视为随机上下文，利用对称KL散度来量化策略的敏感性，创建一个直接的信号以支持不确定性感知的探索。VOGUE通过不确定性比例奖励、令牌熵奖励和逐步采样计划有效平衡探索与利用，显著提高了模型在视觉数学基准和一般领域推理基准上的准确性。我们的研究表明，将探索与视觉输入的固有不确定性结合是一种有效的多模态推理改进策略。'}}}, {'id': 'https://huggingface.co/papers/2510.01179', 'title': 'TOUCAN: Synthesizing 1.5M Tool-Agentic Data from Real-World MCP\n  Environments', 'url': 'https://huggingface.co/papers/2510.01179', 'abstract': 'Toucan, a large publicly available tool-agentic dataset, enhances the performance of LLM agents by providing diverse, realistic, and complex multi-tool and multi-turn interactions.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Model (LLM) agents are rapidly emerging as powerful systems for automating tasks across domains. Yet progress in the open-source community is constrained by the lack of high quality permissively licensed tool-agentic training data. Existing datasets are often limited in diversity, realism, and complexity, particularly regarding multi-tool and multi-turn interactions. To address this gap, we introduce Toucan, the largest publicly available tool-agentic dataset to date, containing 1.5 million trajectories synthesized from nearly 500 real-world Model Context Protocols (MCPs). Unlike prior work, Toucan leverages authentic MCP environments to generate diverse, realistic, and challenging tasks with trajectories involving real tool execution. Our pipeline first produces a broad spectrum of tool-use queries using five distinct models, applies model-based quality filtering, and then generates agentic trajectories with three teacher models using two agentic frameworks. Rigorous rule-based and model-based validation ensures high-quality outputs. We also introduce three extension mechanisms to further diversify tasks and simulate multi-turn conversations. Models fine-tuned on Toucan outperform larger closed-source counterparts on the BFCL V3 benchmark and push the Pareto frontier forward on MCP-Universe Bench.', 'score': 4, 'issue_id': 6221, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '30b0ec9c798b87c6', 'authors': ['Zhangchen Xu', 'Adriana Meza Soria', 'Shawn Tan', 'Anurag Roy', 'Ashish Sunil Agrawal', 'Radha Poovendran', 'Rameswar Panda'], 'affiliations': ['MIT-IBM Watson AI Lab', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2510.01179.jpg', 'data': {'categories': ['#open_source', '#synthetic', '#agents', '#benchmark', '#dataset'], 'emoji': '🦜', 'ru': {'title': 'Toucan: крупнейший датасет для обучения AI-агентов работе с инструментами', 'desc': 'Исследователи представили Toucan — самый большой публично доступный датасет для обучения LLM-агентов, содержащий 1,5 миллиона траекторий взаимодействия с реальными инструментами. Датасет создан на основе почти 500 реальных Model Context Protocols (MCP) и включает разнообразные многоступенчатые задачи с использованием нескольких инструментов одновременно. Для генерации данных использовался сложный пайплайн с участием пяти моделей для создания запросов, фильтрацией по качеству и тремя учительскими моделями для генерации траекторий. Модели, дообученные на Toucan, превосходят более крупные закрытые модели на бенчмарке BFCL V3 и демонстрируют лучшие результаты на MCP-Universe Bench.'}, 'en': {'title': 'Toucan: Elevating LLM Agents with Diverse Tool Interactions', 'desc': 'Toucan is a large dataset designed to improve the performance of Large Language Model (LLM) agents by providing a wide variety of realistic and complex interactions involving multiple tools and turns. It addresses the limitations of existing datasets, which often lack diversity and realism, by synthesizing 1.5 million trajectories from nearly 500 real-world Model Context Protocols (MCPs). The dataset generation process includes quality filtering and the use of multiple models to ensure high-quality outputs, along with mechanisms to diversify tasks and simulate multi-turn conversations. Models trained on Toucan have shown superior performance compared to larger closed-source models on established benchmarks, demonstrating its effectiveness in advancing the capabilities of LLM agents.'}, 'zh': {'title': 'Toucan：提升LLM代理性能的关键数据集', 'desc': 'Toucan是一个大型的公开可用工具代理数据集，旨在提升大型语言模型（LLM）代理的性能。该数据集包含150万个轨迹，来源于近500个真实的模型上下文协议（MCP），提供多样化、真实且复杂的多工具和多轮交互。Toucan通过真实的MCP环境生成任务，确保了数据的多样性和挑战性。经过严格的规则和模型验证，Toucan生成的高质量输出使得在BFCL V3基准测试中表现优于更大的封闭源模型。'}}}, {'id': 'https://huggingface.co/papers/2510.02283', 'title': 'Self-Forcing++: Towards Minute-Scale High-Quality Video Generation', 'url': 'https://huggingface.co/papers/2510.02283', 'abstract': "A method is proposed to enhance long-horizon video generation by using sampled segments from self-generated long videos to guide student models, maintaining quality and consistency without additional supervision or retraining.  \t\t\t\t\tAI-generated summary \t\t\t\t Diffusion models have revolutionized image and video generation, achieving unprecedented visual quality. However, their reliance on transformer architectures incurs prohibitively high computational costs, particularly when extending generation to long videos. Recent work has explored autoregressive formulations for long video generation, typically by distilling from short-horizon bidirectional teachers. Nevertheless, given that teacher models cannot synthesize long videos, the extrapolation of student models beyond their training horizon often leads to pronounced quality degradation, arising from the compounding of errors within the continuous latent space. In this paper, we propose a simple yet effective approach to mitigate quality degradation in long-horizon video generation without requiring supervision from long-video teachers or retraining on long video datasets. Our approach centers on exploiting the rich knowledge of teacher models to provide guidance for the student model through sampled segments drawn from self-generated long videos. Our method maintains temporal consistency while scaling video length by up to 20x beyond teacher's capability, avoiding common issues such as over-exposure and error-accumulation without recomputing overlapping frames like previous methods. When scaling up the computation, our method shows the capability of generating videos up to 4 minutes and 15 seconds, equivalent to 99.9% of the maximum span supported by our base model's position embedding and more than 50x longer than that of our baseline model. Experiments on standard benchmarks and our proposed improved benchmark demonstrate that our approach substantially outperforms baseline methods in both fidelity and consistency. Our long-horizon videos demo can be found at https://self-forcing-plus-plus.github.io/", 'score': 3, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '6c012f635291b12f', 'authors': ['Justin Cui', 'Jie Wu', 'Ming Li', 'Tao Yang', 'Xiaojie Li', 'Rui Wang', 'Andrew Bai', 'Yuanhao Ban', 'Cho-Jui Hsieh'], 'affiliations': ['ByteDance Seed', 'UCLA', 'University of Central Florida'], 'pdf_title_img': 'assets/pdf/title_img/2510.02283.jpg', 'data': {'categories': ['#benchmark', '#diffusion', '#long_context', '#video'], 'emoji': '🎬', 'ru': {'title': 'Самообучение на длинных видео без учителя', 'desc': 'Исследователи предложили метод генерации длинных видео с помощью диффузионных моделей, который решает проблему накопления ошибок при авторегрессивном подходе. Вместо обучения на длинных видео или использования учителя, способного генерировать длинные последовательности, модель-студент использует сегменты из собственных сгенерированных длинных видео для самокоррекции. Метод позволяет увеличить длину видео в 20 раз по сравнению с возможностями модели-учителя, достигая генерации видео длительностью более 4 минут. Подход сохраняет временную консистентность и качество без пересчёта перекрывающихся фреймов и избегает типичных проблем вроде переэкспонирования.'}, 'en': {'title': 'Enhancing Long Video Generation with Self-Sampled Guidance', 'desc': 'This paper presents a novel method for improving the generation of long videos using segments from self-generated long videos to guide student models. By leveraging the knowledge of teacher models, the approach maintains high video quality and temporal consistency without the need for additional supervision or retraining. The method allows for scaling video lengths significantly, achieving up to 20 times the length of what teacher models can produce. Experimental results show that this technique outperforms existing methods in both fidelity and consistency, enabling the generation of videos lasting over 4 minutes.'}, 'zh': {'title': '提升长视频生成质量的新方法', 'desc': '本文提出了一种增强长时间视频生成的方法，通过使用自生成长视频的采样片段来指导学生模型，从而在不需要额外监督或重新训练的情况下保持质量和一致性。该方法利用教师模型的丰富知识，为学生模型提供指导，避免了常见的问题，如过度曝光和错误累积。通过这种方式，我们的方法能够将视频长度扩展到教师模型能力的20倍，生成时长可达4分15秒。实验结果表明，该方法在视频生成的保真度和一致性方面显著优于基线方法。'}}}, {'id': 'https://huggingface.co/papers/2510.02294', 'title': 'F2LLM Technical Report: Matching SOTA Embedding Performance with 6\n  Million Open-Source Data', 'url': 'https://huggingface.co/papers/2510.02294', 'abstract': 'F2LLM, a suite of large language models, achieves high embedding performance with efficient fine-tuning from foundation models using open-source datasets.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce F2LLM - Foundation to Feature Large Language Models, a suite of state-of-the-art embedding models in three sizes: 0.6B, 1.7B, and 4B. Unlike previous top-ranking embedding models that require massive contrastive pretraining, sophisticated training pipelines, and costly synthetic training data, F2LLM is directly finetuned from foundation models on 6 million query-document-negative tuples curated from open-source, non-synthetic datasets, striking a strong balance between training cost, model size, and embedding performance. On the MTEB English leaderboard, F2LLM-4B ranks 2nd among models with approximately 4B parameters and 7th overall, while F2LLM-1.7B ranks 1st among models in the 1B-2B size range. To facilitate future research in the field, we release the models, training dataset, and code, positioning F2LLM as a strong, reproducible, and budget-friendly baseline for future works.', 'score': 2, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': 'f50d032bbcffbe10', 'authors': ['Ziyin Zhang', 'Zihan Liao', 'Hang Yu', 'Peng Di', 'Rui Wang'], 'affiliations': ['Ant Group', 'Shanghai Jiao Tong University'], 'pdf_title_img': 'assets/pdf/title_img/2510.02294.jpg', 'data': {'categories': ['#training', '#open_source', '#dataset', '#small_models', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Эффективные эмбеддинги из foundation моделей без дорогостоящего предобучения', 'desc': 'F2LLM — это семейство language models для создания эмбеддингов размером 0.6B, 1.7B и 4B параметров. В отличие от предыдущих топовых моделей, F2LLM не требует масштабного contrastive pretraining и дорогих синтетических данных — модели просто файнтюнятся на 6 миллионах троек query-document-negative из открытых источников. На бенчмарке MTEB модель F2LLM-4B заняла 2-е место среди 4B моделей и 7-е место в общем зачёте, а F2LLM-1.7B стала лучшей в категории 1B-2B параметров. Авторы открыли код, датасет и веса моделей, создав доступный baseline для будущих исследований в области эмбеддингов.'}, 'en': {'title': 'F2LLM: Efficient Embedding Models for Cost-Effective Performance', 'desc': 'F2LLM is a new suite of large language models designed for efficient embedding performance. It fine-tunes foundation models using a curated dataset of 6 million query-document-negative tuples, avoiding the need for expensive pretraining and synthetic data. The models come in three sizes: 0.6B, 1.7B, and 4B parameters, with the largest model achieving high rankings on the MTEB English leaderboard. By releasing the models and training data, F2LLM aims to provide a cost-effective and reproducible baseline for future research in machine learning.'}, 'zh': {'title': 'F2LLM：高效嵌入的基础模型微调', 'desc': 'F2LLM是一套大型语言模型，专注于高效的嵌入性能。它通过对基础模型进行微调，使用开放源代码数据集，避免了以往模型需要的大规模对比预训练和复杂的训练流程。F2LLM提供了三种不同规模的模型，分别为0.6B、1.7B和4B，并在MTEB英语排行榜上表现优异。为了推动未来的研究，我们公开了模型、训练数据集和代码，旨在为后续工作提供一个强大且经济实惠的基准。'}}}, {'id': 'https://huggingface.co/papers/2510.02259', 'title': 'Transformers Discover Molecular Structure Without Graph Priors', 'url': 'https://huggingface.co/papers/2510.02259', 'abstract': 'Transformers trained directly on Cartesian coordinates can achieve competitive performance in molecular energy and force prediction without predefined graphs, demonstrating adaptability and scalability.  \t\t\t\t\tAI-generated summary \t\t\t\t Graph Neural Networks (GNNs) are the dominant architecture for molecular machine learning, particularly for molecular property prediction and machine learning interatomic potentials (MLIPs). GNNs perform message passing on predefined graphs often induced by a fixed radius cutoff or k-nearest neighbor scheme. While this design aligns with the locality present in many molecular tasks, a hard-coded graph can limit expressivity due to the fixed receptive field and slows down inference with sparse graph operations. In this work, we investigate whether pure, unmodified Transformers trained directly on Cartesian coordinatesx2013without predefined graphs or physical priorsx2013can approximate molecular energies and forces. As a starting point for our analysis, we demonstrate how to train a Transformer to competitive energy and force mean absolute errors under a matched training compute budget, relative to a state-of-the-art equivariant GNN on the OMol25 dataset. We discover that the Transformer learns physically consistent patternsx2013such as attention weights that decay inversely with interatomic distancex2013and flexibly adapts them across different molecular environments due to the absence of hard-coded biases. The use of a standard Transformer also unlocks predictable improvements with respect to scaling training resources, consistent with empirical scaling laws observed in other domains. Our results demonstrate that many favorable properties of GNNs can emerge adaptively in Transformers, challenging the necessity of hard-coded graph inductive biases and pointing toward standardized, scalable architectures for molecular modeling.', 'score': 2, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '2f48683b9886f234', 'authors': ['Tobias Kreiman', 'Yutong Bai', 'Fadi Atieh', 'Elizabeth Weaver', 'Eric Qu', 'Aditi S. Krishnapriyan'], 'affiliations': ['LBNL', 'UC Berkeley'], 'pdf_title_img': 'assets/pdf/title_img/2510.02259.jpg', 'data': {'categories': ['#graphs', '#architecture', '#dataset', '#optimization', '#science'], 'emoji': '⚛️', 'ru': {'title': 'Трансформеры побеждают графы в молекулярном моделировании', 'desc': 'Исследователи показали, что обычные Transformer-модели, обученные напрямую на декартовых координатах атомов без предопределённых графов, могут достигать конкурентной точности в предсказании энергии и сил молекул. В отличие от доминирующих Graph Neural Networks (GNN), которые используют жёстко заданные связи между атомами, трансформеры адаптивно обучаются физически корректным паттернам, таким как зависимость внимания от межатомных расстояний. Отсутствие встроенных индуктивных смещений делает архитектуру более гибкой и масштабируемой, позволяя применять стандартные законы масштабирования из других областей AI. Результаты ставят под вопрос необходимость специализированных графовых архитектур для молекулярного машинного обучения.'}, 'en': {'title': 'Transformers: A New Era for Molecular Predictions Without Graphs', 'desc': 'This paper explores the use of Transformers, a type of neural network, for predicting molecular energies and forces directly from Cartesian coordinates, without relying on predefined graphs. Traditionally, Graph Neural Networks (GNNs) have been used for these tasks, but they can be limited by their fixed graph structures. The authors show that Transformers can achieve competitive performance while being more adaptable and scalable, as they learn patterns based on the data rather than hard-coded rules. This research suggests that Transformers can effectively replace GNNs in molecular modeling, offering a more flexible approach to machine learning in this field.'}, 'zh': {'title': '变换器：分子建模的新选择', 'desc': '本研究探讨了直接在笛卡尔坐标上训练的变换器（Transformers）在分子能量和力预测中的表现。与传统的图神经网络（GNNs）不同，变换器不依赖于预定义的图结构，因此具有更好的适应性和可扩展性。实验结果表明，变换器能够学习到物理一致的模式，并在不同的分子环境中灵活适应。我们的发现挑战了硬编码图结构的必要性，指向了分子建模中标准化和可扩展的架构。'}}}, {'id': 'https://huggingface.co/papers/2510.00523', 'title': 'VIRTUE: Visual-Interactive Text-Image Universal Embedder', 'url': 'https://huggingface.co/papers/2510.00523', 'abstract': 'VIRTUE, a novel Visual-InteRactive Text-Image Universal Embedder, integrates segmentation and vision-language models to enable visual interactions and localized grounding, achieving state-of-the-art performance in representation learning tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t Multimodal representation learning models have demonstrated successful operation across complex tasks, and the integration of vision-language models (VLMs) has further enabled embedding models with instruction-following capabilities. However, existing embedding models lack visual-interactive capabilities to specify regions of interest from users (e.g., point, bounding box, mask), which have been explored in generative models to broaden their human-interactive applicability. Equipping embedding models with visual interactions not only would unlock new applications with localized grounding of user intent, which remains unexplored, but also enable the models to learn entity-level information within images to complement their global representations for conventional embedding tasks. In this paper, we propose a novel Visual-InteRactive Text-Image Universal Embedder (VIRTUE) that extends the capabilities of the segmentation model and the vision-language model to the realm of representation learning. In VIRTUE, the segmentation model can process visual prompts that pinpoint specific regions within an image, thereby enabling the embedder to handle complex and ambiguous scenarios more precisely. To evaluate the visual-interaction ability of VIRTUE, we introduce a large-scale Segmentation-and-Scene Caption Retrieval (SCaR) benchmark comprising 1M samples that aims to retrieve the text caption by jointly considering the entity with a specific object and image scene. VIRTUE consistently achieves a state-of-the-art performance with significant improvements across 36 universal MMEB (3.1%-8.5%) and five visual-interactive SCaR (15.2%-20.3%) tasks.', 'score': 2, 'issue_id': 6221, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '8379081e03e82135', 'authors': ['Wei-Yao Wang', 'Kazuya Tateishi', 'Qiyu Wu', 'Shusuke Takahashi', 'Yuki Mitsufuji'], 'affiliations': ['Sony AI', 'Sony Group Corporation'], 'pdf_title_img': 'assets/pdf/title_img/2510.00523.jpg', 'data': {'categories': ['#multimodal', '#benchmark', '#interpretability', '#games', '#optimization', '#cv'], 'emoji': '👆', 'ru': {'title': 'Embeddings с визуальным взаимодействием: указывай на объекты и получай точные представления', 'desc': 'Представлена модель VIRTUE, которая объединяет сегментацию и vision-language модели для создания embeddings с визуальным взаимодействием. Пользователь может указывать конкретные области на изображении (точкой, bounding box или маской), что позволяет модели более точно понимать намерения и работать с локализованными объектами. Авторы создали новый benchmark SCaR с 1 миллионом примеров для оценки способности модели находить текстовые описания с учетом конкретных объектов и общей сцены. VIRTUE показывает state-of-the-art результаты, превосходя существующие методы на 3-8% на стандартных задачах и на 15-20% на задачах с визуальным взаимодействием.'}, 'en': {'title': 'Empowering Visual Interaction with VIRTUE', 'desc': "VIRTUE is a new model that combines segmentation and vision-language techniques to enhance how machines understand and interact with images and text. It allows users to specify areas of interest in images, improving the model's ability to learn detailed information about specific objects. This capability enables more precise responses to user queries and enhances the model's performance in various representation learning tasks. The paper introduces a benchmark to test VIRTUE's effectiveness, showing it outperforms existing models in multiple tasks."}, 'zh': {'title': 'VIRTUE：开启视觉交互的新纪元', 'desc': 'VIRTUE是一种新型的视觉交互文本-图像通用嵌入模型，它结合了分割模型和视觉语言模型，能够实现视觉交互和局部定位。该模型通过处理用户指定的感兴趣区域（如点、边界框、掩码），提升了嵌入模型的交互能力。VIRTUE在表示学习任务中表现出色，尤其是在复杂和模糊场景下的处理能力。通过引入大规模的分割和场景描述检索基准，VIRTUE在多个任务中实现了显著的性能提升。'}}}, {'id': 'https://huggingface.co/papers/2510.02209', 'title': 'StockBench: Can LLM Agents Trade Stocks Profitably In Real-world\n  Markets?', 'url': 'https://huggingface.co/papers/2510.02209', 'abstract': 'StockBench evaluates large language models in realistic stock trading environments, revealing challenges and opportunities in developing LLM-powered financial agents.  \t\t\t\t\tAI-generated summary \t\t\t\t Large language models (LLMs) have recently demonstrated strong capabilities as autonomous agents, showing promise in reasoning, tool use, and sequential decision-making. While prior benchmarks have evaluated LLM agents in domains such as software engineering and scientific discovery, the finance domain remains underexplored, despite its direct relevance to economic value and high-stakes decision-making. Existing financial benchmarks primarily test static knowledge through question answering, but they fall short of capturing the dynamic and iterative nature of trading. To address this gap, we introduce StockBench, a contamination-free benchmark designed to evaluate LLM agents in realistic, multi-month stock trading environments. Agents receive daily market signals -- including prices, fundamentals, and news -- and must make sequential buy, sell, or hold decisions. Performance is assessed using financial metrics such as cumulative return, maximum drawdown, and the Sortino ratio. Our evaluation of state-of-the-art proprietary (e.g., GPT-5, Claude-4) and open-weight (e.g., Qwen3, Kimi-K2, GLM-4.5) models shows that while most LLM agents struggle to outperform the simple buy-and-hold baseline, several models demonstrate the potential to deliver higher returns and manage risk more effectively. These findings highlight both the challenges and opportunities in developing LLM-powered financial agents, showing that excelling at static financial knowledge tasks does not necessarily translate into successful trading strategies. We release StockBench as an open-source resource to support reproducibility and advance future research in this domain.', 'score': 1, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '6d2362d30dbb6925', 'authors': ['Yanxu Chen', 'Zijun Yao', 'Yantao Liu', 'Jin Ye', 'Jianing Yu', 'Lei Hou', 'Juanzi Li'], 'affiliations': ['Beijing University of Posts and Telecommunications', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2510.02209.jpg', 'data': {'categories': ['#reasoning', '#open_source', '#benchmark', '#agents'], 'emoji': '📈', 'ru': {'title': 'LLM-агенты учатся торговать акциями, но пока проигрывают простым стратегиям', 'desc': 'StockBench - это новый бенчмарк для оценки больших языковых моделей (LLM) в роли автономных агентов для торговли акциями. Агенты получают ежедневные рыночные данные - цены, финансовые показатели и новости - и должны принимать последовательные решения о покупке, продаже или удержании акций на протяжении нескольких месяцев. Исследование показало, что большинство современных LLM-агентов, включая GPT-5 и Claude-4, с трудом превосходят простую стратегию "купи и держи", хотя некоторые модели демонстрируют потенциал для более высокой доходности. Результаты подчеркивают, что успех в статических финансовых тестах не гарантирует эффективных торговых стратегий, открывая новые направления для исследований AI-агентов в финансовой сфере.'}, 'en': {'title': 'StockBench: Evaluating LLMs in Real-World Stock Trading', 'desc': 'This paper introduces StockBench, a new benchmark for evaluating large language models (LLMs) in realistic stock trading scenarios. Unlike previous benchmarks that focus on static knowledge, StockBench assesses LLMs on their ability to make dynamic trading decisions based on daily market signals. The evaluation uses financial metrics to measure performance, revealing that while many LLMs struggle to outperform a basic buy-and-hold strategy, some show promise in generating higher returns and managing risk. This research highlights the complexities of applying LLMs in finance and aims to foster further exploration in developing effective financial agents.'}, 'zh': {'title': 'StockBench：评估金融代理的未来潜力', 'desc': 'StockBench 是一个评估大型语言模型（LLM）在真实股票交易环境中的基准测试工具。它解决了现有金融基准测试无法捕捉交易动态和迭代特性的不足。通过提供每日市场信号，LLM 代理需要做出买入、卖出或持有的决策。我们的研究表明，尽管大多数 LLM 代理未能超越简单的买入持有策略，但一些模型显示出更高的回报潜力和更有效的风险管理能力。'}}}, {'id': 'https://huggingface.co/papers/2510.02190', 'title': 'A Rigorous Benchmark with Multidimensional Evaluation for Deep Research\n  Agents: From Answers to Reports', 'url': 'https://huggingface.co/papers/2510.02190', 'abstract': 'A benchmark and evaluation framework for Deep Research Agents (DRAs) assesses their performance on complex tasks with multidimensional metrics.  \t\t\t\t\tAI-generated summary \t\t\t\t Artificial intelligence is undergoing the paradigm shift from closed language models to interconnected agent systems capable of external perception and information integration. As a representative embodiment, Deep Research Agents (DRAs) systematically exhibit the capabilities for task decomposition, cross-source retrieval, multi-stage reasoning, and structured output, which markedly enhance performance on complex and open-ended tasks. However, existing benchmarks remain deficient in evaluation dimensions, response formatting, and scoring mechanisms, limiting their capacity to assess such systems effectively. This paper introduces a rigorous benchmark and a multidimensional evaluation framework tailored to DRAs and report-style responses. The benchmark comprises 214 expert-curated challenging queries distributed across 10 broad thematic domains, each accompanied by manually constructed reference bundles to support composite evaluation. The framework enables comprehensive evaluation of long-form reports generated by DRAs, incorporating integrated scoring metrics for semantic quality, topical focus, and retrieval trustworthiness. Extensive experimentation confirms the superior performance of mainstream DRAs over web-search-tool-augmented reasoning models, yet reveals considerable scope for further improvement. This study provides a robust foundation for capability assessment, architectural refinement, and paradigm advancement in DRA systems.', 'score': 1, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '98260d7be8c3395a', 'authors': ['Yang Yao', 'Yixu Wang', 'Yuxuan Zhang', 'Yi Lu', 'Tianle Gu', 'Lingyu Li', 'Dingyi Zhao', 'Keming Wu', 'Haozhe Wang', 'Ping Nie', 'Yan Teng', 'Yingchun Wang'], 'affiliations': ['Fudan University', 'Hong Kong University of Science and Technology', 'Peking University', 'Shanghai Artificial Intelligence Laboratory', 'Shanghai Jiao Tong University', 'The University of Hong Kong', 'Tsinghua University', 'University of British Columbia', 'University of Toronto'], 'pdf_title_img': 'assets/pdf/title_img/2510.02190.jpg', 'data': {'categories': ['#benchmark', '#agents', '#evaluation', '#optimization', '#reasoning'], 'emoji': '🔍', 'ru': {'title': 'Комплексная оценка агентов глубокого исследования', 'desc': 'Статья представляет новый бенчмарк для оценки Deep Research Agents (DRA) — AI-агентов, способных к декомпозиции задач, поиску информации из разных источников и многоступенчатому рассуждению. Бенчмарк включает 214 экспертных вопросов из 10 тематических областей с эталонными ответами для комплексной оценки. Предложенная система оценивает длинные отчёты агентов по семантическому качеству, релевантности и достоверности источников. Эксперименты показали, что DRA превосходят обычные LLM с веб-поиском, но всё ещё имеют значительный потенциал для улучшения.'}, 'en': {'title': 'Enhancing Evaluation for Deep Research Agents', 'desc': 'This paper presents a new benchmark and evaluation framework specifically designed for Deep Research Agents (DRAs), which are advanced AI systems capable of handling complex tasks. The framework includes 214 challenging queries across various themes and offers a multidimensional approach to assess the performance of DRAs based on metrics like semantic quality and retrieval trustworthiness. It highlights the limitations of existing benchmarks in evaluating DRAs and proposes a structured method for comprehensive assessment. The findings indicate that while DRAs outperform traditional web-search models, there is still significant room for improvement in their capabilities.'}, 'zh': {'title': '深度研究代理的评估新标准', 'desc': '本文提出了一种针对深度研究代理（DRA）的基准和评估框架，旨在通过多维度指标评估其在复杂任务上的表现。DRA能够进行任务分解、跨源检索、多阶段推理和结构化输出，显著提升了在开放性任务中的表现。现有的评估基准在评估维度、响应格式和评分机制上存在不足，限制了对这些系统的有效评估。本文的框架包含214个专家策划的挑战性查询，支持对DRA生成的长格式报告进行全面评估，提供语义质量、主题聚焦和检索可信度的综合评分。'}}}, {'id': 'https://huggingface.co/papers/2510.01796', 'title': 'Rethinking the shape convention of an MLP', 'url': 'https://huggingface.co/papers/2510.01796', 'abstract': 'Hourglass MLP blocks, with skip connections in expanded dimensions and narrow bottlenecks, outperform conventional narrow-wide-narrow MLPs in generative tasks across image datasets.  \t\t\t\t\tAI-generated summary \t\t\t\t Multi-layer perceptrons (MLPs) conventionally follow a narrow-wide-narrow design where skip connections operate at the input/output dimensions while processing occurs in expanded hidden spaces. We challenge this convention by proposing wide-narrow-wide (Hourglass) MLP blocks where skip connections operate at expanded dimensions while residual computation flows through narrow bottlenecks. This inversion leverages higher-dimensional spaces for incremental refinement while maintaining computational efficiency through parameter-matched designs. Implementing Hourglass MLPs requires an initial projection to lift input signals to expanded dimensions. We propose that this projection can remain fixed at random initialization throughout training, enabling efficient training and inference implementations. We evaluate both architectures on generative tasks over popular image datasets, characterizing performance-parameter Pareto frontiers through systematic architectural search. Results show that Hourglass architectures consistently achieve superior Pareto frontiers compared to conventional designs. As parameter budgets increase, optimal Hourglass configurations favor deeper networks with wider skip connections and narrower bottlenecks-a scaling pattern distinct from conventional MLPs. Our findings suggest reconsidering skip connection placement in modern architectures, with potential applications extending to Transformers and other residual networks.', 'score': 1, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': 'cb9db736774b09f8', 'authors': ['Meng-Hsi Chen', 'Yu-Ang Lee', 'Feng-Ting Liao', 'Da-shan Shiu'], 'affiliations': ['MediaTek Research', 'National Taiwan University'], 'pdf_title_img': 'assets/pdf/title_img/2510.01796.jpg', 'data': {'categories': ['#dataset', '#architecture', '#optimization'], 'emoji': '⏳', 'ru': {'title': 'Песочные часы для нейросетей: skip connections в широком пространстве', 'desc': 'Авторы предлагают архитектуру Hourglass MLP, которая инвертирует традиционный дизайн многослойных перцептронов: skip connections работают в расширенном пространстве признаков, а основные вычисления проходят через узкие bottleneck-слои. Ключевое открытие заключается в том, что начальная проекция в высокоразмерное пространство может оставаться случайной и неизменной в процессе обучения. Эксперименты на генеративных задачах показывают, что Hourglass MLP превосходит классические архитектуры на Парето-фронтах производительности. При увеличении бюджета параметров оптимальные конфигурации становятся глубже с более широкими skip connections и узкими bottlenecks.'}, 'en': {'title': 'Revolutionizing MLPs: Hourglass Architecture for Superior Generative Performance', 'desc': 'This paper introduces Hourglass MLP blocks, which utilize a wide-narrow-wide architecture with skip connections in expanded dimensions, contrasting with the traditional narrow-wide-narrow design. By allowing residual computations to flow through narrow bottlenecks, the model enhances performance in generative tasks while maintaining computational efficiency. The authors demonstrate that fixed random initialization for input signal projections can streamline training and inference processes. Their experiments reveal that Hourglass architectures outperform conventional MLPs, suggesting a need to rethink skip connection strategies in various neural network designs.'}, 'zh': {'title': '重新定义跳跃连接：Hourglass MLP的优势', 'desc': '本文提出了一种新的多层感知机（MLP）结构，称为Hourglass MLP块，采用宽-窄-宽的设计，跳跃连接在扩展维度上操作，而残差计算则通过窄瓶颈流动。这种设计挑战了传统的窄-宽-窄结构，利用高维空间进行增量优化，同时保持计算效率。研究表明，Hourglass MLP在生成任务中表现优于传统设计，尤其是在参数预算增加时，最佳配置倾向于更深的网络和更宽的跳跃连接。我们的发现提示在现代架构中重新考虑跳跃连接的放置，可能对变换器和其他残差网络有广泛的应用。'}}}, {'id': 'https://huggingface.co/papers/2510.01691', 'title': 'MedQ-Bench: Evaluating and Exploring Medical Image Quality Assessment\n  Abilities in MLLMs', 'url': 'https://huggingface.co/papers/2510.01691', 'abstract': 'MedQ-Bench introduces a benchmark for language-based evaluation of medical image quality using Multi-modal Large Language Models, focusing on both perceptual and reasoning capabilities.  \t\t\t\t\tAI-generated summary \t\t\t\t Medical Image Quality Assessment (IQA) serves as the first-mile safety gate for clinical AI, yet existing approaches remain constrained by scalar, score-based metrics and fail to reflect the descriptive, human-like reasoning process central to expert evaluation. To address this gap, we introduce MedQ-Bench, a comprehensive benchmark that establishes a perception-reasoning paradigm for language-based evaluation of medical image quality with Multi-modal Large Language Models (MLLMs). MedQ-Bench defines two complementary tasks: (1) MedQ-Perception, which probes low-level perceptual capability via human-curated questions on fundamental visual attributes; and (2) MedQ-Reasoning, encompassing both no-reference and comparison reasoning tasks, aligning model evaluation with human-like reasoning on image quality. The benchmark spans five imaging modalities and over forty quality attributes, totaling 2,600 perceptual queries and 708 reasoning assessments, covering diverse image sources including authentic clinical acquisitions, images with simulated degradations via physics-based reconstructions, and AI-generated images. To evaluate reasoning ability, we propose a multi-dimensional judging protocol that assesses model outputs along four complementary axes. We further conduct rigorous human-AI alignment validation by comparing LLM-based judgement with radiologists. Our evaluation of 14 state-of-the-art MLLMs demonstrates that models exhibit preliminary but unstable perceptual and reasoning skills, with insufficient accuracy for reliable clinical use. These findings highlight the need for targeted optimization of MLLMs in medical IQA. We hope that MedQ-Bench will catalyze further exploration and unlock the untapped potential of MLLMs for medical image quality evaluation.', 'score': 1, 'issue_id': 6221, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '1aec9b0a96bf1d83', 'authors': ['Jiyao Liu', 'Jinjie Wei', 'Wanying Qu', 'Chenglong Ma', 'Junzhi Ning', 'Yunheng Li', 'Ying Chen', 'Xinzhe Luo', 'Pengcheng Chen', 'Xin Gao', 'Ming Hu', 'Huihui Xu', 'Xin Wang', 'Shujian Gao', 'Dingkang Yang', 'Zhongying Deng', 'Jin Ye', 'Lihao Liu', 'Junjun He', 'Ningsheng Xu'], 'affiliations': ['Fudan University', 'Imperial College London', 'Shanghai Artificial Intelligence Laboratory', 'University of Cambridge'], 'pdf_title_img': 'assets/pdf/title_img/2510.01691.jpg', 'data': {'categories': ['#multimodal', '#benchmark', '#healthcare', '#optimization', '#reasoning'], 'emoji': '🏥', 'ru': {'title': 'Оценка качества медицинских изображений через призму человеческого восприятия и рассуждений', 'desc': 'MedQ-Bench — это новый benchmark для оценки качества медицинских изображений с помощью мультимодальных LLM, который фокусируется на восприятии и логическом рассуждении вместо простых числовых метрик. Benchmark включает два типа задач: MedQ-Perception для проверки базовых визуальных способностей и MedQ-Reasoning для оценки умения рассуждать о качестве изображений подобно экспертам-радиологам. Датасет охватывает пять типов медицинской визуализации и более 40 параметров качества, включая реальные клинические снимки, изображения с симулированными дефектами и AI-generated контент — всего 2600 перцептивных вопросов и 708 задач на рассуждение. Тестирование 14 современных MLLM показало, что модели обладают лишь начальными и нестабильными навыками оценки качества, что недостаточно для надежного клинического применения.'}, 'en': {'title': 'Revolutionizing Medical Image Quality Assessment with Language Models', 'desc': 'MedQ-Bench is a new benchmark designed to evaluate the quality of medical images using Multi-modal Large Language Models (MLLMs). It addresses the limitations of traditional methods that rely on simple score-based metrics, which do not capture the complex reasoning that human experts use. The benchmark includes two main tasks: MedQ-Perception for assessing basic visual attributes and MedQ-Reasoning for evaluating more complex reasoning about image quality. By providing a comprehensive set of tasks and a robust evaluation framework, MedQ-Bench aims to improve the performance of MLLMs in medical image quality assessment and encourage further research in this area.'}, 'zh': {'title': '医学图像质量评估的新基准：MedQ-Bench', 'desc': 'MedQ-Bench是一个用于医学图像质量评估的基准，利用多模态大型语言模型（MLLMs）进行语言基础的评估。该基准关注感知和推理能力，定义了两个互补的任务：MedQ-Perception和MedQ-Reasoning。MedQ-Perception通过人类策划的问题探测低级感知能力，而MedQ-Reasoning则包括无参考和比较推理任务，旨在使模型评估与人类专家的推理过程相一致。我们的研究表明，现有的MLLM在医学图像质量评估中表现出初步但不稳定的感知和推理能力，强调了对这些模型进行针对性优化的必要性。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents (3)', '#agi', '#alignment', '#architecture (2)', '#audio', '#benchmark (6)', '#cv (1)', '#data (1)', '#dataset (4)', '#diffusion (1)', '#ethics', '#games (2)', '#graphs (1)', '#hallucinations', '#healthcare (1)', '#inference', '#interpretability (2)', '#leakage', '#long_context (2)', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal (3)', '#open_source (4)', '#optimization (8)', '#plp (1)', '#rag', '#reasoning (5)', '#rl (1)', '#rlhf (1)', '#robotics', '#science (1)', '#security', '#small_models (1)', '#story_generation', '#survey', '#synthetic (1)', '#training (5)', '#transfer_learning', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-10-03 02:15',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-10-03 02:15')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-10-03 02:15')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    