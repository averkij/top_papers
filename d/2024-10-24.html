
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 13 papers. October 24.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            flex: 1 0 auto;
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 0 20px 0;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .article-content {
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
        }
        body.dark-theme>div>main>article {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article {
            background-color: #fff;
        }
        body.dark-theme>div>main>article:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 0px;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
                margin: 0 -20px;
            }
            footer {
                margin-top: -20px;
            }
            article {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">24 октября</span> | <span id="title-articles-count">13 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item" id="nav-prev"><a href="/d/2024-10-23.html">⬅️ <span id="prev-date">23.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-10-25.html">➡️ <span id="next-date">25.10</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2024-10.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'};
        let feedDateNext = {'ru': '25.10', 'en': '10/25', 'zh': '10月25日'};
        let feedDatePrev = {'ru': '23.10', 'en': '10/23', 'zh': '10月23日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2410.17637', 'title': 'MIA-DPO: Multi-Image Augmented Direct Preference Optimization For Large Vision-Language Models', 'url': 'https://huggingface.co/papers/2410.17637', 'abstract': "Visual preference alignment involves training Large Vision-Language Models (LVLMs) to predict human preferences between visual inputs. This is typically achieved by using labeled datasets of chosen/rejected pairs and employing optimization algorithms like direct preference optimization (DPO). Existing visual alignment methods, primarily designed for single-image scenarios, struggle to effectively handle the complexity of multi-image tasks due to the scarcity of diverse training data and the high cost of annotating chosen/rejected pairs. We present Multi-Image Augmented Direct Preference Optimization (MIA-DPO), a visual preference alignment approach that effectively handles multi-image inputs. MIA-DPO mitigates the scarcity of diverse multi-image training data by extending single-image data with unrelated images arranged in grid collages or pic-in-pic formats, significantly reducing the costs associated with multi-image data annotations. Our observation reveals that attention values of LVLMs vary considerably across different images. We use attention values to identify and filter out rejected responses the model may have mistakenly focused on. Our attention-aware selection for constructing the chosen/rejected pairs without relying on (i) human annotation, (ii) extra data, and (iii) external models or APIs. MIA-DPO is compatible with various architectures and outperforms existing methods on five multi-image benchmarks, achieving an average performance boost of 3.0% on LLaVA-v1.5 and 4.3% on the recent InternLM-XC2.5. Moreover, MIA-DPO has a minimal effect on the model's ability to understand single images.", 'score': 34, 'issue_id': 243, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '2dc1395b8aa096fc', 'authors': ['Ziyu Liu', 'Yuhang Zang', 'Xiaoyi Dong', 'Pan Zhang', 'Yuhang Cao', 'Haodong Duan', 'Conghui He', 'Yuanjun Xiong', 'Dahua Lin', 'Jiaqi Wang'], 'affiliations': ['CUHK', 'MThreads, Inc.', 'SJTU', 'Shanghai AI Laboratory'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.17637.jpg', 'data': {'categories': ['#synthetic', '#rlhf', '#benchmark', '#cv', '#optimization', '#dataset', '#architecture', '#alignment'], 'emoji': '🖼️', 'ru': {'title': 'MIA-DPO: эффективное обучение LVLM на многоизображительных данных', 'desc': 'Статья представляет новый метод обучения больших визуально-языковых моделей (LVLM) под названием MIA-DPO. Этот подход эффективно работает с многоизображительными входными данными, решая проблему нехватки разнообразных обучающих данных. MIA-DPO расширяет однозображительные данные, добавляя несвязанные изображения в виде сеток или картинок-в-картинке. Метод использует значения внимания LVLM для идентификации и фильтрации ошибочно отвергнутых ответов, не требуя дополнительной аннотации или внешних моделей.'}, 'en': {'title': 'Enhancing Visual Preference Prediction with MIA-DPO', 'desc': 'The paper introduces a new method called Multi-Image Augmented Direct Preference Optimization (MIA-DPO) to improve how Large Vision-Language Models (LVLMs) predict human preferences between multiple images. MIA-DPO cleverly uses existing single-image data by combining them into collages, which helps reduce the need for expensive multi-image annotations. The method also uses attention values from the models to automatically filter out less relevant images, avoiding the need for human input or extra data. This approach is shown to work well with different model architectures, improving performance on several benchmarks without affecting single-image understanding.'}, 'zh': {'title': '多图像任务的视觉偏好对齐新突破', 'desc': '这篇论文介绍了一种新的视觉偏好对齐方法，称为多图像增强直接偏好优化（MIA-DPO）。MIA-DPO通过将单图像数据与不相关的图像组合在一起，解决了多图像任务中训练数据稀缺的问题，从而降低了数据标注的成本。该方法利用大规模视觉语言模型的注意力值来识别和过滤掉错误关注的图像，无需依赖人工标注或额外数据。实验结果表明，MIA-DPO在多个多图像基准测试中表现优异，并且对单图像理解能力影响较小。'}}}, {'id': 'https://huggingface.co/papers/2410.17434', 'title': 'LongVU: Spatiotemporal Adaptive Compression for Long Video-Language Understanding', 'url': 'https://huggingface.co/papers/2410.17434', 'abstract': "Multimodal Large Language Models (MLLMs) have shown promising progress in understanding and analyzing video content. However, processing long videos remains a significant challenge constrained by LLM's context size. To address this limitation, we propose LongVU, a spatiotemporal adaptive compression mechanism thats reduces the number of video tokens while preserving visual details of long videos. Our idea is based on leveraging cross-modal query and inter-frame dependencies to adaptively reduce temporal and spatial redundancy in videos. Specifically, we leverage DINOv2 features to remove redundant frames that exhibit high similarity. Then we utilize text-guided cross-modal query for selective frame feature reduction. Further, we perform spatial token reduction across frames based on their temporal dependencies. Our adaptive compression strategy effectively processes a large number of frames with little visual information loss within given context length. Our LongVU consistently surpass existing methods across a variety of video understanding benchmarks, especially on hour-long video understanding tasks such as VideoMME and MLVU. Given a light-weight LLM, our LongVU also scales effectively into a smaller size with state-of-the-art video understanding performance.", 'score': 24, 'issue_id': 253, 'pub_date': '2024-10-22', 'pub_date_card': {'ru': '22 октября', 'en': 'October 22', 'zh': '10月22日'}, 'hash': 'ab4b27c05d7611e1', 'authors': ['Xiaoqian Shen', 'Yunyang Xiong', 'Changsheng Zhao', 'Lemeng Wu', 'Jun Chen', 'Chenchen Zhu', 'Zechun Liu', 'Fanyi Xiao', 'Balakrishnan Varadarajan', 'Florian Bordes', 'Zhuang Liu', 'Hu Xu', 'Hyunwoo J. Kim', 'Bilge Soran', 'Raghuraman Krishnamoorthi', 'Mohamed Elhoseiny', 'Vikas Chandra'], 'affiliations': ['King Abdullah University of Science and Technology (KAUST)', 'Korea University', 'Meta AI'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.17434.jpg', 'data': {'categories': ['#long_context', '#small_models', '#benchmark', '#video', '#optimization', '#multimodal', '#architecture'], 'emoji': '🎥', 'ru': {'title': 'LongVU: Эффективное сжатие для понимания длинных видео', 'desc': 'LongVU - это новый механизм адаптивного сжатия для анализа длинных видео мультимодальными большими языковыми моделями (MLLM). Он использует кросс-модальные запросы и межкадровые зависимости для уменьшения временной и пространственной избыточности в видео. LongVU применяет признаки DINOv2 для удаления похожих кадров и текстовые запросы для выборочного сокращения признаков кадров. Этот подход позволяет эффективно обрабатывать большое количество кадров с минимальной потерей визуальной информации в рамках заданного контекста.'}, 'en': {'title': '"LongVU: Mastering Long Video Understanding with Efficient Compression"', 'desc': 'The paper introduces LongVU, a method to efficiently process long videos using Multimodal Large Language Models (MLLMs) by reducing video tokens while maintaining visual details. It uses a spatiotemporal adaptive compression mechanism that leverages cross-modal queries and inter-frame dependencies to minimize redundancy. By employing DINOv2 features, it removes similar frames and uses text-guided queries for selective frame reduction. LongVU outperforms existing methods in video understanding tasks, especially with hour-long videos, and scales well with smaller LLMs.'}, 'zh': {'title': 'LongVU：长视频理解的新突破', 'desc': '这篇论文介绍了一种名为LongVU的新方法，用于处理长视频中的信息冗余问题。LongVU通过跨模态查询和帧间依赖性，适应性地减少视频中的时间和空间冗余。具体来说，它利用DINOv2特征去除相似度高的冗余帧，并通过文本引导的跨模态查询选择性地减少帧特征。该方法在处理长视频时，能够在保持视觉细节的同时，显著减少视频令牌数量。'}}}, {'id': 'https://huggingface.co/papers/2410.18072', 'title': 'WorldSimBench: Towards Video Generation Models as World Simulators', 'url': 'https://huggingface.co/papers/2410.18072', 'abstract': 'Recent advancements in predictive models have demonstrated exceptional capabilities in predicting the future state of objects and scenes. However, the lack of categorization based on inherent characteristics continues to hinder the progress of predictive model development. Additionally, existing benchmarks are unable to effectively evaluate higher-capability, highly embodied predictive models from an embodied perspective. In this work, we classify the functionalities of predictive models into a hierarchy and take the first step in evaluating World Simulators by proposing a dual evaluation framework called WorldSimBench. WorldSimBench includes Explicit Perceptual Evaluation and Implicit Manipulative Evaluation, encompassing human preference assessments from the visual perspective and action-level evaluations in embodied tasks, covering three representative embodied scenarios: Open-Ended Embodied Environment, Autonomous, Driving, and Robot Manipulation. In the Explicit Perceptual Evaluation, we introduce the HF-Embodied Dataset, a video assessment dataset based on fine-grained human feedback, which we use to train a Human Preference Evaluator that aligns with human perception and explicitly assesses the visual fidelity of World Simulators. In the Implicit Manipulative Evaluation, we assess the video-action consistency of World Simulators by evaluating whether the generated situation-aware video can be accurately translated into the correct control signals in dynamic environments. Our comprehensive evaluation offers key insights that can drive further innovation in video generation models, positioning World Simulators as a pivotal advancement toward embodied artificial intelligence.', 'score': 17, 'issue_id': 243, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': 'e4c42676df8ded0d', 'authors': ['Yiran Qin', 'Zhelun Shi', 'Jiwen Yu', 'Xijun Wang', 'Enshen Zhou', 'Lijun Li', 'Zhenfei Yin', 'Xihui Liu', 'Lu Sheng', 'Jing Shao', 'Lei Bai', 'Wanli Ouyang', 'Ruimao Zhang'], 'affiliations': ['Beihang University', 'Shanghai Artificial Intelligence Laboratory', 'The Chinese University of Hong Kong, Shenzhen', 'The University of Hong Kong'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.18072.jpg', 'data': {'categories': ['#synthetic', '#rlhf', '#benchmark', '#video', '#multimodal', '#interpretability', '#robotics', '#dataset', '#games', '#alignment'], 'emoji': '🌐', 'ru': {'title': 'WorldSimBench: Комплексная оценка симуляторов мира для воплощенного ИИ', 'desc': 'Статья представляет новый подход к оценке предиктивных моделей, называемый WorldSimBench. Эта система включает в себя явную перцептивную оценку и неявную манипулятивную оценку, охватывающие три сценария: открытую среду, автономное вождение и робототехнику. Авторы вводят датасет HF-Embodied для оценки визуальной точности симуляторов мира на основе человеческих предпочтений. Также предлагается оценка соответствия видео и действий, проверяя, могут ли сгенерированные видео точно преобразовываться в сигналы управления в динамических средах.'}, 'en': {'title': 'Advancing Predictive Models with WorldSimBench: A New Era for Embodied AI', 'desc': 'This paper addresses the challenge of categorizing predictive models based on their inherent characteristics to enhance their development. It introduces WorldSimBench, a dual evaluation framework for assessing World Simulators, which includes Explicit Perceptual Evaluation and Implicit Manipulative Evaluation. The framework uses the HF-Embodied Dataset to train a Human Preference Evaluator for visual fidelity and assesses video-action consistency in dynamic environments. This comprehensive evaluation aims to advance video generation models and promote the development of embodied artificial intelligence.'}, 'zh': {'title': '推动具身人工智能的世界模拟器评估', 'desc': '这篇论文探讨了预测模型在预测物体和场景未来状态方面的能力，但指出缺乏基于内在特征的分类限制了其发展。为了解决这个问题，作者提出了一个名为WorldSimBench的双重评估框架，用于评估世界模拟器。WorldSimBench包括显式感知评估和隐式操作评估，涵盖了开放式环境、自主驾驶和机器人操作等场景。通过这种评估，研究人员希望推动视频生成模型的创新，促进具身人工智能的发展。'}}}, {'id': 'https://huggingface.co/papers/2410.17891', 'title': 'Scaling Diffusion Language Models via Adaptation from Autoregressive Models', 'url': 'https://huggingface.co/papers/2410.17891', 'abstract': 'Diffusion Language Models (DLMs) have emerged as a promising new paradigm for text generative modeling, potentially addressing limitations of autoregressive (AR) models. However, current DLMs have been studied at a smaller scale compared to their AR counterparts and lack fair comparison on language modeling benchmarks. Additionally, training diffusion models from scratch at scale remains challenging. Given the prevalence of open-source AR language models, we propose adapting these models to build text diffusion models. We demonstrate connections between AR and diffusion modeling objectives and introduce a simple continual pre-training approach for training diffusion models. Through systematic evaluation on language modeling, reasoning, and commonsense benchmarks, we show that we can convert AR models ranging from 127M to 7B parameters (GPT2 and LLaMA) into diffusion models DiffuGPT and DiffuLLaMA, using less than 200B tokens for training. Our experimental results reveal that these models outperform earlier DLMs and are competitive with their AR counterparts. We release a suite of DLMs (with 127M, 355M, and 7B parameters) capable of generating fluent text, performing in-context learning, filling in the middle without prompt re-ordering, and following instructions https://github.com/HKUNLP/DiffuLLaMA.', 'score': 15, 'issue_id': 243, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': 'a6f6dc7932b17a7f', 'authors': ['Shansan Gong', 'Shivam Agarwal', 'Yizhe Zhang', 'Jiacheng Ye', 'Lin Zheng', 'Mukai Li', 'Chenxin An', 'Peilin Zhao', 'Wei Bi', 'Jiawei Han', 'Hao Peng', 'Lingpeng Kong'], 'affiliations': ['Apple', 'Tencent AI Lab', 'The University of HongKong', 'University of Illinois at Urbana-Champaign'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.17891.jpg', 'data': {'categories': ['#diffusion', '#small_models', '#reasoning', '#benchmark', '#training', '#transfer_learning', '#open_source', '#architecture'], 'emoji': '🔄', 'ru': {'title': 'Преобразование авторегрессионных моделей в диффузионные: новый шаг в языковом моделировании', 'desc': 'Исследователи предлагают новый подход к созданию диффузионных языковых моделей (DLM), адаптируя существующие авторегрессионные модели. Они демонстрируют связь между целевыми функциями авторегрессионных и диффузионных моделей и вводят метод дообучения для создания DLM. Эксперименты показывают, что полученные модели DiffuGPT и DiffuLLaMA превосходят предыдущие DLM и конкурентоспособны с авторегрессионными аналогами. Авторы представляют набор DLM различных размеров, способных генерировать связный текст и выполнять различные языковые задачи.'}, 'en': {'title': 'Revolutionizing Text Generation: From Autoregressive to Diffusion Models', 'desc': 'This paper explores the potential of Diffusion Language Models (DLMs) as an alternative to traditional autoregressive (AR) models for text generation. The authors propose a method to adapt existing AR models into DLMs, demonstrating that these adapted models can perform competitively on various language tasks. They introduce a continual pre-training approach to efficiently train these diffusion models using fewer resources. The study shows that the adapted models, DiffuGPT and DiffuLLaMA, outperform previous DLMs and match the performance of AR models on several benchmarks.'}, 'zh': {'title': '扩散语言模型：突破自回归模型的局限', 'desc': '扩散语言模型（DLMs）是一种新兴的文本生成模型，可能解决自回归（AR）模型的局限性。研究表明，通过将开源的AR模型适配为扩散模型，可以在语言建模基准上实现更好的性能。我们提出了一种简单的持续预训练方法，将AR模型转换为扩散模型，并在多个基准上进行了系统评估。实验结果显示，这些转换后的模型在生成流畅文本和上下文学习等任务上表现优异。'}}}, {'id': 'https://huggingface.co/papers/2410.18013', 'title': 'Scalable Ranked Preference Optimization for Text-to-Image Generation', 'url': 'https://huggingface.co/papers/2410.18013', 'abstract': "Direct Preference Optimization (DPO) has emerged as a powerful approach to align text-to-image (T2I) models with human feedback. Unfortunately, successful application of DPO to T2I models requires a huge amount of resources to collect and label large-scale datasets, e.g., millions of generated paired images annotated with human preferences. In addition, these human preference datasets can get outdated quickly as the rapid improvements of T2I models lead to higher quality images. In this work, we investigate a scalable approach for collecting large-scale and fully synthetic datasets for DPO training. Specifically, the preferences for paired images are generated using a pre-trained reward function, eliminating the need for involving humans in the annotation process, greatly improving the dataset collection efficiency. Moreover, we demonstrate that such datasets allow averaging predictions across multiple models and collecting ranked preferences as opposed to pairwise preferences. Furthermore, we introduce RankDPO to enhance DPO-based methods using the ranking feedback. Applying RankDPO on SDXL and SD3-Medium models with our synthetically generated preference dataset ``Syn-Pic'' improves both prompt-following (on benchmarks like T2I-Compbench, GenEval, and DPG-Bench) and visual quality (through user studies). This pipeline presents a practical and scalable solution to develop better preference datasets to enhance the performance of text-to-image models.", 'score': 14, 'issue_id': 246, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '05611e12662f347d', 'authors': ['Shyamgopal Karthik', 'Huseyin Coskun', 'Zeynep Akata', 'Sergey Tulyakov', 'Jian Ren', 'Anil Kag'], 'affiliations': ['Snap Inc.', 'Tübingen AI Center, Technical University of Munich, Helmholtz Munich'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.18013.jpg', 'data': {'categories': ['#synthetic', '#rlhf', '#benchmark', '#cv', '#optimization', '#data', '#training', '#dataset', '#alignment'], 'emoji': '🖼️', 'ru': {'title': 'Синтетические данные для улучшения генерации изображений по тексту', 'desc': 'Статья представляет новый подход к улучшению моделей генерации изображений по текстовому описанию (text-to-image). Авторы предлагают использовать синтетические наборы данных для обучения методом Direct Preference Optimization (DPO), что позволяет избежать трудоемкого процесса сбора предпочтений от людей. Они вводят метод RankDPO, который использует ранжированные предпочтения вместо попарных. Эксперименты показывают, что предложенный подход улучшает как следование промпту, так и визуальное качество генерируемых изображений.'}, 'en': {'title': '"Revolutionizing Text-to-Image Models with Synthetic Preferences"', 'desc': 'The paper explores a new method for improving text-to-image models by using Direct Preference Optimization (DPO) without relying on human-annotated datasets. Instead of collecting human feedback, the authors use a pre-trained reward function to generate synthetic datasets, which makes the process more efficient and scalable. They introduce RankDPO, a technique that uses ranking feedback to further enhance model performance. The results show that using these synthetic datasets improves both the accuracy of following prompts and the visual quality of generated images.'}, 'zh': {'title': '合成数据集：提升文本到图像模型的新途径', 'desc': '这篇论文探讨了一种可扩展的方法来收集用于直接偏好优化（DPO）训练的大规模全合成数据集。通过使用预训练的奖励函数生成图像对的偏好，消除了人工标注的需求，大大提高了数据集收集的效率。此外，研究表明，这种数据集允许在多个模型之间进行预测平均，并收集排名偏好而不是成对偏好。引入的RankDPO方法通过排名反馈增强了基于DPO的方法，提升了文本到图像模型的性能。'}}}, {'id': 'https://huggingface.co/papers/2410.18084', 'title': 'DynamicCity: Large-Scale LiDAR Generation from Dynamic Scenes', 'url': 'https://huggingface.co/papers/2410.18084', 'abstract': 'LiDAR scene generation has been developing rapidly recently. However, existing methods primarily focus on generating static and single-frame scenes, overlooking the inherently dynamic nature of real-world driving environments. In this work, we introduce DynamicCity, a novel 4D LiDAR generation framework capable of generating large-scale, high-quality LiDAR scenes that capture the temporal evolution of dynamic environments. DynamicCity mainly consists of two key models. 1) A VAE model for learning HexPlane as the compact 4D representation. Instead of using naive averaging operations, DynamicCity employs a novel Projection Module to effectively compress 4D LiDAR features into six 2D feature maps for HexPlane construction, which significantly enhances HexPlane fitting quality (up to 12.56 mIoU gain). Furthermore, we utilize an Expansion & Squeeze Strategy to reconstruct 3D feature volumes in parallel, which improves both network training efficiency and reconstruction accuracy than naively querying each 3D point (up to 7.05 mIoU gain, 2.06x training speedup, and 70.84% memory reduction). 2) A DiT-based diffusion model for HexPlane generation. To make HexPlane feasible for DiT generation, a Padded Rollout Operation is proposed to reorganize all six feature planes of the HexPlane as a squared 2D feature map. In particular, various conditions could be introduced in the diffusion or sampling process, supporting versatile 4D generation applications, such as trajectory- and command-driven generation, inpainting, and layout-conditioned generation. Extensive experiments on the CarlaSC and Waymo datasets demonstrate that DynamicCity significantly outperforms existing state-of-the-art 4D LiDAR generation methods across multiple metrics. The code will be released to facilitate future research.', 'score': 12, 'issue_id': 250, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': 'c726f29cc044d5f6', 'authors': ['Hengwei Bian', 'Lingdong Kong', 'Haozhe Xie', 'Liang Pan', 'Yu Qiao', 'Ziwei Liu'], 'affiliations': ['Carnegie Mellon University', 'National University of Singapore', 'S-Lab, Nanyang Technological University', 'Shanghai AI Laboratory'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.18084.jpg', 'data': {'categories': ['#diffusion', '#cv', '#graphs', '#optimization', '#dataset', '#open_source', '#games', '#3d', '#architecture'], 'emoji': '🚗', 'ru': {'title': 'DynamicCity: революция в генерации динамических 4D LiDAR сцен', 'desc': 'Статья представляет DynamicCity - новую систему для генерации динамических 4D LiDAR сцен. Основу системы составляют VAE модель для создания компактного 4D представления HexPlane и DiT-based диффузионная модель для генерации HexPlane. Авторы предлагают ряд инновационных методов, включая Projection Module и Expansion & Squeeze Strategy, для повышения качества и эффективности генерации. Эксперименты показывают, что DynamicCity значительно превосходит существующие методы генерации 4D LiDAR сцен по нескольким метрикам.'}, 'en': {'title': 'DynamicCity: Bringing 4D LiDAR Scenes to Life', 'desc': 'DynamicCity is a new framework for generating 4D LiDAR scenes that capture the dynamic nature of real-world environments. It uses a VAE model to create a compact 4D representation called HexPlane, which improves fitting quality by compressing features into 2D maps. The framework also includes an Expansion & Squeeze Strategy to enhance training efficiency and accuracy. Additionally, a DiT-based diffusion model is used for generating HexPlane, allowing for versatile applications like trajectory-driven generation and inpainting.'}, 'zh': {'title': 'DynamicCity：捕捉动态环境的4D LiDAR生成框架', 'desc': '这篇论文介绍了一种名为DynamicCity的新型4D LiDAR生成框架，能够生成大规模、高质量的动态环境LiDAR场景。DynamicCity主要由两个关键模型组成：一个VAE模型用于学习HexPlane作为紧凑的4D表示，通过投影模块将4D特征压缩为六个2D特征图，从而提高了HexPlane的拟合质量。另一个是基于DiT的扩散模型，用于生成HexPlane，并通过填充展开操作将六个特征平面重新组织为一个方形2D特征图。实验表明，DynamicCity在多个指标上显著优于现有的4D LiDAR生成方法。'}}}, {'id': 'https://huggingface.co/papers/2410.15522', 'title': 'M-RewardBench: Evaluating Reward Models in Multilingual Settings', 'url': 'https://huggingface.co/papers/2410.15522', 'abstract': "Reward models (RMs) have driven the state-of-the-art performance of LLMs today by enabling the integration of human feedback into the language modeling process. However, RMs are primarily trained and evaluated in English, and their capabilities in multilingual settings remain largely understudied. In this work, we conduct a systematic evaluation of several reward models in multilingual settings. We first construct the first-of-its-kind multilingual RM evaluation benchmark, M-RewardBench, consisting of 2.87k preference instances for 23 typologically diverse languages, that tests the chat, safety, reasoning, and translation capabilities of RMs. We then rigorously evaluate a wide range of reward models on M-RewardBench, offering fresh insights into their performance across diverse languages. We identify a significant gap in RMs' performances between English and non-English languages and show that RM preferences can change substantially from one language to another. We also present several findings on how different multilingual aspects impact RM performance. Specifically, we show that the performance of RMs is improved with improved translation quality. Similarly, we demonstrate that the models exhibit better performance for high-resource languages. We release M-RewardBench dataset and the codebase in this study to facilitate a better understanding of RM evaluation in multilingual settings.", 'score': 10, 'issue_id': 247, 'pub_date': '2024-10-20', 'pub_date_card': {'ru': '20 октября', 'en': 'October 20', 'zh': '10月20日'}, 'hash': '5143b0b6f1067fee', 'authors': ['Srishti Gureja', 'Lester James V. Miranda', 'Shayekh Bin Islam', 'Rishabh Maheshwary', 'Drishti Sharma', 'Gusti Winata', 'Nathan Lambert', 'Sebastian Ruder', 'Sara Hooker', 'Marzieh Fadaee'], 'affiliations': ['Allen Institute for AI', 'Bangladesh University of Engineering and Technology', 'Cohere', 'Cohere For AI', 'Cohere For AI Community', 'ServiceNow', 'Writesonic'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.15522.jpg', 'data': {'categories': ['#rlhf', '#benchmark', '#multilingual', '#dataset', '#open_source', '#low_resource', '#machine_translation', '#alignment'], 'emoji': '🌍', 'ru': {'title': 'Многоязычная оценка моделей вознаграждения: новые горизонты и вызовы', 'desc': 'Данная статья посвящена исследованию моделей вознаграждения (reward models) в многоязычном контексте. Авторы создали первый в своем роде многоязычный эталонный набор данных M-RewardBench для оценки таких моделей на 23 типологически разных языках. Проведя тщательную оценку различных моделей вознаграждения, исследователи выявили значительный разрыв в производительности между английским и другими языками. Результаты показывают, что качество перевода и ресурсообеспеченность языка положительно влияют на эффективность моделей вознаграждения.'}, 'en': {'title': 'Bridging the Language Gap: Evaluating Reward Models Multilingually', 'desc': "This paper explores how reward models (RMs), which enhance language models by incorporating human feedback, perform in multilingual contexts. The authors introduce M-RewardBench, a new benchmark with 2.87k preference instances across 23 languages, to evaluate RMs' abilities in chat, safety, reasoning, and translation. Their findings reveal a performance gap between English and other languages, with RMs showing varied preferences across languages. The study highlights that better translation quality and high-resource languages improve RM performance, and they provide the M-RewardBench dataset and codebase for further research."}, 'zh': {'title': '多语言奖励模型：跨语言表现的新视角', 'desc': '这篇论文研究了奖励模型在多语言环境中的表现。研究者们创建了一个名为M-RewardBench的多语言评估基准，包含23种语言的偏好实例。结果显示，奖励模型在英语和非英语语言之间的表现存在显著差距。研究还发现，翻译质量和语言资源丰富度对模型表现有重要影响。'}}}, {'id': 'https://huggingface.co/papers/2410.17883', 'title': 'Lightweight Neural App Control', 'url': 'https://huggingface.co/papers/2410.17883', 'abstract': 'This paper introduces a novel mobile phone control architecture, termed ``app agents", for efficient interactions and controls across various Android apps. The proposed Lightweight Multi-modal App Control (LiMAC) takes as input a textual goal and a sequence of past mobile observations, such as screenshots and corresponding UI trees, to generate precise actions. To address the computational constraints inherent to smartphones, within LiMAC, we introduce a small Action Transformer (AcT) integrated with a fine-tuned vision-language model (VLM) for real-time decision-making and task execution. We evaluate LiMAC on two open-source mobile control datasets, demonstrating the superior performance of our small-form-factor approach against fine-tuned versions of open-source VLMs, such as Florence2 and Qwen2-VL. It also significantly outperforms prompt engineering baselines utilising closed-source foundation models like GPT-4o. More specifically, LiMAC increases the overall action accuracy by up to 19% compared to fine-tuned VLMs, and up to 42% compared to prompt-engineering baselines.', 'score': 9, 'issue_id': 243, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '66e9ccd38bb979e0', 'authors': ['Filippos Christianos', 'Georgios Papoudakis', 'Thomas Coste', 'Jianye Hao', 'Jun Wang', 'Kun Shao'], 'affiliations': ['Huawei Noahs Ark Lab', 'University College London'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.17883.jpg', 'data': {'categories': ['#small_models', '#cv', '#multimodal', '#training', '#dataset', '#transfer_learning', '#open_source', '#agents', '#architecture'], 'emoji': '📱', 'ru': {'title': 'Эффективное управление Android-приложениями с помощью легковесных агентов', 'desc': "Статья представляет новую архитектуру управления мобильными приложениями под названием 'app agents'. Предложенная система LiMAC использует текстовую цель и последовательность предыдущих наблюдений для генерации точных действий. Авторы вводят компактный Action Transformer (AcT) в сочетании с настроенной мультимодальной моделью для принятия решений в реальном времени. Эксперименты показывают, что LiMAC превосходит базовые модели на основе промптов и настроенные мультимодальные модели, повышая точность действий до 42%."}, 'en': {'title': '"LiMAC: Smarter, Faster Mobile App Control"', 'desc': 'This paper presents a new system called "app agents" for controlling Android apps more efficiently. The system, LiMAC, uses text goals and past mobile data like screenshots to decide what actions to take. It includes a small Action Transformer and a vision-language model to work quickly on smartphones. Tests show LiMAC performs better than other models, improving action accuracy by up to 42%.'}, 'zh': {'title': 'LiMAC：提升手机应用控制效率的新架构', 'desc': '这篇论文介绍了一种新的手机控制架构，称为“应用代理”，用于在各种安卓应用中实现高效的交互和控制。提出的轻量级多模态应用控制（LiMAC）可以根据文本目标和过去的手机观察（如截图和UI树）生成精确的操作。为了应对智能手机的计算限制，LiMAC中引入了一个小型动作变换器（AcT），并与微调的视觉语言模型（VLM）集成，实现实时决策和任务执行。实验结果表明，LiMAC在两个开源移动控制数据集上的表现优于微调的开源VLM，并显著超过了使用闭源基础模型的提示工程基线。'}}}, {'id': 'https://huggingface.co/papers/2410.13458', 'title': 'MedINST: Meta Dataset of Biomedical Instructions', 'url': 'https://huggingface.co/papers/2410.13458', 'abstract': "The integration of large language model (LLM) techniques in the field of medical analysis has brought about significant advancements, yet the scarcity of large, diverse, and well-annotated datasets remains a major challenge. Medical data and tasks, which vary in format, size, and other parameters, require extensive preprocessing and standardization for effective use in training LLMs. To address these challenges, we introduce MedINST, the Meta Dataset of Biomedical Instructions, a novel multi-domain, multi-task instructional meta-dataset. MedINST comprises 133 biomedical NLP tasks and over 7 million training samples, making it the most comprehensive biomedical instruction dataset to date. Using MedINST as the meta dataset, we curate MedINST32, a challenging benchmark with different task difficulties aiming to evaluate LLMs' generalization ability. We fine-tune several LLMs on MedINST and evaluate on MedINST32, showcasing enhanced cross-task generalization.", 'score': 6, 'issue_id': 250, 'pub_date': '2024-10-17', 'pub_date_card': {'ru': '17 октября', 'en': 'October 17', 'zh': '10月17日'}, 'hash': '838e617c67ce19c3', 'authors': ['Wenhan Han', 'Meng Fang', 'Zihan Zhang', 'Yu Yin', 'Zirui Song', 'Ling Chen', 'Mykola Pechenizkiy', 'Qingyu Chen'], 'affiliations': ['Eindhoven University of Technology', 'University of Liverpool', 'University of Technology Sydney', 'Yale University'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.13458.jpg', 'data': {'categories': ['#science', '#synthetic', '#benchmark', '#healthcare', '#data', '#training', '#dataset', '#transfer_learning'], 'emoji': '🧬', 'ru': {'title': 'MedINST: революция в обучении LLM для медицинского анализа', 'desc': 'Статья представляет MedINST - новый мета-датасет медицинских инструкций для обучения больших языковых моделей (LLM) в области биомедицинского анализа. MedINST включает 133 задачи и более 7 миллионов обучающих примеров, что делает его самым обширным биомедицинским инструкционным датасетом на сегодняшний день. Авторы также создали MedINST32 - сложный бенчмарк для оценки способности LLM к обобщению. Эксперименты показали улучшенную кросс-задачную генерализацию моделей, обученных на MedINST.'}, 'en': {'title': 'MedINST: Revolutionizing Medical NLP with Comprehensive Datasets', 'desc': 'The paper discusses the development of MedINST, a comprehensive meta-dataset designed to improve the training of large language models (LLMs) in the medical field. MedINST includes 133 different biomedical natural language processing tasks and over 7 million training samples, addressing the challenge of limited and diverse medical datasets. The authors also introduce MedINST32, a benchmark to test the generalization abilities of LLMs across various tasks. By fine-tuning LLMs on MedINST, the study demonstrates improved cross-task generalization, highlighting the potential of MedINST in advancing medical data analysis.'}, 'zh': {'title': 'MedINST：突破医学数据集瓶颈的创新解决方案', 'desc': '这篇论文介绍了在医学分析领域中整合大型语言模型技术所带来的进步，但也指出了缺乏大型、多样化和良好标注的数据集是一个主要挑战。为了应对这些挑战，作者们引入了MedINST，一个新的多领域、多任务的指令元数据集。MedINST包含133个生物医学自然语言处理任务和超过700万个训练样本，是迄今为止最全面的生物医学指令数据集。通过在MedINST上微调多个大型语言模型，并在MedINST32基准上进行评估，展示了增强的跨任务泛化能力。'}}}, {'id': 'https://huggingface.co/papers/2410.13924', 'title': 'ARKit LabelMaker: A New Scale for Indoor 3D Scene Understanding', 'url': 'https://huggingface.co/papers/2410.13924', 'abstract': 'The performance of neural networks scales with both their size and the amount of data they have been trained on. This is shown in both language and image generation. However, this requires scaling-friendly network architectures as well as large-scale datasets. Even though scaling-friendly architectures like transformers have emerged for 3D vision tasks, the GPT-moment of 3D vision remains distant due to the lack of training data. In this paper, we introduce ARKit LabelMaker, the first large-scale, real-world 3D dataset with dense semantic annotations. Specifically, we complement ARKitScenes dataset with dense semantic annotations that are automatically generated at scale. To this end, we extend LabelMaker, a recent automatic annotation pipeline, to serve the needs of large-scale pre-training. This involves extending the pipeline with cutting-edge segmentation models as well as making it robust to the challenges of large-scale processing. Further, we push forward the state-of-the-art performance on ScanNet and ScanNet200 dataset with prevalent 3D semantic segmentation models, demonstrating the efficacy of our generated dataset.', 'score': 6, 'issue_id': 249, 'pub_date': '2024-10-17', 'pub_date_card': {'ru': '17 октября', 'en': 'October 17', 'zh': '10月17日'}, 'hash': '37c34e5be2bb734e', 'authors': ['Guangda Ji', 'Silvan Weder', 'Francis Engelmann', 'Marc Pollefeys', 'Hermann Blum'], 'affiliations': ['ETH Zurich Switzerland', 'Stranford University / ETH Zurich USA / Switzerland', 'Uni Bonn / ETH Zurich Germany / Switzerland'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.13924.jpg', 'data': {'categories': ['#synthetic', '#cv', '#optimization', '#data', '#training', '#dataset', '#3d'], 'emoji': '🏷️', 'ru': {'title': 'Большие данные для прорыва в 3D-зрении', 'desc': 'Эта статья представляет ARKit LabelMaker - первый крупномасштабный набор данных реального мира с плотными семантическими аннотациями для задач 3D-зрения. Авторы расширили существующий инструмент LabelMaker, чтобы автоматически генерировать аннотации в больших масштабах. Они использовали современные модели сегментации и сделали процесс устойчивым к проблемам обработки больших данных. Результаты показывают улучшение производительности моделей семантической сегментации на наборах данных ScanNet и ScanNet200.'}, 'en': {'title': 'Unlocking 3D Vision with ARKit LabelMaker: A New Era of Large-Scale Datasets', 'desc': 'The paper discusses how the performance of neural networks improves with larger sizes and more data, particularly in language and image generation. It highlights the challenge in 3D vision tasks due to a lack of large-scale datasets, despite having suitable architectures like transformers. The authors introduce ARKit LabelMaker, a new large-scale 3D dataset with dense semantic annotations, enhancing the ARKitScenes dataset. They demonstrate the effectiveness of this dataset by improving state-of-the-art results on existing 3D semantic segmentation benchmarks like ScanNet.'}, 'zh': {'title': 'ARKit LabelMaker：推动3D视觉的未来', 'desc': '这篇论文讨论了神经网络的性能如何随着其规模和训练数据量的增加而提高。为了实现这一点，需要适合扩展的网络架构和大规模数据集。作者介绍了ARKit LabelMaker，这是第一个具有密集语义标注的大规模真实3D数据集。通过改进自动标注流程，作者展示了在3D语义分割任务中使用该数据集的有效性。'}}}, {'id': 'https://huggingface.co/papers/2410.18071', 'title': "TP-Eval: Tap Multimodal LLMs' Potential in Evaluation by Customizing Prompts", 'url': 'https://huggingface.co/papers/2410.18071', 'abstract': "Recently, multimodal large language models (MLLMs) have received much attention for their impressive capabilities. The evaluation of MLLMs is becoming critical to analyzing attributes of MLLMs and providing valuable insights. However, current benchmarks overlook the problem of prompt sensitivity - minor prompt variations may lead to significant performance fluctuations. Thus, inappropriate prompts may obscure the models' capabilities, underestimating the models' performance. Moreover, different models have different preferences for different prompts, and thus, using the same prompt for all models will cause evaluation bias. This paper analyzes this deficiency in existing benchmarks and further introduces a new evaluation framework named TP-Eval, which introduces a prompt customization method to reduce evaluation biases and tap models' potential. TP-Eval will rewrite the original prompts to different customized prompts for different models. In particular, we propose some well-designed modules for prompt customization tailored to the scenario of MLLM evaluation. Extensive experiments demonstrate the effectiveness of our approach to uncovering models' capabilities, and TP-Eval should benefit the community in developing more comprehensive and convincing MLLM evaluation benchmarks.", 'score': 6, 'issue_id': 245, 'pub_date': '2024-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '9fe4ef775d3f190c', 'authors': ['Yuxuan Xie', 'Tianhua Li', 'Wenqi Shao', 'Kaipeng Zhang'], 'affiliations': ['OpenGV Lab, Shanghai Artificial Intelligence Laboratory', 'School of Electronic Information and Electrical Engineering, Shanghai Jiao Tong University'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.18071.jpg', 'data': {'categories': ['#benchmark', '#optimization', '#multimodal', '#interpretability', '#ethics', '#architecture'], 'emoji': '🎯', 'ru': {'title': 'Точная настройка промптов для справедливой оценки мультимодальных языковых моделей', 'desc': 'Статья посвящена проблеме чувствительности к промптам в мультимодальных больших языковых моделях (MLLM). Авторы предлагают новую систему оценки TP-Eval, которая использует метод настройки промптов для снижения предвзятости оценки и раскрытия потенциала моделей. TP-Eval переписывает исходные промпты в индивидуальные варианты для разных моделей. Эксперименты показывают эффективность этого подхода в выявлении возможностей моделей.'}, 'en': {'title': '"Unlocking True Potential: Tailored Prompts for Fair MLLM Evaluation"', 'desc': 'The paper discusses the challenges in evaluating multimodal large language models (MLLMs) due to prompt sensitivity, where small changes in prompts can lead to significant performance differences. It highlights that using the same prompt for all models can introduce bias, as different models may respond better to different prompts. To address this, the authors propose a new evaluation framework called TP-Eval, which customizes prompts for each model to reduce bias and better reveal their capabilities. The framework includes specially designed modules for prompt customization, and experiments show that TP-Eval effectively enhances the evaluation of MLLMs.'}, 'zh': {'title': 'TP-Eval：定制化提示词，挖掘模型潜力', 'desc': '这篇论文讨论了多模态大语言模型（MLLMs）的评估问题，特别是提示词敏感性的问题。现有的评估标准常常忽视了提示词的微小变化可能导致模型性能的显著波动。为了解决这个问题，作者提出了一种新的评估框架TP-Eval，通过定制化提示词来减少评估偏差。实验结果表明，TP-Eval能够更好地挖掘模型的潜力，为多模态大语言模型的评估提供了更全面和有说服力的基准。'}}}, {'id': 'https://huggingface.co/papers/2410.17242', 'title': 'LVSM: A Large View Synthesis Model with Minimal 3D Inductive Bias', 'url': 'https://huggingface.co/papers/2410.17242', 'abstract': 'We propose the Large View Synthesis Model (LVSM), a novel transformer-based approach for scalable and generalizable novel view synthesis from sparse-view inputs. We introduce two architectures: (1) an encoder-decoder LVSM, which encodes input image tokens into a fixed number of 1D latent tokens, functioning as a fully learned scene representation, and decodes novel-view images from them; and (2) a decoder-only LVSM, which directly maps input images to novel-view outputs, completely eliminating intermediate scene representations. Both models bypass the 3D inductive biases used in previous methods -- from 3D representations (e.g., NeRF, 3DGS) to network designs (e.g., epipolar projections, plane sweeps) -- addressing novel view synthesis with a fully data-driven approach. While the encoder-decoder model offers faster inference due to its independent latent representation, the decoder-only LVSM achieves superior quality, scalability, and zero-shot generalization, outperforming previous state-of-the-art methods by 1.5 to 3.5 dB PSNR. Comprehensive evaluations across multiple datasets demonstrate that both LVSM variants achieve state-of-the-art novel view synthesis quality. Notably, our models surpass all previous methods even with reduced computational resources (1-2 GPUs). Please see our website for more details: https://haian-jin.github.io/projects/LVSM/ .', 'score': 3, 'issue_id': 255, 'pub_date': '2024-10-22', 'pub_date_card': {'ru': '22 октября', 'en': 'October 22', 'zh': '10月22日'}, 'hash': 'f91cd290a84f0584', 'authors': ['Haian Jin', 'Hanwen Jiang', 'Hao Tan', 'Kai Zhang', 'Sai Bi', 'Tianyuan Zhang', 'Fujun Luan', 'Noah Snavely', 'Zexiang Xu'], 'affiliations': ['Adobe Research', 'Cornell University', 'Massachusetts Institute of Technology', 'The University of Texas at Austin'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.17242.jpg', 'data': {'categories': ['#small_models', '#synthetic', '#cv', '#inference', '#optimization', '#transfer_learning', '#3d', '#architecture'], 'emoji': '🖼️', 'ru': {'title': 'Трансформеры покоряют синтез новых ракурсов', 'desc': 'Исследователи представили Large View Synthesis Model (LVSM) - новый подход на основе трансформеров для масштабируемого и обобщаемого синтеза новых ракурсов по небольшому набору входных изображений. Предложены две архитектуры: энкодер-декодер LVSM, кодирующий входные изображения в латентные токены, и декодер-только LVSM, напрямую преобразующий входные изображения в новые ракурсы. Оба варианта LVSM превосходят современные методы по качеству синтеза новых ракурсов, при этом декодер-только LVSM демонстрирует лучшие результаты по качеству, масштабируемости и обобщению на новые данные. Модели достигают state-of-the-art результатов даже при использовании меньших вычислительных ресурсов.'}, 'en': {'title': 'Transforming Sparse Views into Stunning Images with LVSM!', 'desc': 'The Large View Synthesis Model (LVSM) introduces a new transformer-based method for creating images from limited input views. It features two architectures: an encoder-decoder model that learns a scene representation and a decoder-only model that generates images directly from inputs. Both models avoid traditional 3D biases, relying instead on a data-driven approach for novel view synthesis. The LVSM models demonstrate superior performance in image quality and efficiency, outperforming existing methods while using fewer computational resources.'}, 'zh': {'title': '大型视图合成模型：数据驱动的新视角', 'desc': '我们提出了一种新的大型视图合成模型（LVSM），这是一种基于变换器的可扩展和通用的新视图合成方法。该模型包括两种架构：编码-解码器LVSM和仅解码器LVSM，前者通过将输入图像编码为固定数量的潜在标记来生成新视图图像，后者则直接将输入图像映射到新视图输出。两种模型都避免了以往方法中使用的3D归纳偏见，采用完全数据驱动的方法进行新视图合成。我们的模型在多个数据集上的评估显示，LVSM在新视图合成质量上达到了最先进的水平，且在计算资源减少的情况下仍然表现优异。'}}}, {'id': 'https://huggingface.co/papers/2410.13816', 'title': 'Steering Your Generalists: Improving Robotic Foundation Models via Value Guidance', 'url': 'https://huggingface.co/papers/2410.13816', 'abstract': 'Large, general-purpose robotic policies trained on diverse demonstration datasets have been shown to be remarkably effective both for controlling a variety of robots in a range of different scenes, and for acquiring broad repertoires of manipulation skills. However, the data that such policies are trained on is generally of mixed quality -- not only are human-collected demonstrations unlikely to perform the task perfectly, but the larger the dataset is, the harder it is to curate only the highest quality examples. It also remains unclear how optimal data from one embodiment is for training on another embodiment. In this paper, we present a general and broadly applicable approach that enhances the performance of such generalist robot policies at deployment time by re-ranking their actions according to a value function learned via offline RL. This approach, which we call Value-Guided Policy Steering (V-GPS), is compatible with a wide range of different generalist policies, without needing to fine-tune or even access the weights of the policy. We show that the same value function can improve the performance of five different state-of-the-art policies with different architectures, even though they were trained on distinct datasets, attaining consistent performance improvement on multiple robotic platforms across a total of 12 tasks. Code and videos can be found at: https://nakamotoo.github.io/V-GPS', 'score': 1, 'issue_id': 255, 'pub_date': '2024-10-17', 'pub_date_card': {'ru': '17 октября', 'en': 'October 17', 'zh': '10月17日'}, 'hash': 'ee6d24e9422674a5', 'authors': ['Mitsuhiko Nakamoto', 'Oier Mees', 'Aviral Kumar', 'Sergey Levine'], 'affiliations': ['Carnegie Mellon University', 'Google DeepMind', 'UC Berkeley'], 'pdf_title_img': 'assets\\pdf\\title_img\\2410.13816.jpg', 'data': {'categories': ['#rl', '#benchmark', '#optimization', '#data', '#training', '#robotics', '#transfer_learning', '#open_source'], 'emoji': '🤖', 'ru': {'title': 'Улучшение робототехнических политик без переобучения: V-GPS в действии', 'desc': 'Статья представляет новый подход под названием Value-Guided Policy Steering (V-GPS) для улучшения производительности обобщенных робототехнических политик. V-GPS использует функцию ценности, обученную с помощью офлайн-обучения с подкреплением, для переранжирования действий политики во время развертывания. Этот метод совместим с различными типами политик и не требует доступа к их весам или дополнительной настройки. Авторы демонстрируют эффективность V-GPS на пяти современных политиках с разными архитектурами, показывая улучшение производительности на нескольких робототехнических платформах в 12 задачах.'}, 'en': {'title': 'Enhancing Robot Performance with Value-Guided Policy Steering', 'desc': 'This paper introduces a method called Value-Guided Policy Steering (V-GPS) to improve the performance of general-purpose robotic policies during deployment. The authors address the issue of mixed-quality training data by using a value function learned through offline reinforcement learning (RL) to re-rank the actions of the robots. V-GPS is designed to work with various existing policies without requiring any modifications to their underlying models. The results demonstrate that this approach consistently enhances the performance of multiple state-of-the-art robotic policies across different tasks and platforms.'}, 'zh': {'title': '提升机器人策略性能的新方法', 'desc': '本文提出了一种名为价值引导策略引导（V-GPS）的方法，旨在提高通用机器人策略的性能。该方法通过离线强化学习学习的价值函数，对机器人在执行任务时的动作进行重新排序。V-GPS可以与多种不同的通用策略兼容使用，而无需微调或访问策略的权重。实验表明，使用相同的价值函数可以在不同架构的五种最先进策略上实现一致的性能提升，适用于12个不同的机器人任务。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (3)', '#agents (1)', '#agi', '#alignment (4)', '#architecture (7)', '#audio', '#benchmark (9)', '#cv (6)', '#data (4)', '#dataset (8)', '#diffusion (2)', '#ethics (1)', '#games (2)', '#graphs (1)', '#hallucinations', '#healthcare (1)', '#inference (1)', '#interpretability (2)', '#leakage', '#long_context (1)', '#low_resource (1)', '#machine_translation (1)', '#math', '#multilingual (1)', '#multimodal (4)', '#open_source (5)', '#optimization (8)', '#plp', '#rag', '#reasoning (1)', '#rl (1)', '#rlhf (4)', '#robotics (2)', '#science (1)', '#security', '#small_models (4)', '#story_generation', '#survey', '#synthetic (6)', '#training (6)', '#transfer_learning (5)', '#video (2)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="background-digit">${index + 1}</div>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-10-24 09:00',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2024-10-24 09:00')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2024-10-24 09:00')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    