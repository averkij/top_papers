
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 19 papers. September 4.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            flex: 1 0 auto;
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 0 20px 0;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .article-content {
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
        }
        body.dark-theme>div>main>article {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article {
            background-color: #fff;
        }
        body.dark-theme>div>main>article:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 0px;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            margin-top: 10px;
            margin-bottom: 10px;
            display: block;
            border-radius: 5px;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
                margin: 0 -20px;
            }
            footer {
                margin-top: -20px;
            }
            article {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">4 сентября</span> | <span id="title-articles-count">19 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item" id="nav-prev"><a href="/d/2024-09-03.html">⬅️ <span id="prev-date">03.09</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-09-05.html">➡️ <span id="next-date">05.09</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2024-09.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'};
        let feedDateNext = {'ru': '05.09', 'en': '09/05', 'zh': '9月5日'};
        let feedDatePrev = {'ru': '03.09', 'en': '09/03', 'zh': '9月3日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2409.01704', 'title': 'General OCR Theory: Towards OCR-2.0 via a Unified End-to-end Model', 'url': 'https://huggingface.co/papers/2409.01704', 'abstract': 'Traditional OCR systems (OCR-1.0) are increasingly unable to meet people\'s usage due to the growing demand for intelligent processing of man-made optical characters. In this paper, we collectively refer to all artificial optical signals (e.g., plain texts, math/molecular formulas, tables, charts, sheet music, and even geometric shapes) as "characters" and propose the General OCR Theory along with an excellent model, namely GOT, to promote the arrival of OCR-2.0. The GOT, with 580M parameters, is a unified, elegant, and end-to-end model, consisting of a high-compression encoder and a long-contexts decoder. As an OCR-2.0 model, GOT can handle all the above "characters" under various OCR tasks. On the input side, the model supports commonly used scene- and document-style images in slice and whole-page styles. On the output side, GOT can generate plain or formatted results (markdown/tikz/smiles/kern) via an easy prompt. Besides, the model enjoys interactive OCR features, i.e., region-level recognition guided by coordinates or colors. Furthermore, we also adapt dynamic resolution and multi-page OCR technologies to GOT for better practicality. In experiments, we provide sufficient results to prove the superiority of our model.', 'score': 80, 'issue_id': 1, 'pub_date': '2024-09-03', 'pub_date_card': {'ru': '3 сентября', 'en': 'September 3', 'zh': '9月3日'}, 'hash': 'cc052755a384b1f8', 'data': {'categories': ['#cv', '#long_context', '#optimization', '#small_models', '#architecture', '#synthetic'], 'emoji': '👁️', 'ru': {'title': 'GOT: Универсальное оптическое распознавание для эры OCR 2.0', 'desc': "Статья представляет новую модель под названием GOT для оптического распознавания символов (OCR). Эта модель способна обрабатывать различные типы 'символов', включая обычный текст, формулы, таблицы и даже геометрические фигуры. GOT использует архитектуру кодировщик-декодировщик и поддерживает интерактивное распознавание на уровне регионов. Модель демонстрирует превосходные результаты в экспериментах и обещает стать шагом к OCR 2.0."}, 'en': {'title': 'Revolutionizing OCR with GOT: The Future of Intelligent Character Recognition', 'desc': 'This paper introduces the General OCR Theory and a new model called GOT, designed to enhance optical character recognition (OCR) capabilities. GOT is an end-to-end model with 580 million parameters that can process a wide range of artificial optical signals, including text, formulas, and charts. It features a high-compression encoder and a long-context decoder, allowing it to handle various OCR tasks effectively. The model supports both scene and document images and can produce formatted outputs while offering interactive features for improved user experience.'}, 'zh': {'title': '推动OCR-2.0的通用OCR理论与GOT模型', 'desc': '传统的光学字符识别系统（OCR-1.0）已无法满足人们对智能处理人造光学字符的需求。本文提出了一种通用OCR理论及其优秀模型GOT，旨在推动OCR-2.0的到来。GOT模型具有580M参数，是一个统一、优雅的端到端模型，能够处理各种光学字符，包括文本、公式、表格等。通过动态分辨率和多页OCR技术，GOT在实验中展示了其卓越的性能和实用性。'}}}, {'id': 'https://huggingface.co/papers/2409.02060', 'title': 'OLMoE: Open Mixture-of-Experts Language Models', 'url': 'https://huggingface.co/papers/2409.02060', 'abstract': 'We introduce OLMoE, a fully open, state-of-the-art language model leveraging sparse Mixture-of-Experts (MoE). OLMoE-1B-7B has 7 billion (B) parameters but uses only 1B per input token. We pretrain it on 5 trillion tokens and further adapt it to create OLMoE-1B-7B-Instruct. Our models outperform all available models with similar active parameters, even surpassing larger ones like Llama2-13B-Chat and DeepSeekMoE-16B. We present various experiments on MoE training, analyze routing in our model showing high specialization, and open-source all aspects of our work: model weights, training data, code, and logs.', 'score': 77, 'issue_id': 1, 'pub_date': '2024-09-03', 'pub_date_card': {'ru': '3 сентября', 'en': 'September 3', 'zh': '9月3日'}, 'hash': 'fd0ab48efdc585ed', 'data': {'categories': ['#training', '#optimization', '#open_source', '#small_models', '#architecture'], 'emoji': '🧠', 'ru': {'title': 'OLMoE: Эффективная языковая модель на основе экспертов', 'desc': 'OLMoE - это новая языковая модель, использующая метод Mixture-of-Experts (MoE). Модель имеет 7 миллиардов параметров, но активирует только 1 миллиард для каждого токена ввода. OLMoE превосходит по производительности существующие модели с аналогичным количеством активных параметров, включая более крупные модели. Авторы проводят различные эксперименты по обучению MoE и анализируют маршрутизацию в своей модели, демонстрируя высокую специализацию.'}, 'en': {'title': 'Unlocking Efficiency with OLMoE: A New Era in Language Models', 'desc': "OLMoE is a cutting-edge language model that utilizes a sparse Mixture-of-Experts (MoE) architecture, allowing it to efficiently manage a large number of parameters. With 7 billion parameters, OLMoE-1B-7B only activates 1 billion parameters for each input, optimizing resource use. It has been pretrained on an extensive dataset of 5 trillion tokens and fine-tuned for instruction-based tasks, demonstrating superior performance compared to other models with similar active parameters. The research includes detailed experiments on MoE training and routing analysis, showcasing the model's specialization, and all components of the project are open-sourced for public access."}, 'zh': {'title': 'OLMoE：高效的稀疏专家混合语言模型', 'desc': '我们介绍了OLMoE，这是一种完全开放的最先进语言模型，利用了稀疏的专家混合（MoE）技术。OLMoE-1B-7B拥有70亿个参数，但每个输入令牌仅使用10亿个参数。我们在5万亿个令牌上进行了预训练，并进一步调整以创建OLMoE-1B-7B-Instruct。我们的模型在活跃参数相似的情况下超越了所有可用模型，甚至超过了更大的模型，如Llama2-13B-Chat和DeepSeekMoE-16B。'}}}, {'id': 'https://huggingface.co/papers/2409.01437', 'title': 'Kvasir-VQA: A Text-Image Pair GI Tract Dataset', 'url': 'https://huggingface.co/papers/2409.01437', 'abstract': "We introduce Kvasir-VQA, an extended dataset derived from the HyperKvasir and Kvasir-Instrument datasets, augmented with question-and-answer annotations to facilitate advanced machine learning tasks in Gastrointestinal (GI) diagnostics. This dataset comprises 6,500 annotated images spanning various GI tract conditions and surgical instruments, and it supports multiple question types including yes/no, choice, location, and numerical count. The dataset is intended for applications such as image captioning, Visual Question Answering (VQA), text-based generation of synthetic medical images, object detection, and classification. Our experiments demonstrate the dataset's effectiveness in training models for three selected tasks, showcasing significant applications in medical image analysis and diagnostics. We also present evaluation metrics for each task, highlighting the usability and versatility of our dataset. The dataset and supporting artifacts are available at https://datasets.simula.no/kvasir-vqa.", 'score': 70, 'issue_id': 1, 'pub_date': '2024-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': 'a914aa77110d40cd', 'data': {'categories': ['#science', '#dataset', '#cv', '#healthcare', '#benchmark', '#open_source', '#synthetic'], 'emoji': '🔬', 'ru': {'title': 'Новый набор данных для ИИ-анализа медицинских изображений ЖКТ', 'desc': 'Представлен набор данных Kvasir-VQA для задач машинного обучения в области гастроэнтерологической диагностики. Он содержит 6500 аннотированных изображений ЖКТ с вопросами и ответами различных типов. Набор данных предназначен для решения задач генерации подписей к изображениям, визуального ответа на вопросы, синтеза медицинских изображений и других. Эксперименты показали эффективность набора данных для обучения моделей по трем выбранным задачам.'}, 'en': {'title': 'Kvasir-VQA: Advancing GI Diagnostics with Visual Question Answering', 'desc': 'Kvasir-VQA is a new dataset designed to enhance machine learning applications in Gastrointestinal diagnostics. It includes 6,500 annotated images of various GI conditions and surgical tools, with questions that can be answered in different formats like yes/no or numerical counts. This dataset is useful for tasks such as image captioning, Visual Question Answering (VQA), and object detection. Our experiments show that Kvasir-VQA effectively trains models for these tasks, proving its value in medical image analysis.'}, 'zh': {'title': 'Kvasir-VQA：推动医学图像分析的新数据集', 'desc': 'Kvasir-VQA是一个扩展的数据集，源自HyperKvasir和Kvasir-Instrument数据集，增加了问答注释，以促进胃肠道（GI）诊断中的高级机器学习任务。该数据集包含6500张标注图像，涵盖各种GI道疾病和手术工具，支持多种问题类型，包括是/否、选择、位置和数字计数。该数据集适用于图像描述、视觉问答（VQA）、基于文本的合成医学图像生成、物体检测和分类等应用。我们的实验表明，该数据集在训练模型方面的有效性，展示了在医学图像分析和诊断中的重要应用。'}}}, {'id': 'https://huggingface.co/papers/2409.00509', 'title': 'LongRecipe: Recipe for Efficient Long Context Generalization in Large Languge Models', 'url': 'https://huggingface.co/papers/2409.00509', 'abstract': "Large language models (LLMs) face significant challenges in handling long-context tasks because of their limited effective context window size during pretraining, which restricts their ability to generalize over extended sequences. Meanwhile, extending the context window in LLMs through post-pretraining is highly resource-intensive. To address this, we introduce **LongRecipe**, an efficient training strategy for extending the context window of LLMs, including impactful token analysis, position index transformation, and training optimization strategies. It simulates long-sequence inputs while maintaining training efficiency and significantly improves the model's understanding of long-range dependencies. Experiments on three types of LLMs show that LongRecipe can utilize long sequences while requiring only 30% of the target context window size, and reduces computational training resource over 85% compared to full sequence training. Furthermore, LongRecipe also preserves the original LLM's capabilities in general tasks. Ultimately, *we can extend the effective context window of open-source LLMs from 8k to 128k, achieving performance close to GPT-4 with just one day of dedicated training using a single GPU with 80G memory.* Our code is released at the [link](https://github.com/zhiyuanhubj/LongRecipe).", 'score': 38, 'issue_id': 1, 'pub_date': '2024-08-31', 'pub_date_card': {'ru': '31 августа', 'en': 'August 31', 'zh': '8月31日'}, 'hash': '7c96239ce2e612ce', 'data': {'categories': ['#long_context', '#training', '#inference', '#optimization', '#open_source', '#small_models'], 'emoji': '🔬', 'ru': {'title': 'Эффективное расширение контекста LLM: больше возможностей, меньше ресурсов', 'desc': 'Статья предлагает новый метод LongRecipe для эффективного расширения контекстного окна больших языковых моделей (LLM). Этот подход позволяет моделям обрабатывать длинные последовательности, используя лишь 30% от целевого размера контекстного окна и сокращая вычислительные ресурсы на 85% по сравнению с полным обучением. LongRecipe включает в себя анализ значимых токенов, преобразование позиционных индексов и оптимизацию стратегий обучения. В результате авторам удалось расширить эффективное контекстное окно открытых LLM с 8 тыс. до 128 тыс. токенов за один день обучения на одном GPU.'}, 'en': {'title': 'Unlocking Long Contexts Efficiently with LongRecipe', 'desc': 'This paper presents LongRecipe, a novel training strategy designed to enhance the context window of large language models (LLMs) without the extensive resource demands typically associated with such tasks. By employing techniques like impactful token analysis and position index transformation, LongRecipe efficiently simulates long-sequence inputs, allowing models to better understand long-range dependencies. The approach enables LLMs to utilize long sequences while only requiring 30% of the target context window size, leading to over 85% reduction in computational resources compared to traditional full sequence training. Ultimately, LongRecipe allows for the effective context window of open-source LLMs to be extended from 8k to 128k, achieving performance levels comparable to GPT-4 with minimal training time on a single GPU.'}, 'zh': {'title': '高效扩展大型语言模型的上下文窗口', 'desc': '大型语言模型（LLMs）在处理长上下文任务时面临挑战，因为它们在预训练期间的有效上下文窗口大小有限，限制了对长序列的泛化能力。为了解决这个问题，我们提出了**LongRecipe**，这是一种高效的训练策略，可以扩展LLMs的上下文窗口。该方法通过影响力的标记分析、位置索引转换和训练优化策略来模拟长序列输入，同时保持训练效率。实验表明，LongRecipe能够在仅需目标上下文窗口大小的30%的情况下利用长序列，并且相比于完整序列训练，计算资源减少超过85%。'}}}, {'id': 'https://huggingface.co/papers/2409.02095', 'title': 'DepthCrafter: Generating Consistent Long Depth Sequences for Open-world Videos', 'url': 'https://huggingface.co/papers/2409.02095', 'abstract': 'Despite significant advancements in monocular depth estimation for static images, estimating video depth in the open world remains challenging, since open-world videos are extremely diverse in content, motion, camera movement, and length. We present DepthCrafter, an innovative method for generating temporally consistent long depth sequences with intricate details for open-world videos, without requiring any supplementary information such as camera poses or optical flow. DepthCrafter achieves generalization ability to open-world videos by training a video-to-depth model from a pre-trained image-to-video diffusion model, through our meticulously designed three-stage training strategy with the compiled paired video-depth datasets. Our training approach enables the model to generate depth sequences with variable lengths at one time, up to 110 frames, and harvest both precise depth details and rich content diversity from realistic and synthetic datasets. We also propose an inference strategy that processes extremely long videos through segment-wise estimation and seamless stitching. Comprehensive evaluations on multiple datasets reveal that DepthCrafter achieves state-of-the-art performance in open-world video depth estimation under zero-shot settings. Furthermore, DepthCrafter facilitates various downstream applications, including depth-based visual effects and conditional video generation.', 'score': 35, 'issue_id': 1, 'pub_date': '2024-09-03', 'pub_date_card': {'ru': '3 сентября', 'en': 'September 3', 'zh': '9月3日'}, 'hash': '803f31c2683713de', 'data': {'categories': ['#video', '#cv', '#long_context', '#training', '#inference', '#transfer_learning', '#diffusion', '#synthetic'], 'emoji': '🎥', 'ru': {'title': 'DepthCrafter: Революция в оценке глубины видео реального мира', 'desc': 'DepthCrafter - это инновационный метод для генерации темпорально согласованных длинных последовательностей глубины с детальной проработкой для видео из реального мира. Модель обучается на основе предварительно обученной диффузионной модели преобразования изображений в видео, используя трехэтапную стратегию обучения на составленных парных наборах данных видео-глубина. DepthCrafter способен генерировать последовательности глубины переменной длины до 110 кадров за один раз, сочетая точные детали глубины и разнообразие контента из реалистичных и синтетических датасетов. Метод достигает высокой производительности в оценке глубины видео реального мира в условиях нулевого обучения и может применяться для различных задач, включая создание визуальных эффектов на основе глубины и условную генерацию видео.'}, 'en': {'title': 'DepthCrafter: Revolutionizing Depth Estimation in Open-World Videos', 'desc': 'DepthCrafter is a novel method designed to estimate depth in open-world videos, addressing the challenges posed by diverse content and motion. It utilizes a three-stage training strategy that leverages a pre-trained image-to-video diffusion model, allowing it to generate long depth sequences without needing additional information like camera poses. The model can produce depth sequences of varying lengths, capturing detailed depth information and content diversity from both realistic and synthetic datasets. Additionally, DepthCrafter includes an inference strategy for processing long videos by segmenting them and seamlessly stitching the results together, achieving state-of-the-art performance in zero-shot depth estimation.'}, 'zh': {'title': 'DepthCrafter：开放世界视频深度估计的新突破', 'desc': '尽管在静态图像的单目深度估计方面取得了显著进展，但在开放世界中估计视频深度仍然具有挑战性。我们提出了DepthCrafter，这是一种创新的方法，可以为开放世界视频生成时间一致的长深度序列，且无需额外的信息，如相机姿态或光流。DepthCrafter通过从预训练的图像到视频扩散模型中训练视频到深度模型，展现了对开放世界视频的泛化能力。我们的训练方法使模型能够一次生成可变长度的深度序列，并从真实和合成数据集中提取精确的深度细节和丰富的内容多样性。'}}}, {'id': 'https://huggingface.co/papers/2409.00587', 'title': 'FLUX that Plays Music', 'url': 'https://huggingface.co/papers/2409.00587', 'abstract': 'This paper explores a simple extension of diffusion-based rectified flow Transformers for text-to-music generation, termed as FluxMusic. Generally, along with design in advanced Fluxhttps://github.com/black-forest-labs/flux model, we transfers it into a latent VAE space of mel-spectrum. It involves first applying a sequence of independent attention to the double text-music stream, followed by a stacked single music stream for denoised patch prediction. We employ multiple pre-trained text encoders to sufficiently capture caption semantic information as well as inference flexibility. In between, coarse textual information, in conjunction with time step embeddings, is utilized in a modulation mechanism, while fine-grained textual details are concatenated with the music patch sequence as inputs. Through an in-depth study, we demonstrate that rectified flow training with an optimized architecture significantly outperforms established diffusion methods for the text-to-music task, as evidenced by various automatic metrics and human preference evaluations. Our experimental data, code, and model weights are made publicly available at: https://github.com/feizc/FluxMusic.', 'score': 31, 'issue_id': 1, 'pub_date': '2024-09-01', 'pub_date_card': {'ru': '1 сентября', 'en': 'September 1', 'zh': '9月1日'}, 'hash': '8e90043f3c31a7df', 'data': {'categories': ['#audio', '#dataset', '#training', '#transfer_learning', '#open_source', '#diffusion', '#architecture'], 'emoji': '🎵', 'ru': {'title': 'FluxMusic: Улучшенная генерация музыки по текстовому описанию', 'desc': 'В этой статье представлен FluxMusic - расширение диффузионных Transformer-моделей для генерации музыки по текстовому описанию. Модель работает в латентном VAE-пространстве мел-спектрограмм, используя независимое внимание для текста и музыки, а затем стекированное внимание для предсказания музыкальных фрагментов. Применяются предобученные текстовые энкодеры и механизм модуляции для интеграции текстовой информации. Эксперименты показывают превосходство этого подхода над стандартными диффузионными методами для задачи текст-в-музыку.'}, 'en': {'title': 'Transforming Text to Music with FluxMusic: A New Era in Generation!', 'desc': 'This paper introduces FluxMusic, an innovative approach that enhances diffusion-based rectified flow Transformers for generating music from text. It utilizes a latent Variational Autoencoder (VAE) space focused on the mel-spectrum, allowing for effective representation of audio features. The model employs independent attention mechanisms to process text and music streams, improving the prediction of music patches. The results show that this optimized architecture outperforms traditional diffusion methods in generating music from textual descriptions, supported by both quantitative metrics and qualitative assessments.'}, 'zh': {'title': 'FluxMusic：文本到音乐生成的新突破', 'desc': '本文提出了一种名为FluxMusic的扩展方法，用于基于扩散的文本到音乐生成。该方法将模型转移到梅尔频谱的潜在变分自编码器空间中，首先对文本和音乐流进行独立注意力处理，然后进行去噪音的音乐片段预测。我们使用多个预训练的文本编码器来捕捉语义信息，并结合时间步嵌入进行调制机制。通过深入研究，我们证明了优化架构的修正流训练在文本到音乐任务中显著优于传统的扩散方法。'}}}, {'id': 'https://huggingface.co/papers/2409.02097', 'title': 'LinFusion: 1 GPU, 1 Minute, 16K Image', 'url': 'https://huggingface.co/papers/2409.02097', 'abstract': 'Modern diffusion models, particularly those utilizing a Transformer-based UNet for denoising, rely heavily on self-attention operations to manage complex spatial relationships, thus achieving impressive generation performance. However, this existing paradigm faces significant challenges in generating high-resolution visual content due to its quadratic time and memory complexity with respect to the number of spatial tokens. To address this limitation, we aim at a novel linear attention mechanism as an alternative in this paper. Specifically, we begin our exploration from recently introduced models with linear complexity, e.g., Mamba, Mamba2, and Gated Linear Attention, and identify two key features-attention normalization and non-causal inference-that enhance high-resolution visual generation performance. Building on these insights, we introduce a generalized linear attention paradigm, which serves as a low-rank approximation of a wide spectrum of popular linear token mixers. To save the training cost and better leverage pre-trained models, we initialize our models and distill the knowledge from pre-trained StableDiffusion (SD). We find that the distilled model, termed LinFusion, achieves performance on par with or superior to the original SD after only modest training, while significantly reducing time and memory complexity. Extensive experiments on SD-v1.5, SD-v2.1, and SD-XL demonstrate that LinFusion delivers satisfactory zero-shot cross-resolution generation performance, generating high-resolution images like 16K resolution. Moreover, it is highly compatible with pre-trained SD components, such as ControlNet and IP-Adapter, requiring no adaptation efforts. Codes are available at https://github.com/Huage001/LinFusion.', 'score': 31, 'issue_id': 1, 'pub_date': '2024-09-03', 'pub_date_card': {'ru': '3 сентября', 'en': 'September 3', 'zh': '9月3日'}, 'hash': '704dccb6db5f3e9d', 'data': {'categories': ['#cv', '#training', '#optimization', '#transfer_learning', '#open_source', '#diffusion', '#architecture'], 'emoji': '🖼️', 'ru': {'title': 'LinFusion: Линейное внимание для сверхвысокого разрешения', 'desc': 'Статья представляет новый подход к генерации изображений высокого разрешения с использованием линейного механизма внимания. Авторы предлагают обобщенную парадигму линейного внимания, которая служит аппроксимацией низкого ранга для широкого спектра популярных линейных токен-миксеров. Модель, названная LinFusion, инициализируется и обучается на основе предобученной StableDiffusion, достигая сопоставимой или превосходящей производительности при значительном снижении временной и пространственной сложности. Эксперименты показывают, что LinFusion способна генерировать изображения сверхвысокого разрешения до 16K без дополнительного обучения.'}, 'en': {'title': 'Revolutionizing High-Resolution Image Generation with Linear Attention', 'desc': 'This paper presents a new approach to improve the performance of diffusion models in generating high-resolution images by introducing a linear attention mechanism. Traditional models struggle with high memory and time complexity due to self-attention operations, especially as the number of spatial tokens increases. The authors explore existing linear complexity models and propose a generalized linear attention paradigm that enhances visual generation while reducing resource demands. Their model, LinFusion, shows competitive performance with pre-trained models like StableDiffusion, achieving impressive results in generating images up to 16K resolution with minimal training effort.'}, 'zh': {'title': '线性注意力，提升高分辨率生成性能！', 'desc': '现代扩散模型，特别是使用基于Transformer的UNet进行去噪的模型，依赖自注意力操作来处理复杂的空间关系，从而实现出色的生成性能。然而，由于其在空间标记数量上的二次时间和内存复杂性，现有范式在生成高分辨率视觉内容时面临重大挑战。为了解决这一限制，本文提出了一种新的线性注意力机制，旨在提高高分辨率视觉生成性能。我们通过引入注意力归一化和非因果推理等关键特征，开发了一种通用的线性注意力范式，显著降低了训练成本并提高了生成效率。'}}}, {'id': 'https://huggingface.co/papers/2409.01071', 'title': 'VideoLLaMB: Long-context Video Understanding with Recurrent Memory Bridges', 'url': 'https://huggingface.co/papers/2409.01071', 'abstract': "Recent advancements in large-scale video-language models have shown significant potential for real-time planning and detailed interactions. However, their high computational demands and the scarcity of annotated datasets limit their practicality for academic researchers. In this work, we introduce VideoLLaMB, a novel framework that utilizes temporal memory tokens within bridge layers to allow for the encoding of entire video sequences alongside historical visual data, effectively preserving semantic continuity and enhancing model performance across various tasks. This approach includes recurrent memory tokens and a SceneTilling algorithm, which segments videos into independent semantic units to preserve semantic integrity. Empirically, VideoLLaMB significantly outstrips existing video-language models, demonstrating a 5.5 points improvement over its competitors across three VideoQA benchmarks, and 2.06 points on egocentric planning. Comprehensive results on the MVBench show that VideoLLaMB-7B achieves markedly better results than previous 7B models of same LLM. Remarkably, it maintains robust performance as PLLaVA even as video length increases up to 8 times. Besides, the frame retrieval results on our specialized Needle in a Video Haystack (NIAVH) benchmark, further validate VideoLLaMB's prowess in accurately identifying specific frames within lengthy videos. Our SceneTilling algorithm also enables the generation of streaming video captions directly, without necessitating additional training. In terms of efficiency, VideoLLaMB, trained on 16 frames, supports up to 320 frames on a single Nvidia A100 GPU with linear GPU memory scaling, ensuring both high performance and cost-effectiveness, thereby setting a new foundation for long-form video-language models in both academic and practical applications.", 'score': 26, 'issue_id': 1, 'pub_date': '2024-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': '3a4932f3d059c107', 'data': {'categories': ['#science', '#video', '#long_context', '#training', '#inference', '#optimization', '#benchmark', '#small_models', '#architecture'], 'emoji': '🎬', 'ru': {'title': 'VideoLLaMB: Прорыв в обработке длинных видео с сохранением семантической целостности', 'desc': 'VideoLLaMB - это новая модель для обработки видео и языка, использующая временные токены памяти в мостовых слоях для кодирования целых видеопоследовательностей. Модель включает рекуррентные токены памяти и алгоритм SceneTilling для сегментации видео на семантические единицы. VideoLLaMB значительно превосходит существующие модели на нескольких бенчмарках, демонстрируя улучшение на 5.5 пунктов в задачах VideoQA. Модель эффективно обрабатывает длинные видео и поддерживает до 320 кадров на одном GPU Nvidia A100.'}, 'en': {'title': 'VideoLLaMB: Revolutionizing Video-Language Models with Efficiency and Performance', 'desc': 'This paper presents VideoLLaMB, a new framework designed to improve the performance of video-language models by using temporal memory tokens and a SceneTilling algorithm. These innovations allow the model to encode entire video sequences while maintaining semantic continuity, which is crucial for tasks like video question answering and planning. VideoLLaMB outperforms existing models, showing significant improvements in benchmarks and maintaining efficiency even with longer videos. The framework is also cost-effective, enabling high performance on a single GPU, making it accessible for both researchers and practical applications.'}, 'zh': {'title': 'VideoLLaMB：高效的视频语言模型新基石', 'desc': '本文介绍了一种新颖的视频语言模型框架VideoLLaMB，利用时间记忆标记在桥接层中编码整个视频序列和历史视觉数据，从而增强模型在各种任务中的表现。该方法通过引入递归记忆标记和场景切分算法，将视频分割为独立的语义单元，以保持语义完整性。实验结果表明，VideoLLaMB在三个视频问答基准上比现有模型提高了5.5分，在自我中心规划上提高了2.06分，显示出其优越的性能。VideoLLaMB在效率上也表现出色，能够在单个Nvidia A100 GPU上支持高达320帧的处理，确保高性能和成本效益。'}}}, {'id': 'https://huggingface.co/papers/2409.00588', 'title': 'Diffusion Policy Policy Optimization', 'url': 'https://huggingface.co/papers/2409.00588', 'abstract': 'We introduce Diffusion Policy Policy Optimization, DPPO, an algorithmic framework including best practices for fine-tuning diffusion-based policies (e.g. Diffusion Policy) in continuous control and robot learning tasks using the policy gradient (PG) method from reinforcement learning (RL). PG methods are ubiquitous in training RL policies with other policy parameterizations; nevertheless, they had been conjectured to be less efficient for diffusion-based policies. Surprisingly, we show that DPPO achieves the strongest overall performance and efficiency for fine-tuning in common benchmarks compared to other RL methods for diffusion-based policies and also compared to PG fine-tuning of other policy parameterizations. Through experimental investigation, we find that DPPO takes advantage of unique synergies between RL fine-tuning and the diffusion parameterization, leading to structured and on-manifold exploration, stable training, and strong policy robustness. We further demonstrate the strengths of DPPO in a range of realistic settings, including simulated robotic tasks with pixel observations, and via zero-shot deployment of simulation-trained policies on robot hardware in a long-horizon, multi-stage manipulation task. Website with code: diffusion-ppo.github.io', 'score': 19, 'issue_id': 1, 'pub_date': '2024-09-01', 'pub_date_card': {'ru': '1 сентября', 'en': 'September 1', 'zh': '9月1日'}, 'hash': 'a92679b4e7f59810', 'data': {'categories': ['#training', '#rl', '#optimization', '#benchmark', '#open_source', '#diffusion', '#robotics'], 'emoji': '🤖', 'ru': {'title': 'DPPO: Мощный метод настройки диффузионных политик для робототехники', 'desc': 'Статья представляет DPPO (Diffusion Policy Policy Optimization) - алгоритмическую структуру для настройки политик на основе диффузии в задачах непрерывного управления и обучения роботов. Авторы показывают, что DPPO достигает наилучших результатов по сравнению с другими методами обучения с подкреплением для политик на основе диффузии. Исследование выявляет уникальную синергию между настройкой с помощью обучения с подкреплением и параметризацией диффузии, что приводит к структурированному исследованию, стабильному обучению и устойчивости политики. Эффективность DPPO демонстрируется на реалистичных задачах, включая симулированные робототехнические задачи с пиксельными наблюдениями и развертывание обученных в симуляции политик на реальном роботизированном оборудовании.'}, 'en': {'title': 'Unlocking Efficiency in Robot Learning with DPPO', 'desc': 'The paper presents Diffusion Policy Policy Optimization (DPPO), a new framework designed to enhance the fine-tuning of diffusion-based policies in continuous control and robot learning tasks. It utilizes the policy gradient method from reinforcement learning, which is commonly used for training various policy types. The authors demonstrate that DPPO outperforms other reinforcement learning methods and traditional policy gradient fine-tuning, achieving superior performance and efficiency on standard benchmarks. Additionally, DPPO benefits from the unique characteristics of diffusion parameterization, enabling effective exploration, stable training, and robust policy performance in complex robotic tasks.'}, 'zh': {'title': '扩散策略优化：强化学习的新突破', 'desc': '我们提出了一种名为扩散策略优化（DPPO）的算法框架，旨在通过强化学习中的策略梯度方法对基于扩散的策略进行微调。尽管策略梯度方法在训练强化学习策略中广泛应用，但它们在扩散策略上的效率曾被认为较低。令人惊讶的是，DPPO在常见基准测试中表现出色，显示出其在微调方面的强大性能和效率。通过实验，我们发现DPPO利用了强化学习微调与扩散参数化之间的独特协同作用，从而实现了结构化的探索、稳定的训练和强大的策略鲁棒性。'}}}, {'id': 'https://huggingface.co/papers/2409.00558', 'title': 'Compositional 3D-aware Video Generation with LLM Director', 'url': 'https://huggingface.co/papers/2409.00558', 'abstract': 'Significant progress has been made in text-to-video generation through the use of powerful generative models and large-scale internet data. However, substantial challenges remain in precisely controlling individual concepts within the generated video, such as the motion and appearance of specific characters and the movement of viewpoints. In this work, we propose a novel paradigm that generates each concept in 3D representation separately and then composes them with priors from Large Language Models (LLM) and 2D diffusion models. Specifically, given an input textual prompt, our scheme consists of three stages: 1) We leverage LLM as the director to first decompose the complex query into several sub-prompts that indicate individual concepts within the video~(e.g., scene, objects, motions), then we let LLM to invoke pre-trained expert models to obtain corresponding 3D representations of concepts. 2) To compose these representations, we prompt multi-modal LLM to produce coarse guidance on the scales and coordinates of trajectories for the objects. 3) To make the generated frames adhere to natural image distribution, we further leverage 2D diffusion priors and use Score Distillation Sampling to refine the composition. Extensive experiments demonstrate that our method can generate high-fidelity videos from text with diverse motion and flexible control over each concept. Project page: https://aka.ms/c3v.', 'score': 14, 'issue_id': 1, 'pub_date': '2024-08-31', 'pub_date_card': {'ru': '31 августа', 'en': 'August 31', 'zh': '8月31日'}, 'hash': 'dd559e15ff6e9a56', 'data': {'categories': ['#video', '#diffusion', '#architecture', '#synthetic', '#multimodal', '#3d'], 'emoji': '🎬', 'ru': {'title': '3D-композиция для управляемой генерации видео из текста', 'desc': 'В статье представлен новый подход к генерации видео на основе текста с использованием 3D-представлений отдельных концепций. Авторы предлагают трехэтапный процесс, включающий декомпозицию запроса с помощью большой языковой модели (LLM), создание 3D-представлений и их композицию. Метод использует предобученные экспертные модели и диффузионные модели для улучшения качества генерации. Эксперименты показывают, что данный подход позволяет создавать высококачественные видео с разнообразными движениями и гибким контролем над отдельными элементами.'}, 'en': {'title': 'Mastering Video Generation: Control Every Concept!', 'desc': 'This paper presents a new approach to generating videos from text prompts by separately creating 3D representations of individual concepts. It utilizes Large Language Models (LLMs) to break down complex queries into simpler sub-prompts, which helps in controlling specific elements like motion and appearance. The method involves a three-stage process: decomposing the input, guiding the composition of 3D representations, and refining the output using 2D diffusion models. The results show that this approach allows for high-quality video generation with precise control over various aspects of the content.'}, 'zh': {'title': '精确控制视频生成中的概念', 'desc': '本文提出了一种新颖的文本到视频生成方法，旨在更精确地控制生成视频中的各个概念。我们首先利用大型语言模型（LLM）将复杂的文本提示分解为多个子提示，以获取每个概念的3D表示。接着，通过多模态LLM生成对象的运动轨迹的粗略指导，最后结合2D扩散模型进行细化，确保生成的帧符合自然图像分布。实验结果表明，该方法能够从文本生成高保真度的视频，并对每个概念进行灵活控制。'}}}, {'id': 'https://huggingface.co/papers/2409.00729', 'title': 'ContextCite: Attributing Model Generation to Context', 'url': 'https://huggingface.co/papers/2409.00729', 'abstract': 'How do language models use information provided as context when generating a response? Can we infer whether a particular generated statement is actually grounded in the context, a misinterpretation, or fabricated? To help answer these questions, we introduce the problem of context attribution: pinpointing the parts of the context (if any) that led a model to generate a particular statement. We then present ContextCite, a simple and scalable method for context attribution that can be applied on top of any existing language model. Finally, we showcase the utility of ContextCite through three applications: (1) helping verify generated statements (2) improving response quality by pruning the context and (3) detecting poisoning attacks. We provide code for ContextCite at https://github.com/MadryLab/context-cite.', 'score': 13, 'issue_id': 1, 'pub_date': '2024-09-01', 'pub_date_card': {'ru': '1 сентября', 'en': 'September 1', 'zh': '9月1日'}, 'hash': '69f8f12112b36fb2', 'data': {'categories': ['#security', '#rag', '#interpretability', '#open_source', '#architecture'], 'emoji': '🔍', 'ru': {'title': 'ContextCite: прозрачность генерации текста языковыми моделями', 'desc': "Статья представляет метод ContextCite для определения, какие части контекста использовались языковой моделью при генерации ответа. Авторы вводят понятие 'context attribution' - привязки генерируемых утверждений к конкретным частям контекста. ContextCite можно применять поверх существующих языковых моделей для проверки сгенерированных утверждений, улучшения качества ответов и обнаружения атак. Метод позволяет понять, основано ли утверждение на контексте, является ли оно неверной интерпретацией или выдумкой."}, 'en': {'title': 'ContextCite: Uncovering the Roots of Language Model Responses', 'desc': "This paper addresses how language models utilize context when generating responses and whether generated statements are based on that context. It introduces the concept of context attribution, which identifies specific parts of the context that influence the model's output. The authors present ContextCite, a method that can be easily integrated with any language model to perform context attribution. They demonstrate its effectiveness in verifying statements, enhancing response quality, and detecting potential poisoning attacks."}, 'zh': {'title': '揭示语言模型生成背后的上下文', 'desc': '本文探讨了语言模型在生成响应时如何利用上下文信息。我们提出了上下文归因的问题，即确定哪些上下文部分导致模型生成特定语句。为此，我们介绍了ContextCite，这是一种简单且可扩展的上下文归因方法，可以应用于任何现有的语言模型。通过三个应用案例，我们展示了ContextCite的实用性，包括验证生成语句、提高响应质量和检测攻击。'}}}, {'id': 'https://huggingface.co/papers/2409.01199', 'title': 'OD-VAE: An Omni-dimensional Video Compressor for Improving Latent Video Diffusion Model', 'url': 'https://huggingface.co/papers/2409.01199', 'abstract': "Variational Autoencoder (VAE), compressing videos into latent representations, is a crucial preceding component of Latent Video Diffusion Models (LVDMs). With the same reconstruction quality, the more sufficient the VAE's compression for videos is, the more efficient the LVDMs are. However, most LVDMs utilize 2D image VAE, whose compression for videos is only in the spatial dimension and often ignored in the temporal dimension. How to conduct temporal compression for videos in a VAE to obtain more concise latent representations while promising accurate reconstruction is seldom explored. To fill this gap, we propose an omni-dimension compression VAE, named OD-VAE, which can temporally and spatially compress videos. Although OD-VAE's more sufficient compression brings a great challenge to video reconstruction, it can still achieve high reconstructed accuracy by our fine design. To obtain a better trade-off between video reconstruction quality and compression speed, four variants of OD-VAE are introduced and analyzed. In addition, a novel tail initialization is designed to train OD-VAE more efficiently, and a novel inference strategy is proposed to enable OD-VAE to handle videos of arbitrary length with limited GPU memory. Comprehensive experiments on video reconstruction and LVDM-based video generation demonstrate the effectiveness and efficiency of our proposed methods.", 'score': 12, 'issue_id': 1, 'pub_date': '2024-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': 'b85158ae49081549', 'data': {'categories': ['#video', '#cv', '#training', '#inference', '#optimization', '#diffusion', '#architecture'], 'emoji': '🎥', 'ru': {'title': 'OD-VAE: Революция в сжатии видео для эффективных латентных видеодиффузионных моделей', 'desc': 'Статья представляет OD-VAE - вариационный автоэнкодер для сжатия видео как в пространственном, так и во временном измерении. Авторы предлагают несколько вариантов OD-VAE для оптимального баланса между качеством реконструкции и скоростью сжатия. Разработаны новые методы инициализации и стратегия вывода для эффективного обучения и работы с видео произвольной длины при ограниченной памяти GPU. Эксперименты показывают эффективность предложенного подхода для реконструкции видео и генерации видео на основе латентных видеодиффузионных моделей.'}, 'en': {'title': 'Revolutionizing Video Compression with OD-VAE', 'desc': 'This paper introduces the Omni-Dimension Variational Autoencoder (OD-VAE), which enhances video compression by addressing both spatial and temporal dimensions. Traditional VAEs typically focus on spatial compression, neglecting the temporal aspect, which limits their efficiency in video applications. OD-VAE achieves a more concise latent representation while maintaining high reconstruction accuracy through innovative design strategies. The authors also present four variants of OD-VAE and novel techniques for efficient training and inference, demonstrating significant improvements in video reconstruction and generation tasks.'}, 'zh': {'title': '全维压缩，提升视频重建效率', 'desc': '变分自编码器（VAE）在将视频压缩为潜在表示方面起着重要作用，是潜在视频扩散模型（LVDM）的关键组成部分。我们提出了一种全维压缩的变分自编码器（OD-VAE），能够同时进行时间和空间上的视频压缩，从而获得更简洁的潜在表示。尽管OD-VAE的压缩带来了视频重建的挑战，但通过精心设计，它仍能实现高重建精度。我们还引入了四种OD-VAE的变体，并设计了一种新颖的尾部初始化方法，以提高训练效率。'}}}, {'id': 'https://huggingface.co/papers/2409.00492', 'title': 'Accurate Compression of Text-to-Image Diffusion Models via Vector Quantization', 'url': 'https://huggingface.co/papers/2409.00492', 'abstract': 'Text-to-image diffusion models have emerged as a powerful framework for high-quality image generation given textual prompts. Their success has driven the rapid development of production-grade diffusion models that consistently increase in size and already contain billions of parameters. As a result, state-of-the-art text-to-image models are becoming less accessible in practice, especially in resource-limited environments. Post-training quantization (PTQ) tackles this issue by compressing the pretrained model weights into lower-bit representations. Recent diffusion quantization techniques primarily rely on uniform scalar quantization, providing decent performance for the models compressed to 4 bits. This work demonstrates that more versatile vector quantization (VQ) may achieve higher compression rates for large-scale text-to-image diffusion models. Specifically, we tailor vector-based PTQ methods to recent billion-scale text-to-image models (SDXL and SDXL-Turbo), and show that the diffusion models of 2B+ parameters compressed to around 3 bits using VQ exhibit the similar image quality and textual alignment as previous 4-bit compression techniques.', 'score': 11, 'issue_id': 1, 'pub_date': '2024-08-31', 'pub_date_card': {'ru': '31 августа', 'en': 'August 31', 'zh': '8月31日'}, 'hash': 'caecd9179e740837', 'data': {'categories': ['#cv', '#inference', '#optimization', '#diffusion', '#architecture'], 'emoji': '🗜️', 'ru': {'title': 'Векторное квантование сжимает гигантские модели без потери качества', 'desc': 'Эта статья посвящена применению векторного квантования (VQ) для сжатия крупномасштабных диффузионных моделей генерации изображений по текстовому описанию. Авторы адаптировали методы векторного квантования для моделей SDXL и SDXL-Turbo, содержащих более 2 миллиардов параметров. Результаты показывают, что сжатие до 3 бит с помощью VQ позволяет сохранить качество изображений и соответствие текстовым описаниям на уровне предыдущих методов 4-битного сжатия. Это исследование открывает путь к более эффективному использованию ресурсов при работе с крупными диффузионными моделями.'}, 'en': {'title': 'Enhancing Accessibility of Text-to-Image Models through Vector Quantization', 'desc': 'This paper discusses the advancements in text-to-image diffusion models, which are used for generating high-quality images from text prompts. It highlights the challenge of accessibility due to the increasing size of these models, which can have billions of parameters. To address this, the authors propose post-training quantization (PTQ) as a method to compress model weights into lower-bit formats. They specifically focus on vector quantization (VQ) techniques, demonstrating that they can achieve better compression rates while maintaining image quality and alignment with text prompts compared to traditional 4-bit methods.'}, 'zh': {'title': '向量量化提升文本到图像模型的压缩效率', 'desc': '文本到图像的扩散模型是一种强大的图像生成框架，可以根据文本提示生成高质量图像。随着模型规模的迅速扩大，现有的最先进模型已经包含数十亿个参数，这使得在资源有限的环境中使用这些模型变得更加困难。为了解决这个问题，后训练量化（PTQ）通过将预训练模型的权重压缩为低位表示来降低模型的复杂性。本文展示了向量量化（VQ）在大规模文本到图像扩散模型中的应用，证明了使用VQ进行压缩可以在保持图像质量和文本对齐的同时，达到更高的压缩率。'}}}, {'id': 'https://huggingface.co/papers/2409.01392', 'title': 'GenAgent: Build Collaborative AI Systems with Automated Workflow Generation -- Case Studies on ComfyUI', 'url': 'https://huggingface.co/papers/2409.01392', 'abstract': 'Much previous AI research has focused on developing monolithic models to maximize their intelligence and capability, with the primary goal of enhancing performance on specific tasks. In contrast, this paper explores an alternative approach: collaborative AI systems that use workflows to integrate models, data sources, and pipelines to solve complex and diverse tasks. We introduce GenAgent, an LLM-based framework that automatically generates complex workflows, offering greater flexibility and scalability compared to monolithic models. The core innovation of GenAgent lies in representing workflows with code, alongside constructing workflows with collaborative agents in a step-by-step manner. We implement GenAgent on the ComfyUI platform and propose a new benchmark, OpenComfy. The results demonstrate that GenAgent outperforms baseline approaches in both run-level and task-level evaluations, showing its capability to generate complex workflows with superior effectiveness and stability.', 'score': 9, 'issue_id': 1, 'pub_date': '2024-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': 'ccb90d08b0c22618', 'data': {'categories': ['#agi', '#optimization', '#agents', '#benchmark', '#open_source', '#architecture'], 'emoji': '🔀', 'ru': {'title': 'Генерация сложных ИИ-процессов с помощью коллаборативных агентов', 'desc': 'Эта статья представляет GenAgent - фреймворк на основе больших языковых моделей для автоматической генерации сложных рабочих процессов в ИИ-системах. В отличие от монолитных моделей, GenAgent использует совместную работу агентов для пошагового создания рабочих процессов, представленных в виде кода. Фреймворк реализован на платформе ComfyUI и протестирован на новом бенчмарке OpenComfy. Результаты показывают, что GenAgent превосходит базовые подходы по эффективности и стабильности при создании сложных рабочих процессов.'}, 'en': {'title': 'Empowering AI Collaboration with GenAgent Workflows', 'desc': 'This paper presents GenAgent, a framework that utilizes large language models (LLMs) to create collaborative AI systems. Unlike traditional monolithic models that focus on single tasks, GenAgent generates complex workflows that integrate various models and data sources. The innovative aspect of GenAgent is its ability to represent workflows as code, allowing for step-by-step construction with collaborative agents. The implementation on the ComfyUI platform and the introduction of the OpenComfy benchmark show that GenAgent significantly outperforms existing methods in generating effective and stable workflows.'}, 'zh': {'title': '协作AI：灵活高效的工作流生成', 'desc': '这篇论文探讨了一种新的人工智能系统，称为协作AI系统，旨在通过工作流整合模型、数据源和管道来解决复杂任务。我们介绍了GenAgent，这是一个基于大型语言模型的框架，能够自动生成复杂的工作流，提供比单一模型更大的灵活性和可扩展性。GenAgent的核心创新在于用代码表示工作流，并通过协作代理逐步构建工作流。实验结果表明，GenAgent在运行级别和任务级别的评估中均优于基线方法，展示了其生成复杂工作流的卓越效果和稳定性。'}}}, {'id': 'https://huggingface.co/papers/2409.01055', 'title': 'Follow-Your-Canvas: Higher-Resolution Video Outpainting with Extensive Content Generation', 'url': 'https://huggingface.co/papers/2409.01055', 'abstract': 'This paper explores higher-resolution video outpainting with extensive content generation. We point out common issues faced by existing methods when attempting to largely outpaint videos: the generation of low-quality content and limitations imposed by GPU memory. To address these challenges, we propose a diffusion-based method called Follow-Your-Canvas. It builds upon two core designs. First, instead of employing the common practice of "single-shot" outpainting, we distribute the task across spatial windows and seamlessly merge them. It allows us to outpaint videos of any size and resolution without being constrained by GPU memory. Second, the source video and its relative positional relation are injected into the generation process of each window. It makes the generated spatial layout within each window harmonize with the source video. Coupling with these two designs enables us to generate higher-resolution outpainting videos with rich content while keeping spatial and temporal consistency. Follow-Your-Canvas excels in large-scale video outpainting, e.g., from 512X512 to 1152X2048 (9X), while producing high-quality and aesthetically pleasing results. It achieves the best quantitative results across various resolution and scale setups. The code is released on https://github.com/mayuelala/FollowYourCanvas', 'score': 6, 'issue_id': 1, 'pub_date': '2024-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': 'f683bbfc6edc815b', 'data': {'categories': ['#video', '#training', '#open_source', '#diffusion', '#architecture'], 'emoji': '🎬', 'ru': {'title': 'Расширение видео без границ: Follow-Your-Canvas покоряет новые горизонты', 'desc': 'Эта статья представляет новый метод для расширения видео с высоким разрешением, называемый Follow-Your-Canvas. Метод основан на диффузионной модели и решает проблемы низкого качества контента и ограничений памяти GPU, с которыми сталкиваются существующие подходы. Follow-Your-Canvas использует распределенную генерацию по пространственным окнам и внедряет информацию об исходном видео в процесс генерации каждого окна. Это позволяет создавать высококачественные расширенные видео с богатым содержанием, сохраняя пространственную и временную согласованность.'}, 'en': {'title': 'Revolutionizing Video Outpainting with Follow-Your-Canvas', 'desc': "This paper presents a novel approach for higher-resolution video outpainting using a method called Follow-Your-Canvas. It addresses common challenges in video outpainting, such as low-quality content generation and GPU memory limitations, by distributing the outpainting task across spatial windows. The method incorporates the source video's positional information to ensure that the generated content aligns well with the original video, maintaining both spatial and temporal consistency. As a result, Follow-Your-Canvas can effectively generate high-quality, large-scale outpainted videos, significantly improving upon existing techniques."}, 'zh': {'title': '高分辨率视频外延的新方法', 'desc': '本文探讨了高分辨率视频的外延生成，提出了一种名为Follow-Your-Canvas的扩散方法。我们指出现有方法在大规模视频外延时常遇到的低质量内容生成和GPU内存限制等问题。该方法通过将任务分布到空间窗口并无缝合并，解决了内存限制，支持任意大小和分辨率的视频外延。同时，源视频及其相对位置关系被注入到每个窗口的生成过程中，确保生成内容与源视频的空间布局和谐一致。'}}}, {'id': 'https://huggingface.co/papers/2409.00391', 'title': 'Density Adaptive Attention-based Speech Network: Enhancing Feature Understanding for Mental Health Disorders', 'url': 'https://huggingface.co/papers/2409.00391', 'abstract': "Speech-based depression detection poses significant challenges for automated detection due to its unique manifestation across individuals and data scarcity. Addressing these challenges, we introduce DAAMAudioCNNLSTM and DAAMAudioTransformer, two parameter efficient and explainable models for audio feature extraction and depression detection. DAAMAudioCNNLSTM features a novel CNN-LSTM framework with multi-head Density Adaptive Attention Mechanism (DAAM), focusing dynamically on informative speech segments. DAAMAudioTransformer, leveraging a transformer encoder in place of the CNN-LSTM architecture, incorporates the same DAAM module for enhanced attention and interpretability. These approaches not only enhance detection robustness and interpretability but also achieve state-of-the-art performance: DAAMAudioCNNLSTM with an F1 macro score of 0.702 and DAAMAudioTransformer with an F1 macro score of 0.72 on the DAIC-WOZ dataset, without reliance on supplementary information such as vowel positions and speaker information during training/validation as in previous approaches. Both models' significant explainability and efficiency in leveraging speech signals for depression detection represent a leap towards more reliable, clinically useful diagnostic tools, promising advancements in speech and mental health care. To foster further research in this domain, we make our code publicly available.", 'score': 4, 'issue_id': 1, 'pub_date': '2024-08-31', 'pub_date_card': {'ru': '31 августа', 'en': 'August 31', 'zh': '8月31日'}, 'hash': '76a69d5f1be00050', 'data': {'categories': ['#audio', '#healthcare', '#interpretability', '#open_source', '#small_models', '#architecture'], 'emoji': '🎙️', 'ru': {'title': 'Инновационные модели машинного обучения для выявления депрессии по голосу', 'desc': 'Статья представляет два новых метода для обнаружения депрессии по речи: DAAMAudioCNNLSTM и DAAMAudioTransformer. Обе модели используют механизм адаптивного внимания к плотности (DAAM) для фокусировки на информативных сегментах речи. Модели демонстрируют высокую производительность на датасете DAIC-WOZ, достигая F1-macro score 0.702 и 0.72 соответственно. Предложенные подходы обеспечивают интерпретируемость результатов и эффективность в использовании речевых сигналов для диагностики депрессии.'}, 'en': {'title': 'Revolutionizing Depression Detection with Speech Analysis', 'desc': 'This paper presents two innovative models, DAAMAudioCNNLSTM and DAAMAudioTransformer, designed for detecting depression through speech analysis. Both models utilize a Density Adaptive Attention Mechanism (DAAM) to focus on the most relevant parts of speech data, improving the accuracy of detection. The DAAMAudioCNNLSTM combines Convolutional Neural Networks (CNN) with Long Short-Term Memory (LSTM) networks, while the DAAMAudioTransformer employs a transformer architecture for enhanced interpretability. Achieving state-of-the-art F1 macro scores on the DAIC-WOZ dataset, these models demonstrate significant advancements in automated depression detection without needing additional speaker information.'}, 'zh': {'title': '基于语音的抑郁检测新突破', 'desc': '本论文提出了两种新的模型，DAAMAudioCNNLSTM和DAAMAudioTransformer，用于基于语音的抑郁检测。这些模型通过引入多头密度自适应注意机制（DAAM），有效提取音频特征并动态关注重要的语音片段。与以往方法不同，这些模型在训练和验证过程中不依赖于额外的信息，如元音位置和说话者信息。实验结果表明，这两种模型在DAIC-WOZ数据集上达到了最先进的性能，展示了在抑郁检测领域的显著进展。'}}}, {'id': 'https://huggingface.co/papers/2409.01357', 'title': 'Know When to Fuse: Investigating Non-English Hybrid Retrieval in the Legal Domain', 'url': 'https://huggingface.co/papers/2409.01357', 'abstract': 'Hybrid search has emerged as an effective strategy to offset the limitations of different matching paradigms, especially in out-of-domain contexts where notable improvements in retrieval quality have been observed. However, existing research predominantly focuses on a limited set of retrieval methods, evaluated in pairs on domain-general datasets exclusively in English. In this work, we study the efficacy of hybrid search across a variety of prominent retrieval models within the unexplored field of law in the French language, assessing both zero-shot and in-domain scenarios. Our findings reveal that in a zero-shot context, fusing different domain-general models consistently enhances performance compared to using a standalone model, regardless of the fusion method. Surprisingly, when models are trained in-domain, we find that fusion generally diminishes performance relative to using the best single system, unless fusing scores with carefully tuned weights. These novel insights, among others, expand the applicability of prior findings across a new field and language, and contribute to a deeper understanding of hybrid search in non-English specialized domains.', 'score': 2, 'issue_id': 1, 'pub_date': '2024-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': '8cc67a6869d64f74', 'data': {'categories': ['#dataset', '#multilingual', '#rag', '#transfer_learning', '#low_resource'], 'emoji': '⚖️', 'ru': {'title': 'Гибридный поиск в юриспруденции: неожиданные результаты для французского языка', 'desc': 'В статье исследуется эффективность гибридного поиска в юридической области на французском языке. Авторы оценивают различные модели извлечения информации в сценариях zero-shot и обучения на предметной области. Результаты показывают, что в zero-shot режиме объединение разных моделей улучшает производительность. Однако при обучении на предметной области слияние моделей обычно снижает эффективность, если не использовать тщательно подобранные веса.'}, 'en': {'title': 'Enhancing Legal Search: The Power of Hybrid Models in French', 'desc': 'This paper explores hybrid search, which combines different retrieval methods to improve search results, particularly in the legal domain using the French language. The authors find that using a mix of models in a zero-shot scenario leads to better performance than any single model. However, when models are trained specifically for the legal domain, combining them often results in worse performance unless the fusion weights are finely adjusted. These results highlight the complexities of hybrid search in specialized fields and suggest that previous findings may not directly apply to non-English contexts.'}, 'zh': {'title': '混合搜索：提升检索质量的新策略', 'desc': '混合搜索是一种有效的策略，可以弥补不同匹配范式的局限性，特别是在领域外的情况下，检索质量显著提高。现有研究主要集中在有限的检索方法上，且仅在英语的领域通用数据集上进行评估。本文研究了混合搜索在法语法律领域的有效性，评估了零样本和领域内场景。我们的发现表明，在零样本情况下，融合不同的领域通用模型始终能提高性能，而在领域内训练的模型中，除非使用精心调整的权重进行融合，否则融合通常会降低性能。'}}}, {'id': 'https://huggingface.co/papers/2409.00447', 'title': 'The MERIT Dataset: Modelling and Efficiently Rendering Interpretable Transcripts', 'url': 'https://huggingface.co/papers/2409.00447', 'abstract': "This paper introduces the MERIT Dataset, a multimodal (text + image + layout) fully labeled dataset within the context of school reports. Comprising over 400 labels and 33k samples, the MERIT Dataset is a valuable resource for training models in demanding Visually-rich Document Understanding (VrDU) tasks. By its nature (student grade reports), the MERIT Dataset can potentially include biases in a controlled way, making it a valuable tool to benchmark biases induced in Language Models (LLMs). The paper outlines the dataset's generation pipeline and highlights its main features in the textual, visual, layout, and bias domains. To demonstrate the dataset's utility, we present a benchmark with token classification models, showing that the dataset poses a significant challenge even for SOTA models and that these would greatly benefit from including samples from the MERIT Dataset in their pretraining phase.", 'score': 2, 'issue_id': 1, 'pub_date': '2024-08-31', 'pub_date_card': {'ru': '31 августа', 'en': 'August 31', 'zh': '8月31日'}, 'hash': '7d3ef5f0783e4fb6', 'data': {'categories': ['#dataset', '#cv', '#ethics', '#data', '#benchmark', '#open_source', '#multimodal'], 'emoji': '📊', 'ru': {'title': 'MERIT: мультимодальный датасет для анализа документов и оценки предвзятости ИИ', 'desc': 'Статья представляет набор данных MERIT - мультимодальный датасет для понимания визуально насыщенных документов. Он содержит более 400 меток и 33 тысячи образцов школьных отчетов, включая текст, изображения и разметку. MERIT может использоваться для оценки предвзятости языковых моделей, так как содержит потенциальные смещения в контролируемом виде. В работе описывается процесс создания датасета и проводится бенчмарк моделей классификации токенов, демонстрирующий сложность задачи даже для современных алгоритмов.'}, 'en': {'title': 'Unlocking Visually-rich Document Understanding with MERIT', 'desc': 'The MERIT Dataset is a new resource designed for training machine learning models on school reports, combining text, images, and layout information. It contains over 33,000 samples and 400 labels, making it suitable for complex tasks in Visually-rich Document Understanding (VrDU). The dataset also allows researchers to study biases in Language Models (LLMs) due to its specific context. The paper demonstrates that even state-of-the-art models struggle with this dataset, indicating its potential to improve model performance when included in pretraining.'}, 'zh': {'title': 'MERIT数据集：推动视觉文档理解的利器', 'desc': '本文介绍了MERIT数据集，这是一个包含文本、图像和布局的多模态完全标注数据集，专注于学校报告。该数据集包含超过400个标签和33,000个样本，是训练视觉丰富文档理解（VrDU）任务模型的重要资源。由于其特性（学生成绩报告），MERIT数据集可能以受控方式包含偏见，成为评估语言模型（LLMs）偏见的重要工具。文章还描述了数据集的生成流程，并强调了其在文本、视觉、布局和偏见领域的主要特征。'}}}, {'id': 'https://huggingface.co/papers/2409.00138', 'title': 'PrivacyLens: Evaluating Privacy Norm Awareness of Language Models in Action', 'url': 'https://huggingface.co/papers/2409.00138', 'abstract': "As language models (LMs) are widely utilized in personalized communication scenarios (e.g., sending emails, writing social media posts) and endowed with a certain level of agency, ensuring they act in accordance with the contextual privacy norms becomes increasingly critical. However, quantifying the privacy norm awareness of LMs and the emerging privacy risk in LM-mediated communication is challenging due to (1) the contextual and long-tailed nature of privacy-sensitive cases, and (2) the lack of evaluation approaches that capture realistic application scenarios. To address these challenges, we propose PrivacyLens, a novel framework designed to extend privacy-sensitive seeds into expressive vignettes and further into agent trajectories, enabling multi-level evaluation of privacy leakage in LM agents' actions. We instantiate PrivacyLens with a collection of privacy norms grounded in privacy literature and crowdsourced seeds. Using this dataset, we reveal a discrepancy between LM performance in answering probing questions and their actual behavior when executing user instructions in an agent setup. State-of-the-art LMs, like GPT-4 and Llama-3-70B, leak sensitive information in 25.68% and 38.69% of cases, even when prompted with privacy-enhancing instructions. We also demonstrate the dynamic nature of PrivacyLens by extending each seed into multiple trajectories to red-team LM privacy leakage risk. Dataset and code are available at https://github.com/SALT-NLP/PrivacyLens.", 'score': 1, 'issue_id': 1, 'pub_date': '2024-08-29', 'pub_date_card': {'ru': '29 августа', 'en': 'August 29', 'zh': '8月29日'}, 'hash': 'b5d2f82929b24c1c', 'data': {'categories': ['#dataset', '#leakage', '#multilingual', '#training', '#ethics', '#agents', '#benchmark', '#open_source'], 'emoji': '🕵️', 'ru': {'title': 'PrivacyLens: защита приватности в эпоху языковых моделей', 'desc': 'Авторы представляют PrivacyLens - новую систему для оценки осведомленности языковых моделей о нормах конфиденциальности и рисках утечки данных в коммуникациях с их участием. Система генерирует сценарии и траектории агентов на основе исходных примеров, связанных с приватностью. Эксперименты показали, что современные языковые модели, такие как GPT-4 и Llama-3-70B, допускают утечку конфиденциальной информации в 25-39% случаев даже при наличии инструкций по защите приватности. PrivacyLens позволяет проводить многоуровневую оценку рисков и тестировать модели на устойчивость к утечкам данных.'}, 'en': {'title': 'Enhancing Privacy Awareness in Language Models with PrivacyLens', 'desc': 'This paper introduces PrivacyLens, a framework aimed at evaluating the privacy awareness of language models (LMs) in communication tasks. It addresses the challenges of quantifying privacy norms due to the complex and varied nature of privacy-sensitive situations. The framework allows for a multi-level assessment of privacy leakage by transforming privacy-sensitive seeds into detailed scenarios and agent actions. The study reveals significant privacy risks, showing that advanced LMs like GPT-4 and Llama-3-70B can leak sensitive information in a substantial percentage of cases, even when given privacy-focused instructions.'}, 'zh': {'title': '确保语言模型遵循隐私规范的关键', 'desc': '本文提出了一种名为PrivacyLens的新框架，旨在评估语言模型在个性化沟通中对隐私规范的遵循情况。该框架通过将隐私敏感的种子扩展为生动的场景和代理轨迹，实现对隐私泄露的多层次评估。研究发现，尽管先进的语言模型在回答隐私相关问题时表现良好，但在实际执行用户指令时，仍有相当比例的案例泄露敏感信息。通过动态扩展种子，PrivacyLens能够有效识别和评估语言模型的隐私泄露风险。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (1)', '#agents (2)', '#agi (1)', '#alignment', '#architecture (12)', '#audio (2)', '#benchmark (6)', '#cv (7)', '#data (1)', '#dataset (5)', '#diffusion (8)', '#ethics (2)', '#games', '#graphs', '#hallucinations', '#healthcare (2)', '#inference (5)', '#interpretability (2)', '#leakage (1)', '#long_context (4)', '#low_resource (1)', '#machine_translation', '#math', '#multilingual (2)', '#multimodal (2)', '#open_source (12)', '#optimization (9)', '#plp', '#rag (2)', '#reasoning', '#rl (1)', '#rlhf', '#robotics (1)', '#science (2)', '#security (1)', '#small_models (5)', '#story_generation', '#survey', '#synthetic (4)', '#training (10)', '#transfer_learning (4)', '#video (5)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="background-digit">${index + 1}</div>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <img class="article-pdf-title-img" src="${pdfImg}" />
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-09-04 09:00',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2024-09-04 09:00')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2024-09-04 09:00')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    