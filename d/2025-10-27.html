
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 11 papers. October 27.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">27 октября</span> | <span id="title-articles-count">11 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-10-24.html">⬅️ <span id="prev-date">24.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-10-28.html">➡️ <span id="next-date">28.10</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-10.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '27 октября', 'en': 'October 27', 'zh': '10月27日'};
        let feedDateNext = {'ru': '28.10', 'en': '10/28', 'zh': '10月28日'};
        let feedDatePrev = {'ru': '24.10', 'en': '10/24', 'zh': '10月24日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2510.21618', 'title': 'DeepAgent: A General Reasoning Agent with Scalable Toolsets', 'url': 'https://huggingface.co/papers/2510.21618', 'abstract': 'DeepAgent, an end-to-end deep reasoning agent, autonomously performs thinking, tool discovery, and action execution using memory folding and reinforcement learning, outperforming baselines in various tool-use and application tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t Large reasoning models have demonstrated strong problem-solving abilities, yet real-world tasks often require external tools and long-horizon interactions. Existing agent frameworks typically follow predefined workflows, which limit autonomous and global task completion. In this paper, we introduce DeepAgent, an end-to-end deep reasoning agent that performs autonomous thinking, tool discovery, and action execution within a single, coherent reasoning process. To address the challenges of long-horizon interactions, particularly the context length explosion from multiple tool calls and the accumulation of interaction history, we introduce an autonomous memory folding mechanism that compresses past interactions into structured episodic, working, and tool memories, reducing error accumulation while preserving critical information. To teach general-purpose tool use efficiently and stably, we develop an end-to-end reinforcement learning strategy, namely ToolPO, that leverages LLM-simulated APIs and applies tool-call advantage attribution to assign fine-grained credit to the tool invocation tokens. Extensive experiments on eight benchmarks, including general tool-use tasks (ToolBench, API-Bank, TMDB, Spotify, ToolHop) and downstream applications (ALFWorld, WebShop, GAIA, HLE), demonstrate that DeepAgent consistently outperforms baselines across both labeled-tool and open-set tool retrieval scenarios. This work takes a step toward more general and capable agents for real-world applications. The code and demo are available at https://github.com/RUC-NLPIR/DeepAgent.', 'score': 24, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': '58d13c7e0c138478', 'authors': ['Xiaoxi Li', 'Wenxiang Jiao', 'Jiarui Jin', 'Guanting Dong', 'Jiajie Jin', 'Yinuo Wang', 'Hao Wang', 'Yutao Zhu', 'Ji-Rong Wen', 'Yuan Lu', 'Zhicheng Dou'], 'affiliations': ['Renmin University of China', 'Xiaohongshu Inc.'], 'pdf_title_img': 'assets/pdf/title_img/2510.21618.jpg', 'data': {'categories': ['#optimization', '#rl', '#agents', '#reasoning'], 'emoji': '🤖', 'ru': {'title': 'DeepAgent: автономный AI-агент с глубоким reasoning и управлением памятью', 'desc': 'В статье представлен DeepAgent — end-to-end агент для решения сложных задач, который автономно выполняет рассуждения, поиск инструментов и действия в едином процессе. Для работы с длинными последовательностями взаимодействий используется механизм автономного сжатия памяти (memory folding), который структурирует историю в эпизодическую, рабочую и инструментальную память. Для обучения применяется reinforcement learning стратегия ToolPO, которая использует симулированные LLM API и детальное распределение credit assignment для токенов вызова инструментов. Эксперименты на восьми бенчмарках показывают превосходство DeepAgent над базовыми методами как в задачах с известными инструментами, так и в open-set сценариях.'}, 'en': {'title': 'DeepAgent: Autonomous Reasoning and Tool Discovery for Real-World Tasks', 'desc': 'DeepAgent is a novel deep reasoning agent designed to autonomously think, discover tools, and execute actions in a unified process. It addresses the challenges of long-horizon interactions by implementing a memory folding mechanism that compresses past interactions, thus minimizing errors while retaining essential information. The agent is trained using an end-to-end reinforcement learning approach called ToolPO, which effectively assigns credit to tool usage based on simulated API interactions. Extensive testing shows that DeepAgent outperforms existing frameworks in various tool-use and application tasks, paving the way for more capable AI agents in real-world scenarios.'}, 'zh': {'title': 'DeepAgent：自主思考与工具发现的智能代理', 'desc': 'DeepAgent是一种端到端的深度推理代理，能够自主进行思考、工具发现和行动执行。它通过记忆折叠和强化学习的方法，解决了长时间交互中的上下文长度爆炸问题。DeepAgent在多个工具使用和应用任务中表现优于基线模型，展示了其强大的问题解决能力。该研究为更通用和强大的现实世界代理迈出了重要一步。'}}}, {'id': 'https://huggingface.co/papers/2510.20286', 'title': 'UI-Ins: Enhancing GUI Grounding with Multi-Perspective\n  Instruction-as-Reasoning', 'url': 'https://huggingface.co/papers/2510.20286', 'abstract': 'The Instruction-as-Reasoning paradigm enhances GUI grounding by treating instructions as dynamic pathways, improving performance through multi-perspective reasoning and reinforcement learning.  \t\t\t\t\tAI-generated summary \t\t\t\t GUI grounding, which maps natural-language instructions to actionable UI elements, is a core capability of GUI agents. Prior works largely treats instructions as a static proxy for user intent, overlooking the impact of instruction diversity and quality on grounding performance. Through a careful investigation of existing grounding datasets, we find a 23.3% flaw rate in their instructions and show that inference-time exploitation of instruction diversity yields up to a substantial 76% relative performance improvement. In this paper, we introduce the Instruction-as-Reasoning paradigm, treating instructions as dynamic analytical pathways that offer distinct perspectives and enabling the model to select the most effective pathway during reasoning. To achieve this, we propose a two-stage training framework: supervised fine-tuning (SFT) on synthesized, diverse instructions to instill multi-perspective reasoning, followed by reinforcement learning (RL) to optimize pathway selection and composition. Our resulting models, UI-Ins-7B and UI-Ins-32B, achieve state-of-the-art results on five challenging grounding benchmarks and exhibit emergent reasoning, selectively composing and synthesizing novel instruction pathways at inference. In particular, UI-Ins-32B attains the best grounding accuracy, scoring 87.3% on UI-I2E-Bench, 57.0% on ScreenSpot-Pro, and 84.9% on MMBench-GUI L2. Furthermore, our model demonstrates strong agentic potential, achieving a 74.1% success rate on AndroidWorld using UI-Ins-7B as the executor. Our in-depth analysis reveals additional insights such as how reasoning can be formulated to enhance rather than hinder grounding performance, and how our method mitigates policy collapse in the SFT+RL framework. All code and model checkpoints will be publicly released in https://github.com/alibaba/UI-Ins.', 'score': 12, 'issue_id': 6621, 'pub_date': '2025-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '7a550042831907d9', 'authors': ['Liangyu Chen', 'Hanzhang Zhou', 'Chenglin Cai', 'Jianan Zhang', 'Panrong Tong', 'Quyu Kong', 'Xu Zhang', 'Chen Liu', 'Yuqi Liu', 'Wenxuan Wang', 'Yue Wang', 'Qin Jin', 'Steven Hoi'], 'affiliations': ['CUHK', 'Renmin University of China', 'Tongyi Lab, Alibaba Group'], 'pdf_title_img': 'assets/pdf/title_img/2510.20286.jpg', 'data': {'categories': ['#training', '#rl', '#open_source', '#benchmark', '#agents', '#optimization', '#reasoning'], 'emoji': '🎯', 'ru': {'title': 'Инструкции как пути рассуждения: новый подход к пониманию интерфейсов', 'desc': 'Исследователи представили новую парадигму Instruction-as-Reasoning для GUI grounding - задачи сопоставления естественно-языковых инструкций с элементами пользовательского интерфейса. Вместо того чтобы рассматривать инструкции как статичные команды, модель использует их как динамические аналитические пути, выбирая наиболее эффективный подход к рассуждению. Обучение проходит в два этапа: сначала supervised fine-tuning на разнообразных синтезированных инструкциях, затем reinforcement learning для оптимизации выбора путей рассуждения. Модели UI-Ins-7B и UI-Ins-32B достигли state-of-the-art результатов на пяти бенчмарках, при этом UI-Ins-32B показала 87.3% точности на UI-I2E-Bench и 74.1% успешности в качестве агента на AndroidWorld.'}, 'en': {'title': 'Dynamic Pathways for Enhanced GUI Grounding', 'desc': 'This paper introduces the Instruction-as-Reasoning paradigm, which enhances GUI grounding by treating instructions as dynamic pathways for reasoning. It highlights the flaws in existing grounding datasets and demonstrates that leveraging instruction diversity can significantly improve performance. The authors propose a two-stage training framework that combines supervised fine-tuning and reinforcement learning to optimize the selection of effective reasoning pathways. Their models achieve state-of-the-art results on multiple benchmarks, showcasing improved grounding accuracy and emergent reasoning capabilities.'}, 'zh': {'title': '指令作为推理：提升GUI基础性能的动态路径', 'desc': '本论文提出了"指令作为推理"的范式，通过将指令视为动态分析路径，来增强图形用户界面（GUI）基础的性能。研究发现，现有数据集中指令的多样性和质量对基础性能有显著影响，且在推理时利用指令多样性可以提高性能达76%。我们提出了一个两阶段的训练框架，首先通过监督微调（SFT）来培养多角度推理，然后通过强化学习（RL）优化路径选择。最终模型在多个基准测试中表现出色，特别是在UI-I2E-Bench上达到了87.3%的最佳准确率。'}}}, {'id': 'https://huggingface.co/papers/2510.20888', 'title': 'Video-As-Prompt: Unified Semantic Control for Video Generation', 'url': 'https://huggingface.co/papers/2510.20888', 'abstract': "Video-As-Prompt (VAP) uses a reference video to guide a frozen Video Diffusion Transformer via a Mixture-of-Transformers expert, achieving state-of-the-art results in semantic-controlled video generation with strong zero-shot generalization.  \t\t\t\t\tAI-generated summary \t\t\t\t Unified, generalizable semantic control in video generation remains a critical open challenge. Existing methods either introduce artifacts by enforcing inappropriate pixel-wise priors from structure-based controls, or rely on non-generalizable, condition-specific finetuning or task-specific architectures. We introduce Video-As-Prompt (VAP), a new paradigm that reframes this problem as in-context generation. VAP leverages a reference video as a direct semantic prompt, guiding a frozen Video Diffusion Transformer (DiT) via a plug-and-play Mixture-of-Transformers (MoT) expert. This architecture prevents catastrophic forgetting and is guided by a temporally biased position embedding that eliminates spurious mapping priors for robust context retrieval. To power this approach and catalyze future research, we built VAP-Data, the largest dataset for semantic-controlled video generation with over 100K paired videos across 100 semantic conditions. As a single unified model, VAP sets a new state-of-the-art for open-source methods, achieving a 38.7% user preference rate that rivals leading condition-specific commercial models. VAP's strong zero-shot generalization and support for various downstream applications mark a significant advance toward general-purpose, controllable video generation.", 'score': 7, 'issue_id': 6621, 'pub_date': '2025-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '519377609a2a0255', 'authors': ['Yuxuan Bian', 'Xin Chen', 'Zenan Li', 'Tiancheng Zhi', 'Shen Sang', 'Linjie Luo', 'Qiang Xu'], 'affiliations': ['Intelligent Creation Lab, ByteDance', 'The Chinese University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2510.20888.jpg', 'data': {'categories': ['#video', '#open_source', '#dataset', '#architecture', '#diffusion'], 'emoji': '🎬', 'ru': {'title': 'Видео как промпт: универсальный контроль генерации через референс', 'desc': 'Статья представляет Video-As-Prompt (VAP) — новый подход к контролируемой генерации видео, где референсное видео используется как семантический промпт для замороженного Video Diffusion Transformer. Архитектура основана на Mixture-of-Transformers эксперте, который обеспечивает сильную zero-shot генерализацию без катастрофического забывания. Авторы создали VAP-Data — крупнейший датасет для семантически контролируемой генерации видео с более чем 100K парами видео по 100 условиям. Модель достигает state-of-the-art результатов среди open-source методов с 38.7% предпочтением пользователей, конкурируя с коммерческими специализированными моделями.'}, 'en': {'title': 'Revolutionizing Video Generation with Contextual Prompts', 'desc': "Video-As-Prompt (VAP) is a novel approach in video generation that utilizes a reference video to guide a pre-trained Video Diffusion Transformer, enhancing semantic control without the need for extensive fine-tuning. This method employs a Mixture-of-Transformers expert to ensure robust context retrieval while avoiding common pitfalls like catastrophic forgetting and inappropriate pixel-wise priors. VAP introduces a temporally biased position embedding to improve the model's ability to generate coherent and contextually relevant videos. With the creation of VAP-Data, a comprehensive dataset of over 100,000 paired videos, VAP achieves state-of-the-art results in user preference and demonstrates strong zero-shot generalization capabilities."}, 'zh': {'title': '视频生成的新范式：视频作为提示', 'desc': 'Video-As-Prompt (VAP) 是一种新方法，通过参考视频来引导一个冻结的Video Diffusion Transformer，从而实现语义控制的视频生成。该方法使用混合变换器专家，避免了传统方法中常见的伪影问题，并且不需要特定任务的微调。VAP 通过时间偏置位置嵌入来增强上下文检索的鲁棒性，防止灾难性遗忘。VAP-Data 数据集是目前最大的语义控制视频生成数据集，包含超过10万对视频，推动了这一领域的研究进展。'}}}, {'id': 'https://huggingface.co/papers/2510.21682', 'title': 'WorldGrow: Generating Infinite 3D World', 'url': 'https://huggingface.co/papers/2510.21682', 'abstract': 'WorldGrow, a hierarchical framework, generates large, continuous 3D environments with coherent geometry and realistic appearance using pre-trained 3D models and a coarse-to-fine generation strategy.  \t\t\t\t\tAI-generated summary \t\t\t\t We tackle the challenge of generating the infinitely extendable 3D world -- large, continuous environments with coherent geometry and realistic appearance. Existing methods face key challenges: 2D-lifting approaches suffer from geometric and appearance inconsistencies across views, 3D implicit representations are hard to scale up, and current 3D foundation models are mostly object-centric, limiting their applicability to scene-level generation. Our key insight is leveraging strong generation priors from pre-trained 3D models for structured scene block generation. To this end, we propose WorldGrow, a hierarchical framework for unbounded 3D scene synthesis. Our method features three core components: (1) a data curation pipeline that extracts high-quality scene blocks for training, making the 3D structured latent representations suitable for scene generation; (2) a 3D block inpainting mechanism that enables context-aware scene extension; and (3) a coarse-to-fine generation strategy that ensures both global layout plausibility and local geometric/textural fidelity. Evaluated on the large-scale 3D-FRONT dataset, WorldGrow achieves SOTA performance in geometry reconstruction, while uniquely supporting infinite scene generation with photorealistic and structurally consistent outputs. These results highlight its capability for constructing large-scale virtual environments and potential for building future world models.', 'score': 3, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': 'c8660a9a47c4dbe3', 'authors': ['Sikuang Li', 'Chen Yang', 'Jiemin Fang', 'Taoran Yi', 'Jia Lu', 'Jiazhong Cen', 'Lingxi Xie', 'Wei Shen', 'Qi Tian'], 'affiliations': ['Huawei Inc.', 'Huazhong University of Science and Technology', 'MoE Key Lab of Artificial Intelligence, School of Computer Science, SJTU'], 'pdf_title_img': 'assets/pdf/title_img/2510.21682.jpg', 'data': {'categories': ['#3d', '#dataset', '#games'], 'emoji': '🌍', 'ru': {'title': 'Бесконечная генерация 3D-миров блок за блоком', 'desc': 'WorldGrow - это иерархический фреймворк для генерации бесконечно расширяемых 3D-миров с реалистичной геометрией и текстурами. Метод использует предобученные 3D-модели и генерирует сцены блоками через механизм inpainting с учётом контекста. Ключевая особенность - стратегия генерации от грубого к детальному, обеспечивающая согласованность как глобальной структуры, так и локальных деталей. Система достигает state-of-the-art результатов на датасете 3D-FRONT и способна создавать фотореалистичные виртуальные окружения неограниченного масштаба.'}, 'en': {'title': 'Infinite 3D Worlds Made Real with WorldGrow', 'desc': 'WorldGrow is a hierarchical framework designed to create large, continuous 3D environments that maintain coherent geometry and realistic appearances. It addresses the limitations of existing methods, such as inconsistencies in 2D-lifting approaches and the challenges of scaling 3D implicit representations. By utilizing pre-trained 3D models, WorldGrow employs a coarse-to-fine generation strategy that enhances both the global layout and local details of the generated scenes. The framework demonstrates state-of-the-art performance in geometry reconstruction and supports the generation of infinite, photorealistic environments, making it a significant advancement in 3D scene synthesis.'}, 'zh': {'title': '无限扩展的3D世界生成框架', 'desc': 'WorldGrow是一个层次化框架，旨在生成大型、连续的3D环境，具有一致的几何形状和真实的外观。该方法利用预训练的3D模型和粗到细的生成策略，解决了现有方法在几何和外观一致性方面的挑战。WorldGrow的核心组件包括高质量场景块的数据整理管道、上下文感知的3D块修复机制，以及确保全局布局合理性和局部几何/纹理保真度的生成策略。经过在大规模3D-FRONT数据集上的评估，WorldGrow在几何重建方面达到了最先进的性能，并支持无限场景生成，展示了其构建大规模虚拟环境的能力。'}}}, {'id': 'https://huggingface.co/papers/2510.21223', 'title': 'Model Merging with Functional Dual Anchors', 'url': 'https://huggingface.co/papers/2510.21223', 'abstract': 'Functional Dual Anchors (FDAs) enhance model merging by aligning gradients with task vectors in the input-representation space, offering robustness and flexibility compared to parameter-space methods.  \t\t\t\t\tAI-generated summary \t\t\t\t Model merging is an efficient post-training strategy for integrating knowledge from multiple finetuned checkpoints of a shared foundation model. Existing methods operate in the parameter space, combining task vectors to mitigate conflicts, but remain constrained by parameter inconsistencies. We propose Functional Dual Anchors (FDAs), a framework that instead models the input-representation space. FDAs are synthetic inputs whose induced gradients align with task vectors, capturing task-specific functional shifts relative to the pretrained model. This perspective bridges joint multi-task training and post-hoc merging, offering both robustness and flexibility. We further introduce a principled initialization scheme and show that FDAs are complementary to parameter-space model merging. Comprehensive experiments demonstrate the effectiveness of FDAs in model merging.', 'score': 3, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': '029e5f4701cf63dd', 'authors': ['Kexuan Shi', 'Yandong Wen', 'Weiyang Liu'], 'affiliations': ['The Chinese University of Hong Kong', 'Westlake University'], 'pdf_title_img': 'assets/pdf/title_img/2510.21223.jpg', 'data': {'categories': ['#synthetic', '#architecture', '#training', '#optimization'], 'emoji': '⚓', 'ru': {'title': 'Функциональные якоря для умного объединения моделей', 'desc': 'Исследователи предложили новый подход к объединению fine-tuned моделей под названием Functional Dual Anchors (FDA). Вместо работы в пространстве параметров, метод работает в пространстве входов и представлений, используя синтетические входные данные как «якоря». Градиенты этих якорей выравниваются с task vectors, что позволяет эффективно захватывать специфичные для каждой задачи изменения относительно базовой модели. Метод показывает большую робастность по сравнению с классическими подходами и может их дополнять.'}, 'en': {'title': 'Enhancing Model Merging with Functional Dual Anchors', 'desc': 'Functional Dual Anchors (FDAs) improve the process of model merging by focusing on the input-representation space rather than the parameter space. This approach aligns gradients with task vectors, which helps to manage conflicts that arise when integrating knowledge from different finetuned models. FDAs act as synthetic inputs that reflect task-specific changes, enhancing the robustness and flexibility of the merging process. Our experiments show that FDAs work well alongside traditional parameter-space methods, making them a valuable addition to model merging techniques.'}, 'zh': {'title': '功能双锚：提升模型合并的鲁棒性与灵活性', 'desc': '功能双锚（FDAs）通过在输入表示空间中对齐梯度与任务向量，增强了模型合并的能力，相比于参数空间的方法，提供了更强的鲁棒性和灵活性。现有的模型合并方法主要在参数空间中操作，试图通过组合任务向量来减少冲突，但受到参数不一致性的限制。FDAs作为合成输入，其诱导的梯度与任务向量对齐，能够捕捉相对于预训练模型的任务特定功能变化。这种方法将联合多任务训练与后期合并相结合，展示了FDAs在模型合并中的有效性。'}}}, {'id': 'https://huggingface.co/papers/2510.18212', 'title': 'A Definition of AGI', 'url': 'https://huggingface.co/papers/2510.18212', 'abstract': 'A quantifiable framework based on Cattell-Horn-Carroll theory evaluates AI systems across ten cognitive domains, revealing significant gaps in foundational cognitive abilities like long-term memory.  \t\t\t\t\tAI-generated summary \t\t\t\t The lack of a concrete definition for Artificial General Intelligence (AGI) obscures the gap between today\'s specialized AI and human-level cognition. This paper introduces a quantifiable framework to address this, defining AGI as matching the cognitive versatility and proficiency of a well-educated adult. To operationalize this, we ground our methodology in Cattell-Horn-Carroll theory, the most empirically validated model of human cognition. The framework dissects general intelligence into ten core cognitive domains-including reasoning, memory, and perception-and adapts established human psychometric batteries to evaluate AI systems. Application of this framework reveals a highly "jagged" cognitive profile in contemporary models. While proficient in knowledge-intensive domains, current AI systems have critical deficits in foundational cognitive machinery, particularly long-term memory storage. The resulting AGI scores (e.g., GPT-4 at 27%, GPT-5 at 58%) concretely quantify both rapid progress and the substantial gap remaining before AGI.', 'score': 3, 'issue_id': 6621, 'pub_date': '2025-10-21', 'pub_date_card': {'ru': '21 октября', 'en': 'October 21', 'zh': '10月21日'}, 'hash': 'be8269623d74c8cf', 'authors': ['Dan Hendrycks', 'Dawn Song', 'Christian Szegedy', 'Honglak Lee', 'Yarin Gal', 'Erik Brynjolfsson', 'Sharon Li', 'Andy Zou', 'Lionel Levine', 'Bo Han', 'Jie Fu', 'Ziwei Liu', 'Jinwoo Shin', 'Kimin Lee', 'Mantas Mazeika', 'Long Phan', 'George Ingebretsen', 'Adam Khoja', 'Cihang Xie', 'Olawale Salaudeen', 'Matthias Hein', 'Kevin Zhao', 'Alexander Pan', 'David Duvenaud', 'Bo Li', 'Steve Omohundro', 'Gabriel Alfour', 'Max Tegmark', 'Kevin McGrew', 'Gary Marcus', 'Jaan Tallinn', 'Eric Schmidt', 'Yoshua Bengio'], 'affiliations': ['Beneficial AI Research', 'CSER', 'Carnegie Mellon University', 'Center for AI Safety', 'Conjecture', 'Cornell University', 'Gray Swan AI', 'HKUST', 'Hong Kong Baptist University', 'Institute for Applied Psychometrics', 'KAIST', 'LG AI Research', 'LawZero', 'Massachusetts Institute of Technology', 'Morph Labs', 'Nanyang Technological University', 'New York University', 'Stanford University', 'University of California, Berkeley', 'University of California, Santa Cruz', 'University of Chicago', 'University of Michigan', 'University of Oxford', 'University of Toronto', 'University of Tübingen', 'University of Washington', 'University of Wisconsin-Madison', 'Université de Montréal', 'Vector Institute'], 'pdf_title_img': 'assets/pdf/title_img/2510.18212.jpg', 'data': {'categories': ['#agi', '#benchmark', '#long_context', '#reasoning', '#math'], 'emoji': '🧠', 'ru': {'title': 'Измеряя разрыв до AGI через призму человеческой психометрии', 'desc': 'Статья предлагает количественную методику оценки AI-систем на основе теории Кеттелла-Хорна-Кэрролла, рассматривая десять когнитивных доменов человеческого интеллекта. Авторы адаптируют психометрические тесты для людей, чтобы измерить способности LLM в областях рассуждения, памяти и восприятия. Исследование показывает "зубчатый" профиль современных моделей: они сильны в задачах, требующих знаний, но имеют критические недостатки в базовых когнитивных функциях, особенно в долговременной памяти. По предложенной шкале GPT-4 достигает 27% на пути к AGI, а GPT-5 - 58%, что наглядно демонстрирует прогресс и оставшийся разрыв до человеческого уровня.'}, 'en': {'title': 'Bridging the Gap to Artificial General Intelligence', 'desc': 'This paper presents a framework to evaluate AI systems based on the Cattell-Horn-Carroll theory of intelligence, which breaks down general intelligence into ten cognitive domains. It aims to define Artificial General Intelligence (AGI) as the ability to perform across these domains like a well-educated adult. The evaluation shows that while current AI models excel in knowledge-heavy tasks, they significantly lack in foundational cognitive abilities, especially in long-term memory. The framework provides quantifiable AGI scores, highlighting both the advancements made and the considerable gaps that still exist in achieving true AGI.'}, 'zh': {'title': '量化框架揭示AI认知能力的差距', 'desc': '本文提出了一个基于Cattell-Horn-Carroll理论的量化框架，用于评估人工智能系统在十个认知领域的表现。研究发现，当前的AI系统在基础认知能力上存在显著差距，尤其是在长期记忆方面。通过将一般智力分解为推理、记忆和感知等核心认知领域，框架能够有效评估AI的认知能力。最终的AGI评分显示，尽管AI在知识密集型领域表现出色，但在实现与人类相当的认知灵活性和熟练度方面仍有很大提升空间。'}}}, {'id': 'https://huggingface.co/papers/2510.21697', 'title': 'Visual Diffusion Models are Geometric Solvers', 'url': 'https://huggingface.co/papers/2510.21697', 'abstract': 'Visual diffusion models can solve geometric problems by transforming noisy images into valid solutions, demonstrating a novel approach to geometric reasoning through image generation.  \t\t\t\t\tAI-generated summary \t\t\t\t In this paper we show that visual diffusion models can serve as effective geometric solvers: they can directly reason about geometric problems by working in pixel space. We first demonstrate this on the Inscribed Square Problem, a long-standing problem in geometry that asks whether every Jordan curve contains four points forming a square. We then extend the approach to two other well-known hard geometric problems: the Steiner Tree Problem and the Simple Polygon Problem.   Our method treats each problem instance as an image and trains a standard visual diffusion model that transforms Gaussian noise into an image representing a valid approximate solution that closely matches the exact one. The model learns to transform noisy geometric structures into correct configurations, effectively recasting geometric reasoning as image generation.   Unlike prior work that necessitates specialized architectures and domain-specific adaptations when applying diffusion to parametric geometric representations, we employ a standard visual diffusion model that operates on the visual representation of the problem. This simplicity highlights a surprising bridge between generative modeling and geometric problem solving. Beyond the specific problems studied here, our results point toward a broader paradigm: operating in image space provides a general and practical framework for approximating notoriously hard problems, and opens the door to tackling a far wider class of challenging geometric tasks.', 'score': 1, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': 'ca1111516b2085c3', 'authors': ['Nir Goren', 'Shai Yehezkel', 'Omer Dahary', 'Andrey Voynov', 'Or Patashnik', 'Daniel Cohen-Or'], 'affiliations': ['Google DeepMind', 'Tel Aviv University'], 'pdf_title_img': 'assets/pdf/title_img/2510.21697.jpg', 'data': {'categories': ['#cv', '#reasoning', '#multimodal', '#diffusion'], 'emoji': '🔷', 'ru': {'title': 'Геометрия через генерацию: диффузионные модели как решатели задач', 'desc': 'Исследователи показали, что визуальные диффузионные модели могут решать сложные геометрические задачи, работая напрямую с изображениями. Модель обучается преобразовывать шумные картинки в валидные геометрические решения, превращая геометрическое рассуждение в задачу генерации изображений. В отличие от предыдущих подходов, метод использует стандартные visual diffusion модели без специализированных архитектур. Подход был успешно применён к известным сложным задачам: проблеме вписанного квадрата, задаче Штейнера и проблеме простого многоугольника.'}, 'en': {'title': 'Transforming Noise into Geometry: A New Approach with Visual Diffusion Models', 'desc': 'This paper explores how visual diffusion models can effectively solve geometric problems by transforming noisy images into valid solutions. It demonstrates this capability through the Inscribed Square Problem, the Steiner Tree Problem, and the Simple Polygon Problem, treating each problem as an image. The model learns to convert Gaussian noise into images that represent approximate solutions, thereby framing geometric reasoning as a process of image generation. This approach simplifies the application of diffusion models to geometric tasks, suggesting a new paradigm for addressing complex geometric challenges using standard visual models.'}, 'zh': {'title': '视觉扩散模型：几何问题的新解法', 'desc': '本文展示了视觉扩散模型如何通过将噪声图像转化为有效解来解决几何问题。这种方法在像素空间中直接推理几何问题，首次应用于著名的内切正方形问题。我们的方法将每个问题实例视为图像，并训练标准的视觉扩散模型，将高斯噪声转化为接近精确解的有效近似解。我们的研究表明，图像空间的操作为近似解决复杂几何问题提供了一个通用且实用的框架。'}}}, {'id': 'https://huggingface.co/papers/2510.21652', 'title': 'AstaBench: Rigorous Benchmarking of AI Agents with a Scientific Research\n  Suite', 'url': 'https://huggingface.co/papers/2510.21652', 'abstract': 'AstaBench provides a comprehensive benchmark suite for evaluating AI agents in scientific research, revealing that while progress has been made, AI still falls short in fully assisting scientific research.  \t\t\t\t\tAI-generated summary \t\t\t\t AI agents hold the potential to revolutionize scientific productivity by automating literature reviews, replicating experiments, analyzing data, and even proposing new directions of inquiry; indeed, there are now many such agents, ranging from general-purpose "deep research" systems to specialized science-specific agents, such as AI Scientist and AIGS. Rigorous evaluation of these agents is critical for progress. Yet existing benchmarks fall short on several fronts: they (1) fail to provide holistic, product-informed measures of real-world use cases such as science research; (2) lack reproducible agent tools necessary for a controlled comparison of core agentic capabilities; (3) do not account for confounding variables such as model cost and tool access; (4) do not provide standardized interfaces for quick agent prototyping and evaluation; and (5) lack comprehensive baseline agents necessary to identify true advances. In response, we define principles and tooling for more rigorously benchmarking agents. Using these, we present AstaBench, a suite that provides the first holistic measure of agentic ability to perform scientific research, comprising 2400+ problems spanning the entire scientific discovery process and multiple scientific domains, and including many problems inspired by actual user requests to deployed Asta agents. Our suite comes with the first scientific research environment with production-grade search tools that enable controlled, reproducible evaluation, better accounting for confounders. Alongside, we provide a comprehensive suite of nine science-optimized classes of Asta agents and numerous baselines. Our extensive evaluation of 57 agents across 22 agent classes reveals several interesting findings, most importantly that despite meaningful progress on certain individual aspects, AI remains far from solving the challenge of science research assistance.', 'score': 1, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': 'e8b1cd801c13a100', 'authors': ['Jonathan Bragg', "Mike D'Arcy", 'Nishant Balepur', 'Dan Bareket', 'Bhavana Dalvi', 'Sergey Feldman', 'Dany Haddad', 'Jena D. Hwang', 'Peter Jansen', 'Varsha Kishore', 'Bodhisattwa Prasad Majumder', 'Aakanksha Naik', 'Sigal Rahamimov', 'Kyle Richardson', 'Amanpreet Singh', 'Harshit Surana', 'Aryeh Tiktinsky', 'Rosni Vasu', 'Guy Wiener', 'Chloe Anastasiades', 'Stefan Candra', 'Jason Dunkelberger', 'Dan Emery', 'Rob Evans', 'Malachi Hamada', 'Regan Huff', 'Rodney Kinney', 'Matt Latzke', 'Jaron Lochner', 'Ruben Lozano-Aguilera', 'Cecile Nguyen', 'Smita Rao', 'Amber Tanaka', 'Brooke Vlahos', 'Peter Clark', 'Doug Downey', 'Yoav Goldberg', 'Ashish Sabharwal', 'Daniel S. Weld'], 'affiliations': ['Allen Institute for AI', 'Bar-Ilan University', 'University of Arizona', 'University of Maryland', 'University of Washington', 'University of Zurich'], 'pdf_title_img': 'assets/pdf/title_img/2510.21652.jpg', 'data': {'categories': ['#benchmark', '#agents', '#science'], 'emoji': '🔬', 'ru': {'title': 'AI в науке: ещё не замена учёным', 'desc': 'AstaBench представляет собой набор тестов для оценки возможностей AI агентов в научных исследованиях. Он выявляет, что, несмотря на прогресс, AI пока не может полностью заменить учёных. AstaBench включает более 2400 задач, охватывающих весь процесс научного открытия. Это позволяет более точно оценивать способности AI в научной среде.'}, 'en': {'title': "AstaBench: Elevating AI's Role in Scientific Research Evaluation", 'desc': 'AstaBench is a new benchmark suite designed to evaluate AI agents specifically in the context of scientific research. It addresses the shortcomings of existing benchmarks by providing a comprehensive set of over 2400 problems that reflect real-world scientific tasks. The suite includes tools for reproducible evaluations and accounts for various confounding factors, ensuring a more accurate assessment of AI capabilities. Despite advancements in AI, the evaluation shows that these agents still struggle to fully assist in scientific research, highlighting the need for further development.'}, 'zh': {'title': 'AstaBench：科学研究中的 AI 代理评估新标准', 'desc': 'AstaBench 是一个全面的基准测试套件，用于评估 AI 代理在科学研究中的表现。尽管 AI 在某些方面取得了进展，但仍未能完全支持科学研究。该套件提供了2400多个问题，涵盖整个科学发现过程，并包括多个科学领域的问题。通过严格的评估，AstaBench 旨在为科学研究提供更有效的 AI 代理评估工具。'}}}, {'id': 'https://huggingface.co/papers/2510.21447', 'title': 'PhysWorld: From Real Videos to World Models of Deformable Objects via\n  Physics-Aware Demonstration Synthesis', 'url': 'https://huggingface.co/papers/2510.21447', 'abstract': 'PhysWorld uses a simulator to generate diverse demonstrations for training a GNN-based world model, enabling accurate and fast predictions for deformable objects with competitive performance and faster inference speeds.  \t\t\t\t\tAI-generated summary \t\t\t\t Interactive world models that simulate object dynamics are crucial for robotics, VR, and AR. However, it remains a significant challenge to learn physics-consistent dynamics models from limited real-world video data, especially for deformable objects with spatially-varying physical properties. To overcome the challenge of data scarcity, we propose PhysWorld, a novel framework that utilizes a simulator to synthesize physically plausible and diverse demonstrations to learn efficient world models. Specifically, we first construct a physics-consistent digital twin within MPM simulator via constitutive model selection and global-to-local optimization of physical properties. Subsequently, we apply part-aware perturbations to the physical properties and generate various motion patterns for the digital twin, synthesizing extensive and diverse demonstrations. Finally, using these demonstrations, we train a lightweight GNN-based world model that is embedded with physical properties. The real video can be used to further refine the physical properties. PhysWorld achieves accurate and fast future predictions for various deformable objects, and also generalizes well to novel interactions. Experiments show that PhysWorld has competitive performance while enabling inference speeds 47 times faster than the recent state-of-the-art method, i.e., PhysTwin.', 'score': 1, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': 'aee1bcbeeb33e55c', 'authors': ['Yu Yang', 'Zhilu Zhang', 'Xiang Zhang', 'Yihan Zeng', 'Hui Li', 'Wangmeng Zuo'], 'affiliations': ['Harbin Institute of Technology', 'Huawei Noahs Ark Lab'], 'pdf_title_img': 'assets/pdf/title_img/2510.21447.jpg', 'data': {'categories': ['#dataset', '#agents', '#robotics', '#synthetic', '#graphs', '#inference'], 'emoji': '🌊', 'ru': {'title': 'Физический мир: симуляция для обучения моделей деформируемых объектов', 'desc': 'PhysWorld — это framework для создания интерактивных world models, которые симулируют динамику деформируемых объектов. Система использует MPM-симулятор для генерации разнообразных демонстраций с физически правдоподобными свойствами материалов, которые затем используются для обучения легковесной GNN-модели. Подход решает проблему нехватки реальных видеоданных путём создания цифрового двойника объекта с последующей генерацией вариаций его физических свойств. В результате модель обеспечивает точные предсказания будущих состояний объектов со скоростью inference в 47 раз быстрее, чем state-of-the-art метод PhysTwin.'}, 'en': {'title': 'Revolutionizing Predictions for Deformable Objects with PhysWorld', 'desc': 'PhysWorld is a framework designed to improve the training of Graph Neural Network (GNN)-based world models for predicting the behavior of deformable objects. It addresses the challenge of limited real-world data by using a simulator to create diverse and physically plausible demonstrations. By constructing a digital twin and applying part-aware perturbations, PhysWorld generates a wide range of motion patterns that enhance the learning process. The resulting model not only achieves accurate predictions but also operates significantly faster than previous methods, making it highly effective for applications in robotics and virtual environments.'}, 'zh': {'title': 'PhysWorld：快速准确的可变形物体预测', 'desc': 'PhysWorld是一个新颖的框架，利用模拟器生成多样化的演示数据，以训练基于图神经网络的世界模型。该模型能够准确快速地预测可变形物体的动态，尤其是在数据稀缺的情况下。通过构建物理一致的数字双胞胎，并对物理属性进行局部优化，PhysWorld能够合成丰富的运动模式。实验表明，PhysWorld在性能上具有竞争力，并且推理速度比最新的PhysTwin方法快47倍。'}}}, {'id': 'https://huggingface.co/papers/2510.20535', 'title': 'ARC-Encoder: learning compressed text representations for large language\n  models', 'url': 'https://huggingface.co/papers/2510.20535', 'abstract': 'An ARC-Encoder compresses context into continuous representations for LLMs, improving inference efficiency and performance across various scenarios.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent techniques such as retrieval-augmented generation or chain-of-thought reasoning have led to longer contexts and increased inference costs. Context compression techniques can reduce these costs, but the most effective approaches require fine-tuning the target model or even modifying its architecture. This can degrade its general abilities when not used for this specific purpose. Here we explore an alternative approach: an encoder that compresses the context into continuous representations which replace token embeddings in decoder LLMs. First, we perform a systematic study of training strategies and architecture choices for the encoder. Our findings led to the design of an Adaptable text Representations Compressor, named ARC-Encoder, which outputs x-times fewer continuous representations (typically x!in!{4,8}) than text tokens. We evaluate ARC-Encoder across a variety of LLM usage scenarios, ranging from in-context learning to context window extension, on both instruct and base decoders. Results show that ARC-Encoder achieves state-of-the-art performance on several benchmarks while improving computational efficiency at inference. Finally, we demonstrate that our models can be adapted to multiple decoders simultaneously, allowing a single encoder to generalize across different decoder LLMs. This makes ARC-Encoder a flexible and efficient solution for portable encoders that work seamlessly with multiple LLMs. We release a training code at https://github.com/kyutai-labs/ARC-Encoder , fine-tuning dataset and pretrained models are available at https://huggingface.co/collections/kyutai/arc-encoders-68ee18787301407d60a57047 .', 'score': 1, 'issue_id': 6621, 'pub_date': '2025-10-23', 'pub_date_card': {'ru': '23 октября', 'en': 'October 23', 'zh': '10月23日'}, 'hash': '38daae856d0502b4', 'authors': ['Hippolyte Pilchen', 'Edouard Grave', 'Patrick Pérez'], 'affiliations': ['Kyutai, Paris, France'], 'pdf_title_img': 'assets/pdf/title_img/2510.20535.jpg', 'data': {'categories': ['#training', '#open_source', '#dataset', '#long_context', '#architecture', '#optimization', '#inference'], 'emoji': '🗜️', 'ru': {'title': 'Сжатие контекста без потери качества для эффективного inference', 'desc': 'Статья представляет ARC-Encoder — энкодер, который сжимает контекст в непрерывные представления для decoder LLM, уменьшая количество токенов в 4-8 раз. Это решение повышает эффективность inference без необходимости fine-tuning целевой модели или изменения её архитектуры, что сохраняет общие способности LLM. ARC-Encoder показывает state-of-the-art результаты в различных сценариях использования — от in-context learning до расширения контекстного окна. Ключевое преимущество — один энкодер может работать одновременно с несколькими разными decoder LLM, обеспечивая гибкость и портативность решения.'}, 'en': {'title': 'Efficient Context Compression for Enhanced LLM Performance', 'desc': 'The ARC-Encoder is a novel approach that compresses context into continuous representations for large language models (LLMs), enhancing both inference efficiency and performance. Unlike traditional methods that require fine-tuning or architectural changes, ARC-Encoder replaces token embeddings with fewer continuous representations, typically reducing the number of outputs by a factor of 4 to 8. This method has been systematically studied to optimize training strategies and architecture, resulting in state-of-the-art performance across various benchmarks. Additionally, ARC-Encoder is adaptable, allowing it to work with multiple decoder LLMs, making it a versatile solution for improving computational efficiency in diverse applications.'}, 'zh': {'title': 'ARC-Encoder：高效的上下文压缩解决方案', 'desc': 'ARC-Encoder是一种将上下文压缩为连续表示的编码器，旨在提高大语言模型（LLM）的推理效率和性能。与传统的上下文压缩技术不同，ARC-Encoder不需要对目标模型进行微调或架构修改，从而避免了对模型通用能力的影响。通过系统研究训练策略和架构选择，ARC-Encoder能够输出比文本标记少x倍的连续表示，显著提高计算效率。我们的实验表明，ARC-Encoder在多种使用场景下表现出色，能够灵活适应不同的解码器，成为一种高效的可移植编码器解决方案。'}}}, {'id': 'https://huggingface.co/papers/2510.21553', 'title': 'Document Understanding, Measurement, and Manipulation Using Category\n  Theory', 'url': 'https://huggingface.co/papers/2510.21553', 'abstract': 'Category theory is used to develop information-theoretic measures, summarization, and self-supervised improvement of large pretrained models through a mathematical framework of question-answer pairs and orthogonalization.  \t\t\t\t\tAI-generated summary \t\t\t\t We apply category theory to extract multimodal document structure which leads us to develop information theoretic measures, content summarization and extension, and self-supervised improvement of large pretrained models. We first develop a mathematical representation of a document as a category of question-answer pairs. Second, we develop an orthogonalization procedure to divide the information contained in one or more documents into non-overlapping pieces. The structures extracted in the first and second steps lead us to develop methods to measure and enumerate the information contained in a document. We also build on those steps to develop new summarization techniques, as well as to develop a solution to a new problem viz. exegesis resulting in an extension of the original document. Our question-answer pair methodology enables a novel rate distortion analysis of summarization techniques. We implement our techniques using large pretrained models, and we propose a multimodal extension of our overall mathematical framework. Finally, we develop a novel self-supervised method using RLVR to improve large pretrained models using consistency constraints such as composability and closure under certain operations that stem naturally from our category theoretic framework.', 'score': 0, 'issue_id': 6621, 'pub_date': '2025-10-24', 'pub_date_card': {'ru': '24 октября', 'en': 'October 24', 'zh': '10月24日'}, 'hash': 'aa27a9cf9e256732', 'pdf_title_img': 'img/title_stub.png', 'data': {'categories': ['#interpretability', '#training', '#rl', '#multimodal', '#survey', '#data', '#optimization', '#math'], 'emoji': '🔷', 'ru': {'title': 'Теория категорий для структурирования и улучшения больших языковых моделей', 'desc': 'Исследователи применили теорию категорий для анализа структуры документов через пары вопрос-ответ. Они разработали метод ортогонализации для разделения информации на непересекающиеся части и создали информационно-теоретические меры для оценки содержания документов. На основе этого подхода предложены новые методы суммаризации и расширения текстов, а также выполнен rate-distortion анализ. Авторы также представили self-supervised метод с использованием RLVR для улучшения LLM через ограничения согласованности, вытекающие из категорно-теоретического фреймворка.'}, 'en': {'title': 'Harnessing Category Theory for Enhanced Document Understanding and Model Improvement', 'desc': 'This paper uses category theory to create new ways to measure and summarize information in documents. It represents documents as categories of question-answer pairs, allowing for a structured analysis of their content. The authors introduce an orthogonalization method to separate information into distinct parts, which aids in developing effective summarization techniques. Additionally, they propose a self-supervised learning approach to enhance large pretrained models by applying consistency constraints derived from their mathematical framework.'}, 'zh': {'title': '利用范畴理论提升预训练模型的摘要与扩展能力', 'desc': '本文利用范畴理论来提取多模态文档结构，从而开发信息理论度量、内容摘要和扩展，以及大型预训练模型的自监督改进。我们首先将文档数学表示为问题-答案对的范畴。接着，我们开发了正交化程序，将一个或多个文档中的信息划分为不重叠的部分。这些结构的提取使我们能够测量和枚举文档中包含的信息，并提出新的摘要技术和文档扩展的解决方案。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (1)', '#agents (4)', '#agi (1)', '#alignment', '#architecture (3)', '#audio', '#benchmark (3)', '#cv (1)', '#data (1)', '#dataset (4)', '#diffusion (2)', '#ethics', '#games (1)', '#graphs (1)', '#hallucinations', '#healthcare', '#inference (2)', '#interpretability (1)', '#leakage', '#long_context (2)', '#low_resource', '#machine_translation', '#math (2)', '#multilingual', '#multimodal (2)', '#open_source (3)', '#optimization (5)', '#plp', '#rag', '#reasoning (4)', '#rl (3)', '#rlhf', '#robotics (1)', '#science (1)', '#security', '#small_models', '#story_generation', '#survey (1)', '#synthetic (2)', '#training (4)', '#transfer_learning', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-10-27 02:47',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-10-27 02:47')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-10-27 02:47')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    