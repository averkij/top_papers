
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 16 papers. November 1.</title>
    <link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #0989eacf;
            --secondary-color: #fff;
            --background-color: #f5f5f5;
            --text-color: #333333;
            --header-color: #0989eacf;
            --body-color: #f5f5f5;
            --menu-color: #002370;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2em;
            padding: 10px 0 20px 0;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.tags {
            color: #555;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .article-content {
            padding: 1.5em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
        }
        body.dark-theme>div>main>article {
            background-color: #444;
        }
        body.light-theme>div>main>article {
            background-color: #fff;
        }
        body.dark-theme>div>main>article:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
        }
        .pub-date {
            font-size: 0.9em;
            margin-bottom: 0.8em;
            font-weight: 300;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 1em;
            position: absolute;
            bottom: 10px;
            font-weight: 300;
            font-family: 'Roboto Slab';
        }
        .background-digit {
            position: absolute;
            bottom: -20px;
            right: -10px;
            font-size: 12em;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.03);
            z-index: 0;
            line-height: 1;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 80px;
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        a:hover {
            color: #e73838;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            padding: 1em 0;
            margin-top: 2em;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
        }
        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .update-info-container {
            flex: 1;
        }
        .sort-container {
            flex: 2;
        }
        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
                display: block;
                margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .category-toggle {
            display: inline-block;
            margin-bottom: 10px;
            margin-top: 15px;
            cursor: pointer;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 0px;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        body.light-theme>div>main>article.xbb45ca9d1b89342a { background: url("https://hfday.ru/img/20241028/bb45ca9d1b89342a.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.xbb45ca9d1b89342a:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.xbb45ca9d1b89342a { background: url("https://hfday.ru/img/20241028/bb45ca9d1b89342a.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.xbb45ca9d1b89342a:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.x6af756426d4b0064 { background: url("https://hfday.ru/img/20241031/6af756426d4b0064.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.x6af756426d4b0064:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.x6af756426d4b0064 { background: url("https://hfday.ru/img/20241031/6af756426d4b0064.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.x6af756426d4b0064:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.x22f1775d93baf7e1 { background: url("https://hfday.ru/img/20241029/22f1775d93baf7e1.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.x22f1775d93baf7e1:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.x22f1775d93baf7e1 { background: url("https://hfday.ru/img/20241029/22f1775d93baf7e1.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.x22f1775d93baf7e1:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.x2ba3bbe4b8a9836d { background: url("https://hfday.ru/img/20241031/2ba3bbe4b8a9836d.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.x2ba3bbe4b8a9836d:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.x2ba3bbe4b8a9836d { background: url("https://hfday.ru/img/20241031/2ba3bbe4b8a9836d.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.x2ba3bbe4b8a9836d:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.x6550f79d46b1945c { background: url("https://hfday.ru/img/20241031/6550f79d46b1945c.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.x6550f79d46b1945c:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.x6550f79d46b1945c { background: url("https://hfday.ru/img/20241031/6550f79d46b1945c.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.x6550f79d46b1945c:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.x7699f83913665aca { background: url("https://hfday.ru/img/20241031/7699f83913665aca.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.x7699f83913665aca:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.x7699f83913665aca { background: url("https://hfday.ru/img/20241031/7699f83913665aca.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.x7699f83913665aca:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.xcbb8d9bd8efa2823 { background: url("https://hfday.ru/img/20241029/cbb8d9bd8efa2823.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.xcbb8d9bd8efa2823:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.xcbb8d9bd8efa2823 { background: url("https://hfday.ru/img/20241029/cbb8d9bd8efa2823.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.xcbb8d9bd8efa2823:hover { background-color: rgba(60,60,60,0.92) !important;}
body.light-theme>div>main>article.x76a150925181ec52 { background: url("https://hfday.ru/img/20241031/76a150925181ec52.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: lighten !important; background-color: rgba(255,255,255,0.91) !important;}
body.light-theme>div>main>article.x76a150925181ec52:hover { background-color: rgba(255,255,255,0.95) !important;}
body.dark-theme>div>main>article.x76a150925181ec52 { background: url("https://hfday.ru/img/20241031/76a150925181ec52.jpg") !important; background-size: cover !important; background-position: center !important; background-blend-mode: hue !important; background-color: rgba(60,60,60,0.9) !important; }
body.dark-theme>div>main>article.x76a150925181ec52:hover { background-color: rgba(60,60,60,0.92) !important;}

        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .sort-container {
                margin-top: 0px;
                text-align: left;
                width: 100%;
            .sort-dropdown {
                float: right;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">1 ноября</span> | <span id="title-articles-count">16 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item" id="nav-prev"><a href="/d/2024-10-31.html">⬅️ <span id="prev-date">31.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-11-04.html">➡️ <span id="next-date">04.11</span></a></span>
            <!--<span class="nav-item" id="nav-weekly">Топ за неделю</span>
            <span class="nav-item" id="nav-weekly">Топ за месяц</span>-->
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="category-toggle">
            <div class="svg-container">
                <span id="category-toggle">🏷️ Фильтр</span>
                <svg height="3" width="200">
                    <line x1="0" y1="0" x2="200" y2="0" 
                        stroke="black" 
                        stroke-width="2" 
                        stroke-dasharray="3, 3" />
                </svg>
            </div>
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '1 ноября', 'en': 'November 1', 'zh': '11月1日'};
        let feedDateNext = {'ru': '04.11', 'en': '11/04', 'zh': '11月4日'};
        let feedDatePrev = {'ru': '31.10', 'en': '10/31', 'zh': '10月31日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'Статья от ', 'en': 'Published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2410.22366', 'title': 'Unpacking SDXL Turbo: Interpreting Text-to-Image Models with Sparse Autoencoders', 'url': 'https://huggingface.co/papers/2410.22366', 'abstract': "Sparse autoencoders (SAEs) have become a core ingredient in the reverse engineering of large-language models (LLMs). For LLMs, they have been shown to decompose intermediate representations that often are not interpretable directly into sparse sums of interpretable features, facilitating better control and subsequent analysis. However, similar analyses and approaches have been lacking for text-to-image models. We investigated the possibility of using SAEs to learn interpretable features for a few-step text-to-image diffusion models, such as SDXL Turbo. To this end, we train SAEs on the updates performed by transformer blocks within SDXL Turbo's denoising U-net. We find that their learned features are interpretable, causally influence the generation process, and reveal specialization among the blocks. In particular, we find one block that deals mainly with image composition, one that is mainly responsible for adding local details, and one for color, illumination, and style. Therefore, our work is an important first step towards better understanding the internals of generative text-to-image models like SDXL Turbo and showcases the potential of features learned by SAEs for the visual domain.   Code is available at https://github.com/surkovv/sdxl-unbox", 'score': 53, 'issue_id': 366, 'pub_date': '2024-10-28', 'pub_date_card': {'ru': '28 октября', 'en': 'October 28', 'zh': '10月28日'}, 'hash': 'bb45ca9d1b89342a', 'data': {'categories': ['#cv', '#interpretability', '#diffusion'], 'emoji': '🔍', 'ru': {'title': 'Раскрывая секреты SDXL Turbo: разреженные автоэнкодеры в действии', 'desc': 'Исследователи применили разреженные автоэнкодеры (SAE) для анализа внутренних представлений модели генерации изображений по тексту SDXL Turbo. Они обнаружили, что SAE способны выделять интерпретируемые признаки из промежуточных слоев модели. Анализ показал специализацию различных блоков модели на композиции изображения, локальных деталях и цвете/освещении. Это исследование открывает путь к лучшему пониманию и контролю генеративных моделей изображений.'}, 'en': {'title': 'Unlocking Interpretability in Text-to-Image Models with Sparse Autoencoders', 'desc': "This paper explores the use of Sparse Autoencoders (SAEs) to analyze and interpret the inner workings of text-to-image diffusion models, specifically SDXL Turbo. By training SAEs on the updates from transformer blocks in the model's denoising U-net, the authors demonstrate that these autoencoders can extract interpretable features that influence the image generation process. The study reveals that different transformer blocks specialize in various aspects of image creation, such as composition, local details, and color. This research marks a significant advancement in understanding generative models and highlights the utility of SAEs in the visual domain."}, 'zh': {'title': '稀疏自编码器助力文本到图像模型的理解', 'desc': '稀疏自编码器（SAEs）在大型语言模型（LLMs）的逆向工程中发挥了重要作用。本文探讨了将SAEs应用于文本到图像模型的可能性，特别是针对SDXL Turbo的几步扩散模型。我们发现，SAEs学习到的特征具有可解释性，并且对生成过程有因果影响，揭示了模型内部块之间的专业化。我们的研究为更好地理解生成文本到图像模型的内部机制迈出了重要的一步。'}}}, {'id': 'https://huggingface.co/papers/2410.23743', 'title': 'What Happened in LLMs Layers when Trained for Fast vs. Slow Thinking: A Gradient Perspective', 'url': 'https://huggingface.co/papers/2410.23743', 'abstract': 'What makes a difference in the post-training of LLMs? We investigate the training patterns of different layers in large language models (LLMs), through the lens of gradient, when training with different responses and initial models. We are specifically interested in how fast vs. slow thinking affects the layer-wise gradients, given the recent popularity of training LLMs on reasoning paths such as chain-of-thoughts (CoT) and process rewards. In our study, fast thinking without CoT leads to larger gradients and larger differences of gradients across layers than slow thinking (Detailed CoT), indicating the learning stability brought by the latter. Moreover, pre-trained LLMs are less affected by the instability of fast thinking than instruction-tuned LLMs. Additionally, we study whether the gradient patterns can reflect the correctness of responses when training different LLMs using slow vs. fast thinking paths. The results show that the gradients of slow thinking can distinguish correct and irrelevant reasoning paths. As a comparison, we conduct similar gradient analyses on non-reasoning knowledge learning tasks, on which, however, trivially increasing the response length does not lead to similar behaviors of slow thinking. Our study strengthens fundamental understandings of LLM training and sheds novel insights on its efficiency and stability, which pave the way towards building a generalizable System-2 agent. Our code, data, and gradient statistics can be found in: https://github.com/MingLiiii/Layer_Gradient.', 'score': 41, 'issue_id': 364, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '6af756426d4b0064', 'data': {'categories': ['#agents', '#reasoning'], 'emoji': '🧠', 'ru': {'title': 'Градиенты раскрывают тайны обучения языковых моделей', 'desc': 'Исследование анализирует паттерны обучения различных слоев больших языковых моделей (LLM) через призму градиентов. Авторы изучают влияние быстрого и медленного мышления на градиенты слоев, учитывая популярность обучения LLM на цепочках рассуждений (CoT) и процессных вознаграждениях. Результаты показывают, что медленное мышление с детальным CoT приводит к большей стабильности обучения по сравнению с быстрым мышлением. Исследование также выявляет различия в градиентных паттернах между предобученными и инструктированными LLM, а также между задачами рассуждения и обучения знаниям.'}, 'en': {'title': 'Unlocking Stability: The Power of Slow Thinking in LLM Training', 'desc': 'This paper explores how different training patterns in large language models (LLMs) affect their learning stability and efficiency. It focuses on the impact of fast versus slow thinking on layer-wise gradients during training, particularly when using reasoning techniques like chain-of-thoughts (CoT). The findings reveal that fast thinking generates larger gradients and more variability across layers, while slow thinking promotes stability and better distinguishes correct reasoning paths. Additionally, the study highlights that pre-trained LLMs are more resilient to the instability caused by fast thinking compared to instruction-tuned models.'}, 'zh': {'title': '快速与慢速思维对大语言模型训练的影响', 'desc': '本研究探讨了大语言模型（LLMs）在后训练阶段的不同层次的训练模式，特别关注快速思维与慢速思维对梯度的影响。研究发现，快速思维在没有链式思维（CoT）的情况下，会导致更大的梯度和层间梯度差异，而慢速思维则带来了更好的学习稳定性。预训练的LLMs对快速思维的不稳定性影响较小，而指令调优的LLMs则更为敏感。此外，慢速思维的梯度模式能够有效区分正确与无关的推理路径，增强了对LLM训练的基本理解。'}}}, {'id': 'https://huggingface.co/papers/2410.22476', 'title': 'A Pointer Network-based Approach for Joint Extraction and Detection of Multi-Label Multi-Class Intents', 'url': 'https://huggingface.co/papers/2410.22476', 'abstract': 'In task-oriented dialogue systems, intent detection is crucial for interpreting user queries and providing appropriate responses. Existing research primarily addresses simple queries with a single intent, lacking effective systems for handling complex queries with multiple intents and extracting different intent spans. Additionally, there is a notable absence of multilingual, multi-intent datasets. This study addresses three critical tasks: extracting multiple intent spans from queries, detecting multiple intents, and developing a multi-lingual multi-label intent dataset. We introduce a novel multi-label multi-class intent detection dataset (MLMCID-dataset) curated from existing benchmark datasets. We also propose a pointer network-based architecture (MLMCID) to extract intent spans and detect multiple intents with coarse and fine-grained labels in the form of sextuplets. Comprehensive analysis demonstrates the superiority of our pointer network-based system over baseline approaches in terms of accuracy and F1-score across various datasets.', 'score': 18, 'issue_id': 370, 'pub_date': '2024-10-29', 'pub_date_card': {'ru': '29 октября', 'en': 'October 29', 'zh': '10月29日'}, 'hash': '22f1775d93baf7e1', 'data': {'categories': ['#dataset', '#data', '#multilingual', '#architecture'], 'emoji': '🎯', 'ru': {'title': 'Точное определение множественных намерений в диалоговых системах', 'desc': 'Статья представляет новый подход к обнаружению намерений в диалоговых системах. Авторы предлагают архитектуру на основе указательной сети для извлечения нескольких намерений из запросов пользователей. Также создан новый многоязычный датасет для задачи многометочной классификации намерений. Эксперименты показывают превосходство предложенного метода над базовыми подходами по точности и F1-мере.'}, 'en': {'title': 'Enhancing Intent Detection for Complex Queries in Multilingual Dialogue Systems', 'desc': 'This paper focuses on improving task-oriented dialogue systems by enhancing intent detection, especially for complex queries that involve multiple intents. The authors identify a gap in existing research, which often only addresses simple queries, and they highlight the need for multilingual datasets that can handle multiple intents. To tackle this, they introduce the MLMCID-dataset, a new multi-label multi-class intent detection dataset, and a pointer network-based architecture designed to extract intent spans and detect multiple intents effectively. Their experiments show that this new approach outperforms traditional methods, achieving better accuracy and F1-scores across different datasets.'}, 'zh': {'title': '多意图检测的新突破', 'desc': '在任务导向对话系统中，意图检测对于理解用户查询和提供合适的响应至关重要。现有研究主要集中于处理单一意图的简单查询，缺乏有效的系统来处理复杂的多意图查询和提取不同的意图范围。此外，缺乏多语言和多意图的数据集。本研究提出了一个新的多标签多类意图检测数据集（MLMCID-dataset），并提出了一种基于指针网络的架构（MLMCID），能够提取意图范围并检测多种意图，分析结果显示该系统在准确性和F1分数上优于基线方法。'}}}, {'id': 'https://huggingface.co/papers/2410.23933', 'title': 'Language Models can Self-Lengthen to Generate Long Texts', 'url': 'https://huggingface.co/papers/2410.23933', 'abstract': 'Recent advancements in Large Language Models (LLMs) have significantly enhanced their ability to process long contexts, yet a notable gap remains in generating long, aligned outputs. This limitation stems from a training gap where pre-training lacks effective instructions for long-text generation, and post-training data primarily consists of short query-response pairs. Current approaches, such as instruction backtranslation and behavior imitation, face challenges including data quality, copyright issues, and constraints on proprietary model usage. In this paper, we introduce an innovative iterative training framework called Self-Lengthen that leverages only the intrinsic knowledge and skills of LLMs without the need for auxiliary data or proprietary models. The framework consists of two roles: the Generator and the Extender. The Generator produces the initial response, which is then split and expanded by the Extender. This process results in a new, longer response, which is used to train both the Generator and the Extender iteratively. Through this process, the models are progressively trained to handle increasingly longer responses. Experiments on benchmarks and human evaluations show that Self-Lengthen outperforms existing methods in long-text generation, when applied to top open-source LLMs such as Qwen2 and LLaMA3. Our code is publicly available at https://github.com/QwenLM/Self-Lengthen.', 'score': 14, 'issue_id': 363, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '2ba3bbe4b8a9836d', 'data': {'categories': ['#long_context', '#benchmark'], 'emoji': '📏', 'ru': {'title': 'Самоудлинение: революция в генерации длинных текстов для LLM', 'desc': 'Статья представляет новый метод обучения больших языковых моделей (LLM) для генерации длинных текстов, называемый Self-Lengthen. Этот подход использует итеративное обучение с двумя ролями: Генератор и Расширитель, которые работают вместе для создания и улучшения длинных ответов. Метод не требует дополнительных данных или проприетарных моделей, опираясь только на внутренние знания и навыки LLM. Эксперименты показывают, что Self-Lengthen превосходит существующие методы в генерации длинных текстов при применении к ведущим открытым LLM.'}, 'en': {'title': 'Empowering LLMs to Generate Longer, Coherent Texts with Self-Lengthen', 'desc': "This paper addresses the challenge of generating long, coherent outputs from Large Language Models (LLMs), which often struggle due to a lack of effective training for long-text generation. The authors propose a novel iterative training framework called Self-Lengthen, which utilizes the models' existing capabilities without relying on external data or proprietary models. The framework involves two components: a Generator that creates an initial response and an Extender that expands this response into a longer format. Through iterative training, the models improve their ability to generate longer, aligned outputs, demonstrating superior performance compared to existing methods in experiments and human evaluations."}, 'zh': {'title': '自我延长：提升长文本生成的创新框架', 'desc': '最近，大型语言模型（LLMs）的进步显著提升了处理长文本的能力，但在生成长且一致的输出方面仍存在不足。这一限制源于训练过程中的缺陷，预训练缺乏有效的长文本生成指令，而后期训练的数据主要是短问答对。本文提出了一种创新的迭代训练框架Self-Lengthen，利用LLMs的内在知识和技能，无需辅助数据或专有模型。该框架包括生成器和扩展器两个角色，通过生成初始响应并进行扩展，逐步训练模型以处理更长的响应。'}}}, {'id': 'https://huggingface.co/papers/2410.24175', 'title': 'Constraint Back-translation Improves Complex Instruction Following of Large Language Models', 'url': 'https://huggingface.co/papers/2410.24175', 'abstract': "Large language models (LLMs) struggle to follow instructions with complex constraints in format, length, etc. Following the conventional instruction-tuning practice, previous works conduct post-training on complex instruction-response pairs generated by feeding complex instructions to advanced LLMs. However, even advanced LLMs cannot follow complex instructions well, thus limiting the quality of generated data. In this work, we find that existing datasets inherently contain implicit complex constraints and propose a novel data generation technique, constraint back-translation. Specifically, we take the high-quality instruction-response pairs in existing datasets and only adopt advanced LLMs to add complex constraints already met by the responses to the instructions, which naturally reduces costs and data noise. In the experiments, we adopt Llama3-70B-Instruct to back-translate constraints and create a high-quality complex instruction-response dataset, named CRAB. We present that post-training on CRAB improves multiple backbone LLMs' complex instruction-following ability, evaluated on extensive instruction-following benchmarks. We further find that constraint back-translation also serves as a useful auxiliary training objective in post-training. Our code, data, and models will be released to facilitate future research.", 'score': 12, 'issue_id': 363, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '6550f79d46b1945c', 'data': {'categories': ['#dataset', '#data', '#benchmark'], 'emoji': '🦀', 'ru': {'title': 'Улучшение следования сложным инструкциям в LLM через обратный перевод ограничений', 'desc': "Эта статья представляет новый метод улучшения способности больших языковых моделей (LLM) следовать сложным инструкциям. Авторы предлагают технику 'обратного перевода ограничений', которая использует существующие наборы данных для генерации высококачественных пар инструкция-ответ со сложными ограничениями. Они создали набор данных CRAB, используя эту технику, и показали, что дообучение на нем улучшает способность LLM следовать сложным инструкциям. Исследователи также обнаружили, что обратный перевод ограничений может служить полезной вспомогательной целью обучения."}, 'en': {'title': 'Enhancing LLMs with Constraint Back-Translation for Complex Instructions', 'desc': 'This paper addresses the challenges that large language models (LLMs) face when following complex instructions. It critiques traditional instruction-tuning methods that rely on generating complex instruction-response pairs, which often leads to poor performance due to the limitations of LLMs. The authors introduce a new technique called constraint back-translation, which enhances existing high-quality instruction-response pairs by adding implicit complex constraints. Their experiments show that using this method to create a dataset, named CRAB, significantly improves the ability of various LLMs to follow complex instructions, demonstrating its effectiveness as a training strategy.'}, 'zh': {'title': '提升复杂指令跟随能力的新方法', 'desc': '大型语言模型（LLMs）在处理复杂指令时表现不佳，尤其是在格式和长度等约束方面。以往的研究通过对复杂指令-响应对进行后训练来改进模型，但效果有限。本文提出了一种新颖的数据生成技术，称为约束反向翻译，利用现有数据集中的高质量指令-响应对，添加已满足的复杂约束，从而提高数据质量。实验表明，在新生成的数据集CRAB上进行后训练，可以显著提升多个基础LLM在复杂指令跟随能力上的表现。'}}}, {'id': 'https://huggingface.co/papers/2410.23918', 'title': 'BitStack: Fine-Grained Size Control for Compressed Large Language Models in Variable Memory Environments', 'url': 'https://huggingface.co/papers/2410.23918', 'abstract': 'Large language models (LLMs) have revolutionized numerous applications, yet their deployment remains challenged by memory constraints on local devices. While scaling laws have enhanced LLM capabilities, the primary bottleneck has shifted from capability to availability, emphasizing the need for efficient memory management. Traditional compression methods, such as quantization, often require predefined compression ratios and separate compression processes for each setting, complicating deployment in variable memory environments. In this paper, we introduce BitStack, a novel, training-free weight compression approach that enables megabyte-level trade-offs between memory usage and model performance. By leveraging weight decomposition, BitStack can dynamically adjust the model size with minimal transmission between running memory and storage devices. Our approach iteratively decomposes weight matrices while considering the significance of each parameter, resulting in an approximately 1-bit per parameter residual block in each decomposition iteration. These blocks are sorted and stacked in storage as basic transmission units, with different quantities loaded based on current memory availability. Extensive experiments across a wide range of tasks demonstrate that, despite offering fine-grained size control, BitStack consistently matches or surpasses strong quantization baselines, particularly at extreme compression ratios. To the best of our knowledge, this is the first decomposition-based method that effectively bridges the gap to practical compression techniques like quantization. Code is available at https://github.com/xinghaow99/BitStack.', 'score': 11, 'issue_id': 371, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '7699f83913665aca', 'data': {'categories': ['#inference', '#edge_computing', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'BitStack: эффективное сжатие весов для гибкого развертывания языковых моделей', 'desc': 'В статье представлен новый метод сжатия весов моделей машинного обучения под названием BitStack. Этот подход позволяет динамически регулировать размер модели с минимальной передачей данных между оперативной памятью и устройствами хранения. BitStack использует декомпозицию весов, учитывая значимость каждого параметра, что приводит к созданию резидуальных блоков размером примерно 1 бит на параметр в каждой итерации декомпозиции. Эксперименты показывают, что BitStack соответствует или превосходит сильные базовые линии квантования, особенно при экстремальных коэффициентах сжатия.'}, 'en': {'title': 'Dynamic Memory Management for Large Language Models with BitStack', 'desc': 'This paper presents BitStack, a new method for compressing large language models (LLMs) without the need for prior training. It addresses the challenge of deploying LLMs on devices with limited memory by allowing dynamic adjustments to model size based on available memory. BitStack uses weight decomposition to create small, efficient blocks of model parameters, which can be easily transmitted and loaded as needed. The results show that BitStack not only provides fine control over memory usage but also performs as well or better than traditional quantization methods, especially under high compression scenarios.'}, 'zh': {'title': 'BitStack：高效的权重压缩方法', 'desc': '大型语言模型（LLMs）在许多应用中取得了革命性进展，但在本地设备上的部署仍面临内存限制的挑战。本文提出了一种名为BitStack的新方法，它是一种无训练的权重压缩技术，能够在内存使用和模型性能之间实现灵活的权衡。通过权重分解，BitStack可以动态调整模型大小，减少运行内存与存储设备之间的传输。实验表明，尽管提供了细粒度的大小控制，BitStack在极端压缩比下的性能仍然与强量化基线相当或更优。'}}}, {'id': 'https://huggingface.co/papers/2410.22394', 'title': "AAAR-1.0: Assessing AI's Potential to Assist Research", 'url': 'https://huggingface.co/papers/2410.22394', 'abstract': 'Numerous studies have assessed the proficiency of AI systems, particularly large language models (LLMs), in facilitating everyday tasks such as email writing, question answering, and creative content generation. However, researchers face unique challenges and opportunities in leveraging LLMs for their own work, such as brainstorming research ideas, designing experiments, and writing or reviewing papers. In this study, we introduce AAAR-1.0, a benchmark dataset designed to evaluate LLM performance in three fundamental, expertise-intensive research tasks: (i) EquationInference, assessing the correctness of equations based on the contextual information in paper submissions; (ii) ExperimentDesign, designing experiments to validate research ideas and solutions; (iii) PaperWeakness, identifying weaknesses in paper submissions; and (iv) REVIEWCRITIQUE, identifying each segment in human reviews is deficient or not. AAAR-1.0 differs from prior benchmarks in two key ways: first, it is explicitly research-oriented, with tasks requiring deep domain expertise; second, it is researcher-oriented, mirroring the primary activities that researchers engage in on a daily basis. An evaluation of both open-source and proprietary LLMs reveals their potential as well as limitations in conducting sophisticated research tasks. We will keep iterating AAAR-1.0 to new versions.', 'score': 10, 'issue_id': 379, 'pub_date': '2024-10-29', 'pub_date_card': {'ru': '29 октября', 'en': 'October 29', 'zh': '10月29日'}, 'hash': 'cbb8d9bd8efa2823', 'data': {'categories': ['#dataset', '#benchmark', '#rlhf'], 'emoji': '🔬', 'ru': {'title': 'AAAR-1.0: Новый рубеж в оценке ИИ для научных исследований', 'desc': 'Представлен новый бенчмарк AAAR-1.0 для оценки производительности больших языковых моделей (LLM) в исследовательских задачах. Он включает четыре задания: вывод уравнений, разработку экспериментов, выявление слабых мест в статьях и анализ рецензий. AAAR-1.0 отличается от существующих бенчмарков ориентацией на исследовательскую деятельность и необходимостью глубоких экспертных знаний. Оценка различных LLM на этом бенчмарке выявила их потенциал и ограничения в выполнении сложных исследовательских задач.'}, 'en': {'title': 'Empowering Researchers with AI: Introducing AAAR-1.0', 'desc': 'This paper presents AAAR-1.0, a new benchmark dataset aimed at evaluating the performance of large language models (LLMs) in research-related tasks. The dataset focuses on four key tasks: assessing equation correctness, designing experiments, identifying weaknesses in papers, and critiquing reviews. Unlike previous benchmarks, AAAR-1.0 is specifically tailored for research activities that require specialized knowledge. The study highlights both the capabilities and limitations of current LLMs in handling complex research tasks, with plans for future iterations of the benchmark.'}, 'zh': {'title': 'AAAR-1.0：提升研究效率的语言模型基准', 'desc': '本研究介绍了AAAR-1.0，这是一个用于评估大型语言模型（LLMs）在研究任务中的表现的基准数据集。该数据集专注于三个关键任务：方程推理、实验设计和论文弱点识别，旨在帮助研究人员更好地利用LLMs。与以往的基准不同，AAAR-1.0强调研究导向，要求深厚的领域专业知识。通过对开源和专有LLMs的评估，我们揭示了它们在复杂研究任务中的潜力和局限性。'}}}, {'id': 'https://huggingface.co/papers/2410.24198', 'title': 'SelfCodeAlign: Self-Alignment for Code Generation', 'url': 'https://huggingface.co/papers/2410.24198', 'abstract': "Instruction tuning is a supervised fine-tuning approach that significantly improves the ability of large language models (LLMs) to follow human instructions. We propose SelfCodeAlign, the first fully transparent and permissive pipeline for self-aligning code LLMs without extensive human annotations or distillation. SelfCodeAlign employs the same base model for inference throughout the data generation process. It first extracts diverse coding concepts from high-quality seed snippets to generate new tasks. It then samples multiple responses per task, pairs each with test cases, and validates them in a sandbox environment. Finally, passing examples are selected for instruction tuning. In our primary experiments, we use SelfCodeAlign with CodeQwen1.5-7B to generate a dataset of 74k instruction-response pairs. Finetuning on this dataset leads to a model that achieves a 67.1 pass@1 on HumanEval+, surpassing CodeLlama-70B-Instruct despite being ten times smaller. Across all benchmarks, this finetuned model consistently outperforms the original version trained with OctoPack, the previous state-of-the-art method for instruction tuning without human annotations or distillation. Additionally, we show that SelfCodeAlign is effective across LLMs of various sizes, from 3B to 33B, and that the base models can benefit more from alignment with their own data distribution. We further validate each component's effectiveness in our pipeline, showing that SelfCodeAlign outperforms both direct distillation from GPT-4o and leading GPT-3.5-based distillation methods, such as OSS-Instruct and Evol-Instruct. SelfCodeAlign has also led to the creation of StarCoder2-Instruct, the first fully transparent, permissively licensed, and self-aligned code LLM that achieves state-of-the-art coding performance.", 'score': 10, 'issue_id': 372, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '76a150925181ec52', 'data': {'categories': ['#training', '#dataset', '#architecture', '#plp'], 'emoji': '🤖', 'ru': {'title': 'SelfCodeAlign: самообучение ИИ-программиста без человеческих аннотаций', 'desc': 'SelfCodeAlign - это новый метод самонастройки языковых моделей для программирования без использования обширных человеческих аннотаций. Он генерирует разнообразные задачи программирования, создает и проверяет решения, а затем использует успешные примеры для дообучения модели. Эксперименты показывают, что SelfCodeAlign значительно улучшает производительность моделей разного размера в задачах программирования. Метод превосходит предыдущие подходы к инструктивной настройке без участия человека и дистилляции.'}, 'en': {'title': 'SelfCodeAlign: Revolutionizing Code LLMs with Minimal Human Input', 'desc': "This paper introduces SelfCodeAlign, a novel method for improving large language models (LLMs) specifically for coding tasks without needing extensive human input. The approach involves generating diverse coding tasks from high-quality code snippets and validating the model's responses in a controlled environment. By fine-tuning the model on a dataset of 74,000 instruction-response pairs, SelfCodeAlign significantly enhances the model's ability to follow instructions, achieving superior performance compared to larger models. The results demonstrate that this method is effective across various model sizes and establishes a new standard for self-aligned code LLMs."}, 'zh': {'title': '自我对齐，提升代码模型性能！', 'desc': '本论文提出了一种名为SelfCodeAlign的自我对齐代码大语言模型（LLM）的方法，旨在提高模型遵循人类指令的能力。该方法无需大量人工标注或蒸馏，利用相同的基础模型在数据生成过程中进行推理。SelfCodeAlign通过从高质量的种子代码片段中提取多样化的编码概念，生成新的任务，并在沙箱环境中验证每个任务的多个响应。实验结果表明，使用SelfCodeAlign生成的数据集进行微调后，模型在多个基准测试中表现优于之前的最先进方法。'}}}, {'id': 'https://huggingface.co/papers/2410.24213', 'title': 'Learning Video Representations without Natural Videos', 'url': 'https://huggingface.co/papers/2410.24213', 'abstract': 'In this paper, we show that useful video representations can be learned from synthetic videos and natural images, without incorporating natural videos in the training. We propose a progression of video datasets synthesized by simple generative processes, that model a growing set of natural video properties (e.g. motion, acceleration, and shape transformations). The downstream performance of video models pre-trained on these generated datasets gradually increases with the dataset progression. A VideoMAE model pre-trained on our synthetic videos closes 97.2% of the performance gap on UCF101 action classification between training from scratch and self-supervised pre-training from natural videos, and outperforms the pre-trained model on HMDB51. Introducing crops of static images to the pre-training stage results in similar performance to UCF101 pre-training and outperforms the UCF101 pre-trained model on 11 out of 14 out-of-distribution datasets of UCF101-P. Analyzing the low-level properties of the datasets, we identify correlations between frame diversity, frame similarity to natural data, and downstream performance. Our approach provides a more controllable and transparent alternative to video data curation processes for pre-training.', 'score': 9, 'issue_id': 362, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': 'a01960d8f855aede', 'data': {'categories': ['#dataset', '#video', '#synthetic'], 'emoji': '🎞️', 'ru': {'title': 'Синтетические видео для эффективного предобучения видеомоделей', 'desc': 'Исследователи показали, что полезные представления видео можно обучить на синтетических видео и естественных изображениях, без использования реальных видео. Они предложили последовательность синтетических видеонаборов данных, моделирующих различные свойства естественных видео. Модель VideoMAE, предобученная на этих синтетических данных, показала результаты, близкие к предобучению на реальных видео для задачи классификации действий. Анализ свойств наборов данных выявил корреляции между разнообразием кадров, их схожестью с естественными данными и эффективностью на целевых задачах.'}, 'en': {'title': 'Synthetic Videos: A New Path to Effective Video Representation Learning', 'desc': 'This paper demonstrates that effective video representations can be learned using synthetic videos and natural images, without needing natural videos for training. The authors introduce a series of progressively complex synthetic video datasets that capture essential characteristics of natural videos, such as motion and shape changes. They show that a VideoMAE model pre-trained on these synthetic datasets significantly narrows the performance gap compared to models trained on natural videos. Additionally, incorporating static image crops during pre-training enhances performance on various action classification tasks, suggesting a strong link between dataset properties and model effectiveness.'}, 'zh': {'title': '合成视频助力视频表示学习的突破', 'desc': '本文展示了如何从合成视频和自然图像中学习有用的视频表示，而无需在训练中使用自然视频。我们提出了一系列通过简单生成过程合成的视频数据集，这些数据集模拟了越来越多的自然视频特性，如运动、加速度和形状变换。通过在这些合成数据集上预训练的VideoMAE模型，在UCF101动作分类任务中，性能差距缩小了97.2%，并在HMDB51上表现优于预训练模型。我们的研究表明，数据集的帧多样性和与自然数据的相似性与下游性能之间存在相关性，为视频数据的预训练提供了更可控和透明的替代方案。'}}}, {'id': 'https://huggingface.co/papers/2410.21969', 'title': 'BenchX: A Unified Benchmark Framework for Medical Vision-Language Pretraining on Chest X-Rays', 'url': 'https://huggingface.co/papers/2410.21969', 'abstract': 'Medical Vision-Language Pretraining (MedVLP) shows promise in learning generalizable and transferable visual representations from paired and unpaired medical images and reports. MedVLP can provide useful features to downstream tasks and facilitate adapting task-specific models to new setups using fewer examples. However, existing MedVLP methods often differ in terms of datasets, preprocessing, and finetuning implementations. This pose great challenges in evaluating how well a MedVLP method generalizes to various clinically-relevant tasks due to the lack of unified, standardized, and comprehensive benchmark. To fill this gap, we propose BenchX, a unified benchmark framework that enables head-to-head comparison and systematical analysis between MedVLP methods using public chest X-ray datasets. Specifically, BenchX is composed of three components: 1) Comprehensive datasets covering nine datasets and four medical tasks; 2) Benchmark suites to standardize data preprocessing, train-test splits, and parameter selection; 3) Unified finetuning protocols that accommodate heterogeneous MedVLP methods for consistent task adaptation in classification, segmentation, and report generation, respectively. Utilizing BenchX, we establish baselines for nine state-of-the-art MedVLP methods and found that the performance of some early MedVLP methods can be enhanced to surpass more recent ones, prompting a revisiting of the developments and conclusions from prior works in MedVLP. Our code are available at https://github.com/yangzhou12/BenchX.', 'score': 7, 'issue_id': 362, 'pub_date': '2024-10-29', 'pub_date_card': {'ru': '29 октября', 'en': 'October 29', 'zh': '10月29日'}, 'hash': 'f3fe2798fa53bad0', 'data': {'categories': ['#dataset', '#benchmark', '#medicine'], 'emoji': '〰️', 'ru': {'title': 'Единый стандарт для оценки моделей анализа медицинских данных', 'desc': 'Статья представляет BenchX - унифицированную систему оценки методов предобучения моделей для анализа медицинских изображений и текстов (MedVLP). BenchX включает обширные наборы данных рентгеновских снимков грудной клетки, стандартизированные протоколы предобработки и разделения данных, а также унифицированные методы дообучения моделей. С помощью BenchX авторы провели сравнительный анализ девяти современных методов MedVLP, выявив неожиданные результаты и необходимость пересмотра некоторых выводов предыдущих исследований.'}, 'en': {'title': 'Standardizing Medical Vision-Language Pretraining Evaluation with BenchX', 'desc': 'The paper introduces MedVLP, a method for learning visual representations from medical images and reports, which can be applied to various medical tasks. It highlights the challenges in evaluating MedVLP methods due to inconsistencies in datasets and implementations. To address this, the authors propose BenchX, a benchmark framework that standardizes evaluation across multiple MedVLP methods using public chest X-ray datasets. BenchX includes comprehensive datasets, standardized preprocessing, and unified finetuning protocols, allowing for systematic comparisons and improved performance assessments of MedVLP techniques.'}, 'zh': {'title': '统一基准，提升医疗视觉语言预训练的比较与评估', 'desc': '本文提出了一个名为BenchX的统一基准框架，旨在评估医疗视觉语言预训练（MedVLP）方法的性能。BenchX包含三个主要组成部分：涵盖九个数据集和四个医疗任务的综合数据集、标准化的数据预处理和训练测试划分的基准套件，以及适应不同MedVLP方法的一致微调协议。通过使用BenchX，我们为九种最先进的MedVLP方法建立了基线，并发现一些早期的MedVLP方法的性能可以提升，超过更近期的方法。这一发现促使我们重新审视MedVLP领域的研究进展和结论。'}}}, {'id': 'https://huggingface.co/papers/2410.20650', 'title': 'NeuZip: Memory-Efficient Training and Inference with Dynamic Compression of Neural Networks', 'url': 'https://huggingface.co/papers/2410.20650', 'abstract': 'The performance of neural networks improves when more parameters are used. However, the model sizes are constrained by the available on-device memory during training and inference. Although applying techniques like quantization can alleviate the constraint, they suffer from performance degradation. In this work, we introduce NeuZip, a new weight compression scheme based on the entropy of floating-point numbers in neural networks. With NeuZip, we are able to achieve memory-efficient training and inference without sacrificing performance. Notably, we significantly reduce the memory footprint of training a Llama-3 8B model from 31GB to less than 16GB, while keeping the training dynamics fully unchanged. In inference, our method can reduce memory usage by more than half while maintaining near-lossless performance. Our code is publicly available.', 'score': 5, 'issue_id': 380, 'pub_date': '2024-10-28', 'pub_date_card': {'ru': '28 октября', 'en': 'October 28', 'zh': '10月28日'}, 'hash': '2878f8bac8da005d', 'data': {'categories': ['#inference', '#optimization'], 'emoji': '🗜️', 'ru': {'title': 'NeuZip: эффективное сжатие нейросетей без потери качества', 'desc': 'NeuZip - это новая схема сжатия весов нейронных сетей, основанная на энтропии чисел с плавающей запятой. Метод позволяет значительно уменьшить объем памяти, необходимой для обучения и вывода крупных моделей, без потери производительности. Например, NeuZip сокращает использование памяти при обучении модели Llama-3 8B с 31 ГБ до менее чем 16 ГБ. При выводе метод может уменьшить использование памяти более чем вдвое, сохраняя почти безупречную производительность.'}, 'en': {'title': 'NeuZip: Compressing Neural Networks Without Compromise', 'desc': 'This paper presents NeuZip, a novel weight compression technique designed for neural networks. NeuZip leverages the entropy of floating-point numbers to compress model weights, allowing for more efficient use of on-device memory during both training and inference. The method significantly reduces the memory requirements of large models, such as the Llama-3 8B, without compromising their performance. By implementing NeuZip, users can achieve a memory footprint reduction of over 50% while maintaining the integrity of the training dynamics and inference results.'}, 'zh': {'title': 'NeuZip：高效内存压缩，性能不打折！', 'desc': '本论文介绍了一种新的权重压缩方案，称为NeuZip，旨在提高神经网络的内存效率。通过利用浮点数的熵，NeuZip能够在不牺牲性能的情况下，显著减少模型的内存占用。具体来说，我们将Llama-3 8B模型的训练内存需求从31GB降低到16GB以下，同时保持训练动态不变。在推理阶段，我们的方法可以将内存使用减少一半以上，同时保持接近无损的性能。'}}}, {'id': 'https://huggingface.co/papers/2410.24032', 'title': 'Navigating the Unknown: A Chat-Based Collaborative Interface for Personalized Exploratory Tasks', 'url': 'https://huggingface.co/papers/2410.24032', 'abstract': "The rise of large language models (LLMs) has revolutionized user interactions with knowledge-based systems, enabling chatbots to synthesize vast amounts of information and assist with complex, exploratory tasks. However, LLM-based chatbots often struggle to provide personalized support, particularly when users start with vague queries or lack sufficient contextual information. This paper introduces the Collaborative Assistant for Personalized Exploration (CARE), a system designed to enhance personalization in exploratory tasks by combining a multi-agent LLM framework with a structured user interface. CARE's interface consists of a Chat Panel, Solution Panel, and Needs Panel, enabling iterative query refinement and dynamic solution generation. The multi-agent framework collaborates to identify both explicit and implicit user needs, delivering tailored, actionable solutions. In a within-subject user study with 22 participants, CARE was consistently preferred over a baseline LLM chatbot, with users praising its ability to reduce cognitive load, inspire creativity, and provide more tailored solutions. Our findings highlight CARE's potential to transform LLM-based systems from passive information retrievers to proactive partners in personalized problem-solving and exploration.", 'score': 5, 'issue_id': 368, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': 'b4fbb07af8c8665c', 'data': {'categories': ['#agents', '#multimodal', '#interpretability'], 'emoji': '🤝', 'ru': {'title': 'CARE: Персонализированный ИИ-помощник для исследовательских задач', 'desc': 'Статья представляет систему CARE (Collaborative Assistant for Personalized Exploration), которая улучшает персонализацию в исследовательских задачах, сочетая мультиагентную архитектуру на основе больших языковых моделей (LLM) со структурированным пользовательским интерфейсом. CARE состоит из панелей чата, решений и потребностей, что позволяет итеративно уточнять запросы и динамически генерировать решения. Система использует коллаборативный подход для выявления явных и неявных потребностей пользователя, предоставляя индивидуальные, действенные решения. Пользовательское исследование показало, что CARE предпочтительнее базового чат-бота на основе LLM, снижая когнитивную нагрузку и стимулируя креативность.'}, 'en': {'title': 'Transforming LLMs into Proactive Personal Assistants', 'desc': 'This paper presents the Collaborative Assistant for Personalized Exploration (CARE), a system that improves how users interact with large language models (LLMs) during exploratory tasks. CARE uses a multi-agent framework that works together to understand both the explicit and implicit needs of users, allowing for more personalized assistance. The system features a structured user interface with different panels that help users refine their queries and generate solutions dynamically. A user study showed that participants preferred CARE over traditional LLM chatbots, noting its effectiveness in reducing cognitive load and providing tailored support.'}, 'zh': {'title': '个性化探索的协作助手CARE', 'desc': '这篇论文介绍了一种名为CARE的系统，旨在提高大型语言模型（LLM）在探索性任务中的个性化支持。CARE结合了多代理LLM框架和结构化用户界面，帮助用户在模糊查询时更好地获取信息。系统的界面包括聊天面板、解决方案面板和需求面板，支持用户迭代优化查询和动态生成解决方案。研究表明，CARE在用户体验上优于传统的LLM聊天机器人，能够减轻认知负担，激发创造力，并提供更具针对性的解决方案。'}}}, {'id': 'https://huggingface.co/papers/2410.24211', 'title': 'DELTA: Dense Efficient Long-range 3D Tracking for any video', 'url': 'https://huggingface.co/papers/2410.24211', 'abstract': 'Tracking dense 3D motion from monocular videos remains challenging, particularly when aiming for pixel-level precision over long sequences. We introduce \\Approach, a novel method that efficiently tracks every pixel in 3D space, enabling accurate motion estimation across entire videos. Our approach leverages a joint global-local attention mechanism for reduced-resolution tracking, followed by a transformer-based upsampler to achieve high-resolution predictions. Unlike existing methods, which are limited by computational inefficiency or sparse tracking, \\Approach delivers dense 3D tracking at scale, running over 8x faster than previous methods while achieving state-of-the-art accuracy. Furthermore, we explore the impact of depth representation on tracking performance and identify log-depth as the optimal choice. Extensive experiments demonstrate the superiority of \\Approach on multiple benchmarks, achieving new state-of-the-art results in both 2D and 3D dense tracking tasks. Our method provides a robust solution for applications requiring fine-grained, long-term motion tracking in 3D space.', 'score': 4, 'issue_id': 368, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': 'e9fe68be8b772de2', 'data': {'categories': ['#3d', '#cv', '#benchmark'], 'emoji': '🎥', 'ru': {'title': 'Революция в плотном 3D-трекинге: быстро, точно, масштабируемо', 'desc': 'Статья представляет новый метод для точного отслеживания движения каждого пикселя в 3D-пространстве на протяжении длинных видеопоследовательностей. Авторы используют механизм совместного глобально-локального внимания для отслеживания на пониженном разрешении, а затем применяют трансформер для повышения разрешения предсказаний. Метод работает в 8 раз быстрее предыдущих подходов, достигая при этом наилучшей точности. Эксперименты показывают превосходство предложенного метода на нескольких эталонных наборах данных для задач плотного отслеживания в 2D и 3D.'}, 'en': {'title': 'Efficient Dense 3D Motion Tracking with State-of-the-Art Precision', 'desc': 'This paper presents a new method called \\Approach for tracking dense 3D motion from monocular videos with high precision. It utilizes a joint global-local attention mechanism to perform efficient tracking at reduced resolution, followed by a transformer-based upsampler to enhance the predictions to high resolution. The method significantly improves computational efficiency, running over 8 times faster than previous techniques while achieving state-of-the-art accuracy in both 2D and 3D tracking tasks. Additionally, the study identifies log-depth as the best depth representation for enhancing tracking performance.'}, 'zh': {'title': '高效稠密三维运动追踪的新方法', 'desc': '本论文介绍了一种新方法\textit{Approach}，用于从单目视频中高效追踪每个像素的三维运动。该方法结合了全局和局部注意力机制，先进行低分辨率追踪，然后使用基于变换器的上采样器实现高分辨率预测。与现有方法相比，\textit{Approach}在计算效率和稠密追踪方面表现出色，速度比之前的方法快8倍，同时保持了最先进的准确性。通过广泛的实验，我们证明了\textit{Approach}在多个基准测试中的优越性，提供了在三维空间中进行精细、长期运动追踪的强大解决方案。'}}}, {'id': 'https://huggingface.co/papers/2410.24218', 'title': 'Teaching Embodied Reinforcement Learning Agents: Informativeness and Diversity of Language Use', 'url': 'https://huggingface.co/papers/2410.24218', 'abstract': "In real-world scenarios, it is desirable for embodied agents to have the ability to leverage human language to gain explicit or implicit knowledge for learning tasks. Despite recent progress, most previous approaches adopt simple low-level instructions as language inputs, which may not reflect natural human communication. It's not clear how to incorporate rich language use to facilitate task learning. To address this question, this paper studies different types of language inputs in facilitating reinforcement learning (RL) embodied agents. More specifically, we examine how different levels of language informativeness (i.e., feedback on past behaviors and future guidance) and diversity (i.e., variation of language expressions) impact agent learning and inference. Our empirical results based on four RL benchmarks demonstrate that agents trained with diverse and informative language feedback can achieve enhanced generalization and fast adaptation to new tasks. These findings highlight the pivotal role of language use in teaching embodied agents new tasks in an open world. Project website: https://github.com/sled-group/Teachable_RL", 'score': 3, 'issue_id': 375, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '3f784be6816fb87a', 'data': {'categories': ['#rl', '#rlhf', '#agents'], 'emoji': '🤖', 'ru': {'title': 'Язык как ключ к обучению ИИ-агентов в реальном мире', 'desc': 'Статья исследует влияние различных типов языковых входных данных на обучение агентов с подкреплением в воплощенных средах. Авторы изучают, как информативность и разнообразие языка влияют на обучение и вывод агентов. Эксперименты на четырех эталонных задачах показывают, что агенты, обученные с разнообразной и информативной языковой обратной связью, достигают лучшей обобщаемости и быстрой адаптации к новым задачам. Результаты подчеркивают ключевую роль использования естественного языка в обучении воплощенных агентов новым задачам.'}, 'en': {'title': 'Empowering Agents with Rich Language for Smarter Learning', 'desc': 'This paper explores how embodied agents can use human language to improve their learning in real-world tasks. It focuses on the impact of different types of language inputs, specifically looking at how informative and diverse language can enhance reinforcement learning (RL) processes. The study shows that agents receiving varied and detailed language feedback perform better in adapting to new tasks and generalizing their knowledge. These findings emphasize the importance of natural language communication in training intelligent agents to operate effectively in dynamic environments.'}, 'zh': {'title': '语言助力智能体学习新任务', 'desc': '本论文研究了如何利用人类语言来帮助具身智能体学习任务。我们探讨了不同类型的语言输入对强化学习（RL）智能体的影响，特别是语言信息量和多样性如何影响学习效果。实验证明，使用多样且信息丰富的语言反馈训练的智能体，能够更好地适应新任务并提高泛化能力。这些发现强调了语言在教导具身智能体新任务中的重要性。'}}}, {'id': 'https://huggingface.co/papers/2410.23825', 'title': 'GlotCC: An Open Broad-Coverage CommonCrawl Corpus and Pipeline for Minority Languages', 'url': 'https://huggingface.co/papers/2410.23825', 'abstract': 'The need for large text corpora has increased with the advent of pretrained language models and, in particular, the discovery of scaling laws for these models. Most available corpora have sufficient data only for languages with large dominant communities. However, there is no corpus available that (i) covers a wide range of minority languages; (ii) is generated by an open-source reproducible pipeline; and (iii) is rigorously cleaned from noise, making it trustworthy to use. We present GlotCC, a clean, document-level, 2TB general domain corpus derived from CommonCrawl, covering more than 1000 languages. We make GlotCC and the system used to generate it - including the pipeline, language identification model, and filters - available to the research community. Corpus v. 1.0 https://huggingface.co/datasets/cis-lmu/GlotCC-v1, Pipeline v. 3.0 https://github.com/cisnlp/GlotCC.', 'score': 2, 'issue_id': 375, 'pub_date': '2024-10-31', 'pub_date_card': {'ru': '31 октября', 'en': 'October 31', 'zh': '10月31日'}, 'hash': '7d1bf1bef5a430e0', 'data': {'categories': ['#dataset', '#data', '#multilingual'], 'emoji': '🌐', 'ru': {'title': 'GlotCC: Многоязычный корпус для обучения языковых моделей', 'desc': 'Статья представляет GlotCC - чистый корпус текстов объемом 2 ТБ, охватывающий более 1000 языков, включая миноритарные. Корпус создан на основе CommonCrawl с использованием воспроизводимого открытого конвейера обработки данных. GlotCC тщательно очищен от шума, что делает его надежным для использования в обучении языковых моделей. Авторы предоставляют доступ к корпусу и системе его создания для исследовательского сообщества.'}, 'en': {'title': 'Empowering Minority Languages with GlotCC: A Clean, Large-Scale Corpus', 'desc': 'This paper introduces GlotCC, a large and clean text corpus designed for minority languages, addressing the gap in available data for these languages in the context of pretrained language models. The corpus is derived from CommonCrawl and spans over 2TB, covering more than 1000 languages, making it a valuable resource for researchers. The authors emphasize the importance of having a reproducible and open-source pipeline for generating such corpora, which includes a language identification model and noise filters. By providing GlotCC and its generation system to the research community, the authors aim to enhance the development of language models for underrepresented languages.'}, 'zh': {'title': 'GlotCC：多语言研究的新资源', 'desc': '随着预训练语言模型的发展，对大规模文本语料库的需求不断增加。现有的语料库主要集中在大型语言社区，缺乏覆盖广泛少数语言的资源。我们提出了GlotCC，这是一个干净的、文档级的2TB通用语料库，来源于CommonCrawl，涵盖了1000多种语言。我们将GlotCC及其生成系统（包括管道、语言识别模型和过滤器）提供给研究社区，以促进多语言研究。'}}}, {'id': 'https://huggingface.co/papers/2410.21666', 'title': 'Minimum Entropy Coupling with Bottleneck', 'url': 'https://huggingface.co/papers/2410.21666', 'abstract': 'This paper investigates a novel lossy compression framework operating under logarithmic loss, designed to handle situations where the reconstruction distribution diverges from the source distribution. This framework is especially relevant for applications that require joint compression and retrieval, and in scenarios involving distributional shifts due to processing. We show that the proposed formulation extends the classical minimum entropy coupling framework by integrating a bottleneck, allowing for a controlled degree of stochasticity in the coupling. We explore the decomposition of the Minimum Entropy Coupling with Bottleneck (MEC-B) into two distinct optimization problems: Entropy-Bounded Information Maximization (EBIM) for the encoder, and Minimum Entropy Coupling (MEC) for the decoder. Through extensive analysis, we provide a greedy algorithm for EBIM with guaranteed performance, and characterize the optimal solution near functional mappings, yielding significant theoretical insights into the structural complexity of this problem. Furthermore, we illustrate the practical application of MEC-B through experiments in Markov Coding Games (MCGs) under rate limits. These games simulate a communication scenario within a Markov Decision Process, where an agent must transmit a compressed message from a sender to a receiver through its actions. Our experiments highlight the trade-offs between MDP rewards and receiver accuracy across various compression rates, showcasing the efficacy of our method compared to conventional compression baseline.', 'score': 0, 'issue_id': 379, 'pub_date': '2024-10-29', 'pub_date_card': {'ru': '29 октября', 'en': 'October 29', 'zh': '10月29日'}, 'hash': '9e1b09f8eff55094', 'data': {'categories': ['#math', '#optimization', '#agents', '#rl'], 'emoji': '🗜️', 'ru': {'title': 'Сжатие данных с контролируемыми потерями для задач с изменением распределения', 'desc': "Статья представляет новую систему сжатия с потерями, работающую в условиях логарифмических потерь, когда распределение реконструкции отличается от исходного распределения. Это расширение классической задачи минимального энтропийного связывания, включающее 'бутылочное горлышко' для контроля стохастичности. Авторы разделяют задачу на две оптимизационные подзадачи: максимизацию информации с ограничением энтропии (EBIM) для кодировщика и минимальное энтропийное связывание (MEC) для декодера. Практическое применение метода демонстрируется на примере марковских игр кодирования (MCG) с ограничениями скорости передачи данных."}, 'en': {'title': 'Revolutionizing Compression with Controlled Stochasticity', 'desc': 'This paper presents a new lossy compression framework that uses logarithmic loss to effectively manage cases where the output distribution differs from the original input distribution. It is particularly useful for tasks that involve both compression and retrieval, especially when there are changes in the data distribution. The authors enhance the traditional minimum entropy coupling method by adding a bottleneck, which allows for a controlled level of randomness in the data coupling process. They break down the new framework, called Minimum Entropy Coupling with Bottleneck (MEC-B), into two optimization tasks: one for maximizing information during encoding and another for minimizing entropy during decoding, providing a greedy algorithm with proven performance.'}, 'zh': {'title': '新型有损压缩框架：控制随机性的最小熵耦合', 'desc': '本文研究了一种新颖的有损压缩框架，该框架在对数损失下运行，旨在处理重建分布与源分布不一致的情况。该框架特别适用于需要联合压缩和检索的应用，以及由于处理导致的分布变化场景。我们展示了所提出的公式如何通过集成瓶颈扩展经典的最小熵耦合框架，从而在耦合中允许控制的随机性程度。通过对最小熵耦合与瓶颈（MEC-B）的分解，我们提出了编码器的熵约束信息最大化（EBIM）和解码器的最小熵耦合（MEC）两个优化问题，并提供了保证性能的贪婪算法。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            const themeToggle = document.getElementById('theme-toggle');
            let settingSortBy = localStorage.getItem('sort_by');
            const sortDropdown = document.getElementById('sort-dropdown');
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }
            
            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (1)', '#agents (4)', '#agi', '#alignment', '#architecture (2)', '#audio', '#benchmark (5)', '#cv (2)', '#data (3)', '#dataset (7)', '#diffusion (1)', '#edge_computing (1)', '#ethics', '#games', '#graphs', '#hallucinations', '#inference (2)', '#interpretability (2)', '#long_context (1)', '#math (1)', '#medicine (1)', '#multilingual (2)', '#multimodal (1)', '#optimization (3)', '#plp (1)', '#rag', '#reasoning (1)', '#rl (2)', '#rlhf (2)', '#robotics', '#security', '#story_generation', '#survey', '#synthetic (1)', '#training (1)', '#transfer_learning', '#translation', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles = selectedCategories.length === 0
                ? articlesData
                : articlesData.filter(article => 
                    article.data && article.data.categories && 
                    article.data.categories.some(cat => selectedCategories.includes(cat))
                );

            console.log('filteredArticles', filteredArticles)

            //if (filteredArticles.length === 0) {
            //    selectedArticles = articlesData;
            //    selectedCategories = [];
            //    cleanCategorySelection();
            //} else {
            //    selectedArticles = filteredArticles;
            //}

            selectedArticles = filteredArticles;

            console.log('selectedArticles', selectedArticles)

            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].join(" ");
                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="background-digit">${index + 1}</div>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <h2>${item['data']['emoji']} ${item['title']}</h2>
                            <p class="meta"><svg class="text-sm peer-checked:text-gray-500 group-hover:text-gray-500" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 12 12"><path transform="translate(0, 2)" fill="currentColor" d="M5.19 2.67a.94.94 0 0 1 1.62 0l3.31 5.72a.94.94 0 0 1-.82 1.4H2.7a.94.94 0 0 1-.82-1.4l3.31-5.7v-.02Z"></path></svg> ${item['score']}. ${title}</p>
                            <p class="pub-date">📝 ${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>
                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>
                            <p class="tags">${cats}</p>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            }
            if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
        });

        clearCategoriesButton.addEventListener('click', clearAllCategories);
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-11-02 20:13',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];       
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink() {
            if (isToday('2024-11-02 20:13')) {
                const element = document.getElementById('nav-next');
                if (element) {    
                    element.style.display = 'none';
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink(); 
        initializeLanguageFlags();
        updateLocalization();
    </script>
</body>
</html>
    