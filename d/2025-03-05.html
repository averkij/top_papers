
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 16 papers. March 5.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">5 марта</span> | <span id="title-articles-count">16 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-03-04.html">⬅️ <span id="prev-date">04.03</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-03-06.html">➡️ <span id="next-date">06.03</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-03.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '5 марта', 'en': 'March 5', 'zh': '3月5日'};
        let feedDateNext = {'ru': '06.03', 'en': '03/06', 'zh': '3月6日'};
        let feedDatePrev = {'ru': '04.03', 'en': '03/04', 'zh': '3月4日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2503.02682', 'title': 'MPO: Boosting LLM Agents with Meta Plan Optimization', 'url': 'https://huggingface.co/papers/2503.02682', 'abstract': "Recent advancements in large language models (LLMs) have enabled LLM-based agents to successfully tackle interactive planning tasks. However, despite their successes, existing approaches often suffer from planning hallucinations and require retraining for each new agent. To address these challenges, we propose the Meta Plan Optimization (MPO) framework, which enhances agent planning capabilities by directly incorporating explicit guidance. Unlike previous methods that rely on complex knowledge, which either require significant human effort or lack quality assurance, MPO leverages high-level general guidance through meta plans to assist agent planning and enables continuous optimization of the meta plans based on feedback from the agent's task execution. Our experiments conducted on two representative tasks demonstrate that MPO significantly outperforms existing baselines. Moreover, our analysis indicates that MPO provides a plug-and-play solution that enhances both task completion efficiency and generalization capabilities in previous unseen scenarios.", 'score': 12, 'issue_id': 2535, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': 'e5fa3c849c1eee72', 'authors': ['Weimin Xiong', 'Yifan Song', 'Qingxiu Dong', 'Bingchan Zhao', 'Feifan Song', 'Xun Wang', 'Sujian Li'], 'affiliations': ['National Key Laboratory for Multimedia Information Processing, School of Computer Science, Peking University', 'Peking University', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2503.02682.jpg', 'data': {'categories': ['#rl', '#training', '#optimization', '#hallucinations', '#agents'], 'emoji': '🧠', 'ru': {'title': 'Метапланы для умных агентов: эффективнее, универсальнее, без галлюцинаций', 'desc': 'Статья представляет новый подход к улучшению планирования задач агентами на основе больших языковых моделей (LLM). Метод под названием Meta Plan Optimization (MPO) использует высокоуровневые метапланы для руководства агентом и оптимизирует их на основе обратной связи. MPO превосходит существующие методы в эффективности выполнения задач и способности к обобщению. Этот подход не требует переобучения для каждого нового агента и решает проблему галлюцинаций при планировании.'}, 'en': {'title': 'Enhancing Agent Planning with Meta Plans', 'desc': "This paper introduces the Meta Plan Optimization (MPO) framework to improve the planning abilities of large language model (LLM)-based agents. MPO addresses issues like planning hallucinations and the need for retraining by using high-level meta plans for guidance. This approach allows for continuous optimization based on feedback from the agent's performance in tasks. Experimental results show that MPO not only outperforms existing methods but also enhances efficiency and adaptability in new situations."}, 'zh': {'title': '元规划优化：提升智能体规划能力的创新框架', 'desc': '最近，大型语言模型（LLMs）的进步使得基于LLM的智能体能够成功处理交互式规划任务。然而，现有方法常常面临规划幻觉的问题，并且每个新智能体都需要重新训练。为了解决这些挑战，我们提出了元规划优化（MPO）框架，通过直接引入明确的指导来增强智能体的规划能力。我们的实验表明，MPO在任务完成效率和在未见场景中的泛化能力上显著优于现有基线。'}}}, {'id': 'https://huggingface.co/papers/2503.02846', 'title': 'Mask-DPO: Generalizable Fine-grained Factuality Alignment of LLMs', 'url': 'https://huggingface.co/papers/2503.02846', 'abstract': 'Large language models (LLMs) exhibit hallucinations (i.e., unfaithful or nonsensical information) when serving as AI assistants in various domains. Since hallucinations always come with truthful content in the LLM responses, previous factuality alignment methods that conduct response-level preference learning inevitably introduced noises during training. Therefore, this paper proposes a fine-grained factuality alignment method based on Direct Preference Optimization (DPO), called Mask-DPO. Incorporating sentence-level factuality as mask signals, Mask-DPO only learns from factually correct sentences in the preferred samples and prevents the penalty on factual contents in the not preferred samples, which resolves the ambiguity in the preference learning. Extensive experimental results demonstrate that Mask-DPO can significantly improve the factuality of LLMs responses to questions from both in-domain and out-of-domain datasets, although these questions and their corresponding topics are unseen during training. Only trained on the ANAH train set, the score of Llama3.1-8B-Instruct on the ANAH test set is improved from 49.19% to 77.53%, even surpassing the score of Llama3.1-70B-Instruct (53.44%), while its FactScore on the out-of-domain Biography dataset is also improved from 30.29% to 39.39%. We further study the generalization property of Mask-DPO using different training sample scaling strategies and find that scaling the number of topics in the dataset is more effective than the number of questions. We provide a hypothesis of what factual alignment is doing with LLMs, on the implication of this phenomenon, and conduct proof-of-concept experiments to verify it. We hope the method and the findings pave the way for future research on scaling factuality alignment.', 'score': 11, 'issue_id': 2535, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': '7e9277cf8ca5bb98', 'authors': ['Yuzhe Gu', 'Wenwei Zhang', 'Chengqi Lyu', 'Dahua Lin', 'Kai Chen'], 'affiliations': ['MMLab, The Chinese University of Hong Kong', 'Shanghai AI Laboratory', 'Shanghai Jiao Tong University'], 'pdf_title_img': 'assets/pdf/title_img/2503.02846.jpg', 'data': {'categories': ['#hallucinations', '#training', '#rlhf', '#alignment'], 'emoji': '🎭', 'ru': {'title': 'Mask-DPO: точная настройка фактов в ответах языковых моделей', 'desc': 'Эта статья представляет метод Mask-DPO для улучшения фактической точности больших языковых моделей (LLM). Метод основан на оптимизации прямых предпочтений (DPO) и использует маскирование на уровне предложений для обучения только на фактически верных частях ответов. Экспериментальные результаты показывают значительное улучшение фактической точности как на знакомых, так и на новых данных. Исследование также выявило, что масштабирование количества тем в обучающем наборе более эффективно, чем увеличение числа вопросов.'}, 'en': {'title': 'Enhancing Factuality in LLMs with Mask-DPO', 'desc': 'This paper addresses the issue of hallucinations in large language models (LLMs), where they generate incorrect or nonsensical information despite including some accurate content. The authors introduce a new method called Mask-DPO, which focuses on fine-grained factuality alignment by using sentence-level factuality as mask signals. This approach allows the model to learn only from factually correct sentences in preferred samples, reducing noise during training and improving the overall factual accuracy of LLM responses. Experimental results show that Mask-DPO significantly enhances the factuality of LLMs, even on unseen questions and topics, outperforming larger models in certain tests.'}, 'zh': {'title': '提升大型语言模型的事实性对齐', 'desc': '大型语言模型（LLMs）在作为AI助手时常常会出现幻觉现象，即提供不真实或无意义的信息。以往的事实对齐方法在训练过程中引入了噪声，因为它们在响应级别进行偏好学习。本文提出了一种基于直接偏好优化（DPO）的细粒度事实对齐方法，称为Mask-DPO，该方法通过句子级别的事实作为掩码信号，仅从事实正确的句子中学习，从而提高了LLMs的响应准确性。实验结果表明，Mask-DPO显著提升了LLMs在未见问题上的事实性，尤其是在不同领域的数据集上表现优异。'}}}, {'id': 'https://huggingface.co/papers/2503.00735', 'title': 'LADDER: Self-Improving LLMs Through Recursive Problem Decomposition', 'url': 'https://huggingface.co/papers/2503.00735', 'abstract': "We introduce LADDER (Learning through Autonomous Difficulty-Driven Example Recursion), a framework which enables Large Language Models to autonomously improve their problem-solving capabilities through self-guided learning by recursively generating and solving progressively simpler variants of complex problems. Unlike prior approaches that require curated datasets or human feedback, LADDER leverages a model's own capabilities to generate easier question variants. We demonstrate LADDER's effectiveness in the subject of mathematical integration, improving Llama 3.2 3B's accuracy from 1% to 82% on undergraduate-level problems and enabling Qwen2.5 7B Deepseek-R1 Distilled to achieve 73% on the MIT Integration Bee qualifying examination. We also introduce TTRL (Test-Time Reinforcement Learning), where we perform reinforcement learning on variants of test problems at inference time. TTRL enables Qwen2.5 7B Deepseek-R1 Distilled to achieve a state-of-the-art score of 90% on the MIT Integration Bee qualifying examination, surpassing OpenAI o1's performance. These results show how self-directed strategic learning can achieve significant capability improvements without relying on architectural scaling or human supervision.", 'score': 7, 'issue_id': 2540, 'pub_date': '2025-03-02', 'pub_date_card': {'ru': '2 марта', 'en': 'March 2', 'zh': '3月2日'}, 'hash': 'c9ce66a728a6df87', 'authors': ['Toby Simonds', 'Akira Yoshiyama'], 'affiliations': ['Tufa Labs'], 'pdf_title_img': 'assets/pdf/title_img/2503.00735.jpg', 'data': {'categories': ['#math', '#reasoning', '#optimization', '#training', '#rl'], 'emoji': '🧮', 'ru': {'title': 'Самообучение языковых моделей через генерацию упрощенных задач', 'desc': 'Представлен метод LADDER, позволяющий языковым моделям самостоятельно улучшать навыки решения задач путем генерации и решения упрощенных вариантов сложных проблем. В отличие от предыдущих подходов, LADDER не требует подготовленных датасетов или обратной связи от людей. Эффективность метода продемонстрирована на задачах математического интегрирования, где точность модели Llama 3.2 3B выросла с 1% до 82% на задачах университетского уровня. Также представлен метод TTRL, использующий обучение с подкреплением во время вывода, что позволило модели Qwen2.5 7B достичь рекордных 90% на отборочном экзамене MIT Integration Bee.'}, 'en': {'title': 'Empowering Models to Learn and Solve Problems Autonomously', 'desc': 'LADDER is a new framework that helps Large Language Models (LLMs) improve their problem-solving skills by creating and solving simpler versions of complex problems on their own. This method does not need pre-made datasets or human input, as it allows the model to generate easier questions based on its own understanding. The framework has shown remarkable success in mathematical integration, significantly boosting the accuracy of models like Llama 3.2 and Qwen2.5 on challenging exams. Additionally, the introduction of Test-Time Reinforcement Learning (TTRL) further enhances performance by applying reinforcement learning during the testing phase, leading to state-of-the-art results.'}, 'zh': {'title': '自主学习，提升能力的全新框架', 'desc': '本文介绍了LADDER（通过自主难度驱动的示例递归学习）框架，该框架使大型语言模型能够通过自我引导学习，逐步生成和解决复杂问题的简化变体，从而提高其解决问题的能力。与以往需要人工反馈或精心策划数据集的方法不同，LADDER利用模型自身的能力生成更简单的问题变体。我们展示了LADDER在数学积分领域的有效性，使Llama 3.2 3B在本科水平问题上的准确率从1%提高到82%，并使Qwen2.5 7B Deepseek-R1 Distilled在MIT积分竞赛资格考试中达到73%。此外，我们还引入了TTRL（测试时强化学习），在推理时对测试问题的变体进行强化学习，使Qwen2.5 7B Deepseek-R1 Distilled在MIT积分竞赛资格考试中获得90%的领先成绩，超越了OpenAI o1的表现。'}}}, {'id': 'https://huggingface.co/papers/2503.01935', 'title': 'MultiAgentBench: Evaluating the Collaboration and Competition of LLM agents', 'url': 'https://huggingface.co/papers/2503.01935', 'abstract': 'Large Language Models (LLMs) have shown remarkable capabilities as autonomous agents, yet existing benchmarks either focus on single-agent tasks or are confined to narrow domains, failing to capture the dynamics of multi-agent coordination and competition. In this paper, we introduce MultiAgentBench, a comprehensive benchmark designed to evaluate LLM-based multi-agent systems across diverse, interactive scenarios. Our framework measures not only task completion but also the quality of collaboration and competition using novel, milestone-based key performance indicators. Moreover, we evaluate various coordination protocols (including star, chain, tree, and graph topologies) and innovative strategies such as group discussion and cognitive planning. Notably, gpt-4o-mini reaches the average highest task score, graph structure performs the best among coordination protocols in the research scenario, and cognitive planning improves milestone achievement rates by 3%. Code and datasets are public available at https://github.com/MultiagentBench/MARBLE.', 'score': 7, 'issue_id': 2532, 'pub_date': '2025-03-03', 'pub_date_card': {'ru': '3 марта', 'en': 'March 3', 'zh': '3月3日'}, 'hash': '4353f27d396c322a', 'authors': ['Kunlun Zhu', 'Hongyi Du', 'Zhaochen Hong', 'Xiaocheng Yang', 'Shuyi Guo', 'Zhe Wang', 'Zhenhailong Wang', 'Cheng Qian', 'Xiangru Tang', 'Heng Ji', 'Jiaxuan You'], 'affiliations': ['University of Illinois Urbana-Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2503.01935.jpg', 'data': {'categories': ['#games', '#optimization', '#open_source', '#benchmark', '#agents'], 'emoji': '🤖', 'ru': {'title': 'MultiAgentBench: новый стандарт для оценки мультиагентных LLM-систем', 'desc': 'Статья представляет MultiAgentBench - комплексный бенчмарк для оценки мультиагентных систем на основе больших языковых моделей (LLM) в различных интерактивных сценариях. Фреймворк измеряет не только выполнение задач, но и качество сотрудничества и конкуренции с помощью новых ключевых показателей эффективности. Авторы оценивают различные протоколы координации и инновационные стратегии, такие как групповое обсуждение и когнитивное планирование. Результаты показывают, что gpt-4o-mini достигает наивысшего среднего балла за выполнение задач, а графовая структура лучше всего работает среди протоколов координации в исследовательском сценарии.'}, 'en': {'title': 'Evaluating LLMs in Multi-Agent Dynamics', 'desc': 'This paper presents MultiAgentBench, a new benchmark for assessing the performance of Large Language Models (LLMs) in multi-agent environments. Unlike previous benchmarks that focus on single-agent tasks, MultiAgentBench evaluates how well LLMs can collaborate and compete in various interactive scenarios. The framework introduces key performance indicators that measure both task completion and the quality of interactions among agents. The study also explores different coordination protocols and innovative strategies, revealing that certain configurations, like graph structures and cognitive planning, significantly enhance performance.'}, 'zh': {'title': '多智能体系统的全面评估基准', 'desc': '本文介绍了MultiAgentBench，这是一个全面的基准测试，旨在评估基于大型语言模型（LLM）的多智能体系统在多样化互动场景中的表现。该框架不仅测量任务完成情况，还评估协作和竞争的质量，使用新颖的里程碑式关键绩效指标。我们还评估了多种协调协议（如星形、链形、树形和图形拓扑）以及创新策略，如小组讨论和认知规划。研究表明，gpt-4o-mini在任务得分上表现最佳，图形结构在协调协议中表现最佳，而认知规划提高了里程碑达成率3%。'}}}, {'id': 'https://huggingface.co/papers/2503.01328', 'title': 'PipeOffload: Improving Scalability of Pipeline Parallelism with Memory Optimization', 'url': 'https://huggingface.co/papers/2503.01328', 'abstract': 'Pipeline parallelism (PP) is widely used for training large language models (LLMs), yet its scalability is often constrained by high activation memory consumption as the number of in-flight microbatches grows with the degree of PP. In this paper, we focus on addressing this challenge by leveraging the under-explored memory offload strategy in PP. With empirical study, we discover that in the majority of standard configurations, at least half, and potentially all, of the activations can be offloaded with negligible overhead. In the cases where full overload is not possible, we introduce a novel selective offload strategy that decreases peak activation memory in a better-than-linear manner. Furthermore, we integrate memory offload with other techniques to jointly consider overall throughput and memory limitation. Our experiments proves that the per-device activation memory effectively reduces with the total number of stages, making PP a stronger alternative than TP, offering up to a 19\\% acceleration with even lower memory consumption. The implementation is open-sourced at https://github.com/sail-sg/zero-bubble-pipeline-parallelism{this url}.', 'score': 7, 'issue_id': 2532, 'pub_date': '2025-03-03', 'pub_date_card': {'ru': '3 марта', 'en': 'March 3', 'zh': '3月3日'}, 'hash': '75e25b312e4cef8a', 'authors': ['Xinyi Wan', 'Penghui Qi', 'Guangxing Huang', 'Jialin Li', 'Min Lin'], 'affiliations': ['National University of', 'Sea AI Lab'], 'pdf_title_img': 'assets/pdf/title_img/2503.01328.jpg', 'data': {'categories': ['#open_source', '#inference', '#optimization', '#training'], 'emoji': '🚀', 'ru': {'title': 'Оптимизация памяти для масштабирования больших языковых моделей', 'desc': 'Статья посвящена улучшению масштабируемости конвейерного параллелизма при обучении больших языковых моделей. Авторы предлагают стратегию выгрузки активаций из памяти, которая позволяет значительно снизить пиковое потребление памяти. Они также представляют метод выборочной выгрузки для случаев, когда полная выгрузка невозможна. Эксперименты показывают, что данный подход делает конвейерный параллелизм более эффективной альтернативой тензорному параллелизму, ускоряя обучение на 19% при меньшем потреблении памяти.'}, 'en': {'title': 'Optimizing Memory Usage in Pipeline Parallelism for Faster Training', 'desc': 'This paper addresses the challenge of high activation memory consumption in pipeline parallelism (PP) when training large language models (LLMs). The authors explore a memory offload strategy that allows for significant reductions in memory usage, showing that up to half of the activations can be offloaded with minimal impact on performance. They also propose a selective offload strategy that further decreases peak activation memory in a more efficient way. The results demonstrate that using memory offload in conjunction with other techniques can enhance throughput while reducing memory requirements, making PP a more viable option compared to tensor parallelism (TP).'}, 'zh': {'title': '优化管道并行性，降低内存消耗！', 'desc': '本文探讨了在训练大型语言模型时，管道并行性（PP）面临的高激活内存消耗问题。我们提出了一种内存卸载策略，可以在大多数标准配置中卸载至少一半的激活，几乎没有额外开销。对于无法完全卸载的情况，我们引入了一种新的选择性卸载策略，显著降低了峰值激活内存。实验结果表明，随着阶段数量的增加，每个设备的激活内存有效减少，使得PP成为比张量并行性（TP）更强的选择，提供高达19%的加速，同时降低内存消耗。'}}}, {'id': 'https://huggingface.co/papers/2503.02879', 'title': 'Wikipedia in the Era of LLMs: Evolution and Risks', 'url': 'https://huggingface.co/papers/2503.02879', 'abstract': "In this paper, we present a thorough analysis of the impact of Large Language Models (LLMs) on Wikipedia, examining the evolution of Wikipedia through existing data and using simulations to explore potential risks. We begin by analyzing page views and article content to study Wikipedia's recent changes and assess the impact of LLMs. Subsequently, we evaluate how LLMs affect various Natural Language Processing (NLP) tasks related to Wikipedia, including machine translation and retrieval-augmented generation (RAG). Our findings and simulation results reveal that Wikipedia articles have been influenced by LLMs, with an impact of approximately 1%-2% in certain categories. If the machine translation benchmark based on Wikipedia is influenced by LLMs, the scores of the models may become inflated, and the comparative results among models might shift as well. Moreover, the effectiveness of RAG might decrease if the knowledge base becomes polluted by LLM-generated content. While LLMs have not yet fully changed Wikipedia's language and knowledge structures, we believe that our empirical findings signal the need for careful consideration of potential future risks.", 'score': 6, 'issue_id': 2535, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': 'd8fedc8bf5ffc308', 'authors': ['Siming Huang', 'Yuliang Xu', 'Mingmeng Geng', 'Yao Wan', 'Dongping Chen'], 'affiliations': ['Huazhong University of Science and Technology', 'International School for Advanced Studies (SISSA)'], 'pdf_title_img': 'assets/pdf/title_img/2503.02879.jpg', 'data': {'categories': ['#rag', '#benchmark', '#machine_translation', '#dataset', '#multimodal', '#science', '#data'], 'emoji': '🧠', 'ru': {'title': 'Большие языковые модели меняют лицо Википедии: анализ влияния и потенциальных рисков', 'desc': 'Эта статья представляет анализ влияния больших языковых моделей (LLM) на Википедию. Исследователи изучили изменения в просмотрах страниц и содержании статей, а также провели симуляции для оценки потенциальных рисков. Результаты показывают, что LLM повлияли на 1-2% статей в некоторых категориях, что может привести к искажению результатов в задачах машинного перевода и генерации с использованием внешних знаний (RAG). Авторы призывают к осторожности в отношении будущих рисков, связанных с влиянием LLM на структуру знаний в Википедии.'}, 'en': {'title': "Navigating the Impact of LLMs on Wikipedia's Evolution", 'desc': 'This paper analyzes how Large Language Models (LLMs) are affecting Wikipedia by examining changes in page views and article content. It assesses the influence of LLMs on various Natural Language Processing (NLP) tasks, such as machine translation and retrieval-augmented generation (RAG). The study finds that LLMs have caused a 1%-2% impact on certain Wikipedia categories, which could inflate machine translation benchmarks and alter model comparisons. The authors emphasize the importance of monitoring these changes to mitigate potential risks associated with LLM-generated content.'}, 'zh': {'title': '大型语言模型对维基百科的影响分析', 'desc': '本文深入分析了大型语言模型（LLMs）对维基百科的影响，研究了维基百科的演变。我们通过分析页面浏览量和文章内容，评估LLMs对维基百科的影响，发现某些类别的影响约为1%-2%。此外，我们还评估了LLMs对与维基百科相关的自然语言处理（NLP）任务的影响，包括机器翻译和检索增强生成（RAG）。我们的研究结果表明，LLMs可能会导致机器翻译基准的分数膨胀，并可能影响模型之间的比较结果，因此需要对未来的潜在风险进行仔细考虑。'}}}, {'id': 'https://huggingface.co/papers/2503.02368', 'title': 'Iterative Value Function Optimization for Guided Decoding', 'url': 'https://huggingface.co/papers/2503.02368', 'abstract': 'While Reinforcement Learning from Human Feedback (RLHF) has become the predominant method for controlling language model outputs, it suffers from high computational costs and training instability. Guided decoding, especially value-guided methods, offers a cost-effective alternative by controlling outputs without re-training models. However, the accuracy of the value function is crucial for value-guided decoding, as inaccuracies can lead to suboptimal decision-making and degraded performance. Existing methods struggle with accurately estimating the optimal value function, leading to less effective control. We propose Iterative Value Function Optimization, a novel framework that addresses these limitations through two key components: Monte Carlo Value Estimation, which reduces estimation variance by exploring diverse trajectories, and Iterative On-Policy Optimization, which progressively improves value estimation through collecting trajectories from value-guided policies. Extensive experiments on text summarization, multi-turn dialogue, and instruction following demonstrate the effectiveness of value-guided decoding approaches in aligning language models. These approaches not only achieve alignment but also significantly reduce computational costs by leveraging principled value function optimization for efficient and effective control.', 'score': 5, 'issue_id': 2538, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': '6a7f0679f238bd4d', 'authors': ['Zhenhua Liu', 'Lijun Li', 'Ruizhe Chen', 'Yuxian Jiang', 'Tong Zhu', 'Wenliang Chen', 'Jing Shao'], 'affiliations': ['Fudan University', 'Shanghai Artificial Intelligence Laboratory', 'Soochow University', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2503.02368.jpg', 'data': {'categories': ['#optimization', '#alignment', '#training', '#rlhf'], 'emoji': '🧠', 'ru': {'title': 'Эффективное управление языковыми моделями без переобучения', 'desc': "Статья представляет новый метод управления выходными данными языковых моделей, называемый 'Итеративная оптимизация функции ценности'. Этот подход предлагает альтернативу традиционному обучению с подкреплением на основе обратной связи от человека (RLHF), снижая вычислительные затраты и повышая стабильность обучения. Метод использует управляемое декодирование на основе функции ценности, улучшая её точность с помощью оценки Монте-Карло и итеративной оптимизации. Эксперименты показали эффективность предложенного подхода в задачах суммаризации текста, многоэтапного диалога и выполнения инструкций."}, 'en': {'title': 'Optimizing Value Functions for Efficient Language Model Control', 'desc': 'This paper addresses the challenges of Reinforcement Learning from Human Feedback (RLHF) in controlling language models, particularly its high computational costs and instability. It introduces a new framework called Iterative Value Function Optimization, which enhances value-guided decoding methods by improving the accuracy of the value function. The framework employs Monte Carlo Value Estimation to minimize estimation variance and Iterative On-Policy Optimization to refine value estimation through trajectory collection. Experimental results show that this approach not only aligns language models effectively but also reduces computational expenses significantly.'}, 'zh': {'title': '高效控制语言模型的新方法', 'desc': '本论文探讨了人类反馈强化学习（RLHF）在控制语言模型输出时的高计算成本和训练不稳定性问题。我们提出了一种新的框架——迭代值函数优化，通过蒙特卡洛值估计和迭代在线优化来提高值函数的准确性。该方法通过探索多样化的轨迹来减少估计方差，并逐步改进值估计。实验结果表明，基于值引导的解码方法在文本摘要、多轮对话和指令跟随任务中表现出色，显著降低了计算成本。'}}}, {'id': 'https://huggingface.co/papers/2502.14856', 'title': 'FR-Spec: Accelerating Large-Vocabulary Language Models via Frequency-Ranked Speculative Sampling', 'url': 'https://huggingface.co/papers/2502.14856', 'abstract': 'Speculative sampling has emerged as an important technique for accelerating the auto-regressive generation process of large language models (LLMs) by utilizing a draft-then-verify mechanism to produce multiple tokens per forward pass. While state-of-the-art speculative sampling methods use only a single layer and a language modeling (LM) head as the draft model to achieve impressive layer compression, their efficiency gains are substantially reduced for large-vocabulary LLMs, such as Llama-3-8B with a vocabulary of 128k tokens. To address this, we present FR-Spec, a frequency-ranked speculative sampling framework that optimizes draft candidate selection through vocabulary space compression. By constraining the draft search to a frequency-prioritized token subset, our method reduces LM Head computation overhead by 75% while ensuring the equivalence of the final output distribution. Experiments across multiple datasets demonstrate an average of 1.12times speedup over the state-of-the-art speculative sampling method EAGLE-2.', 'score': 5, 'issue_id': 2535, 'pub_date': '2025-02-20', 'pub_date_card': {'ru': '20 февраля', 'en': 'February 20', 'zh': '2月20日'}, 'hash': '45e128ccea542dad', 'authors': ['Weilin Zhao', 'Tengyu Pan', 'Xu Han', 'Yudi Zhang', 'Ao Sun', 'Yuxiang Huang', 'Kaihuo Zhang', 'Weilun Zhao', 'Yuxuan Li', 'Jianyong Wang', 'Zhiyuan Liu', 'Maosong Sun'], 'affiliations': ['Beijing University of Posts and Telecommunications, Beijing, China', 'Harbin Institute of Technology, Harbin, China', 'OpenBMB', 'Tsinghua University, Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2502.14856.jpg', 'data': {'categories': ['#training', '#inference', '#optimization'], 'emoji': '🚀', 'ru': {'title': 'Быстрее и эффективнее: оптимизация спекулятивной выборки для LLM', 'desc': 'Статья представляет FR-Spec - новый метод спекулятивной выборки для ускорения работы больших языковых моделей (LLM). Метод оптимизирует выбор кандидатов путем сжатия пространства словаря, отдавая приоритет наиболее частотным токенам. Это позволяет снизить вычислительные затраты на 75% по сравнению с существующими методами, сохраняя эквивалентность итогового распределения. Эксперименты показывают ускорение в 1.12 раза по сравнению с современным методом EAGLE-2.'}, 'en': {'title': 'Accelerating Token Generation with Frequency-Ranked Speculative Sampling', 'desc': 'This paper introduces FR-Spec, a new framework for speculative sampling in large language models (LLMs) that enhances the efficiency of token generation. By using a draft-then-verify approach, FR-Spec optimizes the selection of draft candidates by focusing on a frequency-ranked subset of tokens, which reduces computational overhead significantly. The method achieves a 75% reduction in LM Head computation while maintaining the same output distribution as traditional methods. Experimental results show that FR-Spec provides an average speedup of 1.12 times compared to the leading speculative sampling technique, EAGLE-2.'}, 'zh': {'title': '频率优先，推测采样加速！', 'desc': '本文提出了一种名为FR-Spec的频率排名推测采样框架，旨在加速大型语言模型的自回归生成过程。该方法通过压缩词汇空间，优化草稿候选选择，从而减少计算开销。FR-Spec将草稿搜索限制在一个优先考虑频率的词汇子集上，使得语言模型头的计算开销降低了75%。实验结果表明，FR-Spec在多个数据集上相较于最先进的推测采样方法EAGLE-2实现了平均1.12倍的加速。'}}}, {'id': 'https://huggingface.co/papers/2503.00955', 'title': 'SemViQA: A Semantic Question Answering System for Vietnamese Information Fact-Checking', 'url': 'https://huggingface.co/papers/2503.00955', 'abstract': 'The rise of misinformation, exacerbated by Large Language Models (LLMs) like GPT and Gemini, demands robust fact-checking solutions, especially for low-resource languages like Vietnamese. Existing methods struggle with semantic ambiguity, homonyms, and complex linguistic structures, often trading accuracy for efficiency. We introduce SemViQA, a novel Vietnamese fact-checking framework integrating Semantic-based Evidence Retrieval (SER) and Two-step Verdict Classification (TVC). Our approach balances precision and speed, achieving state-of-the-art results with 78.97\\% strict accuracy on ISE-DSC01 and 80.82\\% on ViWikiFC, securing 1st place in the UIT Data Science Challenge. Additionally, SemViQA Faster improves inference speed 7x while maintaining competitive accuracy. SemViQA sets a new benchmark for Vietnamese fact verification, advancing the fight against misinformation. The source code is available at: https://github.com/DAVID-NGUYEN-S16/SemViQA.', 'score': 5, 'issue_id': 2535, 'pub_date': '2025-03-02', 'pub_date_card': {'ru': '2 марта', 'en': 'March 2', 'zh': '3月2日'}, 'hash': '651aacbd378465bd', 'authors': ['Nam V. Nguyen', 'Dien X. Tran', 'Thanh T. Tran', 'Anh T. Hoang', 'Tai V. Duong', 'Di T. Le', 'Phuc-Lu Le'], 'affiliations': ['FPT Software AI Center, Viet Nam', 'FPT Telecom, Viet Nam', 'Faculty of Information Technology, Industrial University of Ho Chi Minh City, Viet Nam', 'Faculty of Information Technology, University of Science, VNU-HCM, Viet Nam'], 'pdf_title_img': 'assets/pdf/title_img/2503.00955.jpg', 'data': {'categories': ['#multilingual', '#inference', '#benchmark', '#low_resource', '#dataset', '#science', '#data'], 'emoji': '🕵️', 'ru': {'title': 'SemViQA: Передовая система проверки фактов для борьбы с дезинформацией на вьетнамском языке', 'desc': 'SemViQA - это новая система проверки фактов на вьетнамском языке, разработанная для борьбы с дезинформацией, усугубляемой крупными языковыми моделями. Она объединяет семантический поиск доказательств и двухэтапную классификацию вердиктов, обеспечивая баланс между точностью и скоростью. SemViQA достигла наилучших результатов на датасетах ISE-DSC01 и ViWikiFC, установив новый стандарт для проверки фактов на вьетнамском языке. Быстрая версия SemViQA Faster увеличивает скорость вывода в 7 раз при сохранении конкурентоспособной точности.'}, 'en': {'title': 'SemViQA: Revolutionizing Vietnamese Fact-Checking Against Misinformation', 'desc': 'This paper addresses the challenge of misinformation in low-resource languages, specifically Vietnamese, by introducing SemViQA, a new fact-checking framework. SemViQA combines Semantic-based Evidence Retrieval (SER) and Two-step Verdict Classification (TVC) to enhance both accuracy and efficiency in verifying facts. The framework achieves impressive results, with a strict accuracy of 78.97% on the ISE-DSC01 dataset and 80.82% on ViWikiFC, outperforming existing methods. Additionally, SemViQA Faster significantly boosts inference speed by 7 times while maintaining competitive accuracy, setting a new standard for fact verification in Vietnamese.'}, 'zh': {'title': 'SemViQA：越南语事实核查的新标杆', 'desc': '随着大型语言模型（LLMs）如GPT和Gemini的兴起，虚假信息问题日益严重，尤其是在资源匮乏的语言如越南语中，迫切需要强有力的事实核查解决方案。现有的方法在语义模糊、同义词和复杂语言结构方面存在困难，往往在准确性和效率之间做出妥协。我们提出了SemViQA，这是一种新颖的越南语事实核查框架，结合了基于语义的证据检索（SER）和两步裁决分类（TVC）。我们的方案在保持竞争性准确度的同时，实现了精度与速度的平衡，在ISE-DSC01上达到了78.97%的严格准确率，在ViWikiFC上达到了80.82%，并在UIT数据科学挑战赛中获得第一名。'}}}, {'id': 'https://huggingface.co/papers/2503.01342', 'title': 'UFO: A Unified Approach to Fine-grained Visual Perception via Open-ended Language Interface', 'url': 'https://huggingface.co/papers/2503.01342', 'abstract': 'Generalist models have achieved remarkable success in both language and vision-language tasks, showcasing the potential of unified modeling. However, effectively integrating fine-grained perception tasks like detection and segmentation into these models remains a significant challenge. This is primarily because these tasks often rely heavily on task-specific designs and architectures that can complicate the modeling process. To address this challenge, we present \\ours, a framework that Unifies Fine-grained visual perception tasks through an Open-ended language interface. By transforming all perception targets into the language space, \\ours unifies object-level detection, pixel-level segmentation, and image-level vision-language tasks into a single model. Additionally, we introduce a novel embedding retrieval approach that relies solely on the language interface to support segmentation tasks. Our framework bridges the gap between fine-grained perception and vision-language tasks, significantly simplifying architectural design and training strategies while achieving comparable or superior performance to methods with intricate task-specific designs. After multi-task training on five standard visual perception datasets, \\ours outperforms the previous state-of-the-art generalist models by 12.3 mAP on COCO instance segmentation and 3.3 mIoU on ADE20K semantic segmentation. Furthermore, our method seamlessly integrates with existing MLLMs, effectively combining fine-grained perception capabilities with their advanced language abilities, thereby enabling more challenging tasks such as reasoning segmentation. Code and models will be publicly available.', 'score': 4, 'issue_id': 2535, 'pub_date': '2025-03-03', 'pub_date_card': {'ru': '3 марта', 'en': 'March 3', 'zh': '3月3日'}, 'hash': '8f87e24c90eade92', 'authors': ['Hao Tang', 'Chenwei Xie', 'Haiyang Wang', 'Xiaoyi Bao', 'Tingyu Weng', 'Pandeng Li', 'Yun Zheng', 'Liwei Wang'], 'affiliations': ['Alibaba Group', 'Center for Data Science, Peking University', 'Institute of Automation, Chinese Academy of Sciences'], 'pdf_title_img': 'assets/pdf/title_img/2503.01342.jpg', 'data': {'categories': ['#cv', '#training', '#optimization', '#agi', '#open_source', '#multimodal', '#architecture'], 'emoji': '🔬', 'ru': {'title': 'Унификация задач компьютерного зрения через языковой интерфейс', 'desc': 'Статья представляет новый фреймворк для унификации задач тонкой визуальной перцепции через языковой интерфейс. Авторы трансформируют все цели восприятия в языковое пространство, объединяя обнаружение объектов, сегментацию на уровне пикселей и задачи зрения-языка в единую модель. Предложен новый подход с извлечением эмбеддингов, использующий только языковой интерфейс для поддержки задач сегментации. Фреймворк превосходит предыдущие модели-генералисты на нескольких стандартных наборах данных и легко интегрируется с существующими мультимодальными языковыми моделями.'}, 'en': {'title': 'Unifying Fine-Grained Perception with Language for Enhanced Model Performance', 'desc': 'This paper introduces a framework called \textit{ours} that aims to unify fine-grained visual perception tasks, such as detection and segmentation, with language-based tasks. By converting all perception targets into a language format, the framework simplifies the integration of various tasks into a single model. The authors also propose a new embedding retrieval method that utilizes the language interface to enhance segmentation capabilities. The results show that \textit{ours} outperforms existing generalist models on multiple datasets, demonstrating its effectiveness in bridging fine-grained perception and vision-language tasks.'}, 'zh': {'title': '统一细粒度视觉感知与语言任务的创新框架', 'desc': '本论文提出了一种新的框架\textit{ours}，旨在通过开放式语言接口统一细粒度视觉感知任务，如目标检测和像素分割。该框架将所有感知目标转化为语言空间，从而将对象级检测、像素级分割和图像级视觉语言任务整合到一个模型中。我们还引入了一种新颖的嵌入检索方法，仅依赖语言接口来支持分割任务。经过在五个标准视觉感知数据集上的多任务训练，\textit{ours}在COCO实例分割上比之前的最先进通用模型提高了12.3 mAP，在ADE20K语义分割上提高了3.3 mIoU。'}}}, {'id': 'https://huggingface.co/papers/2503.02197', 'title': 'ATLaS: Agent Tuning via Learning Critical Steps', 'url': 'https://huggingface.co/papers/2503.02197', 'abstract': "Large Language Model (LLM) agents have demonstrated remarkable generalization capabilities across multi-domain tasks. Existing agent tuning approaches typically employ supervised finetuning on entire expert trajectories. However, behavior-cloning of full trajectories can introduce expert bias and weaken generalization to states not covered by the expert data. Additionally, critical steps, such as planning, complex reasoning for intermediate subtasks, and strategic decision-making, are essential to success in agent tasks, so learning these steps is the key to improving LLM agents. For more effective and efficient agent tuning, we propose ATLaS that identifies the critical steps in expert trajectories and finetunes LLMs solely on these steps with reduced costs. By steering the training's focus to a few critical steps, our method mitigates the risk of overfitting entire trajectories and promotes generalization across different environments and tasks. In extensive experiments, an LLM finetuned on only 30% critical steps selected by ATLaS outperforms the LLM finetuned on all steps and recent open-source LLM agents. ATLaS maintains and improves base LLM skills as generalist agents interacting with diverse environments.", 'score': 4, 'issue_id': 2532, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': 'a06c17fd97b92f03', 'authors': ['Zhixun Chen', 'Ming Li', 'Yuxuan Huang', 'Yali Du', 'Meng Fang', 'Tianyi Zhou'], 'affiliations': ['Kings College London', 'University of Liverpool', 'University of Maryland', 'University of Technology Sydney'], 'pdf_title_img': 'assets/pdf/title_img/2503.02197.jpg', 'data': {'categories': ['#optimization', '#reasoning', '#training', '#agents', '#agi'], 'emoji': '🎯', 'ru': {'title': 'ATLaS: точечная настройка LLM-агентов для улучшения обобщения', 'desc': 'ATLaS - это новый метод настройки агентов на основе больших языковых моделей (LLM). Он фокусируется на обучении только критически важным шагам в экспертных траекториях, что улучшает обобщение и снижает риск переобучения. Эксперименты показывают, что LLM, настроенная на 30% критических шагов, выбранных ATLaS, превосходит модели, обученные на всех шагах. Этот подход позволяет сохранить и улучшить базовые навыки LLM как универсальных агентов для взаимодействия с различными средами.'}, 'en': {'title': 'Focus on Critical Steps for Better LLM Performance', 'desc': 'This paper introduces ATLaS, a novel approach for tuning Large Language Model (LLM) agents by focusing on critical steps in expert trajectories rather than using full trajectory behavior-cloning. By finetuning LLMs on only 30% of these essential steps, ATLaS reduces the risk of expert bias and enhances generalization to unseen states. The method emphasizes the importance of planning, reasoning, and decision-making in agent tasks, which are crucial for improving performance. Experimental results show that LLMs trained with ATLaS outperform those trained on complete trajectories and other recent models, while also maintaining their generalist capabilities across various tasks.'}, 'zh': {'title': '聚焦关键步骤，提升LLM代理的泛化能力', 'desc': '大型语言模型（LLM）代理在多领域任务中展现了出色的泛化能力。现有的代理调优方法通常在整个专家轨迹上进行监督微调，但这种行为克隆可能引入专家偏见，削弱对未覆盖状态的泛化能力。本文提出的ATLaS方法通过识别专家轨迹中的关键步骤，仅在这些步骤上进行微调，从而降低成本并提高效率。实验表明，基于ATLaS选择的30%关键步骤微调的LLM在性能上优于在所有步骤上微调的LLM和最近的开源LLM代理。'}}}, {'id': 'https://huggingface.co/papers/2503.02878', 'title': 'Language Models can Self-Improve at State-Value Estimation for Better Search', 'url': 'https://huggingface.co/papers/2503.02878', 'abstract': 'Collecting ground truth task completion rewards or human demonstrations for multi-step reasoning tasks is often cost-prohibitive and time-consuming, especially in interactive domains like web tasks. To address this bottleneck, we present self-taught lookahead, a self-supervised method that leverages state-transition dynamics to train a value model capable of effectively guiding language model-controlled search. We find that moderately sized (8 billion parameters) open-weight value models improved with self-taught lookahead can match the performance of using a frontier LLM such as gpt-4o as the value model. Furthermore, we find that self-taught lookahead improves performance by 20% while reducing costs 37x compared to previous LLM-based tree search, without relying on ground truth rewards.', 'score': 4, 'issue_id': 2532, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': '04d05c7118ce4a93', 'authors': ['Ethan Mendes', 'Alan Ritter'], 'affiliations': ['Georgia Institute of Technology'], 'pdf_title_img': 'assets/pdf/title_img/2503.02878.jpg', 'data': {'categories': ['#reasoning', '#rl', '#optimization', '#training'], 'emoji': '🧠', 'ru': {'title': 'Самообучение для эффективного поиска без дорогостоящих демонстраций', 'desc': "Статья представляет метод 'self-taught lookahead' для обучения модели оценки, способной эффективно направлять поиск, управляемый языковой моделью. Этот самоконтролируемый метод использует динамику переходов состояний, что позволяет избежать дорогостоящего и трудоемкого сбора наград за выполнение задач или демонстраций от людей. Исследование показывает, что относительно небольшие (8 миллиардов параметров) модели оценки, улучшенные с помощью 'self-taught lookahead', могут сравниться по производительности с использованием передовых языковых моделей, таких как GPT-4, в качестве модели оценки. Более того, метод улучшает производительность на 20% при одновременном снижении затрат в 37 раз по сравнению с предыдущими методами поиска на основе больших языковых моделей."}, 'en': {'title': 'Self-Taught Lookahead: Cost-Effective Multi-Step Reasoning', 'desc': 'This paper introduces a method called self-taught lookahead, which is designed to improve the efficiency of training value models for multi-step reasoning tasks without needing expensive human input. By utilizing state-transition dynamics, this self-supervised approach allows the model to learn how to guide searches effectively. The authors demonstrate that a moderately sized value model can achieve performance comparable to larger models like GPT-4o, while also significantly reducing costs. Overall, self-taught lookahead enhances performance by 20% and cuts costs by 37 times compared to traditional LLM-based methods.'}, 'zh': {'title': '自我教导前瞻：高效的多步骤推理解决方案', 'desc': '本论文提出了一种自我学习的前瞻性方法，称为自我教导前瞻（self-taught lookahead），旨在解决多步骤推理任务中收集真实奖励或人类示范的高成本和时间消耗问题。该方法利用状态转移动态来训练一个价值模型，从而有效指导语言模型控制的搜索。研究表明，使用自我教导前瞻的中等规模（80亿参数）开放权重价值模型，其性能可以与前沿的语言模型（如gpt-4o）相媲美。更重要的是，自我教导前瞻在不依赖真实奖励的情况下，能够将性能提升20%，同时将成本降低37倍。'}}}, {'id': 'https://huggingface.co/papers/2503.02537', 'title': 'RectifiedHR: Enable Efficient High-Resolution Image Generation via Energy Rectification', 'url': 'https://huggingface.co/papers/2503.02537', 'abstract': "Diffusion models have achieved remarkable advances in various image generation tasks. However, their performance notably declines when generating images at resolutions higher than those used during the training period. Despite the existence of numerous methods for producing high-resolution images, they either suffer from inefficiency or are hindered by complex operations. In this paper, we propose RectifiedHR, an efficient and straightforward solution for training-free high-resolution image generation. Specifically, we introduce the noise refresh strategy, which theoretically only requires a few lines of code to unlock the model's high-resolution generation ability and improve efficiency. Additionally, we first observe the phenomenon of energy decay that may cause image blurriness during the high-resolution image generation process. To address this issue, we propose an Energy Rectification strategy, where modifying the hyperparameters of the classifier-free guidance effectively improves the generation performance. Our method is entirely training-free and boasts a simple implementation logic. Through extensive comparisons with numerous baseline methods, our RectifiedHR demonstrates superior effectiveness and efficiency.", 'score': 3, 'issue_id': 2540, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': '764b3070cbcdd839', 'authors': ['Zhen Yang', 'Guibao Shen', 'Liang Hou', 'Mushui Liu', 'Luozhou Wang', 'Xin Tao', 'Pengfei Wan', 'Di Zhang', 'Ying-Cong Chen'], 'affiliations': ['HKUST', 'HKUST(GZ)', 'Kuaishou Technology', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2503.02537.jpg', 'data': {'categories': ['#cv', '#optimization', '#diffusion', '#training'], 'emoji': '🖼️', 'ru': {'title': 'Эффективная генерация изображений высокого разрешения без дополнительного обучения', 'desc': 'Статья представляет новый метод RectifiedHR для генерации изображений высокого разрешения с помощью диффузионных моделей. Авторы предлагают стратегию обновления шума, которая позволяет улучшить способность модели генерировать изображения высокого разрешения без дополнительного обучения. Они также вводят стратегию энергетической ректификации для решения проблемы размытости изображений. Метод RectifiedHR показывает превосходную эффективность по сравнению с существующими подходами.'}, 'en': {'title': 'Unlocking High-Resolution Image Generation with RectifiedHR', 'desc': 'This paper presents RectifiedHR, a novel approach for generating high-resolution images using diffusion models without the need for additional training. The authors introduce a noise refresh strategy that simplifies the process, allowing for efficient high-resolution image generation with minimal code changes. They also identify and address the issue of energy decay, which can lead to blurry images, by proposing an Energy Rectification strategy that optimizes hyperparameters for better performance. Overall, RectifiedHR stands out for its simplicity and effectiveness compared to existing methods.'}, 'zh': {'title': '高效无训练的高分辨率图像生成', 'desc': '扩散模型在图像生成任务中取得了显著进展，但在生成高于训练分辨率的图像时性能明显下降。尽管已有多种方法可以生成高分辨率图像，但它们往往效率低下或操作复杂。本文提出了一种名为RectifiedHR的高效且简单的无训练高分辨率图像生成解决方案。我们引入了噪声刷新策略和能量修正策略，显著提高了生成性能，且实现逻辑简单。'}}}, {'id': 'https://huggingface.co/papers/2503.02876', 'title': 'SPIDER: A Comprehensive Multi-Organ Supervised Pathology Dataset and Baseline Models', 'url': 'https://huggingface.co/papers/2503.02876', 'abstract': 'Advancing AI in computational pathology requires large, high-quality, and diverse datasets, yet existing public datasets are often limited in organ diversity, class coverage, or annotation quality. To bridge this gap, we introduce SPIDER (Supervised Pathology Image-DEscription Repository), the largest publicly available patch-level dataset covering multiple organ types, including Skin, Colorectal, and Thorax, with comprehensive class coverage for each organ. SPIDER provides high-quality annotations verified by expert pathologists and includes surrounding context patches, which enhance classification performance by providing spatial context.   Alongside the dataset, we present baseline models trained on SPIDER using the Hibou-L foundation model as a feature extractor combined with an attention-based classification head. The models achieve state-of-the-art performance across multiple tissue categories and serve as strong benchmarks for future digital pathology research. Beyond patch classification, the model enables rapid identification of significant areas, quantitative tissue metrics, and establishes a foundation for multimodal approaches.   Both the dataset and trained models are publicly available to advance research, reproducibility, and AI-driven pathology development. Access them at: https://github.com/HistAI/SPIDER', 'score': 2, 'issue_id': 2532, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': 'a85b69f61f2f377f', 'authors': ['Dmitry Nechaev', 'Alexey Pchelnikov', 'Ekaterina Ivanova'], 'affiliations': ['HistAI'], 'pdf_title_img': 'assets/pdf/title_img/2503.02876.jpg', 'data': {'categories': ['#open_source', '#dataset', '#multimodal', '#science', '#benchmark'], 'emoji': '🕷️', 'ru': {'title': 'SPIDER: Новый стандарт данных для ИИ в патологии', 'desc': 'Статья представляет SPIDER - крупнейший общедоступный набор данных для вычислительной патологии, охватывающий множество типов органов. SPIDER предоставляет высококачественные аннотации, проверенные экспертами-патологами, и включает контекстные патчи для улучшения классификации. Авторы также представляют базовые модели, обученные на SPIDER с использованием модели Hibou-L в качестве экстрактора признаков и классификационной головки на основе механизма внимания. Модели достигают современного уровня производительности в нескольких категориях тканей и служат эталоном для будущих исследований в области цифровой патологии.'}, 'en': {'title': 'SPIDER: Bridging the Gap in Pathology Datasets for AI Advancement', 'desc': 'This paper introduces SPIDER, a large and diverse dataset designed for computational pathology, addressing the limitations of existing public datasets. SPIDER includes high-quality, expert-verified annotations for various organ types, enhancing the classification of pathology images. The authors also present baseline models that utilize the Hibou-L foundation model and an attention-based classification head, achieving state-of-the-art results in tissue classification. The dataset and models are publicly available, promoting further research and development in AI-driven pathology.'}, 'zh': {'title': '推动病理学的AI进步', 'desc': '本论文介绍了SPIDER（监督病理图像描述库），这是一个涵盖多种器官类型的最大公开补丁级数据集，包括皮肤、结直肠和胸部。该数据集提供了高质量的注释，由专家病理学家验证，并包含周围上下文补丁，以提高分类性能。我们还展示了基于SPIDER训练的基线模型，使用Hibou-L基础模型作为特征提取器，并结合基于注意力的分类头，达到了多种组织类别的最先进性能。该数据集和训练模型均可公开获取，以推动研究、可重复性和基于AI的病理发展。'}}}, {'id': 'https://huggingface.co/papers/2503.02783', 'title': 'IterPref: Focal Preference Learning for Code Generation via Iterative Debugging', 'url': 'https://huggingface.co/papers/2503.02783', 'abstract': 'Preference learning enhances Code LLMs beyond supervised fine-tuning by leveraging relative quality comparisons. Existing methods construct preference pairs from   candidates based on test case success, treating the higher pass rate sample as positive and the lower as negative. However, this approach does not pinpoint specific errors in the code, which prevents the model from learning more informative error correction patterns, as aligning failing code as a whole lacks the granularity needed to capture meaningful error-resolution relationships. To address these issues, we propose IterPref, a new preference alignment framework that mimics human iterative debugging to refine Code LLMs. IterPref explicitly locates error regions and aligns the corresponding tokens via a tailored DPO algorithm. To generate informative pairs, we introduce the CodeFlow dataset, where samples are iteratively refined until passing tests, with modifications capturing error corrections. Extensive experiments show that a diverse suite of Code LLMs equipped with IterPref achieves significant performance gains in code generation and improves on challenging tasks like BigCodeBench. In-depth analysis reveals that IterPref yields fewer errors. Our code and data will be made publicaly available.', 'score': 1, 'issue_id': 2540, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': '3d7ced41646a5f95', 'authors': ['Jie Wu', 'Haoling Li', 'Xin Zhang', 'Jianwen Luo', 'Yangyu Huang', 'Ruihang Chu', 'Yujiu Yang', 'Scarlett Li'], 'affiliations': ['CASIA', 'Microsoft Research', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2503.02783.jpg', 'data': {'categories': ['#alignment', '#rlhf', '#open_source', '#dataset', '#optimization', '#training'], 'emoji': '🔧', 'ru': {'title': 'Итеративное обучение предпочтениям для усовершенствования языковых моделей кода', 'desc': 'Статья представляет новый метод IterPref для улучшения языковых моделей кода (Code LLMs) с помощью обучения предпочтениям. В отличие от существующих подходов, IterPref точно определяет области ошибок в коде и выравнивает соответствующие токены с использованием специального алгоритма DPO. Для генерации информативных пар авторы создали набор данных CodeFlow, где образцы кода итеративно улучшаются до прохождения тестов. Эксперименты показывают, что IterPref значительно повышает производительность Code LLMs в генерации кода и улучшает результаты на сложных задачах.'}, 'en': {'title': 'Iterative Preference Learning for Enhanced Code LLMs', 'desc': 'This paper introduces IterPref, a novel framework for enhancing Code LLMs (Language Models) through preference learning. Unlike traditional methods that simply compare pass rates of code samples, IterPref focuses on identifying specific error regions in code, allowing for more precise learning of error correction patterns. By utilizing a tailored DPO (Direct Preference Optimization) algorithm and the CodeFlow dataset, which iteratively refines code samples, the framework generates informative preference pairs that improve model training. Experimental results demonstrate that Code LLMs using IterPref show significant performance improvements in code generation tasks and exhibit fewer errors overall.'}, 'zh': {'title': '迭代调试，提升代码生成能力！', 'desc': '本论文提出了一种新的偏好对齐框架IterPref，旨在通过模拟人类的迭代调试过程来提升代码大语言模型（Code LLMs）的性能。现有方法通过测试用例的成功率构建偏好对，但未能准确定位代码中的具体错误，限制了模型学习有效的错误修正模式。IterPref通过定制的DPO算法明确定位错误区域，并对相应的标记进行对齐，从而生成更具信息量的偏好对。实验结果表明，使用IterPref的多样化代码大语言模型在代码生成和复杂任务上均取得了显著的性能提升。'}}}, {'id': 'https://huggingface.co/papers/2503.02268', 'title': 'AppAgentX: Evolving GUI Agents as Proficient Smartphone Users', 'url': 'https://huggingface.co/papers/2503.02268', 'abstract': "Recent advancements in Large Language Models (LLMs) have led to the development of intelligent LLM-based agents capable of interacting with graphical user interfaces (GUIs). These agents demonstrate strong reasoning and adaptability, enabling them to perform complex tasks that traditionally required predefined rules. However, the reliance on step-by-step reasoning in LLM-based agents often results in inefficiencies, particularly for routine tasks. In contrast, traditional rule-based systems excel in efficiency but lack the intelligence and flexibility to adapt to novel scenarios. To address this challenge, we propose a novel evolutionary framework for GUI agents that enhances operational efficiency while retaining intelligence and flexibility. Our approach incorporates a memory mechanism that records the agent's task execution history. By analyzing this history, the agent identifies repetitive action sequences and evolves high-level actions that act as shortcuts, replacing these low-level operations and improving efficiency. This allows the agent to focus on tasks requiring more complex reasoning, while simplifying routine actions. Experimental results on multiple benchmark tasks demonstrate that our approach significantly outperforms existing methods in both efficiency and accuracy. The code will be open-sourced to support further research.", 'score': 1, 'issue_id': 2536, 'pub_date': '2025-03-04', 'pub_date_card': {'ru': '4 марта', 'en': 'March 4', 'zh': '3月4日'}, 'hash': '03199cb797dc8d88', 'authors': ['Wenjia Jiang', 'Yangyang Zhuang', 'Chenxi Song', 'Xu Yang', 'Chi Zhang'], 'affiliations': ['Henan University', 'Southeast University', 'Westlake University'], 'pdf_title_img': 'assets/pdf/title_img/2503.02268.jpg', 'data': {'categories': ['#optimization', '#agents', '#benchmark', '#reasoning', '#open_source', '#training'], 'emoji': '🧠', 'ru': {'title': 'Эволюционное обучение агентов GUI: баланс эффективности и гибкости', 'desc': 'Эта статья представляет новый эволюционный подход для агентов, работающих с графическим интерфейсом на основе больших языковых моделей (LLM). Авторы предлагают механизм памяти, который записывает историю выполнения задач агентом и анализирует ее для выявления повторяющихся последовательностей действий. На основе этого анализа создаются высокоуровневые действия, которые заменяют низкоуровневые операции, повышая эффективность работы. Экспериментальные результаты показывают, что данный метод значительно превосходит существующие подходы по эффективности и точности.'}, 'en': {'title': 'Evolving Efficiency: Smart Shortcuts for GUI Agents', 'desc': 'This paper presents a new framework for Large Language Model (LLM)-based agents that interact with graphical user interfaces (GUIs). The proposed method enhances the efficiency of these agents by incorporating a memory mechanism that tracks their task execution history. By analyzing this history, the agents can identify repetitive actions and evolve high-level shortcuts, allowing them to streamline routine tasks. This approach maintains the intelligence and adaptability of LLMs while improving their operational efficiency, as demonstrated by experimental results on benchmark tasks.'}, 'zh': {'title': '智能代理的进化：提升效率与灵活性', 'desc': '最近，大型语言模型（LLMs）的进步使得基于LLM的智能代理能够与图形用户界面（GUIs）进行交互。这些代理展现出强大的推理能力和适应性，能够执行传统上需要预定义规则的复杂任务。然而，基于LLM的代理在依赖逐步推理时，往往在处理常规任务时效率较低。为了解决这个问题，我们提出了一种新颖的进化框架，通过记录代理的任务执行历史，识别重复的操作序列，从而演化出高层次的快捷操作，提升了操作效率，同时保留了智能和灵活性。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents (4)', '#agi (2)', '#alignment (3)', '#architecture (1)', '#audio', '#benchmark (5)', '#cv (2)', '#data (2)', '#dataset (4)', '#diffusion (1)', '#ethics', '#games (1)', '#graphs', '#hallucinations (2)', '#healthcare', '#inference (3)', '#interpretability', '#leakage', '#long_context', '#low_resource (1)', '#machine_translation (1)', '#math (1)', '#multilingual (1)', '#multimodal (3)', '#open_source (6)', '#optimization (12)', '#plp', '#rag (1)', '#reasoning (4)', '#rl (3)', '#rlhf (3)', '#robotics', '#science (3)', '#security', '#small_models', '#story_generation', '#survey', '#synthetic', '#training (12)', '#transfer_learning', '#video'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-03-05 11:09',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-03-05 11:09')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-03-05 11:09')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    