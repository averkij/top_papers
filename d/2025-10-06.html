
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 32 papers. October 6.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">6 октября</span> | <span id="title-articles-count">32 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-10-03.html">⬅️ <span id="prev-date">03.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-10-07.html">➡️ <span id="next-date">07.10</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-10.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '6 октября', 'en': 'October 6', 'zh': '10月6日'};
        let feedDateNext = {'ru': '07.10', 'en': '10/07', 'zh': '10月7日'};
        let feedDatePrev = {'ru': '03.10', 'en': '10/03', 'zh': '10月3日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2510.01141', 'title': 'Apriel-1.5-15b-Thinker', 'url': 'https://huggingface.co/papers/2510.01141', 'abstract': 'A 15-billion parameter multimodal reasoning model achieves competitive performance through a progressive training methodology without reinforcement learning, demonstrating efficient use of computational resources.  \t\t\t\t\tAI-generated summary \t\t\t\t We present Apriel-1.5-15B-Thinker, a 15-billion parameter open-weights multimodal reasoning model that achieves frontier-level performance through training design rather than sheer scale. Starting from Pixtral-12B, we apply a progressive three-stage methodology: (1) depth upscaling to expand reasoning capacity without pretraining from scratch, (2) staged continual pre-training that first develops foundational text and vision understanding, then enhances visual reasoning through targeted synthetic data generation addressing spatial structure, compositional understanding, and fine-grained perception, and (3) high-quality text-only supervised fine-tuning on curated instruction-response pairs with explicit reasoning traces spanning mathematics, coding, science, and tool use. Notably, our model achieves competitive results without reinforcement learning or preference optimization, isolating the contribution of our data-centric continual pre-training approach. On the Artificial Analysis Intelligence Index, Apriel-1.5-15B-Thinker attains a score of 52, matching DeepSeek-R1-0528 despite requiring significantly fewer computational resources. Across ten image benchmarks, its performance is on average within five points of Gemini-2.5-Flash and Claude Sonnet-3.7, a key achievement for a model operating within single-GPU deployment constraints. Our results demonstrate that thoughtful mid-training 2 design can close substantial capability gaps without massive scale, making frontier-level multimodal reasoning accessible to organizations with limited infrastructure. We release the model checkpoint, all training recipes, and evaluation protocols under the MIT license to to advance open-source research.', 'score': 72, 'issue_id': 6259, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '6fce98c823104717', 'authors': ['Shruthan Radhakrishna', 'Aman Tiwari', 'Aanjaneya Shukla', 'Masoud Hashemi', 'Rishabh Maheshwary', 'Shiva Krishna Reddy Malay', 'Jash Mehta', 'Pulkit Pattnaik', 'Saloni Mittal', 'Khalil Slimi', 'Kelechi Ogueji', 'Akintunde Oladipo', 'Soham Parikh', 'Oluwanifemi Bamgbose', 'Toby Liang', 'Ahmed Masry', 'Khyati Mahajan', 'Sai Rajeswar Mudumba', 'Vikas Yadav', 'Sathwik Tejaswi Madhusudhan', 'Torsten Scholak', 'Sagar Davasam', 'Srinivas Sunkara', 'Nicholas Chapados'], 'affiliations': ['SLAM Lab', 'ServiceNow'], 'pdf_title_img': 'assets/pdf/title_img/2510.01141.jpg', 'data': {'categories': ['#reasoning', '#architecture', '#agi', '#dataset', '#training', '#multimodal', '#inference', '#open_source'], 'emoji': '🧠', 'ru': {'title': 'Эффективное мультимодальное мышление без избыточных ресурсов', 'desc': 'Представлена модель Apriel-1.5-15B-Thinker с 15 миллиардами параметров, которая достигает высокого уровня производительности в мультимодальных задачах через продуманную методологию обучения, а не за счёт масштаба. Модель использует трёхэтапный подход: расширение глубины сети, поэтапный continual pre-training для развития понимания текста и изображений, и supervised fine-tuning на качественных данных с явными цепочками рассуждений. Примечательно, что модель достигает результатов, сопоставимых с гораздо более крупными моделями вроде Gemini-2.5-Flash и Claude Sonnet-3.7, при этом работая на одном GPU и не используя reinforcement learning. Все веса модели, рецепты обучения и протоколы оценки выпущены под открытой лицензией MIT для развития open-source исследований.'}, 'en': {'title': 'Efficient Multimodal Reasoning Without Reinforcement Learning', 'desc': 'The paper introduces Apriel-1.5-15B-Thinker, a multimodal reasoning model with 15 billion parameters that achieves high performance through a unique training approach rather than relying on large scale. It employs a three-stage progressive training methodology that enhances reasoning capabilities by first upscaling depth, then using continual pre-training to improve text and vision understanding, and finally fine-tuning with high-quality text data. This model stands out by achieving competitive results without the use of reinforcement learning, focusing instead on a data-centric approach. The findings suggest that effective training strategies can significantly enhance model performance while minimizing computational resource requirements, making advanced multimodal reasoning more accessible.'}, 'zh': {'title': '高效训练，前沿推理！', 'desc': '本文介绍了一种名为Apriel-1.5-15B-Thinker的多模态推理模型，具有150亿个参数。该模型通过渐进式训练方法实现了竞争力的性能，而无需强化学习。训练过程包括三个阶段：深度扩展、分阶段持续预训练和高质量的文本监督微调。研究表明，合理的训练设计可以在不依赖大规模计算资源的情况下，缩小能力差距，使前沿级别的多模态推理对资源有限的组织变得可及。'}}}, {'id': 'https://huggingface.co/papers/2510.00515', 'title': 'Efficient Multi-modal Large Language Models via Progressive Consistency\n  Distillation', 'url': 'https://huggingface.co/papers/2510.00515', 'abstract': "EPIC, a progressive learning framework, improves the efficiency of multi-modal large models by reducing training difficulty through token and layer consistency distillation during visual token compression.  \t\t\t\t\tAI-generated summary \t\t\t\t Visual tokens consume substantial computational resources in multi-modal large models (MLLMs), significantly compromising their efficiency. Recent works have attempted to improve efficiency by compressing visual tokens during training, either through modifications to model components or by introducing additional parameters. However, they often overlook the increased learning difficulty caused by such compression, as the model's parameter space struggles to quickly adapt to the substantial perturbations in the feature space induced by token compression. In this work, we propose to develop Efficient MLLMs via Progressive Consistency Distillation (EPIC), a progressive learning framework. Specifically, by decomposing the feature space perturbations introduced by token compression along the token-wise and layer-wise dimensions, we introduce token consistency distillation and layer consistency distillation, respectively, aiming to reduce the training difficulty by leveraging guidance from a teacher model and following a progressive learning trajectory. Extensive experiments demonstrate the superior effectiveness, robustness, and generalization capabilities of our proposed framework.", 'score': 24, 'issue_id': 6256, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': 'f3effef750806c45', 'authors': ['Zichen Wen', 'Shaobo Wang', 'Yufa Zhou', 'Junyuan Zhang', 'Qintong Zhang', 'Yifeng Gao', 'Zhaorun Chen', 'Bin Wang', 'Weijia Li', 'Conghui He', 'Linfeng Zhang'], 'affiliations': ['Duke University', 'EPIC Lab, Shanghai Jiao Tong University', 'Peking University', 'Shanghai AI Laboratory', 'Sun Yat-sen University', 'The University of Hong Kong', 'University of Chicago'], 'pdf_title_img': 'assets/pdf/title_img/2510.00515.jpg', 'data': {'categories': ['#training', '#optimization', '#architecture', '#multimodal'], 'emoji': '🎯', 'ru': {'title': 'Прогрессивное сжатие визуальных токенов через дистилляцию', 'desc': 'EPIC — это фреймворк для эффективного обучения мультимодальных LLM, который решает проблему больших вычислительных затрат на обработку визуальных токенов. Основная идея заключается в том, что сжатие токенов во время обучения создаёт сильные возмущения в пространстве признаков, что усложняет обучение модели. Авторы предлагают прогрессивный подход с двумя видами дистилляции: по токенам и по слоям, используя учителя-модель для постепенной адаптации к сжатию. Эксперименты показывают, что метод эффективно снижает сложность обучения и улучшает производительность мультимодальных моделей.'}, 'en': {'title': 'Enhancing MLLM Efficiency with Progressive Learning', 'desc': 'The paper introduces EPIC, a framework designed to enhance the efficiency of multi-modal large models (MLLMs) by addressing the challenges posed by visual token compression. It focuses on reducing the training difficulty associated with this compression through two key strategies: token consistency distillation and layer consistency distillation. By breaking down the perturbations in the feature space, EPIC allows the model to learn progressively, using guidance from a teacher model to adapt more effectively. Experimental results show that EPIC significantly improves the performance, robustness, and generalization of MLLMs compared to previous methods.'}, 'zh': {'title': 'EPIC：提升多模态大模型效率的渐进学习框架', 'desc': 'EPIC是一种渐进学习框架，通过在视觉令牌压缩过程中进行令牌和层一致性蒸馏，降低训练难度，从而提高多模态大模型的效率。视觉令牌在多模态大模型中消耗大量计算资源，影响模型的效率。以往的研究虽然尝试通过压缩视觉令牌来提高效率，但往往忽视了压缩带来的学习难度。我们的方法通过引导教师模型，分解特征空间的扰动，采用渐进学习轨迹，显著提升了模型的有效性、鲁棒性和泛化能力。'}}}, {'id': 'https://huggingface.co/papers/2510.00938', 'title': 'Large Reasoning Models Learn Better Alignment from Flawed Thinking', 'url': 'https://huggingface.co/papers/2510.00938', 'abstract': 'RECAP, a reinforcement learning method, enhances the safety and robustness of large reasoning models by teaching them to override flawed reasoning and maintain safety without additional training costs.  \t\t\t\t\tAI-generated summary \t\t\t\t Large reasoning models (LRMs) "think" by generating structured chain-of-thought (CoT) before producing a final answer, yet they still lack the ability to reason critically about safety alignment and are easily biased when a flawed premise is injected into their thought process. We propose RECAP (Robust Safety Alignment via Counter-Aligned Prefilling), a principled reinforcement learning (RL) method for post-training that explicitly teaches models to override flawed reasoning trajectories and reroute to safe and helpful responses. RECAP trains on a mixture of synthetically generated counter-aligned CoT prefills and standard prompts, requires no additional training cost or modifications beyond vanilla reinforcement learning from human feedback (RLHF), and substantially improves safety and jailbreak robustness, reduces overrefusal, and preserves core reasoning capability -- all while maintaining inference token budget. Extensive analysis shows that RECAP-trained models engage in self-reflection more frequently and remain robust under adaptive attacks, preserving safety even after repeated attempts to override their reasoning.', 'score': 23, 'issue_id': 6263, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '637757f2ed494d24', 'authors': ['ShengYun Peng', 'Eric Smith', 'Ivan Evtimov', 'Song Jiang', 'Pin-Yu Chen', 'Hongyuan Zhan', 'Haozhu Wang', 'Duen Horng Chau', 'Mahesh Pasupuleti', 'Jianfeng Chi'], 'affiliations': ['Georgia Tech', 'IBM Research', 'Meta Superintelligence Labs'], 'pdf_title_img': 'assets/pdf/title_img/2510.00938.jpg', 'data': {'categories': ['#training', '#rl', '#security', '#rlhf', '#reasoning', '#alignment'], 'emoji': '🛡️', 'ru': {'title': 'Обучение AI моделей переосмысливать ошибочные рассуждения для безопасности', 'desc': 'Исследователи представили RECAP — метод обучения с подкреплением для больших reasoning моделей, которые генерируют цепочки рассуждений перед ответом. Проблема в том, что такие модели легко поддаются манипуляции через внедрение ошибочных предпосылок в процесс мышления. RECAP учит модели распознавать некорректные траектории рассуждений и переключаться на безопасные ответы, используя синтетически созданные примеры с контр-выровненными префиксами. Метод не требует дополнительных вычислительных затрат по сравнению со стандартным RLHF и значительно повышает безопасность, устойчивость к джейлбрейкам и способность к саморефлексии.'}, 'en': {'title': 'RECAP: Reinforcing Safety in Reasoning Models', 'desc': "RECAP is a reinforcement learning method designed to improve the safety and robustness of large reasoning models (LRMs). It teaches these models to identify and correct flawed reasoning paths, ensuring they provide safe and helpful responses. By using a combination of counter-aligned chain-of-thought prompts and standard training, RECAP enhances the model's ability to reflect on its reasoning without incurring additional training costs. The method significantly boosts the model's resilience against biased inputs and maintains its core reasoning capabilities while adhering to token budget constraints."}, 'zh': {'title': 'RECAP：提升推理模型的安全与鲁棒性', 'desc': 'RECAP是一种强化学习方法，旨在提高大型推理模型的安全性和鲁棒性。它通过教导模型覆盖错误推理，确保在没有额外训练成本的情况下保持安全。RECAP使用合成生成的反对齐链式思维（CoT）预填充和标准提示的混合进行训练，显著改善了安全性和抗攻击能力。经过RECAP训练的模型在自我反思方面表现更频繁，并在适应性攻击下保持鲁棒性，确保安全性。'}}}, {'id': 'https://huggingface.co/papers/2510.01068', 'title': 'Compose Your Policies! Improving Diffusion-based or Flow-based Robot\n  Policies via Test-time Distribution-level Composition', 'url': 'https://huggingface.co/papers/2510.01068', 'abstract': 'General Policy Composition (GPC) enhances robotic control performance by combining pre-trained diffusion-based policies without additional training, leading to superior results across various benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Diffusion-based models for robotic control, including vision-language-action (VLA) and vision-action (VA) policies, have demonstrated significant capabilities. Yet their advancement is constrained by the high cost of acquiring large-scale interaction datasets. This work introduces an alternative paradigm for enhancing policy performance without additional model training. Perhaps surprisingly, we demonstrate that the composed policies can exceed the performance of either parent policy. Our contribution is threefold. First, we establish a theoretical foundation showing that the convex composition of distributional scores from multiple diffusion models can yield a superior one-step functional objective compared to any individual score. A Gr\\"onwall-type bound is then used to show that this single-step improvement propagates through entire generation trajectories, leading to systemic performance gains. Second, motivated by these results, we propose General Policy Composition (GPC), a training-free method that enhances performance by combining the distributional scores of multiple pre-trained policies via a convex combination and test-time search. GPC is versatile, allowing for the plug-and-play composition of heterogeneous policies, including VA and VLA models, as well as those based on diffusion or flow-matching, irrespective of their input visual modalities. Third, we provide extensive empirical validation. Experiments on Robomimic, PushT, and RoboTwin benchmarks, alongside real-world robotic evaluations, confirm that GPC consistently improves performance and adaptability across a diverse set of tasks. Further analysis of alternative composition operators and weighting strategies offers insights into the mechanisms underlying the success of GPC. These results establish GPC as a simple yet effective method for improving control performance by leveraging existing policies.', 'score': 16, 'issue_id': 6252, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': 'f7a26368ff58e67e', 'authors': ['Jiahang Cao', 'Yize Huang', 'Hanzhong Guo', 'Rui Zhang', 'Mu Nan', 'Weijian Mai', 'Jiaxu Wang', 'Hao Cheng', 'Jingkai Sun', 'Gang Han', 'Wen Zhao', 'Qiang Zhang', 'Yijie Guo', 'Qihao Zheng', 'Chunfeng Song', 'Xiao Li', 'Ping Luo', 'Andrew F. Luo'], 'affiliations': ['Beijing Innovation Center of Humanoid Robotics', 'Shanghai AI Lab', 'Shanghai Jiaotong University', 'The Hong Kong University of Science and Technology', 'The University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2510.01068.jpg', 'data': {'categories': ['#training', '#robotics', '#optimization', '#benchmark', '#diffusion', '#agents'], 'emoji': '🤝', 'ru': {'title': 'Композиция policy без обучения превосходит отдельные модели', 'desc': 'Статья представляет метод General Policy Composition (GPC), который позволяет улучшить производительность робототехнических систем путём композиции нескольких предобученных diffusion-моделей без дополнительного обучения. Авторы доказывают теоретически, что выпуклая комбинация распределений от разных моделей может превзойти каждую отдельную policy. GPC работает с гетерогенными моделями — vision-language-action (VLA) и vision-action (VA), основанными на diffusion или flow-matching. Эксперименты на бенчмарках Robomimic, PushT, RoboTwin и реальных роботах подтверждают стабильное улучшение качества управления.'}, 'en': {'title': 'Enhancing Robotic Control with Policy Composition', 'desc': 'General Policy Composition (GPC) is a novel approach that enhances robotic control by combining pre-trained diffusion-based policies without the need for additional training. This method leverages the strengths of multiple policies, including vision-language-action and vision-action models, to achieve superior performance on various benchmarks. The theoretical foundation of GPC shows that combining distributional scores from different models can lead to better outcomes than using any single model alone. Extensive experiments demonstrate that GPC not only improves performance but also increases adaptability across diverse robotic tasks, making it a versatile tool in the field of robotic control.'}, 'zh': {'title': '通用策略组合：提升机器人控制性能的新方法', 'desc': '本文提出了一种名为通用策略组合（GPC）的方法，旨在通过结合预训练的扩散模型策略来提升机器人控制性能，而无需额外的训练。研究表明，组合后的策略在多个基准测试中表现优于单独的父策略。GPC利用凸组合的方式，将多个策略的分布得分进行结合，从而实现系统性的性能提升。通过在多个机器人任务上的实验证明，GPC在提高适应性和性能方面表现出色。'}}}, {'id': 'https://huggingface.co/papers/2509.23202', 'title': 'Bridging the Gap Between Promise and Performance for Microscaling FP4\n  Quantization', 'url': 'https://huggingface.co/papers/2509.23202', 'abstract': "A new quantization method, Micro-Rotated-GPTQ, addresses the challenges of 4-bit floating-point formats MXFP4 and NVFP4, achieving high performance and accuracy in large language model inference.  \t\t\t\t\tAI-generated summary \t\t\t\t The recent hardware-accelerated microscaling 4-bit floating-point formats such as MXFP4 and NVFP4, supported on NVIDIA and AMD GPUs, promise to revolutionize large language model (LLM) inference. Yet, their practical benefits remain unproven. We present the first comprehensive study of MXFP4 and NVFP4 for post-training quantization, revealing gaps between their promise and real-world performance. Our analysis shows that state-of-the-art methods struggle with FP4, due to two key issues: (1) NVFP4's small group size provably neutralizes traditional outlier mitigation techniques; (2) MXFP4's power-of-two scale quantization severely degrades accuracy due to high induced error. To bridge this gap, we introduce Micro-Rotated-GPTQ (MR-GPTQ), a variant of the classic GPTQ quantization algorithm that tailors the quantization process to FP4's unique properties, by using block-wise Hadamard transforms and format-specific optimizations. We support our proposal with a set of high-performance GPU kernels that enable the MR-GPTQ format with negligible overhead, by rotation fusion into the weights, and fast online computation of the activations. This leads to speedups vs. FP16 of up to 3.6x layer-wise, and 2.2x end-to-end on NVIDIA B200, and of 6x layer-wise and 4x end-to-end on RTX5090. Our extensive empirical evaluation demonstrates that MR-GPTQ matches or outperforms state-of-the-art accuracy, significantly boosting MXFP4, to the point where it nears that of NVFP4. We conclude that, while FP4 is not an automatic upgrade over INT4, format-specialized methods like MR-GPTQ can unlock a new frontier of accuracy-performance trade-offs.", 'score': 13, 'issue_id': 6264, 'pub_date': '2025-09-27', 'pub_date_card': {'ru': '27 сентября', 'en': 'September 27', 'zh': '9月27日'}, 'hash': '51b515d52895dbd2', 'authors': ['Vage Egiazarian', 'Roberto L. Castro', 'Denis Kuznedelev', 'Andrei Panferov', 'Eldar Kurtic', 'Shubhra Pandit', 'Alexandre Marques', 'Mark Kurtz', 'Saleh Ashkboos', 'Torsten Hoefler', 'Dan Alistarh'], 'affiliations': ['ETH Zürich', 'ISTA & Red Hat AI', 'Yandex Research'], 'pdf_title_img': 'assets/pdf/title_img/2509.23202.jpg', 'data': {'categories': ['#optimization', '#training', '#inference'], 'emoji': '🔄', 'ru': {'title': 'Микро-вращения раскрывают потенциал 4-битных форматов для LLM', 'desc': 'Исследователи представили Micro-Rotated-GPTQ — новый метод квантизации для 4-битных форматов с плавающей точкой MXFP4 и NVFP4, которые поддерживаются на GPU NVIDIA и AMD. Традиционные методы плохо работают с FP4 из-за малого размера групп в NVFP4 и проблем с квантизацией масштаба в MXFP4. MR-GPTQ использует блочные преобразования Адамара и специальные оптимизации для каждого формата, достигая ускорения до 3.6x на уровне слоёв и до 2.2x end-to-end на NVIDIA B200. Метод показывает, что FP4 форматы могут конкурировать с INT4 при правильной специализации алгоритма квантизации.'}, 'en': {'title': 'Unlocking Performance with Micro-Rotated-GPTQ for 4-bit Inference', 'desc': 'The paper introduces a new quantization method called Micro-Rotated-GPTQ (MR-GPTQ) that improves the performance and accuracy of large language model inference using 4-bit floating-point formats, specifically MXFP4 and NVFP4. It identifies challenges with existing methods that struggle with these formats, such as ineffective outlier mitigation and accuracy degradation due to quantization errors. MR-GPTQ leverages block-wise Hadamard transforms and optimizations tailored to the unique properties of FP4, resulting in significant speed improvements on NVIDIA GPUs. The empirical results show that MR-GPTQ not only enhances the performance of MXFP4 but also achieves accuracy levels comparable to NVFP4, demonstrating its potential in optimizing inference for large language models.'}, 'zh': {'title': '量化新方法：Micro-Rotated-GPTQ提升大语言模型性能', 'desc': '本文提出了一种新的量化方法，称为Micro-Rotated-GPTQ，旨在解决4位浮点格式MXFP4和NVFP4在大语言模型推理中的挑战。研究表明，现有的量化方法在FP4格式下表现不佳，主要由于NVFP4的小组大小和MXFP4的二次幂量化导致的高误差。Micro-Rotated-GPTQ通过使用分块Hadamard变换和特定格式的优化，针对FP4的独特特性调整量化过程，从而提高了性能和准确性。实验结果显示，MR-GPTQ在NVIDIA B200和RTX5090上实现了显著的速度提升，并且在准确性上与最先进的方法相当或更优。'}}}, {'id': 'https://huggingface.co/papers/2510.03194', 'title': 'CoDA: Agentic Systems for Collaborative Data Visualization', 'url': 'https://huggingface.co/papers/2510.03194', 'abstract': 'CoDA, a multi-agent system using specialized LLM agents, enhances visualization automation by managing data complexity and ensuring high-quality visualizations through collaborative workflows.  \t\t\t\t\tAI-generated summary \t\t\t\t Deep research has revolutionized data analysis, yet data scientists still devote substantial time to manually crafting visualizations, highlighting the need for robust automation from natural language queries. However, current systems struggle with complex datasets containing multiple files and iterative refinement. Existing approaches, including simple single- or multi-agent systems, often oversimplify the task, focusing on initial query parsing while failing to robustly manage data complexity, code errors, or final visualization quality. In this paper, we reframe this challenge as a collaborative multi-agent problem. We introduce CoDA, a multi-agent system that employs specialized LLM agents for metadata analysis, task planning, code generation, and self-reflection. We formalize this pipeline, demonstrating how metadata-focused analysis bypasses token limits and quality-driven refinement ensures robustness. Extensive evaluations show CoDA achieves substantial gains in the overall score, outperforming competitive baselines by up to 41.5%. This work demonstrates that the future of visualization automation lies not in isolated code generation but in integrated, collaborative agentic workflows.', 'score': 11, 'issue_id': 6256, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '78ee6c44f0df7217', 'authors': ['Zichen Chen', 'Jiefeng Chen', 'Sercan Ö. Arik', 'Misha Sra', 'Tomas Pfister', 'Jinsung Yoon'], 'affiliations': ['Google Cloud AI Research', 'University of California, Santa Barbara'], 'pdf_title_img': 'assets/pdf/title_img/2510.03194.jpg', 'data': {'categories': ['#agents', '#optimization', '#data', '#interpretability', '#multimodal'], 'emoji': '🤝', 'ru': {'title': 'Команда AI-агентов для автоматической визуализации данных', 'desc': 'Статья представляет CoDA — мультиагентную систему на основе LLM, которая автоматизирует создание визуализаций из текстовых запросов. Система использует специализированных агентов для анализа метаданных, планирования задач, генерации кода и самопроверки, что позволяет работать со сложными датасетами. CoDA превосходит существующие подходы на 41.5% благодаря коллаборативному взаимодействию агентов и итеративной проверке качества. Исследование показывает, что будущее автоматизации визуализации — в совместной работе специализированных AI-агентов, а не в изолированной генерации кода.'}, 'en': {'title': 'CoDA: Revolutionizing Visualization Automation with Collaborative Agents', 'desc': 'This paper presents CoDA, a multi-agent system designed to automate the visualization process by utilizing specialized large language model (LLM) agents. CoDA addresses the challenges of managing complex datasets and improving visualization quality through collaborative workflows, rather than relying on traditional single-agent systems. The system focuses on metadata analysis, task planning, and iterative refinement to enhance the robustness of visualizations. Evaluation results indicate that CoDA significantly outperforms existing methods, highlighting the importance of integrated approaches in visualization automation.'}, 'zh': {'title': 'CoDA：协作智能体驱动的可视化自动化新未来', 'desc': 'CoDA是一种多智能体系统，利用专门的语言模型代理来增强可视化自动化。它通过管理数据复杂性和确保高质量的可视化，支持协作工作流程。该系统解决了现有方法在处理复杂数据集时的不足，能够有效进行元数据分析、任务规划和代码生成。研究表明，CoDA在整体评分上显著优于竞争对手，展示了未来可视化自动化的潜力在于集成的协作智能体工作流程。'}}}, {'id': 'https://huggingface.co/papers/2510.02665', 'title': 'Self-Improvement in Multimodal Large Language Models: A Survey', 'url': 'https://huggingface.co/papers/2510.02665', 'abstract': 'A survey of self-improvement methods in Multimodal Large Language Models (MLLMs) from data collection, organization, and model optimization perspectives.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advancements in self-improvement for Large Language Models (LLMs) have efficiently enhanced model capabilities without significantly increasing costs, particularly in terms of human effort. While this area is still relatively young, its extension to the multimodal domain holds immense potential for leveraging diverse data sources and developing more general self-improving models. This survey is the first to provide a comprehensive overview of self-improvement in Multimodal LLMs (MLLMs). We provide a structured overview of the current literature and discuss methods from three perspectives: 1) data collection, 2) data organization, and 3) model optimization, to facilitate the further development of self-improvement in MLLMs. We also include commonly used evaluations and downstream applications. Finally, we conclude by outlining open challenges and future research directions.', 'score': 10, 'issue_id': 6252, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': 'a7980db6477e39f7', 'authors': ['Shijian Deng', 'Kai Wang', 'Tianyu Yang', 'Harsh Singh', 'Yapeng Tian'], 'affiliations': ['Mohamed bin Zayed University of Artificial Intelligence', 'The University of Texas at Dallas', 'University of Notre Dame', 'University of Toronto'], 'pdf_title_img': 'assets/pdf/title_img/2510.02665.jpg', 'data': {'categories': ['#training', '#survey', '#optimization', '#multimodal', '#data', '#dataset'], 'emoji': '🔄', 'ru': {'title': 'Мультимодальные LLM учатся сами: обзор методов самосовершенствования', 'desc': 'Статья представляет первый комплексный обзор методов самосовершенствования мультимодальных LLM. Авторы систематизируют существующие подходы с трёх ключевых точек зрения: сбор данных, организация данных и оптимизация моделей. Самосовершенствование позволяет улучшать возможности моделей без значительного увеличения затрат и человеческих усилий. В работе также обсуждаются методы оценки, практические применения и открытые проблемы в этой развивающейся области исследований.'}, 'en': {'title': 'Unlocking Potential: Self-Improvement in Multimodal Language Models', 'desc': 'This paper surveys self-improvement methods in Multimodal Large Language Models (MLLMs), focusing on how to enhance model performance through better data handling and optimization techniques. It highlights the importance of efficiently collecting and organizing diverse data sources to improve model capabilities without incurring high costs. The authors provide a structured overview of existing literature and categorize methods into three main areas: data collection, data organization, and model optimization. Additionally, the paper discusses evaluation metrics and potential applications, while identifying challenges and future research opportunities in the field.'}, 'zh': {'title': '多模态语言模型的自我改进潜力', 'desc': '本论文对多模态大型语言模型（MLLMs）中的自我改进方法进行了全面调查。我们从数据收集、数据组织和模型优化三个角度，系统性地回顾了当前文献，探讨了如何有效提升模型能力。尽管这一领域仍在发展中，但其在多模态领域的扩展具有巨大的潜力，可以利用多样的数据源。最后，我们总结了当前面临的挑战和未来的研究方向。'}}}, {'id': 'https://huggingface.co/papers/2509.26354', 'title': 'Your Agent May Misevolve: Emergent Risks in Self-evolving LLM Agents', 'url': 'https://huggingface.co/papers/2509.26354', 'abstract': "Self-evolving agents based on Large Language Models can deviate in unintended ways, leading to various risks such as safety misalignment and vulnerability introduction, necessitating new safety paradigms.  \t\t\t\t\tAI-generated summary \t\t\t\t Advances in Large Language Models (LLMs) have enabled a new class of self-evolving agents that autonomously improve through interaction with the environment, demonstrating strong capabilities. However, self-evolution also introduces novel risks overlooked by current safety research. In this work, we study the case where an agent's self-evolution deviates in unintended ways, leading to undesirable or even harmful outcomes. We refer to this as Misevolution. To provide a systematic investigation, we evaluate misevolution along four key evolutionary pathways: model, memory, tool, and workflow. Our empirical findings reveal that misevolution is a widespread risk, affecting agents built even on top-tier LLMs (e.g., Gemini-2.5-Pro). Different emergent risks are observed in the self-evolutionary process, such as the degradation of safety alignment after memory accumulation, or the unintended introduction of vulnerabilities in tool creation and reuse. To our knowledge, this is the first study to systematically conceptualize misevolution and provide empirical evidence of its occurrence, highlighting an urgent need for new safety paradigms for self-evolving agents. Finally, we discuss potential mitigation strategies to inspire further research on building safer and more trustworthy self-evolving agents. Our code and data are available at https://github.com/ShaoShuai0605/Misevolution . Warning: this paper includes examples that may be offensive or harmful in nature.", 'score': 8, 'issue_id': 6255, 'pub_date': '2025-09-30', 'pub_date_card': {'ru': '30 сентября', 'en': 'September 30', 'zh': '9月30日'}, 'hash': '154a1fd876a9a445', 'authors': ['Shuai Shao', 'Qihan Ren', 'Chen Qian', 'Boyi Wei', 'Dadi Guo', 'Jingyi Yang', 'Xinhao Song', 'Linfeng Zhang', 'Weinan Zhang', 'Dongrui Liu', 'Jing Shao'], 'affiliations': ['Fudan University', 'Hong Kong University of Science and Technology', 'Princeton University', 'Renmin University of China', 'Shanghai Artificial Intelligence Laboratory', 'Shanghai Jiao Tong University'], 'pdf_title_img': 'assets/pdf/title_img/2509.26354.jpg', 'data': {'categories': ['#alignment', '#ethics', '#agents', '#security', '#safety', '#rl'], 'emoji': '🧬', 'ru': {'title': 'Когда AI-агенты эволюционируют в неправильную сторону', 'desc': 'Исследование изучает новый тип рисков в самообучающихся агентах на основе LLM, которые автономно улучшаются через взаимодействие со средой. Авторы вводят концепцию «мисэволюции» — когда самостоятельная эволюция агента отклоняется в нежелательном направлении, приводя к вредным последствиям. Эксперименты показали, что эта проблема затрагивает даже агентов на базе передовых LLM (таких как Gemini-2.5-Pro) по четырём эволюционным направлениям: модель, память, инструменты и рабочий процесс. Работа подчёркивает необходимость разработки новых парадигм безопасности для самоэволюционирующих AI-агентов и предлагает потенциальные стратегии смягчения рисков.'}, 'en': {'title': 'Understanding Misevolution: The Hidden Risks of Self-Evolving AI', 'desc': "This paper investigates the concept of 'misevolution' in self-evolving agents powered by Large Language Models (LLMs). Misevolution refers to unintended deviations during the self-improvement process, which can lead to safety misalignment and the introduction of vulnerabilities. The authors evaluate misevolution across four pathways: model, memory, tool, and workflow, revealing that even advanced LLMs can experience significant risks. The study emphasizes the urgent need for new safety frameworks to address these challenges and proposes potential strategies for creating safer self-evolving agents."}, 'zh': {'title': '自我进化代理的误进化风险与安全挑战', 'desc': '本研究探讨了基于大型语言模型（LLM）的自我进化代理可能出现的意外偏差，称之为“误进化”。这种误进化可能导致安全不对齐和引入脆弱性等风险，亟需新的安全范式。我们系统地评估了误进化的四个关键路径：模型、记忆、工具和工作流程。研究结果表明，误进化是一个普遍存在的风险，影响到即使是顶级LLM构建的代理，强调了构建更安全和可信的自我进化代理的必要性。'}}}, {'id': 'https://huggingface.co/papers/2509.22033', 'title': 'OrtSAE: Orthogonal Sparse Autoencoders Uncover Atomic Features', 'url': 'https://huggingface.co/papers/2509.22033', 'abstract': 'Orthogonal Sparse Autoencoders (OrtSAE) mitigate feature absorption and composition by enforcing orthogonality, leading to better feature discovery and improved performance on spurious correlation removal.  \t\t\t\t\tAI-generated summary \t\t\t\t Sparse autoencoders (SAEs) are a technique for sparse decomposition of neural network activations into human-interpretable features. However, current SAEs suffer from feature absorption, where specialized features capture instances of general features creating representation holes, and feature composition, where independent features merge into composite representations. In this work, we introduce Orthogonal SAE (OrtSAE), a novel approach aimed to mitigate these issues by enforcing orthogonality between the learned features. By implementing a new training procedure that penalizes high pairwise cosine similarity between SAE features, OrtSAE promotes the development of disentangled features while scaling linearly with the SAE size, avoiding significant computational overhead. We train OrtSAE across different models and layers and compare it with other methods. We find that OrtSAE discovers 9% more distinct features, reduces feature absorption (by 65%) and composition (by 15%), improves performance on spurious correlation removal (+6%), and achieves on-par performance for other downstream tasks compared to traditional SAEs.', 'score': 7, 'issue_id': 6260, 'pub_date': '2025-09-26', 'pub_date_card': {'ru': '26 сентября', 'en': 'September 26', 'zh': '9月26日'}, 'hash': '2ee5b45b21d07892', 'authors': ['Anton Korznikov', 'Andrey Galichin', 'Alexey Dontsov', 'Oleg Rogov', 'Elena Tutubalina', 'Ivan Oseledets'], 'affiliations': [], 'pdf_title_img': 'assets/pdf/title_img/2509.22033.jpg', 'data': {'categories': ['#training', '#optimization', '#architecture'], 'emoji': '⊥', 'ru': {'title': 'Ортогональность против запутанности: как разделить признаки нейросети', 'desc': 'Исследователи представили Orthogonal SAE (OrtSAE) — улучшенную версию sparse autoencoders для разложения активаций нейронных сетей на интерпретируемые признаки. Традиционные SAE страдают от проблем поглощения признаков (когда специализированные признаки захватывают общие) и композиции признаков (когда независимые признаки сливаются). OrtSAE решает эти проблемы, добавляя штраф за высокое косинусное сходство между признаками, что обеспечивает их ортогональность и независимость. В результате метод обнаруживает на 9% больше уникальных признаков, снижает поглощение на 65%, композицию на 15% и улучшает производительность в задачах удаления ложных корреляций на 6%.'}, 'en': {'title': 'Enhancing Feature Discovery with Orthogonal Sparse Autoencoders', 'desc': 'Orthogonal Sparse Autoencoders (OrtSAE) are designed to improve the feature learning process in neural networks by addressing issues like feature absorption and composition. By enforcing orthogonality among the learned features, OrtSAE ensures that each feature remains distinct and interpretable, which enhances feature discovery. The training method penalizes high cosine similarity between features, promoting a clearer separation of learned representations. As a result, OrtSAE not only discovers more unique features but also significantly reduces unwanted correlations, leading to better overall performance in various tasks.'}, 'zh': {'title': '正交稀疏自编码器：提升特征发现与去除虚假相关性', 'desc': '正交稀疏自编码器（OrtSAE）通过强制特征之间的正交性，减轻了特征吸收和特征组合的问题，从而提高了特征发现的效果和去除虚假相关性的性能。稀疏自编码器（SAE）在神经网络激活的稀疏分解中表现良好，但现有的SAE存在特征吸收和特征组合的缺陷。OrtSAE通过新的训练过程，惩罚特征之间的高余弦相似度，促进了独立特征的发展，同时在计算上保持线性扩展。实验结果表明，OrtSAE发现了9%的独特特征，特征吸收减少了65%，特征组合减少了15%，并在去除虚假相关性方面提高了6%的性能。'}}}, {'id': 'https://huggingface.co/papers/2510.03120', 'title': 'SurveyBench: How Well Can LLM(-Agents) Write Academic Surveys?', 'url': 'https://huggingface.co/papers/2510.03120', 'abstract': "A new evaluation framework, SurveyBench, assesses the quality of automatically generated academic surveys using a quiz-driven approach, revealing deficiencies in current LLM4Survey methods.  \t\t\t\t\tAI-generated summary \t\t\t\t Academic survey writing, which distills vast literature into a coherent and insightful narrative, remains a labor-intensive and intellectually demanding task. While recent approaches, such as general DeepResearch agents and survey-specialized methods, can generate surveys automatically (a.k.a. LLM4Survey), their outputs often fall short of human standards and there lacks a rigorous, reader-aligned benchmark for thoroughly revealing their deficiencies. To fill the gap, we propose a fine-grained, quiz-driven evaluation framework SurveyBench, featuring (1) typical survey topics source from recent 11,343 arXiv papers and corresponding 4,947 high-quality surveys; (2) a multifaceted metric hierarchy that assesses the outline quality (e.g., coverage breadth, logical coherence), content quality (e.g., synthesis granularity, clarity of insights), and non-textual richness; and (3) a dual-mode evaluation protocol that includes content-based and quiz-based answerability tests, explicitly aligned with readers' informational needs. Results show SurveyBench effectively challenges existing LLM4Survey approaches (e.g., on average 21% lower than human in content-based evaluation).", 'score': 5, 'issue_id': 6252, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '9114023adb7490f9', 'authors': ['Zhaojun Sun', 'Xuzhou Zhu', 'Xuanhe Zhou', 'Xin Tong', 'Shuo Wang', 'Jie Fu', 'Guoliang Li', 'Zhiyuan Liu', 'Fan Wu'], 'affiliations': ['Shanghai AI Laboratory', 'Shanghai Jiao Tong University', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2510.03120.jpg', 'data': {'categories': ['#survey', '#benchmark'], 'emoji': '📊', 'ru': {'title': 'SurveyBench: бенчмарк для проверки AI-генерации научных обзоров через викторины', 'desc': 'Исследователи представили SurveyBench — новый фреймворк для оценки качества автоматически сгенерированных научных обзоров с помощью LLM. Система использует quiz-driven подход и оценивает структуру обзора, качество контента и наличие нетекстовых элементов на основе 11,343 статей с arXiv и 4,947 высококачественных обзоров. Результаты показывают, что современные LLM4Survey методы в среднем на 21% хуже справляются с задачей по сравнению с человеком. Фреймворк включает двухрежимную оценку, которая проверяет способность сгенерированных обзоров отвечать на вопросы читателей.'}, 'en': {'title': 'SurveyBench: Elevating AI-Generated Academic Surveys', 'desc': 'The paper introduces SurveyBench, a new evaluation framework designed to assess the quality of automatically generated academic surveys. It highlights the limitations of current LLM4Survey methods, which often fail to meet human standards in survey writing. SurveyBench utilizes a quiz-driven approach and a comprehensive metric hierarchy to evaluate both outline and content quality, ensuring alignment with reader needs. The results demonstrate that existing methods significantly underperform compared to human-generated surveys, with an average score 21% lower in content-based evaluations.'}, 'zh': {'title': 'SurveyBench：提升自动生成学术调查的评估标准', 'desc': '本论文提出了一种新的评估框架SurveyBench，用于评估自动生成的学术调查的质量。该框架采用基于测验的方法，揭示了当前LLM4Survey方法的不足之处。SurveyBench通过分析来自11,343篇arXiv论文的典型调查主题和4,947篇高质量调查，建立了多层次的评估指标体系。研究结果表明，SurveyBench在内容评估中平均比人类低21%，有效挑战了现有的LLM4Survey方法。'}}}, {'id': 'https://huggingface.co/papers/2510.01879', 'title': 'REPAIR: Robust Editing via Progressive Adaptive Intervention and\n  Reintegration', 'url': 'https://huggingface.co/papers/2510.01879', 'abstract': 'REPAIR is a lifelong editing framework for large language models that enhances editing accuracy and reduces knowledge forgetting through progressive adaptive intervention and reintegration.  \t\t\t\t\tAI-generated summary \t\t\t\t Post-training for large language models (LLMs) is constrained by the high cost of acquiring new knowledge or correcting errors and by the unintended side effects that frequently arise from retraining. To address these issues, we introduce REPAIR (Robust Editing via Progressive Adaptive Intervention and Reintegration), a lifelong editing framework designed to support precise and low-cost model updates while preserving non-target knowledge. REPAIR mitigates the instability and conflicts of large-scale sequential edits through a closed-loop feedback mechanism coupled with dynamic memory management. Furthermore, by incorporating frequent knowledge fusion and enforcing strong locality guards, REPAIR effectively addresses the shortcomings of traditional distribution-agnostic approaches that often overlook unintended ripple effects. Our experiments demonstrate that REPAIR boosts editing accuracy by 10%-30% across multiple model families and significantly reduces knowledge forgetting. This work introduces a robust framework for developing reliable, scalable, and continually evolving LLMs.', 'score': 5, 'issue_id': 6253, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '6a90da50c87cca3c', 'authors': ['Yisu Wang', 'Ming Wang', 'Haoyuan Song', 'Wenjie Huang', 'Chaozheng Wang', 'Yi Xie', 'Xuming Ran'], 'affiliations': ['ContiAI Research'], 'pdf_title_img': 'assets/pdf/title_img/2510.01879.jpg', 'data': {'categories': ['#optimization', '#training', '#inference'], 'emoji': '🔧', 'ru': {'title': 'Непрерывное обучение языковых моделей без забывания знаний', 'desc': 'В статье представлен фреймворк REPAIR для редактирования больших языковых моделей (LLM), который позволяет исправлять ошибки и добавлять новые знания без дорогостоящего переобучения. Метод использует механизм обратной связи и динамическое управление памятью для последовательного внесения изменений без конфликтов. Частое слияние знаний и строгий контроль локальности изменений помогают избежать нежелательных побочных эффектов при обновлении модели. Эксперименты показали повышение точности редактирования на 10-30% и значительное снижение забывания ранее изученной информации.'}, 'en': {'title': 'Enhancing Language Models with REPAIR: Accurate, Cost-effective, and Knowledge-preserving Editing', 'desc': 'REPAIR is a framework designed to improve the editing process of large language models (LLMs) by making it more accurate and cost-effective. It allows models to learn new information or correct mistakes without losing previously learned knowledge. The framework uses a feedback system and manages memory dynamically to handle multiple edits without causing conflicts. Experiments show that REPAIR increases editing accuracy significantly while minimizing knowledge loss, making it a valuable tool for evolving LLMs.'}, 'zh': {'title': 'REPAIR：提升语言模型编辑准确性的终身框架', 'desc': 'REPAIR是一个针对大型语言模型的终身编辑框架，旨在提高编辑的准确性并减少知识遗忘。它通过渐进式的适应性干预和再整合来实现低成本的模型更新，同时保护非目标知识。REPAIR采用闭环反馈机制和动态记忆管理，缓解了大规模顺序编辑带来的不稳定性和冲突。实验结果表明，REPAIR在多个模型家族中提高了10%-30%的编辑准确性，并显著减少了知识遗忘。'}}}, {'id': 'https://huggingface.co/papers/2510.03204', 'title': 'FocusAgent: Simple Yet Effective Ways of Trimming the Large Context of\n  Web Agents', 'url': 'https://huggingface.co/papers/2510.03204', 'abstract': 'FocusAgent uses a lightweight LLM retriever to extract relevant content from web page observations, improving efficiency and security in web agents.  \t\t\t\t\tAI-generated summary \t\t\t\t Web agents powered by large language models (LLMs) must process lengthy web page observations to complete user goals; these pages often exceed tens of thousands of tokens. This saturates context limits and increases computational cost processing; moreover, processing full pages exposes agents to security risks such as prompt injection. Existing pruning strategies either discard relevant content or retain irrelevant context, leading to suboptimal action prediction. We introduce FocusAgent, a simple yet effective approach that leverages a lightweight LLM retriever to extract the most relevant lines from accessibility tree (AxTree) observations, guided by task goals. By pruning noisy and irrelevant content, FocusAgent enables efficient reasoning while reducing vulnerability to injection attacks. Experiments on WorkArena and WebArena benchmarks show that FocusAgent matches the performance of strong baselines, while reducing observation size by over 50%. Furthermore, a variant of FocusAgent significantly reduces the success rate of prompt-injection attacks, including banner and pop-up attacks, while maintaining task success performance in attack-free settings. Our results highlight that targeted LLM-based retrieval is a practical and robust strategy for building web agents that are efficient, effective, and secure.', 'score': 3, 'issue_id': 6252, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': 'cff617954ead65b4', 'authors': ['Imene Kerboua', 'Sahar Omidi Shayegan', 'Megh Thakkar', 'Xing Han Lù', 'Léo Boisvert', 'Massimo Caccia', 'Jérémy Espinas', 'Alexandre Aussem', 'Véronique Eglin', 'Alexandre Lacoste'], 'affiliations': ['Esker', 'LIRIS - CNRS, INSA Lyon, Universite Claude Bernard Lyon 1', 'McGill University', 'Mila - Quebec AI Institute', 'Polytechnique Montréal', 'ServiceNow Research'], 'pdf_title_img': 'assets/pdf/title_img/2510.03204.jpg', 'data': {'categories': ['#long_context', '#inference', '#benchmark', '#agents', '#security', '#reasoning'], 'emoji': '🎯', 'ru': {'title': 'Фокусировка внимания веб-агентов для эффективности и безопасности', 'desc': 'FocusAgent — это подход для создания веб-агентов на основе LLM, который использует лёгкий retriever для извлечения релевантного контента из веб-страниц. Проблема в том, что веб-страницы часто содержат десятки тысяч токенов, что создаёт нагрузку на контекст и увеличивает вычислительные затраты, а также открывает уязвимости для prompt injection атак. FocusAgent фильтрует accessibility tree наблюдений, оставляя только важные строки согласно цели задачи, сокращая размер наблюдений более чем на 50% без потери качества. Эксперименты показывают, что метод не только сохраняет производительность на бенчмарках WorkArena и WebArena, но и значительно повышает защищённость от инъекций промптов.'}, 'en': {'title': 'Efficient and Secure Web Agents with FocusAgent', 'desc': 'FocusAgent is a novel approach that enhances the efficiency and security of web agents using a lightweight LLM retriever. It extracts the most relevant information from lengthy web page observations, which often contain excessive tokens that can overwhelm processing capabilities. By focusing on task-specific content and eliminating irrelevant data, FocusAgent minimizes computational costs and reduces the risk of security threats like prompt injection. Experimental results demonstrate that it not only maintains performance comparable to existing methods but also significantly decreases the amount of data processed, leading to safer and more effective web interactions.'}, 'zh': {'title': 'FocusAgent：高效安全的网页代理解决方案', 'desc': 'FocusAgent 是一种轻量级的 LLM 检索器，旨在从网页观察中提取相关内容，从而提高网络代理的效率和安全性。传统的大型语言模型在处理长达数万标记的网页时，容易导致上下文限制饱和和计算成本增加，同时也增加了安全风险。FocusAgent 通过从可访问性树（AxTree）观察中提取最相关的行，减少了噪声和无关内容，使推理过程更加高效，并降低了注入攻击的脆弱性。实验结果表明，FocusAgent 在保持任务成功率的同时，观察大小减少超过 50%，并显著降低了提示注入攻击的成功率。'}}}, {'id': 'https://huggingface.co/papers/2510.01354', 'title': 'WAInjectBench: Benchmarking Prompt Injection Detections for Web Agents', 'url': 'https://huggingface.co/papers/2510.01354', 'abstract': 'A comprehensive benchmark study evaluates the detection of prompt injection attacks against web agents, revealing that current detectors perform well against explicit attacks but struggle with subtle ones.  \t\t\t\t\tAI-generated summary \t\t\t\t Multiple prompt injection attacks have been proposed against web agents. At the same time, various methods have been developed to detect general prompt injection attacks, but none have been systematically evaluated for web agents. In this work, we bridge this gap by presenting the first comprehensive benchmark study on detecting prompt injection attacks targeting web agents. We begin by introducing a fine-grained categorization of such attacks based on the threat model. We then construct datasets containing both malicious and benign samples: malicious text segments generated by different attacks, benign text segments from four categories, malicious images produced by attacks, and benign images from two categories. Next, we systematize both text-based and image-based detection methods. Finally, we evaluate their performance across multiple scenarios. Our key findings show that while some detectors can identify attacks that rely on explicit textual instructions or visible image perturbations with moderate to high accuracy, they largely fail against attacks that omit explicit instructions or employ imperceptible perturbations. Our datasets and code are released at: https://github.com/Norrrrrrr-lyn/WAInjectBench.', 'score': 3, 'issue_id': 6256, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '4f65a94ba28daed6', 'authors': ['Yinuo Liu', 'Ruohan Xu', 'Xilong Wang', 'Yuqi Jia', 'Neil Zhenqiang Gong'], 'affiliations': ['Duke University'], 'pdf_title_img': 'assets/pdf/title_img/2510.01354.jpg', 'data': {'categories': ['#agents', '#dataset', '#benchmark', '#security'], 'emoji': '🕵️', 'ru': {'title': 'Детекторы инъекций промптов не справляются с тонкими атаками на веб-агентов', 'desc': 'Исследователи провели первое комплексное тестирование методов обнаружения атак типа prompt injection на веб-агентов с использованием AI. Они создали детальную классификацию таких атак и собрали датасеты с вредоносными и безопасными текстовыми и визуальными примерами. Результаты показали, что существующие детекторы хорошо распознают явные атаки с прямыми инструкциями или видимыми искажениями изображений. Однако они практически беспомощны против скрытых атак без явных инструкций или с незаметными модификациями, что выявляет серьёзные проблемы в защите LLM-агентов.'}, 'en': {'title': 'Bridging the Gap in Detecting Subtle Prompt Injection Attacks', 'desc': 'This paper presents a thorough benchmark study on detecting prompt injection attacks aimed at web agents. It categorizes these attacks based on their threat models and creates datasets with both malicious and benign samples, including text and images. The study evaluates various detection methods, revealing that while some can effectively identify explicit attacks, they struggle with more subtle ones that lack clear instructions or use imperceptible changes. The findings highlight the need for improved detection techniques to address the challenges posed by nuanced prompt injection attacks.'}, 'zh': {'title': '全面评估网络代理的提示注入攻击检测', 'desc': '本研究对针对网络代理的提示注入攻击检测进行了全面的基准评估。我们发现，当前的检测器在识别明显攻击时表现良好，但在处理微妙攻击时却面临挑战。我们构建了包含恶意和良性样本的数据集，并对文本和图像的检测方法进行了系统化。研究结果表明，尽管一些检测器能够有效识别依赖于明确文本指令的攻击，但在面对缺乏明确指令或使用不可察觉扰动的攻击时，它们的表现大幅下降。'}}}, {'id': 'https://huggingface.co/papers/2509.26388', 'title': 'Game-Time: Evaluating Temporal Dynamics in Spoken Language Models', 'url': 'https://huggingface.co/papers/2509.26388', 'abstract': 'The Game-Time Benchmark evaluates the temporal dynamics and real-time interaction capabilities of conversational spoken language models, highlighting performance gaps in instruction-following and synchronized responses.  \t\t\t\t\tAI-generated summary \t\t\t\t Conversational Spoken Language Models (SLMs) are emerging as a promising paradigm for real-time speech interaction. However, their capacity of temporal dynamics, including the ability to manage timing, tempo and simultaneous speaking, remains a critical and unevaluated challenge for conversational fluency. To address this gap, we introduce the Game-Time Benchmark, a framework to systematically assess these temporal capabilities. Inspired by how humans learn a language through language activities, Game-Time consists of basic instruction-following tasks and advanced tasks with temporal constraints, such as tempo adherence and synchronized responses. Our evaluation of diverse SLM architectures reveals a clear performance disparity: while state-of-the-art models handle basic tasks well, many contemporary systems still struggle with fundamental instruction-following. More critically, nearly all models degrade substantially under temporal constraints, exposing persistent weaknesses in time awareness and full-duplex interaction. The Game-Time Benchmark provides a foundation for guiding future research toward more temporally-aware conversational AI. Demos and datasets are available on our project website https://ga642381.github.io/Game-Time.', 'score': 3, 'issue_id': 6263, 'pub_date': '2025-09-30', 'pub_date_card': {'ru': '30 сентября', 'en': 'September 30', 'zh': '9月30日'}, 'hash': '6f2dc381222d8711', 'authors': ['Kai-Wei Chang', 'En-Pei Hu', 'Chun-Yi Kuan', 'Wenze Ren', 'Wei-Chih Chen', 'Guan-Ting Lin', 'Yu Tsao', 'Shao-Hua Sun', 'Hung-yi Lee', 'James Glass'], 'affiliations': ['Academia Sinica, Taiwan', 'Massachusetts Institute of Technology, USA', 'National Taiwan University, Taiwan'], 'pdf_title_img': 'assets/pdf/title_img/2509.26388.jpg', 'data': {'categories': ['#audio', '#alignment', '#benchmark', '#games'], 'emoji': '⏱️', 'ru': {'title': 'Когда AI не попадает в такт: тестируем разговорные модели на чувство времени', 'desc': 'Исследователи представили Game-Time Benchmark — новый бенчмарк для оценки способности разговорных речевых language models управлять временными аспектами диалога. Тестирование включает базовые задачи на следование инструкциям и продвинутые задачи с временными ограничениями, такие как соблюдение темпа и синхронизированные ответы. Результаты показывают, что современные модели хорошо справляются с простыми задачами, но значительно деградируют при добавлении временных требований. Бенчмарк выявил критические слабости в temporal awareness и full-duplex взаимодействии у практически всех протестированных систем.'}, 'en': {'title': 'Enhancing Conversational AI with Temporal Awareness', 'desc': 'The paper introduces the Game-Time Benchmark, a new framework designed to evaluate the temporal dynamics of conversational spoken language models (SLMs). It focuses on assessing how well these models can manage timing, tempo, and simultaneous speech, which are crucial for natural conversation. The study reveals that while advanced models perform adequately on basic tasks, they struggle significantly with instruction-following and temporal constraints. This highlights the need for improved time awareness and full-duplex interaction in future conversational AI systems.'}, 'zh': {'title': '评估对话式AI的时间动态能力', 'desc': '本论文介绍了一个名为Game-Time Benchmark的评估框架，旨在评估对话式口语语言模型在时间动态和实时交互能力方面的表现。研究发现，尽管当前的先进模型在基本任务上表现良好，但在指令遵循和时间约束下的任务中仍存在显著的性能差距。几乎所有模型在时间约束下的表现都显著下降，显示出它们在时间意识和全双工交互方面的持续弱点。Game-Time Benchmark为未来研究提供了一个基础，旨在推动更具时间意识的对话式人工智能的发展。'}}}, {'id': 'https://huggingface.co/papers/2510.03230', 'title': 'Improving GUI Grounding with Explicit Position-to-Coordinate Mapping', 'url': 'https://huggingface.co/papers/2510.03230', 'abstract': 'Explicit coordinate markers and improved spatial encoding enhance GUI grounding accuracy across diverse resolutions and platforms.  \t\t\t\t\tAI-generated summary \t\t\t\t GUI grounding, the task of mapping natural-language instructions to pixel coordinates, is crucial for autonomous agents, yet remains difficult for current VLMs. The core bottleneck is reliable patch-to-pixel mapping, which breaks when extrapolating to high-resolution displays unseen during training. Current approaches generate coordinates as text tokens directly from visual features, forcing the model to infer complex position-to-pixel mappings implicitly; as a result, accuracy degrades and failures proliferate on new resolutions. We address this with two complementary innovations. First, RULER tokens serve as explicit coordinate markers, letting the model reference positions similar to gridlines on a map and adjust rather than generate coordinates from scratch. Second, Interleaved MRoPE (I-MRoPE) improves spatial encoding by ensuring that width and height dimensions are represented equally, addressing the asymmetry of standard positional schemes. Experiments on ScreenSpot, ScreenSpot-V2, and ScreenSpot-Pro show consistent gains in grounding accuracy, with the largest improvements on high-resolution interfaces. By providing explicit spatial guidance rather than relying on implicit learning, our approach enables more reliable GUI automation across diverse resolutions and platforms.', 'score': 2, 'issue_id': 6252, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '8911479d98450376', 'authors': ['Suyuchen Wang', 'Tianyu Zhang', 'Ahmed Masry', 'Christopher Pal', 'Spandana Gella', 'Bang Liu', 'Perouz Taslakian'], 'affiliations': ['CIFAR AI Chair', 'McGill University', 'Mila - Quebec AI Institute', 'Polytechnique Montreal', 'ServiceNow', 'Universite de Montreal', 'York University'], 'pdf_title_img': 'assets/pdf/title_img/2510.03230.jpg', 'data': {'categories': ['#interpretability', '#agents', '#cv', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Явные координаты вместо угадывания: как научить модели точно находить элементы интерфейса', 'desc': 'Статья посвящена проблеме GUI grounding — задаче сопоставления текстовых инструкций с координатами пикселей на экране, что критично для автономных AI-агентов. Основная сложность заключается в том, что современные vision-language модели плохо экстраполируют на высокие разрешения экранов, не встреченные при обучении. Авторы предлагают два решения: RULER tokens — явные маркеры координат, работающие как линии сетки на карте, и Interleaved MRoPE (I-MRoPE) — улучшенное позиционное кодирование, которое равномерно представляет ширину и высоту. Эксперименты показывают значительное улучшение точности определения элементов интерфейса, особенно на экранах высокого разрешения.'}, 'en': {'title': 'Enhancing GUI Grounding with Explicit Spatial Markers', 'desc': 'This paper focuses on improving GUI grounding, which is the process of translating natural language commands into specific pixel locations on a screen. The authors identify that existing vision-language models (VLMs) struggle with high-resolution displays due to their reliance on implicit mappings from visual features to pixel coordinates. To overcome this, they introduce RULER tokens as explicit coordinate markers, allowing the model to reference positions more accurately. Additionally, they propose Interleaved MRoPE (I-MRoPE) to enhance spatial encoding, ensuring that both width and height are treated equally, leading to significant improvements in grounding accuracy across various resolutions.'}, 'zh': {'title': '提升GUI定位准确性的创新方法', 'desc': '本文探讨了图形用户界面（GUI）定位的挑战，尤其是在高分辨率显示器上的准确性问题。当前的视觉语言模型（VLMs）在将自然语言指令映射到像素坐标时，面临着可靠的补丁到像素映射的瓶颈。为了解决这个问题，作者提出了两种创新方法：使用RULER标记作为明确的坐标标记，以及改进空间编码的交错MRoPE（I-MRoPE）。实验结果表明，这些方法在不同分辨率和平台上显著提高了GUI定位的准确性。'}}}, {'id': 'https://huggingface.co/papers/2510.01459', 'title': 'LSPO: Length-aware Dynamic Sampling for Policy Optimization in LLM\n  Reasoning', 'url': 'https://huggingface.co/papers/2510.01459', 'abstract': 'Length-aware Sampling for Policy Optimization (LSPO) is a meta-RLVR algorithm that dynamically selects training data based on response length, improving learning effectiveness in large language models.  \t\t\t\t\tAI-generated summary \t\t\t\t Since the release of Deepseek-R1, reinforcement learning with verifiable rewards (RLVR) has become a central approach for training large language models (LLMs) on reasoning tasks. Recent work has largely focused on modifying loss functions to make RLVR more efficient and effective. In this paper, motivated by studies of overthinking in LLMs, we propose Length-aware Sampling for Policy Optimization (LSPO), a novel meta-RLVR algorithm that dynamically selects training data at each step based on the average response length. We evaluate LSPO across multiple base models and datasets, demonstrating that it consistently improves learning effectiveness. In addition, we conduct a detailed ablation study to examine alternative ways of incorporating length signals into dynamic sampling, offering further insights and highlighting promising directions for future research.', 'score': 2, 'issue_id': 6255, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '5ec42f3bafd0af56', 'authors': ['Weizhe Chen', 'Sven Koenig', 'Bistra Dilkina'], 'affiliations': ['University of California, Irvine', 'University of Southern California'], 'pdf_title_img': 'assets/pdf/title_img/2510.01459.jpg', 'data': {'categories': ['#optimization', '#rlhf', '#training', '#rl', '#reasoning'], 'emoji': '📏', 'ru': {'title': 'Учёт длины ответов для эффективного обучения LLM', 'desc': 'В статье представлен LSPO — мета-алгоритм обучения с подкреплением, который динамически выбирает обучающие данные на основе длины ответов модели. Это помогает бороться с проблемой «overthinking» (избыточных рассуждений) в больших языковых моделях при решении задач, требующих reasoning. Алгоритм показывает стабильное улучшение эффективности обучения на разных базовых моделях и датасетах по сравнению со стандартным RLVR. Авторы также проводят детальный ablation study различных способов использования информации о длине ответов для динамического сэмплирования данных.'}, 'en': {'title': 'Optimizing Learning with Length-Aware Sampling', 'desc': 'Length-aware Sampling for Policy Optimization (LSPO) is a new algorithm designed to enhance the training of large language models (LLMs) using reinforcement learning with verifiable rewards (RLVR). It focuses on selecting training data based on the average length of responses, which helps the model learn more effectively. The paper shows that LSPO improves learning outcomes across various models and datasets. Additionally, it includes an ablation study that explores different methods of integrating length information into the sampling process, providing valuable insights for future research.'}, 'zh': {'title': '长度感知采样：提升大语言模型学习效果的关键', 'desc': '本文提出了一种新的元强化学习算法，称为长度感知采样（LSPO），旨在提高大语言模型的学习效果。LSPO通过动态选择训练数据，依据响应的平均长度来优化策略。我们在多个基础模型和数据集上评估了LSPO，结果表明其在学习效果上具有一致的提升。通过详细的消融研究，我们探讨了将长度信号融入动态采样的其他方法，为未来的研究提供了有价值的见解。'}}}, {'id': 'https://huggingface.co/papers/2509.25771', 'title': 'Free Lunch Alignment of Text-to-Image Diffusion Models without\n  Preference Image Pairs', 'url': 'https://huggingface.co/papers/2509.25771', 'abstract': 'A new framework, Text Preference Optimization (TPO), aligns text-to-image models with human preferences without requiring paired image preference data, improving text-to-image alignment and human preference scores.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in diffusion-based text-to-image (T2I) models have led to remarkable success in generating high-quality images from textual prompts. However, ensuring accurate alignment between the text and the generated image remains a significant challenge for state-of-the-art diffusion models. To address this, existing studies employ reinforcement learning with human feedback (RLHF) to align T2I outputs with human preferences. These methods, however, either rely directly on paired image preference data or require a learned reward function, both of which depend heavily on costly, high-quality human annotations and thus face scalability limitations. In this work, we introduce Text Preference Optimization (TPO), a framework that enables "free-lunch" alignment of T2I models, achieving alignment without the need for paired image preference data. TPO works by training the model to prefer matched prompts over mismatched prompts, which are constructed by perturbing original captions using a large language model. Our framework is general and compatible with existing preference-based algorithms. We extend both DPO and KTO to our setting, resulting in TDPO and TKTO. Quantitative and qualitative evaluations across multiple benchmarks show that our methods consistently outperform their original counterparts, delivering better human preference scores and improved text-to-image alignment. Our Open-source code is available at https://github.com/DSL-Lab/T2I-Free-Lunch-Alignment.', 'score': 2, 'issue_id': 6253, 'pub_date': '2025-09-30', 'pub_date_card': {'ru': '30 сентября', 'en': 'September 30', 'zh': '9月30日'}, 'hash': '6c93440c081695bd', 'authors': ['Jia Jun Cheng Xian', 'Muchen Li', 'Haotian Yang', 'Xin Tao', 'Pengfei Wan', 'Leonid Sigal', 'Renjie Liao'], 'affiliations': ['Canada CIFAR AI Chair', 'Kling Team, Kuaishou Technology', 'University of British Columbia', 'Vector Institute for AI'], 'pdf_title_img': 'assets/pdf/title_img/2509.25771.jpg', 'data': {'categories': ['#open_source', '#alignment', '#benchmark', '#rlhf', '#multimodal', '#diffusion'], 'emoji': '🎯', 'ru': {'title': 'Бесплатное выравнивание: обучение без парных предпочтений', 'desc': 'Представлен фреймворк Text Preference Optimization (TPO) для выравнивания text-to-image моделей с человеческими предпочтениями без использования парных данных о предпочтениях изображений. Метод обучает модель предпочитать правильные текстовые промпты перед искажёнными версиями, которые создаются с помощью LLM. TPO совместим с существующими алгоритмами на основе предпочтений, такими как DPO и KTO, расширяя их до версий TDPO и TKTO. Эксперименты показывают стабильное улучшение качества выравнивания текста с изображением и более высокие оценки человеческих предпочтений по сравнению с оригинальными методами.'}, 'en': {'title': 'Aligning Text and Images: A Free-Lunch Approach!', 'desc': 'The paper introduces a new framework called Text Preference Optimization (TPO) that enhances the alignment of text-to-image (T2I) models with human preferences without needing paired image preference data. This approach addresses the limitations of existing methods that rely on costly human annotations and reinforcement learning with human feedback (RLHF). TPO trains models to prefer correctly matched text-image pairs over mismatched ones, using perturbations generated by a large language model. The results demonstrate that TPO significantly improves human preference scores and T2I alignment compared to traditional methods, making it a scalable solution for better image generation.'}, 'zh': {'title': '文本偏好优化：无须配对数据的对齐新方法', 'desc': '本文提出了一种新的框架，称为文本偏好优化（TPO），旨在在不需要配对图像偏好数据的情况下，使文本到图像模型与人类偏好对齐。该框架通过训练模型更倾向于匹配的提示，而不是通过扰动原始标题生成的不匹配提示，从而实现对齐。TPO与现有的基于偏好的算法兼容，并扩展了DPO和KTO，形成了TDPO和TKTO。实验结果表明，TPO在多个基准测试中表现优于传统方法，提供了更好的文本到图像对齐和人类偏好评分。'}}}, {'id': 'https://huggingface.co/papers/2510.03232', 'title': 'LEAML: Label-Efficient Adaptation to Out-of-Distribution Visual Tasks\n  for Multimodal Large Language Models', 'url': 'https://huggingface.co/papers/2510.03232', 'abstract': 'LEAML, a label-efficient adaptation framework, enhances MLLMs for specialized domains by generating pseudo question-answer pairs and selectively updating relevant neurons, outperforming standard fine-tuning with minimal supervision.  \t\t\t\t\tAI-generated summary \t\t\t\t Multimodal Large Language Models (MLLMs) have achieved strong performance on general visual benchmarks but struggle with out-of-distribution (OOD) tasks in specialized domains such as medical imaging, where labeled data is limited and expensive. We introduce LEAML, a label-efficient adaptation framework that leverages both scarce labeled VQA samples and abundant unlabeled images. Our approach generates domain-relevant pseudo question-answer pairs for unlabeled data using a QA generator regularized by caption distillation. Importantly, we selectively update only those neurons most relevant to question-answering, enabling the QA Generator to efficiently acquire domain-specific knowledge during distillation. Experiments on gastrointestinal endoscopy and sports VQA demonstrate that LEAML consistently outperforms standard fine-tuning under minimal supervision, highlighting the effectiveness of our proposed LEAML framework.', 'score': 1, 'issue_id': 6259, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '3d1a4f894029f711', 'authors': ['Ci-Siang Lin', 'Min-Hung Chen', 'Yu-Yang Sheng', 'Yu-Chiang Frank Wang'], 'affiliations': ['Graduate Institute of Communication Engineering, National Taiwan University, Taiwan', 'NVIDIA'], 'pdf_title_img': 'assets/pdf/title_img/2510.03232.jpg', 'data': {'categories': ['#optimization', '#data', '#dataset', '#multimodal', '#training', '#transfer_learning', '#healthcare'], 'emoji': '🎯', 'ru': {'title': 'Эффективная адаптация мультимодальных LLM с минимальной разметкой', 'desc': 'LEAML — это фреймворк для адаптации мультимодальных больших языковых моделей к специализированным доменам при ограниченных размеченных данных. Метод генерирует псевдо-пары вопрос-ответ для неразмеченных изображений с помощью QA-генератора, регуляризованного дистилляцией описаний. Ключевая особенность — селективное обновление только тех нейронов, которые наиболее релевантны для задачи вопросов и ответов. Эксперименты на медицинских изображениях эндоскопии и спортивных данных показали превосходство над стандартным файн-тюнингом при минимальной разметке.'}, 'en': {'title': 'Efficient Learning with LEAML: Mastering Specialized Domains with Minimal Labels', 'desc': 'LEAML is a framework designed to improve Multimodal Large Language Models (MLLMs) for specialized fields with limited labeled data. It creates pseudo question-answer pairs from unlabeled images, which helps the model learn relevant information without needing extensive supervision. By focusing on updating only the neurons that are crucial for question-answering, LEAML efficiently incorporates domain-specific knowledge. Experiments show that this method surpasses traditional fine-tuning techniques, making it a powerful tool for tasks like medical imaging and sports analysis.'}, 'zh': {'title': 'LEAML：高效适应专业领域的标签框架', 'desc': 'LEAML是一种标签高效的适应框架，旨在增强多模态大语言模型（MLLMs）在专业领域的表现。它通过生成伪问题-答案对，并选择性地更新与问题回答相关的神经元，来提高模型的适应能力。该方法利用稀缺的标记样本和丰富的未标记图像，能够在数据有限的情况下有效学习。实验结果表明，LEAML在内窥镜和体育视觉问答任务中，表现优于标准微调方法，证明了其有效性。'}}}, {'id': 'https://huggingface.co/papers/2510.03160', 'title': 'SpineBench: A Clinically Salient, Level-Aware Benchmark Powered by the\n  SpineMed-450k Corpus', 'url': 'https://huggingface.co/papers/2510.03160', 'abstract': "SpineMed, an ecosystem with SpineMed-450k and SpineBench, addresses the lack of level-aware, multimodal datasets and benchmarks for AI-assisted diagnosis of spine disorders, improving model performance through fine-grained, level-specific reasoning.  \t\t\t\t\tAI-generated summary \t\t\t\t Spine disorders affect 619 million people globally and are a leading cause of disability, yet AI-assisted diagnosis remains limited by the lack of level-aware, multimodal datasets. Clinical decision-making for spine disorders requires sophisticated reasoning across X-ray, CT, and MRI at specific vertebral levels. However, progress has been constrained by the absence of traceable, clinically-grounded instruction data and standardized, spine-specific benchmarks. To address this, we introduce SpineMed, an ecosystem co-designed with practicing spine surgeons. It features SpineMed-450k, the first large-scale dataset explicitly designed for vertebral-level reasoning across imaging modalities with over 450,000 instruction instances, and SpineBench, a clinically-grounded evaluation framework. SpineMed-450k is curated from diverse sources, including textbooks, guidelines, open datasets, and ~1,000 de-identified hospital cases, using a clinician-in-the-loop pipeline with a two-stage LLM generation method (draft and revision) to ensure high-quality, traceable data for question-answering, multi-turn consultations, and report generation. SpineBench evaluates models on clinically salient axes, including level identification, pathology assessment, and surgical planning. Our comprehensive evaluation of several recently advanced large vision-language models (LVLMs) on SpineBench reveals systematic weaknesses in fine-grained, level-specific reasoning. In contrast, our model fine-tuned on SpineMed-450k demonstrates consistent and significant improvements across all tasks. Clinician assessments confirm the diagnostic clarity and practical utility of our model's outputs.", 'score': 1, 'issue_id': 6253, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': 'bd9504c9850d0415', 'authors': ['Ming Zhao', 'Wenhui Dong', 'Yang Zhang', 'Xiang Zheng', 'Zhonghao Zhang', 'Zian Zhou', 'Yunzhi Guan', 'Liukun Xu', 'Wei Peng', 'Zhaoyang Gong', 'Zhicheng Zhang', 'Dachuan Li', 'Xiaosheng Ma', 'Yuli Ma', 'Jianing Ni', 'Changjiang Jiang', 'Lixia Tian', 'Qixin Chen', 'Kaishun Xia', 'Pingping Liu', 'Tongshun Zhang', 'Zhiqiang Liu', 'Zhongan Bi', 'Chenyang Si', 'Tiansheng Sun', 'Caifeng Shan'], 'affiliations': ['Beijing Jiaotong University', 'Institute of Automation, Chinese Academy of Sciences', 'Jilin University', 'Nanjing University', 'Ningxia University', 'Stanford University', 'The General Hospital of the Peoples Liberation Army', 'Wuhan University', 'Zhejiang University', 'π3 Lab'], 'pdf_title_img': 'assets/pdf/title_img/2510.03160.jpg', 'data': {'categories': ['#reasoning', '#training', '#healthcare', '#benchmark', '#dataset', '#multimodal', '#science'], 'emoji': '🦴', 'ru': {'title': 'SpineMed: AI-система для точной диагностики позвоночника на уровне отдельных позвонков', 'desc': 'Статья представляет SpineMed — экосистему для AI-диагностики заболеваний позвоночника, включающую датасет SpineMed-450k с 450 тысячами примеров и бенчмарк SpineBench. Ключевая особенность — способность моделей анализировать конкретные уровни позвонков на рентгене, КТ и МРТ, что критично для клинической диагностики. Датасет создан при участии практикующих хирургов с использованием двухэтапной генерации данных через LLM (черновик и ревизия). Эксперименты показали, что современные vision-language модели плохо справляются с детальным анализом конкретных позвонков, но файн-тюнинг на SpineMed-450k значительно улучшает качество диагностики.'}, 'en': {'title': 'Revolutionizing Spine Disorder Diagnosis with Level-Aware AI', 'desc': 'The paper introduces SpineMed, an innovative ecosystem designed to enhance AI-assisted diagnosis of spine disorders by providing level-aware, multimodal datasets and benchmarks. It features SpineMed-450k, a large-scale dataset with over 450,000 instances specifically curated for vertebral-level reasoning using a clinician-in-the-loop approach. The accompanying SpineBench framework allows for comprehensive evaluation of AI models on critical clinical tasks such as level identification and pathology assessment. Results show that models fine-tuned on SpineMed-450k significantly outperform existing large vision-language models in fine-grained reasoning, demonstrating improved diagnostic clarity and utility in clinical settings.'}, 'zh': {'title': '脊柱疾病AI诊断的新突破', 'desc': 'SpineMed是一个针对脊柱疾病的人工智能辅助诊断生态系统，包含SpineMed-450k数据集和SpineBench评估框架。该系统解决了缺乏针对脊柱特定层次的多模态数据集的问题，提供了超过45万个高质量的指令实例。通过与脊柱外科医生合作，SpineMed确保了数据的临床相关性和可追溯性。我们的研究表明，基于SpineMed-450k微调的模型在各项任务中表现出显著的性能提升。'}}}, {'id': 'https://huggingface.co/papers/2510.02880', 'title': 'Consolidating Reinforcement Learning for Multimodal Discrete Diffusion\n  Models', 'url': 'https://huggingface.co/papers/2510.02880', 'abstract': 'MaskGRPO addresses challenges in optimizing discrete diffusion models with rewards through effective importance sampling and modality-specific adaptations, improving reasoning and generation quality.  \t\t\t\t\tAI-generated summary \t\t\t\t Optimizing discrete diffusion model (DDM) with rewards remains a challenge: the non-autoregressive paradigm makes importance sampling intractable and rollout complex, puzzling reinforcement learning methods such as Group Relative Policy Optimization (GRPO). In this study, we introduce MaskGRPO, the first viable approach to enable scalable multimodal reinforcement learning in discrete diffusion with effective importance sampling and modality-specific adaptations. To this end, we first clarify the theoretical foundation for DDMs, which facilitates building an importance estimator that captures valuable token fluctuation for gradient updates. We then delicately tailored the rollout method for visual sequences, which yields diverse completions and reliable optimization gradients. Upon math reasoning, coding, and visual generation benchmarks, MaskGRPO brings more stable and efficient updates, leading to stronger reasoning performance and better generation quality. This study establishes MaskGRPO as a systematic policy optimization approach and the first practical way for discretized visual diffusion.', 'score': 1, 'issue_id': 6264, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '3b4f72f256d26be3', 'authors': ['Tianren Ma', 'Mu Zhang', 'Yibing Wang', 'Qixiang Ye'], 'affiliations': ['University of Chinese Academy of Sciences'], 'pdf_title_img': 'assets/pdf/title_img/2510.02880.jpg', 'data': {'categories': ['#architecture', '#rlhf', '#multimodal', '#benchmark', '#math', '#diffusion', '#reasoning', '#optimization', '#rl'], 'emoji': '🎭', 'ru': {'title': 'Эффективная оптимизация дискретных диффузионных моделей через обучение с подкреплением', 'desc': 'Статья представляет MaskGRPO — первый практический метод применения reinforcement learning к дискретным диффузионным моделям (DDM). Ключевая проблема заключалась в том, что неавторегрессивная природа DDM делала importance sampling неосуществимым, что мешало использованию стандартных методов оптимизации политик. Авторы разработали теоретическую основу для корректной оценки importance weights и адаптировали метод rollout специально для визуальных последовательностей. Эксперименты показали улучшение качества в задачах математического рассуждения, программирования и генерации изображений.'}, 'en': {'title': 'MaskGRPO: Revolutionizing Discrete Diffusion Model Optimization', 'desc': 'MaskGRPO is a novel method designed to enhance the optimization of discrete diffusion models (DDMs) using rewards. It tackles the difficulties of importance sampling and rollout in non-autoregressive settings, which are common in reinforcement learning. By developing a robust importance estimator and a tailored rollout strategy for visual sequences, MaskGRPO improves the quality of reasoning and generation in multimodal tasks. This approach not only stabilizes updates but also leads to superior performance in various benchmarks, marking a significant advancement in policy optimization for discrete visual diffusion.'}, 'zh': {'title': 'MaskGRPO：优化离散扩散模型的新方法', 'desc': 'MaskGRPO 解决了在优化离散扩散模型时面临的挑战，特别是在使用奖励进行优化时。通过有效的重要性采样和特定模态的适应，MaskGRPO 提高了推理和生成的质量。我们首先阐明了离散扩散模型的理论基础，以便构建一个能够捕捉有价值的标记波动的重要性估计器。最终，MaskGRPO 在数学推理、编码和视觉生成基准测试中表现出更稳定和高效的更新，提升了推理性能和生成质量。'}}}, {'id': 'https://huggingface.co/papers/2510.02571', 'title': 'How Confident are Video Models? Empowering Video Models to Express their\n  Uncertainty', 'url': 'https://huggingface.co/papers/2510.02571', 'abstract': 'A framework for uncertainty quantification in generative video models is introduced, including a metric for calibration, a black-box method called S-QUBED, and a benchmark dataset, demonstrating improved uncertainty estimates and task accuracy.  \t\t\t\t\tAI-generated summary \t\t\t\t Generative video models demonstrate impressive text-to-video capabilities, spurring widespread adoption in many real-world applications. However, like large language models (LLMs), video generation models tend to hallucinate, producing plausible videos even when they are factually wrong. Although uncertainty quantification (UQ) of LLMs has been extensively studied in prior work, no UQ method for video models exists, raising critical safety concerns. To our knowledge, this paper represents the first work towards quantifying the uncertainty of video models. We present a framework for uncertainty quantification of generative video models, consisting of: (i) a metric for evaluating the calibration of video models based on robust rank correlation estimation with no stringent modeling assumptions; (ii) a black-box UQ method for video models (termed S-QUBED), which leverages latent modeling to rigorously decompose predictive uncertainty into its aleatoric and epistemic components; and (iii) a UQ dataset to facilitate benchmarking calibration in video models. By conditioning the generation task in the latent space, we disentangle uncertainty arising due to vague task specifications from that arising from lack of knowledge. Through extensive experiments on benchmark video datasets, we demonstrate that S-QUBED computes calibrated total uncertainty estimates that are negatively correlated with the task accuracy and effectively computes the aleatoric and epistemic constituents.', 'score': 1, 'issue_id': 6252, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '6e5849ca43586c8a', 'authors': ['Zhiting Mei', 'Ola Shorinwa', 'Anirudha Majumdar'], 'affiliations': ['Princeton University'], 'pdf_title_img': 'assets/pdf/title_img/2510.02571.jpg', 'data': {'categories': ['#optimization', '#benchmark', '#hallucinations', '#dataset', '#video'], 'emoji': '🎬', 'ru': {'title': 'Когда AI не уверен в своём видео', 'desc': 'Исследователи представили первый фреймворк для количественной оценки неопределённости в генеративных видеомоделях, которые, как и LLM, склонны к галлюцинациям. Разработан метод S-QUBED, разделяющий неопределённость на алеаторную (из-за неясных формулировок задачи) и эпистемическую (из-за недостатка знаний модели) компоненты через моделирование в латентном пространстве. Предложена метрика калибровки на основе ранговой корреляции и создан специальный benchmark-датасет для оценки. Эксперименты показали, что метод даёт калиброванные оценки неопределённости, которые коррелируют с точностью выполнения задач.'}, 'en': {'title': 'Quantifying Uncertainty in Generative Video Models for Safer AI', 'desc': "This paper introduces a new framework for measuring uncertainty in generative video models, which is crucial for ensuring their reliability in real-world applications. It presents a novel metric for assessing how well these models predict uncertainty, along with a black-box method called S-QUBED that separates different types of uncertainty. The framework also includes a benchmark dataset to evaluate the performance of video models in terms of their uncertainty calibration. Through experiments, the authors show that S-QUBED provides accurate uncertainty estimates that correlate with the models' task performance, addressing safety concerns in video generation."}, 'zh': {'title': '生成视频模型的不确定性量化新框架', 'desc': '本文提出了一种用于生成视频模型的不确定性量化框架，包括一个用于校准的度量标准、一种称为S-QUBED的黑箱方法，以及一个基准数据集。生成视频模型在文本到视频的能力上表现出色，但也存在幻觉现象，即生成的内容可能在事实上一无是处。尽管对大型语言模型的不确定性量化已有大量研究，但目前尚无针对视频模型的不确定性量化方法，这引发了安全隐患。我们的研究首次量化了视频模型的不确定性，并通过实验验证了S-QUBED在校准总不确定性估计方面的有效性。'}}}, {'id': 'https://huggingface.co/papers/2510.01698', 'title': 'TalkPlay-Tools: Conversational Music Recommendation with LLM Tool\n  Calling', 'url': 'https://huggingface.co/papers/2510.01698', 'abstract': 'A unified LLM-based music recommendation system with tool calling integrates various retrieval methods to enhance user intent interpretation and recommendation performance.  \t\t\t\t\tAI-generated summary \t\t\t\t While the recent developments in large language models (LLMs) have successfully enabled generative recommenders with natural language interactions, their recommendation behavior is limited, leaving other simpler yet crucial components such as metadata or attribute filtering underutilized in the system. We propose an LLM-based music recommendation system with tool calling to serve as a unified retrieval-reranking pipeline. Our system positions an LLM as an end-to-end recommendation system that interprets user intent, plans tool invocations, and orchestrates specialized components: boolean filters (SQL), sparse retrieval (BM25), dense retrieval (embedding similarity), and generative retrieval (semantic IDs). Through tool planning, the system predicts which types of tools to use, their execution order, and the arguments needed to find music matching user preferences, supporting diverse modalities while seamlessly integrating multiple database filtering methods. We demonstrate that this unified tool-calling framework achieves competitive performance across diverse recommendation scenarios by selectively employing appropriate retrieval methods based on user queries, envisioning a new paradigm for conversational music recommendation systems.', 'score': 1, 'issue_id': 6262, 'pub_date': '2025-10-02', 'pub_date_card': {'ru': '2 октября', 'en': 'October 2', 'zh': '10月2日'}, 'hash': '55d713420ebe8cf9', 'authors': ['Seungheon Doh', 'Keunwoo Choi', 'Juhan Nam'], 'affiliations': ['KAIST, South Korea', 'talkpl.ai, USA'], 'pdf_title_img': 'assets/pdf/title_img/2510.01698.jpg', 'data': {'categories': ['#games', '#multimodal', '#rag', '#interpretability'], 'emoji': '🎵', 'ru': {'title': 'LLM как дирижёр музыкальных рекомендаций', 'desc': 'Исследователи создали систему музыкальных рекомендаций на основе LLM, которая использует механизм вызова инструментов (tool calling) для интеграции различных методов поиска. Система интерпретирует намерения пользователя и оркестрирует специализированные компоненты: булевы фильтры SQL, разреженный поиск BM25, плотный поиск через эмбеддинги и генеративный поиск по семантическим ID. LLM планирует, какие инструменты использовать, в каком порядке и с какими аргументами, чтобы найти музыку по предпочтениям пользователя. Такой унифицированный подход показывает конкурентную производительность в различных сценариях рекомендаций, выбирая подходящие методы поиска в зависимости от запроса пользователя.'}, 'en': {'title': 'Revolutionizing Music Recommendations with LLMs and Tool Calling', 'desc': "This paper presents a novel music recommendation system that utilizes large language models (LLMs) to better understand user preferences and improve recommendation accuracy. The system integrates various retrieval methods, including boolean filters, sparse retrieval, dense retrieval, and generative retrieval, to create a comprehensive pipeline for music recommendations. By employing tool calling, the LLM can determine the best retrieval methods to use based on the user's intent and the context of the query. The results show that this unified approach enhances the performance of music recommendations across different scenarios, paving the way for more effective conversational systems."}, 'zh': {'title': '统一的音乐推荐系统：智能工具调用的新时代', 'desc': '本文提出了一种基于大型语言模型（LLM）的音乐推荐系统，结合了多种检索方法以增强用户意图的理解和推荐效果。该系统通过工具调用，作为一个统一的检索-重排序管道，能够更好地解释用户的需求。系统利用布尔过滤器、稀疏检索、密集检索和生成检索等多种组件，灵活地选择合适的工具和执行顺序，以满足用户的音乐偏好。实验表明，这种统一的工具调用框架在多种推荐场景中表现出色，展现了对话式音乐推荐系统的新范式。'}}}, {'id': 'https://huggingface.co/papers/2510.01329', 'title': 'Continuously Augmented Discrete Diffusion model for Categorical\n  Generative Modeling', 'url': 'https://huggingface.co/papers/2510.01329', 'abstract': "Continuously Augmented Discrete Diffusion (CADD) enhances generative quality by integrating a continuous latent space into discrete diffusion models, providing informative latent vectors for masked tokens and improving mode-coverage and mode-seeking behaviors.  \t\t\t\t\tAI-generated summary \t\t\t\t Standard discrete diffusion models treat all unobserved states identically by mapping them to an absorbing [MASK] token. This creates an 'information void' where semantic information that could be inferred from unmasked tokens is lost between denoising steps. We introduce Continuously Augmented Discrete Diffusion (CADD), a framework that augments the discrete state space with a paired diffusion in a continuous latent space. This yields graded, gradually corrupted states in which masked tokens are represented by noisy yet informative latent vectors rather than collapsed 'information voids'. At each reverse step, CADD may leverage the continuous latent as a semantic hint to guide discrete denoising. The design is clean and compatible with existing discrete diffusion training. At sampling time, the strength and choice of estimator for the continuous latent vector enables a controlled trade-off between mode-coverage (generating diverse outputs) and mode-seeking (generating contextually precise outputs) behaviors. Empirically, we demonstrate CADD improves generative quality over mask-based diffusion across text generation, image synthesis, and code modeling, with consistent gains on both qualitative and quantitative metrics against strong discrete baselines.", 'score': 1, 'issue_id': 6266, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': 'ebfe526a7feeb967', 'authors': ['Huangjie Zheng', 'Shansan Gong', 'Ruixiang Zhang', 'Tianrong Chen', 'Jiatao Gu', 'Mingyuan Zhou', 'Navdeep Jaitly', 'Yizhe Zhang'], 'affiliations': ['Apple'], 'pdf_title_img': 'assets/pdf/title_img/2510.01329.jpg', 'data': {'categories': ['#diffusion', '#cv', '#multimodal'], 'emoji': '🎭', 'ru': {'title': 'Непрерывные подсказки для дискретной диффузии', 'desc': 'Стандартные дискретные диффузионные модели заменяют все неизвестные токены на специальный токен [MASK], теряя при этом семантическую информацию. CADD решает эту проблему, добавляя непрерывное латентное пространство, где замаскированные токены представлены информативными векторами вместо пустых масок. Это позволяет модели использовать семантические подсказки на каждом шаге генерации и контролировать баланс между разнообразием и точностью результатов. Метод показывает улучшение качества генерации текста, изображений и кода по сравнению с базовыми дискретными моделями.'}, 'en': {'title': 'Enhancing Generative Quality with Continuous Latent Spaces', 'desc': "Continuously Augmented Discrete Diffusion (CADD) improves generative models by combining discrete diffusion with a continuous latent space. This approach addresses the 'information void' problem in standard models, where unobserved states lose semantic information. By using noisy yet informative latent vectors for masked tokens, CADD enhances the denoising process and allows for better guidance during generation. The framework not only boosts generative quality across various tasks but also offers a flexible balance between generating diverse and contextually accurate outputs."}, 'zh': {'title': '提升生成质量的连续增强离散扩散模型', 'desc': '连续增强离散扩散（CADD）通过将连续潜在空间整合到离散扩散模型中，提升了生成质量。该方法为被遮蔽的标记提供了信息丰富的潜在向量，改善了模式覆盖和模式寻求行为。CADD框架通过在连续潜在空间中配对扩散，增强了离散状态空间，使得被遮蔽的标记由噪声但信息丰富的潜在向量表示，而不是信息空洞。实验证明，CADD在文本生成、图像合成和代码建模等任务中，相较于强大的离散基线，生成质量有了显著提升。'}}}, {'id': 'https://huggingface.co/papers/2510.01132', 'title': "A Practitioner's Guide to Multi-turn Agentic Reinforcement Learning", 'url': 'https://huggingface.co/papers/2510.01132', 'abstract': "Research identifies key design choices for training large language models as agents via multi-turn reinforcement learning, focusing on environment complexity, reward sparsity, and policy methods.  \t\t\t\t\tAI-generated summary \t\t\t\t We study what actually works and what doesn't for training large language models as agents via multi-turn reinforcement learning. Despite rapid progress, existing frameworks and definitions are fragmented, and there is no systematic formulation or analysis of which design choices matter across tasks. We address this gap by first breaking down the design space into three inter-related pillars -- environment, reward, and policy -- and empirically derive a recipe for training LLM agents in situated textual domains. In particular, we test TextWorld and ALFWorld, popular domains for testing situated embodied reasoning, as well as SWE-Gym for more software engineering style tasks. (i) For the environment, we analyze the impacts of task complexity in terms of sizes of the state and action spaces as well as optimal solution length, finding that even simple environments within a domain can provide signal on how well an agent can generalize to more complex tasks. (ii) For the reward, we ablate relative reward sparsity, observing that while dense turn-level rewards accelerate training, performance and stability is highly dependent on the choice of RL algorithm. (iii) And for the agent's policy, we explore the interplay between reward sparsity and biased (PPO, GRPO) and unbiased (RLOO) policy gradient methods in addition to showing how to find the optimal Supervised Fine-tuning (SFT) to RL training ratio given a fixed budget. We distill these findings into a training recipe that guides co-design across the three pillars, facilitating research and practical efforts in multi-turn agentic RL. Code: https://github.com/pearls-lab/meow-tea-taro", 'score': 1, 'issue_id': 6258, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': 'f353f3843a42bf9f', 'authors': ['Ruiyi Wang', 'Prithviraj Ammanabrolu'], 'affiliations': ['NVIDIA', 'University of California, San Diego'], 'pdf_title_img': 'assets/pdf/title_img/2510.01132.jpg', 'data': {'categories': ['#agents', '#games', '#reasoning', '#rlhf', '#training', '#rl', '#optimization'], 'emoji': '🤖', 'ru': {'title': 'Рецепт обучения языковых моделей как агентов через reinforcement learning', 'desc': 'Исследование систематизирует ключевые факторы для обучения LLM в роли агентов через multi-turn reinforcement learning. Авторы разделяют пространство решений на три компонента: среда, награда и политика агента. Эксперименты показывают, что даже простые задачи предсказывают обобщающую способность, плотные награды ускоряют обучение но требуют правильного выбора RL-алгоритма, а соотношение между supervised fine-tuning и RL-тренировкой критично для эффективности. Результаты объединены в практический рецепт совместного дизайна всех трёх компонентов для разработки агентных систем.'}, 'en': {'title': 'Optimizing Training for Language Model Agents in Reinforcement Learning', 'desc': 'This paper investigates how to effectively train large language models (LLMs) as agents using multi-turn reinforcement learning (RL). It identifies three key design choices: the complexity of the environment, the sparsity of rewards, and the methods used for policy optimization. The authors conduct experiments in various domains to understand how these factors influence agent performance and generalization. They provide a systematic framework and a training recipe that integrates these elements to enhance the development of LLM agents in complex tasks.'}, 'zh': {'title': '优化大型语言模型训练的关键设计选择', 'desc': '本研究探讨了通过多轮强化学习训练大型语言模型作为智能体的关键设计选择。我们将设计空间分为环境、奖励和策略三个相互关联的支柱，并通过实证研究提出了一种训练LLM智能体的方案。研究发现，环境的复杂性、奖励的稀疏性以及策略方法对训练效果有显著影响。最终，我们总结出一个训练配方，以指导在多轮智能体强化学习中的共同设计。'}}}, {'id': 'https://huggingface.co/papers/2510.00177', 'title': 'Personalized Reasoning: Just-In-Time Personalization and Why LLMs Fail\n  At It', 'url': 'https://huggingface.co/papers/2510.00177', 'abstract': "PREFDISCO evaluates large language models' personalized reasoning capabilities by transforming static benchmarks into interactive tasks with sparse user preferences, revealing significant limitations in current models' ability to adapt to individual needs.  \t\t\t\t\tAI-generated summary \t\t\t\t Current large language model (LLM) development treats task-solving and preference alignment as separate challenges, optimizing first for objective correctness, then for alignment to aggregated human preferences. This paradigm fails in human-facing applications where solving a problem correctly is insufficient if the response mismatches the user's needs. This challenge intensifies in just-in-time scenarios where no prior user interaction history exists due to cold-start conditions or privacy constraints. LLMs need to identify what they don't know about user preferences, strategically elicit preference values through questioning, then adapt their reasoning processes and responses accordingly -- a complicated chain of cognitive processes which we term personalized reasoning. We introduce PREFDISCO, an evaluation methodology that transforms static benchmarks into interactive personalization tasks using psychologically-grounded personas with sparse preferences. Our framework creates scenarios where identical questions require different reasoning chains depending on user context, as optimal explanation approaches vary by individual expertise and preferences while maintaining factual accuracy. Evaluation of 21 frontier models across 10 tasks reveals 29.0% of naive personalization attempts produce worse preference alignment than generic responses, yet generic responses also fail to serve individual user needs effectively. These findings suggest personalized reasoning requires dedicated development rather than emerging naturally. PREFDISCO establishes personalized reasoning as a measurable research frontier and reveals fundamental limitations in current LLMs' interactive capabilities, providing a foundation for developing systems that can adapt to individual users in education, healthcare, and technical domains where personalization is critical.", 'score': 1, 'issue_id': 6266, 'pub_date': '2025-09-30', 'pub_date_card': {'ru': '30 сентября', 'en': 'September 30', 'zh': '9月30日'}, 'hash': 'ecf9395b444869a8', 'authors': ['Shuyue Stella Li', 'Avinandan Bose', 'Faeze Brahman', 'Simon Shaolei Du', 'Pang Wei Koh', 'Maryam Fazel', 'Yulia Tsvetkov'], 'affiliations': ['Allen Institute for AI', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2510.00177.jpg', 'data': {'categories': ['#healthcare', '#benchmark', '#alignment', '#multimodal', '#reasoning'], 'emoji': '🎯', 'ru': {'title': 'Персонализированное мышление: научить AI адаптироваться к предпочтениям каждого пользователя', 'desc': 'Исследование показывает, что современные LLM не умеют эффективно адаптировать свои ответы под индивидуальные предпочтения пользователей, даже если выдают фактически правильную информацию. Авторы предложили методологию PREFDISCO, которая превращает статичные бенчмарки в интерактивные задачи персонализации с использованием психологически обоснованных персон. Тестирование 21 продвинутой модели показало, что 29% попыток наивной персонализации дают худший результат, чем обычные общие ответы, но и общие ответы тоже плохо удовлетворяют индивидуальным потребностям. Это открывает новое направление исследований — развитие способности к персонализированному мышлению у AI для критически важных областей вроде образования и медицины.'}, 'en': {'title': 'Transforming Language Models for Personalized Reasoning', 'desc': 'PREFDISCO is a new evaluation method that tests how well large language models (LLMs) can adapt their reasoning to meet individual user preferences. It highlights that current LLMs often struggle to align their responses with what users actually need, especially in situations where they have no prior information about the user. The study shows that many attempts at personalization can lead to worse outcomes than generic responses, indicating that simply optimizing for correctness is not enough. This research emphasizes the importance of developing personalized reasoning capabilities in LLMs to improve their effectiveness in real-world applications like education and healthcare.'}, 'zh': {'title': '个性化推理：大型语言模型的新挑战', 'desc': 'PREFDISCO是一种评估大型语言模型个性化推理能力的方法。它通过将静态基准转化为互动任务，揭示了当前模型在适应用户个体需求方面的显著局限性。研究表明，个性化推理需要专门的开发，而不是自然而然地出现。PREFDISCO为个性化推理建立了可测量的研究前沿，并为教育、医疗和技术领域的个性化系统开发提供了基础。'}}}, {'id': 'https://huggingface.co/papers/2509.24975', 'title': 'DiffTester: Accelerating Unit Test Generation for Diffusion LLMs via\n  Repetitive Pattern', 'url': 'https://huggingface.co/papers/2509.24975', 'abstract': 'DiffTester is an acceleration framework for diffusion LLMs in unit test generation, improving efficiency without sacrificing test quality by identifying and leveraging common structural patterns.  \t\t\t\t\tAI-generated summary \t\t\t\t Software development relies heavily on extensive unit testing, which makes the efficiency of automated Unit Test Generation (UTG) particularly important. However, most existing LLMs generate test cases one token at a time in each forward pass, which leads to inefficient UTG. Recently, diffusion LLMs (dLLMs) have emerged, offering promising parallel generation capabilities and showing strong potential for efficient UTG. Despite this advantage, their application to UTG is still constrained by a clear trade-off between efficiency and test quality, since increasing the number of tokens generated in each step often causes a sharp decline in the quality of test cases. To overcome this limitation, we present DiffTester, an acceleration framework specifically tailored for dLLMs in UTG. The key idea of DiffTester is that unit tests targeting the same focal method often share repetitive structural patterns. By dynamically identifying these common patterns through abstract syntax tree analysis during generation, DiffTester adaptively increases the number of tokens produced at each step without compromising the quality of the output. To enable comprehensive evaluation, we extend the original TestEval benchmark, which was limited to Python, by introducing additional programming languages including Java and C++. Extensive experiments on three benchmarks with two representative models show that DiffTester delivers significant acceleration while preserving test coverage. Moreover, DiffTester generalizes well across different dLLMs and programming languages, providing a practical and scalable solution for efficient UTG in software development. Code and data are publicly available at https://github.com/wellbeingyang/DLM4UTG-open .', 'score': 1, 'issue_id': 6262, 'pub_date': '2025-09-29', 'pub_date_card': {'ru': '29 сентября', 'en': 'September 29', 'zh': '9月29日'}, 'hash': '5b0e42c5abd718be', 'authors': ['Lekang Yang', 'Yuetong Liu', 'Yitong Zhang', 'Jia Li'], 'affiliations': ['College of AI, Tsinghua University, Beijing, China', 'School of Computer Science and Engineering, Beihang University, Beijing, China', 'School of Software, Beihang University, Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2509.24975.jpg', 'data': {'categories': ['#diffusion', '#optimization', '#dataset', '#plp', '#benchmark', '#open_source', '#training'], 'emoji': '⚡', 'ru': {'title': 'Ускорение генерации unit-тестов через структурные паттерны', 'desc': 'DiffTester - это фреймворк для ускорения diffusion LLM при генерации unit-тестов. Ключевая идея заключается в том, что тесты для одного метода часто имеют повторяющиеся структурные паттерны, которые можно выявить через анализ абстрактного синтаксического дерева. DiffTester использует эти паттерны для адаптивного увеличения количества токенов, генерируемых за один шаг, не теряя при этом качество тестов. Эксперименты на трёх бенчмарках показали значительное ускорение с сохранением покрытия кода для Python, Java и C++.'}, 'en': {'title': 'Accelerating Unit Test Generation with DiffTester', 'desc': 'DiffTester is a framework designed to enhance the efficiency of unit test generation (UTG) using diffusion large language models (dLLMs). It addresses the common issue where generating multiple tokens at once can reduce the quality of test cases. By analyzing abstract syntax trees, DiffTester identifies and utilizes repetitive structural patterns in unit tests, allowing for faster token generation without sacrificing quality. The framework has been tested across various programming languages and benchmarks, demonstrating significant improvements in UTG performance while maintaining comprehensive test coverage.'}, 'zh': {'title': 'DiffTester：高效单元测试生成的新框架', 'desc': 'DiffTester是一个加速框架，专为扩散大语言模型（dLLMs）在单元测试生成中的应用而设计。它通过识别和利用常见的结构模式，提高了生成效率，同时不牺牲测试质量。DiffTester通过抽象语法树分析动态识别这些重复的结构模式，从而在每一步中适应性地增加生成的标记数量。经过广泛实验，DiffTester在不同的编程语言和dLLMs上表现出良好的通用性，为软件开发中的高效单元测试生成提供了实用的解决方案。'}}}, {'id': 'https://huggingface.co/papers/2510.02730', 'title': 'Dale meets Langevin: A Multiplicative Denoising Diffusion Model', 'url': 'https://huggingface.co/papers/2510.02730', 'abstract': "A biologically inspired generative model using multiplicative updates based on geometric Brownian motion and exponential gradient descent achieves state-of-the-art performance on image datasets.  \t\t\t\t\tAI-generated summary \t\t\t\t Gradient descent has proven to be a powerful and effective technique for optimization in numerous machine learning applications. Recent advances in computational neuroscience have shown that learning in standard gradient descent optimization formulation is not consistent with learning in biological systems. This has opened up interesting avenues for building biologically inspired learning techniques. One such approach is inspired by Dale's law, which states that inhibitory and excitatory synapses do not swap roles during the course of learning. The resulting exponential gradient descent optimization scheme leads to log-normally distributed synaptic weights. Interestingly, the density that satisfies the Fokker-Planck equation corresponding to the stochastic differential equation (SDE) with geometric Brownian motion (GBM) is the log-normal density. Leveraging this connection, we start with the SDE governing geometric Brownian motion, and show that discretizing the corresponding reverse-time SDE yields a multiplicative update rule, which surprisingly, coincides with the sampling equivalent of the exponential gradient descent update founded on Dale's law. Furthermore, we propose a new formalism for multiplicative denoising score-matching, subsuming the loss function proposed by Hyvaerinen for non-negative data. Indeed, log-normally distributed data is positive and the proposed score-matching formalism turns out to be a natural fit. This allows for training of score-based models for image data and results in a novel multiplicative update scheme for sample generation starting from a log-normal density. Experimental results on MNIST, Fashion MNIST, and Kuzushiji datasets demonstrate generative capability of the new scheme. To the best of our knowledge, this is the first instance of a biologically inspired generative model employing multiplicative updates, founded on geometric Brownian motion.", 'score': 0, 'issue_id': 6266, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '6d2103d769cb89c9', 'authors': ['Nishanth Shetty', 'Madhava Prasath', 'Chandra Sekhar Seelamantula'], 'affiliations': ['Department of Electrical Engineering Indian Institute of Science Bengaluru 560012'], 'pdf_title_img': 'assets/pdf/title_img/2510.02730.jpg', 'data': {'categories': ['#diffusion', '#dataset', '#training', '#cv', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'Биологически вдохновлённые генеративные модели: новый подход к обучению', 'desc': 'В статье представлен генеративный модель, вдохновлённая биологическими системами, использующая мультипликативные обновления на основе геометрического броуновского движения и экспоненциального градиентного спуска. Эта модель достигает передовых результатов на наборах данных изображений, таких как MNIST и Fashion MNIST. Основная идея заключается в использовании закона Дейла, который утверждает, что ингибиторные и возбуждающие синапсы не меняют свои роли в процессе обучения. Экспериментальные результаты показывают, что предложенная схема обновления позволяет эффективно генерировать образцы из лог-нормального распределения.'}, 'en': {'title': 'Biologically Inspired Image Generation with Multiplicative Updates', 'desc': "This paper presents a new generative model inspired by biological learning processes, specifically using multiplicative updates derived from geometric Brownian motion and exponential gradient descent. The model addresses limitations of traditional gradient descent by incorporating principles from neuroscience, such as Dale's law, which influences how synaptic weights are updated. By establishing a connection between stochastic differential equations and log-normal distributions, the authors develop a novel training method for score-based models that effectively generates images. Experimental results on various datasets, including MNIST and Fashion MNIST, show that this approach achieves state-of-the-art performance in image generation tasks."}, 'zh': {'title': '生物启发的生成模型：乘法更新的新突破', 'desc': '这篇论文提出了一种受生物启发的生成模型，使用基于几何布朗运动和指数梯度下降的乘法更新方法。该模型在图像数据集上达到了最先进的性能，展示了其生成能力。研究表明，传统的梯度下降优化方法与生物系统的学习过程不一致，因此引入了新的学习技术。通过对几何布朗运动的随机微分方程进行离散化，得到了与指数梯度下降相符的乘法更新规则。'}}}, {'id': 'https://huggingface.co/papers/2510.00658', 'title': 'Align Your Tangent: Training Better Consistency Models via\n  Manifold-Aligned Tangents', 'url': 'https://huggingface.co/papers/2510.00658', 'abstract': 'Align Your Tangent (AYT) improves Consistency Model training by reducing oscillatory tangents and enabling faster convergence with small batch sizes.  \t\t\t\t\tAI-generated summary \t\t\t\t With diffusion and flow matching models achieving state-of-the-art generating performance, the interest of the community now turned to reducing the inference time without sacrificing sample quality. Consistency Models (CMs), which are trained to be consistent on diffusion or probability flow ordinary differential equation (PF-ODE) trajectories, enable one or two-step flow or diffusion sampling. However, CMs typically require prolonged training with large batch sizes to obtain competitive sample quality. In this paper, we examine the training dynamics of CMs near convergence and discover that CM tangents -- CM output update directions -- are quite oscillatory, in the sense that they move parallel to the data manifold, not towards the manifold. To mitigate oscillatory tangents, we propose a new loss function, called the manifold feature distance (MFD), which provides manifold-aligned tangents that point toward the data manifold. Consequently, our method -- dubbed Align Your Tangent (AYT) -- can accelerate CM training by orders of magnitude and even out-perform the learned perceptual image patch similarity metric (LPIPS). Furthermore, we find that our loss enables training with extremely small batch sizes without compromising sample quality. Code: https://github.com/1202kbs/AYT', 'score': 0, 'issue_id': 6257, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '1df9ff9248532a64', 'authors': ['Beomsu Kim', 'Byunghee Cha', 'Jong Chul Ye'], 'affiliations': ['Graduate School of AI, KAIST'], 'pdf_title_img': 'assets/pdf/title_img/2510.00658.jpg', 'data': {'categories': ['#training', '#diffusion', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Выравнивание градиентов для быстрого обучения Consistency Models', 'desc': 'Consistency Models (CMs) позволяют генерировать изображения за один-два шага, но требуют долгого обучения с большими батчами. Авторы обнаружили, что градиенты CM ведут себя осцилляторно - двигаются параллельно data manifold вместо того, чтобы направляться к нему. Они предложили новую loss-функцию MFD (manifold feature distance), которая выравнивает градиенты по направлению к многообразию данных. Метод Align Your Tangent (AYT) ускоряет обучение CM на порядки величины и позволяет использовать очень маленькие размеры батчей без потери качества.'}, 'en': {'title': 'Accelerate Consistency Model Training with AYT!', 'desc': 'The paper introduces Align Your Tangent (AYT), a novel approach to enhance the training of Consistency Models (CMs) by addressing the issue of oscillatory tangents during training. By proposing a new loss function called manifold feature distance (MFD), AYT aligns the output update directions of CMs towards the data manifold, leading to more stable and efficient training dynamics. This method allows for significantly faster convergence, even with small batch sizes, while maintaining high sample quality. The results demonstrate that AYT not only accelerates training but also surpasses existing metrics like LPIPS in performance.'}, 'zh': {'title': '对齐你的切线，提升一致性模型训练效率', 'desc': '本文提出了一种新的训练方法，称为Align Your Tangent (AYT)，旨在提高一致性模型（CM）的训练效率。通过引入流形特征距离（MFD）损失函数，AYT能够减少训练过程中输出更新方向的振荡，使其更好地指向数据流形。这样，AYT可以在小批量数据下加速训练，并且在样本质量上超过了现有的评估指标。最终，AYT显著提高了CM的收敛速度，减少了对大批量数据的依赖。'}}}, {'id': 'https://huggingface.co/papers/2509.25944', 'title': 'NuRisk: A Visual Question Answering Dataset for Agent-Level Risk\n  Assessment in Autonomous Driving', 'url': 'https://huggingface.co/papers/2509.25944', 'abstract': 'NuRisk, a comprehensive VQA dataset, addresses the lack of spatio-temporal reasoning in current VLMs for autonomous driving by providing agent-level risk annotations in sequential images, improving accuracy and reducing latency.  \t\t\t\t\tAI-generated summary \t\t\t\t Understanding risk in autonomous driving requires not only perception and prediction, but also high-level reasoning about agent behavior and context. Current Vision Language Models (VLMs)-based methods primarily ground agents in static images and provide qualitative judgments, lacking the spatio-temporal reasoning needed to capture how risks evolve over time. To address this gap, we propose NuRisk, a comprehensive Visual Question Answering (VQA) dataset comprising 2,900 scenarios and 1.1 million agent-level samples, built on real-world data from nuScenes and Waymo, supplemented with safety-critical scenarios from the CommonRoad simulator. The dataset provides Bird-Eye-View (BEV) based sequential images with quantitative, agent-level risk annotations, enabling spatio-temporal reasoning. We benchmark well-known VLMs across different prompting techniques and find that they fail to perform explicit spatio-temporal reasoning, resulting in a peak accuracy of 33% at high latency. To address these shortcomings, our fine-tuned 7B VLM agent improves accuracy to 41% and reduces latency by 75%, demonstrating explicit spatio-temporal reasoning capabilities that proprietary models lacked. While this represents a significant step forward, the modest accuracy underscores the profound challenge of the task, establishing NuRisk as a critical benchmark for advancing spatio-temporal reasoning in autonomous driving.', 'score': 0, 'issue_id': 6259, 'pub_date': '2025-09-30', 'pub_date_card': {'ru': '30 сентября', 'en': 'September 30', 'zh': '9月30日'}, 'hash': '057384fe939d7206', 'authors': ['Yuan Gao', 'Mattia Piccinini', 'Roberto Brusnicki', 'Yuchen Zhang', 'Johannes Betz'], 'affiliations': ['Professorship of Autonomous Vehicle Systems, TUM School of Engineering and Design, Technical University of Munich, 85748 Garching, Germany; Munich Institute of Robotics and Machine Intelligence (MIRMI)'], 'pdf_title_img': 'assets/pdf/title_img/2509.25944.jpg', 'data': {'categories': ['#reasoning', '#games', '#cv', '#dataset', '#training', '#benchmark'], 'emoji': '🚗', 'ru': {'title': 'Обучение понимать риски на дороге во времени и пространстве', 'desc': 'Исследователи представили NuRisk — датасет для оценки пространственно-временного рассуждения Vision Language Models в автономном вождении. Датасет содержит 2900 сценариев и 1.1 миллиона примеров с количественными оценками рисков для каждого агента на последовательных изображениях с видом сверху. Существующие VLM показали точность всего 33%, так как не умеют явно рассуждать о развитии рисков во времени. Дообученная 7B модель улучшила точность до 41% и снизила задержку на 75%, но скромные результаты подчеркивают сложность задачи пространственно-временного анализа рисков для автопилотов.'}, 'en': {'title': 'NuRisk: Advancing Spatio-Temporal Reasoning in Autonomous Driving', 'desc': 'NuRisk is a new Visual Question Answering (VQA) dataset designed to enhance spatio-temporal reasoning in Vision Language Models (VLMs) for autonomous driving. It includes 2,900 scenarios and 1.1 million samples with detailed agent-level risk annotations, allowing models to understand how risks change over time. The dataset is built from real-world data and includes safety-critical scenarios, providing a comprehensive resource for training and evaluating VLMs. Our experiments show that while existing models struggle with spatio-temporal reasoning, our fine-tuned 7B VLM agent significantly improves accuracy and reduces latency, highlighting the importance of this dataset for future research.'}, 'zh': {'title': 'NuRisk：提升自动驾驶的时空推理能力', 'desc': 'NuRisk是一个全面的视觉问答（VQA）数据集，旨在解决当前视觉语言模型（VLMs）在自动驾驶中缺乏时空推理的问题。该数据集包含2900个场景和110万个基于真实世界数据的代理级风险注释样本，支持时空推理。通过对不同提示技术的基准测试，我们发现现有的VLMs在时空推理方面表现不佳，准确率仅为33%。经过微调的7B VLM代理将准确率提高到41%，并将延迟减少了75%，展示了显式的时空推理能力，标志着在自动驾驶领域的重要进展。'}}}, {'id': 'https://huggingface.co/papers/2510.02375', 'title': 'Pretraining with hierarchical memories: separating long-tail and common\n  knowledge', 'url': 'https://huggingface.co/papers/2510.02375', 'abstract': 'A memory-augmented architecture with hierarchical parametric memory banks improves language model performance while reducing parameter size and computational requirements.  \t\t\t\t\tAI-generated summary \t\t\t\t The impressive performance gains of modern language models currently rely on scaling parameters: larger models store more world knowledge and reason better. Yet compressing all world knowledge into parameters is unnecessary, as only a fraction is used per prompt, and impractical for edge devices with limited inference-time memory and compute. We address this shortcoming by a memory-augmented architecture and a pretraining strategy aligned with existing hardware paradigms. We introduce small language models that access large hierarchical parametric memory banks encoding world knowledge. During pretraining and inference, we fetch a small, context-dependent memory block and add it to the model. Our pretraining learns to store long-tail world knowledge in the memory parameters, while the small language model acts as an anchor capturing common knowledge and general reasoning abilities. Through trillion-token-scale experiments, we show significant gains: a 160M-parameters model augmented with an 18M-parameters memory fetched from a 4.6B memory bank obtains comparable performance to a regular model with more than 2x the parameters. Through extensive experiments, we study the optimal type and size of parametric memories in transformers, scaling them to over 21B parameters. We find that our proposed hierarchical feed-forward memories work robustly across transformer architectures, whether added during pretraining or post-hoc.', 'score': 0, 'issue_id': 6264, 'pub_date': '2025-09-29', 'pub_date_card': {'ru': '29 сентября', 'en': 'September 29', 'zh': '9月29日'}, 'hash': '0a53f0b208324e15', 'authors': ['Hadi Pouransari', 'David Grangier', 'C Thomas', 'Michael Kirchhof', 'Oncel Tuzel'], 'affiliations': ['Apple'], 'pdf_title_img': 'assets/pdf/title_img/2510.02375.jpg', 'data': {'categories': ['#architecture', '#small_models', '#agi', '#optimization', '#training'], 'emoji': '🗄️', 'ru': {'title': 'Иерархическая память вместо раздутых параметров', 'desc': 'Исследователи предлагают архитектуру языковых моделей с внешними банками параметрической памяти, которая позволяет хранить знания отдельно от основной модели. Маленькая LLM на 160M параметров с доступом к памяти размером 4.6B показывает результаты, сравнимые с обычной моделью в два раза большего размера. Иерархическая структура памяти хранит редкие факты о мире, в то время как компактная модель фокусируется на общих знаниях и логике. Подход особенно полезен для edge-устройств с ограниченными ресурсами, так как загружается только небольшой блок памяти в зависимости от контекста.'}, 'en': {'title': 'Memory Augmentation: Boosting Language Models with Less!', 'desc': 'This paper presents a novel memory-augmented architecture that enhances the performance of language models while minimizing their size and computational demands. Instead of relying solely on large parameters, the model utilizes hierarchical parametric memory banks to store and retrieve world knowledge efficiently. During both pretraining and inference, the model accesses small, context-specific memory blocks, allowing it to leverage extensive knowledge without the need for a massive parameter count. The results demonstrate that a smaller model with memory augmentation can achieve performance comparable to much larger models, showcasing the effectiveness of this approach in optimizing language model capabilities.'}, 'zh': {'title': '记忆增强架构：小模型，大智慧', 'desc': '这篇论文提出了一种增强记忆的架构，利用分层参数记忆库来提高语言模型的性能，同时减少参数规模和计算需求。现代语言模型的优异表现通常依赖于参数的扩展，但将所有世界知识压缩到参数中是不必要的，因为每次提示只使用其中的一小部分。我们通过一种记忆增强架构和与现有硬件相适应的预训练策略来解决这一问题。实验表明，使用小型语言模型结合大型记忆库，可以在保持较少参数的情况下，获得与更大模型相当的性能。'}}}, {'id': 'https://huggingface.co/papers/2509.25122', 'title': 'Triangle Splatting+: Differentiable Rendering with Opaque Triangles', 'url': 'https://huggingface.co/papers/2509.25122', 'abstract': 'Triangle Splatting+ optimizes triangles within a differentiable framework for real-time, high-fidelity 3D scene reconstruction and novel view synthesis, compatible with standard graphics engines.  \t\t\t\t\tAI-generated summary \t\t\t\t Reconstructing 3D scenes and synthesizing novel views has seen rapid progress in recent years. Neural Radiance Fields demonstrated that continuous volumetric radiance fields can achieve high-quality image synthesis, but their long training and rendering times limit practicality. 3D Gaussian Splatting (3DGS) addressed these issues by representing scenes with millions of Gaussians, enabling real-time rendering and fast optimization. However, Gaussian primitives are not natively compatible with the mesh-based pipelines used in VR headsets, and real-time graphics applications. Existing solutions attempt to convert Gaussians into meshes through post-processing or two-stage pipelines, which increases complexity and degrades visual quality. In this work, we introduce Triangle Splatting+, which directly optimizes triangles, the fundamental primitive of computer graphics, within a differentiable splatting framework. We formulate triangle parametrization to enable connectivity through shared vertices, and we design a training strategy that enforces opaque triangles. The final output is immediately usable in standard graphics engines without post-processing. Experiments on the Mip-NeRF360 and Tanks & Temples datasets show that Triangle Splatting+achieves state-of-the-art performance in mesh-based novel view synthesis. Our method surpasses prior splatting approaches in visual fidelity while remaining efficient and fast to training. Moreover, the resulting semi-connected meshes support downstream applications such as physics-based simulation or interactive walkthroughs. The project page is https://trianglesplatting2.github.io/trianglesplatting2/.', 'score': 0, 'issue_id': 6258, 'pub_date': '2025-09-29', 'pub_date_card': {'ru': '29 сентября', 'en': 'September 29', 'zh': '9月29日'}, 'hash': '0a192916d65d7a77', 'authors': ['Jan Held', 'Renaud Vandeghen', 'Sanghyun Son', 'Daniel Rebain', 'Matheus Gadelha', 'Yi Zhou', 'Ming C. Lin', 'Marc Van Droogenbroeck', 'Andrea Tagliasacchi'], 'affiliations': ['Adobe Research', 'Simon Fraser University', 'University of British Columbia', 'University of Liège', 'University of Maryland', 'University of Toronto'], 'pdf_title_img': 'assets/pdf/title_img/2509.25122.jpg', 'data': {'categories': ['#3d', '#games', '#optimization'], 'emoji': '🔺', 'ru': {'title': "Треугольники вместо гауссиан: прямая оптимизация mesh'ей для real-time 3D рендеринга", 'desc': "Triangle Splatting+ представляет новый подход к 3D реконструкции сцен, который напрямую оптимизирует треугольники в дифференцируемом framework'е для синтеза новых ракурсов. В отличие от 3D Gaussian Splatting, который использует миллионы гауссиан и требует конвертации в mesh, этот метод сразу работает с треугольниками - базовыми примитивами компьютерной графики. Метод обеспечивает state-of-the-art качество визуализации на датасетах Mip-NeRF360 и Tanks & Temples, при этом результат напрямую совместим со стандартными графическими движками без пост-обработки. Полученные полу-связанные mesh'и можно использовать для физических симуляций и интерактивных приложений в VR."}, 'en': {'title': 'Real-Time 3D Scene Reconstruction with Triangle Splatting+', 'desc': 'Triangle Splatting+ is a novel approach for optimizing triangles in 3D scene reconstruction and view synthesis, designed to work seamlessly with standard graphics engines. It improves upon previous methods by directly optimizing triangle primitives within a differentiable framework, allowing for real-time rendering and high visual fidelity. The method introduces a unique triangle parametrization that maintains connectivity through shared vertices and enforces opaque triangle structures during training. As a result, Triangle Splatting+ produces high-quality, semi-connected meshes that are ready for immediate use in various applications, including physics simulations and interactive experiences.'}, 'zh': {'title': '实时高保真3D场景重建的新突破', 'desc': 'Triangle Splatting+ 是一种优化三角形的技术，旨在实现实时、高保真的 3D 场景重建和新视角合成。该方法在可微分的 splatting 框架内直接优化三角形，避免了传统高斯方法的复杂性和视觉质量下降。通过共享顶点的三角形参数化，Triangle Splatting+ 使得生成的网格可以直接在标准图形引擎中使用，无需后处理。实验结果表明，该方法在网格基础的新视角合成中达到了最先进的性能，同时保持了高效的训练速度。'}}}, {'id': 'https://huggingface.co/papers/2509.23291', 'title': 'Scaling Policy Compliance Assessment in Language Models with Policy\n  Reasoning Traces', 'url': 'https://huggingface.co/papers/2509.23291', 'abstract': "Policy Reasoning Traces (PRT) enhance LLMs' policy compliance assessment by providing detailed reasoning chains, improving accuracy and policy clause citation.  \t\t\t\t\tAI-generated summary \t\t\t\t Policy compliance assessment is a fundamental task of evaluating whether an input case strictly complies with a set of human-defined rules, more generally known as policies. In practice, human experts follow a systematic, step-by-step process to identify violations with respect to specific stipulations outlined in the policy. However, such documentation of gold-standard, expert-level reasoning processes is costly to acquire. In this paper, we introduce Policy Reasoning Traces (PRT), a form of specialized generated reasoning chains that serve as a reasoning bridge to improve an LLM's policy compliance assessment capabilities. Our empirical evaluations demonstrate that the use of PRTs for both inference-time and training-time scenarios significantly enhances the performance of open-weight and commercial models, setting a new state-of-the-art for HIPAA and GDPR policies. Beyond accuracy gains, we also highlight how PRTs can improve an LLM's ability to accurately cite policy clauses, as well as influence compliance decisions through their high utilization from the raw chains of thought.", 'score': 0, 'issue_id': 6261, 'pub_date': '2025-09-27', 'pub_date_card': {'ru': '27 сентября', 'en': 'September 27', 'zh': '9月27日'}, 'hash': '7e85879f3354a36e', 'authors': ['Joseph Marvin Imperial', 'Harish Tayyar Madabushi'], 'affiliations': ['Imperial', 'UKRI CDT for Accountable, Responsible, and Transparent AI University of Bath, UK'], 'pdf_title_img': 'assets/pdf/title_img/2509.23291.jpg', 'data': {'categories': ['#alignment', '#training', '#rlhf', '#reasoning'], 'emoji': '⚖️', 'ru': {'title': 'Цепочки рассуждений для проверки соответствия политикам', 'desc': 'Статья представляет метод Policy Reasoning Traces (PRT) для улучшения способности LLM оценивать соответствие входных данных заданным политикам и правилам. PRT представляют собой специализированные цепочки рассуждений, которые имитируют пошаговый процесс анализа экспертов при выявлении нарушений политик. Использование PRT как на этапе инференса, так и на этапе обучения значительно повышает точность оценки соответствия для открытых и коммерческих моделей, устанавливая новый state-of-the-art для политик HIPAA и GDPR. Помимо улучшения точности, PRT также повышают способность моделей корректно цитировать конкретные пункты политик при обосновании своих решений.'}, 'en': {'title': 'Enhancing LLM Compliance with Policy Reasoning Traces', 'desc': 'This paper introduces Policy Reasoning Traces (PRT), which are specialized reasoning chains designed to enhance the policy compliance assessment capabilities of large language models (LLMs). By mimicking the systematic approach that human experts use to evaluate compliance with policies, PRTs provide a structured way for LLMs to identify violations of rules. The authors demonstrate that incorporating PRTs during both training and inference significantly improves the accuracy of LLMs in assessing compliance with regulations like HIPAA and GDPR. Additionally, PRTs help LLMs better cite specific policy clauses and influence compliance decisions through their reasoning processes.'}, 'zh': {'title': '提升政策合规评估的推理链', 'desc': '本文介绍了一种名为政策推理痕迹（PRT）的新方法，旨在提高大型语言模型（LLM）在政策合规评估中的表现。PRT提供了详细的推理链，帮助模型更准确地识别与人类定义的政策条款的符合程度。通过实证评估，我们发现PRT在推理和训练阶段都显著提升了模型的性能，尤其是在HIPAA和GDPR政策的应用中。除了提高准确性，PRT还增强了模型引用政策条款的能力，并通过推理链的高利用率影响合规决策。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (1)', '#agents (7)', '#agi (2)', '#alignment (6)', '#architecture (5)', '#audio (1)', '#benchmark (12)', '#cv (4)', '#data (3)', '#dataset (9)', '#diffusion (7)', '#ethics (1)', '#games (5)', '#graphs', '#hallucinations (1)', '#healthcare (3)', '#inference (4)', '#interpretability (3)', '#leakage', '#long_context (1)', '#low_resource', '#machine_translation', '#math (1)', '#multilingual', '#multimodal (11)', '#open_source (3)', '#optimization (18)', '#plp (1)', '#rag (1)', '#reasoning (10)', '#rl (5)', '#rlhf (6)', '#robotics (1)', '#science (1)', '#security (4)', '#small_models (1)', '#story_generation', '#survey (2)', '#synthetic', '#training (18)', '#transfer_learning (1)', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-10-06 16:14',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-10-06 16:14')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-10-06 16:14')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    