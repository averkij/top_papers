
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 8 papers. January 28.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">28 января</span> | <span id="title-articles-count">8 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-01-27.html">⬅️ <span id="prev-date">27.01</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-01-29.html">➡️ <span id="next-date">29.01</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-01.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '28 января', 'en': 'January 28', 'zh': '1月28日'};
        let feedDateNext = {'ru': '29.01', 'en': '01/29', 'zh': '1月29日'};
        let feedDatePrev = {'ru': '27.01', 'en': '01/27', 'zh': '1月27日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2501.15368', 'title': 'Baichuan-Omni-1.5 Technical Report', 'url': 'https://huggingface.co/papers/2501.15368', 'abstract': 'We introduce Baichuan-Omni-1.5, an omni-modal model that not only has omni-modal understanding capabilities but also provides end-to-end audio generation capabilities. To achieve fluent and high-quality interaction across modalities without compromising the capabilities of any modality, we prioritized optimizing three key aspects. First, we establish a comprehensive data cleaning and synthesis pipeline for multimodal data, obtaining about 500B high-quality data (text, audio, and vision). Second, an audio-tokenizer (Baichuan-Audio-Tokenizer) has been designed to capture both semantic and acoustic information from audio, enabling seamless integration and enhanced compatibility with MLLM. Lastly, we designed a multi-stage training strategy that progressively integrates multimodal alignment and multitask fine-tuning, ensuring effective synergy across all modalities. Baichuan-Omni-1.5 leads contemporary models (including GPT4o-mini and MiniCPM-o 2.6) in terms of comprehensive omni-modal capabilities. Notably, it achieves results comparable to leading models such as Qwen2-VL-72B across various multimodal medical benchmarks.', 'score': 24, 'issue_id': 1898, 'pub_date': '2025-01-26', 'pub_date_card': {'ru': '26 января', 'en': 'January 26', 'zh': '1月26日'}, 'hash': 'f40b7f7b108c1500', 'authors': ['Yadong Li', 'Jun Liu', 'Tao Zhang', 'Tao Zhang', 'Song Chen', 'Tianpeng Li', 'Zehuan Li', 'Lijun Liu', 'Lingfeng Ming', 'Guosheng Dong', 'Da Pan', 'Chong Li', 'Yuanbo Fang', 'Dongdong Kuang', 'Mingrui Wang', 'Chenglin Zhu', 'Youwei Zhang', 'Hongyu Guo', 'Fengyu Zhang', 'Yuran Wang', 'Bowen Ding', 'Wei Song', 'Xu Li', 'Yuqi Huo', 'Zheng Liang', 'Shusen Zhang', 'Xin Wu', 'Shuai Zhao', 'Linchu Xiong', 'Yozhen Wu', 'Jiahui Ye', 'Wenhao Lu', 'Bowen Li', 'Yan Zhang', 'Yaqi Zhou', 'Xin Chen', 'Lei Su', 'Hongda Zhang', 'Fuzhong Chen', 'Xuezhen Dong', 'Na Nie', 'Zhiying Wu', 'Bin Xiao', 'Ting Li', 'Shunya Dang', 'Ping Zhang', 'Yijia Sun', 'Jincheng Wu', 'Jinjie Yang', 'Xionghai Lin', 'Zhi Ma', 'Kegeng Wu', 'Jia li', 'Aiyuan Yang', 'Hui Liu', 'Jianqiang Zhang', 'Xiaoxi Chen', 'Guangwei Ai', 'Wentao Zhang', 'Yicong Chen', 'Xiaoqin Huang', 'Kun Li', 'Wenjing Luo', 'Yifei Duan', 'Lingling Zhu', 'Ran Xiao', 'Zhe Su', 'Jiani Pu', 'Dian Wang', 'Xu Jia', 'Tianyu Zhang', 'Mengyu Ai', 'Mang Wang', 'Yujing Qiao', 'Lei Zhang', 'Yanjun Shen', 'Fan Yang', 'Miao Zhen', 'Yijie Zhou', 'Mingyang Chen', 'Fei Li', 'Chenzheng Zhu', 'Keer Lu', 'Yaqi Zhao', 'Hao Liang', 'Youquan Li', 'Yanzhao Qin', 'Linzhuang Sun', 'Jianhua Xu', 'Haoze Sun', 'Mingan Lin', 'Zenan Zhou', 'Weipeng Chen'], 'affiliations': ['Baichuan Inc.'], 'pdf_title_img': 'assets/pdf/title_img/2501.15368.jpg', 'data': {'categories': ['#data', '#optimization', '#dataset', '#training', '#audio', '#multimodal'], 'emoji': '🎭', 'ru': {'title': 'Baichuan-Omni-1.5: Прорыв в омнимодальном ИИ', 'desc': 'Baichuan-Omni-1.5 - это омнимодальная модель, обладающая способностями понимания и генерации аудио. Для достижения качественного взаимодействия между модальностями, авторы оптимизировали три ключевых аспекта: создали комплексный пайплайн для обработки мультимодальных данных, разработали аудио-токенизатор для захвата семантической и акустической информации, и применили многоэтапную стратегию обучения. Модель демонстрирует ведущие результаты в омнимодальных возможностях и сравнима с передовыми моделями в различных мультимодальных медицинских бенчмарках.'}, 'en': {'title': 'Revolutionizing Multimodal Interaction with Baichuan-Omni-1.5', 'desc': 'Baichuan-Omni-1.5 is a cutting-edge omni-modal model designed for seamless interaction across text, audio, and visual data. It utilizes a robust data cleaning and synthesis pipeline to process approximately 500 billion high-quality multimodal data points. The model features a specialized audio-tokenizer that captures both semantic and acoustic elements, enhancing its compatibility with multi-layered language models (MLLM). Through a multi-stage training approach, it effectively aligns and fine-tunes across modalities, outperforming existing models in various multimodal tasks, particularly in medical benchmarks.'}, 'zh': {'title': '全模态交互的新纪元', 'desc': '我们介绍了Baichuan-Omni-1.5，这是一种全模态模型，具备全模态理解和端到端音频生成能力。为了实现不同模态之间流畅且高质量的交互，我们优化了三个关键方面。首先，我们建立了一个全面的数据清洗和合成管道，获得了约5000亿条高质量的多模态数据（文本、音频和视觉）。其次，我们设计了一个音频标记器（Baichuan-Audio-Tokenizer），能够捕捉音频的语义和声学信息，从而增强与多模态大语言模型的兼容性。'}}}, {'id': 'https://huggingface.co/papers/2501.15383', 'title': 'Qwen2.5-1M Technical Report', 'url': 'https://huggingface.co/papers/2501.15383', 'abstract': 'We introduce Qwen2.5-1M, a series of models that extend the context length to 1 million tokens. Compared to the previous 128K version, the Qwen2.5-1M series have significantly enhanced long-context capabilities through long-context pre-training and post-training. Key techniques such as long data synthesis, progressive pre-training, and multi-stage supervised fine-tuning are employed to effectively enhance long-context performance while reducing training costs.   To promote the use of long-context models among a broader user base, we present and open-source our inference framework. This framework includes a length extrapolation method that can expand the model context lengths by at least four times, or even more, without additional training. To reduce inference costs, we implement a sparse attention method along with chunked prefill optimization for deployment scenarios and a sparsity refinement method to improve precision. Additionally, we detail our optimizations in the inference engine, including kernel optimization, pipeline parallelism, and scheduling optimization, which significantly enhance overall inference performance. By leveraging our inference framework, the Qwen2.5-1M models achieve a remarkable 3x to 7x prefill speedup in scenarios with 1 million tokens of context. This framework provides an efficient and powerful solution for developing applications that require long-context processing using open-source models.   The Qwen2.5-1M series currently includes the open-source models Qwen2.5-7B-Instruct-1M and Qwen2.5-14B-Instruct-1M, as well as the API-accessed model Qwen2.5-Turbo. Evaluations show that Qwen2.5-1M models have been greatly improved in long-context tasks without compromising performance in short-context scenarios. Specifically, the Qwen2.5-14B-Instruct-1M model significantly outperforms GPT-4o-mini in long-context tasks and supports contexts eight times longer.', 'score': 11, 'issue_id': 1898, 'pub_date': '2025-01-26', 'pub_date_card': {'ru': '26 января', 'en': 'January 26', 'zh': '1月26日'}, 'hash': '203817e55fc3eb45', 'authors': ['An Yang', 'Bowen Yu', 'Chengyuan Li', 'Dayiheng Liu', 'Fei Huang', 'Haoyan Huang', 'Jiandong Jiang', 'Jianhong Tu', 'Jianwei Zhang', 'Jingren Zhou', 'Junyang Lin', 'Kai Dang', 'Kexin Yang', 'Le Yu', 'Mei Li', 'Minmin Sun', 'Qin Zhu', 'Rui Men', 'Tao He', 'Weijia Xu', 'Wenbiao Yin', 'Wenyuan Yu', 'Xiafei Qiu', 'Xingzhang Ren', 'Xinlong Yang', 'Yong Li', 'Zhiying Xu', 'Zipeng Zhang'], 'affiliations': ['Alibaba Group'], 'pdf_title_img': 'assets/pdf/title_img/2501.15383.jpg', 'data': {'categories': ['#architecture', '#inference', '#long_context', '#training', '#open_source'], 'emoji': '🚀', 'ru': {'title': 'Миллион токенов: новый рубеж для языковых моделей', 'desc': 'Статья представляет серию моделей Qwen2.5-1M с контекстным окном в 1 миллион токенов. Авторы применили техники синтеза длинных данных, прогрессивного предобучения и многоэтапной супервизированной донастройки для улучшения работы с длинным контекстом. Разработан фреймворк для инференса, включающий метод экстраполяции длины и оптимизации для ускорения обработки. Модели Qwen2.5-1M демонстрируют значительное улучшение на задачах с длинным контекстом без ухудшения производительности на коротких текстах.'}, 'en': {'title': 'Unlocking the Power of 1 Million Tokens with Qwen2.5-1M', 'desc': 'The Qwen2.5-1M models introduce a significant advancement in handling long-context inputs, extending the context length to 1 million tokens. This is achieved through innovative techniques like long data synthesis and multi-stage supervised fine-tuning, which enhance performance while minimizing training costs. The open-source inference framework allows users to expand context lengths without additional training and includes optimizations for efficient deployment. Overall, these models demonstrate superior performance in long-context tasks compared to existing models, making them a valuable resource for applications requiring extensive context processing.'}, 'zh': {'title': 'Qwen2.5-1M：长上下文处理的新突破', 'desc': '我们介绍了Qwen2.5-1M系列模型，能够处理长达100万标记的上下文。与之前的128K版本相比，Qwen2.5-1M在长上下文能力上有显著提升，采用了长数据合成、渐进式预训练和多阶段监督微调等关键技术。为了降低推理成本，我们实现了稀疏注意力机制和分块预填充优化，同时优化了推理引擎的性能。Qwen2.5-1M模型在处理长上下文任务时表现优异，且在短上下文场景中性能没有下降。'}}}, {'id': 'https://huggingface.co/papers/2501.16142', 'title': 'Towards General-Purpose Model-Free Reinforcement Learning', 'url': 'https://huggingface.co/papers/2501.16142', 'abstract': 'Reinforcement learning (RL) promises a framework for near-universal problem-solving. In practice however, RL algorithms are often tailored to specific benchmarks, relying on carefully tuned hyperparameters and algorithmic choices. Recently, powerful model-based RL methods have shown impressive general results across benchmarks but come at the cost of increased complexity and slow run times, limiting their broader applicability. In this paper, we attempt to find a unifying model-free deep RL algorithm that can address a diverse class of domains and problem settings. To achieve this, we leverage model-based representations that approximately linearize the value function, taking advantage of the denser task objectives used by model-based RL while avoiding the costs associated with planning or simulated trajectories. We evaluate our algorithm, MR.Q, on a variety of common RL benchmarks with a single set of hyperparameters and show a competitive performance against domain-specific and general baselines, providing a concrete step towards building general-purpose model-free deep RL algorithms.', 'score': 6, 'issue_id': 1898, 'pub_date': '2025-01-27', 'pub_date_card': {'ru': '27 января', 'en': 'January 27', 'zh': '1月27日'}, 'hash': '0cf7cd0c9c1f5964', 'authors': ['Scott Fujimoto', "Pierluca D'Oro", 'Amy Zhang', 'Yuandong Tian', 'Michael Rabbat'], 'affiliations': ['Meta FAIR'], 'pdf_title_img': 'assets/pdf/title_img/2501.16142.jpg', 'data': {'categories': ['#optimization', '#rl', '#benchmark', '#training', '#games'], 'emoji': '🤖', 'ru': {'title': 'MR.Q: На пути к универсальному обучению с подкреплением', 'desc': 'Статья представляет новый алгоритм обучения с подкреплением под названием MR.Q. Этот алгоритм объединяет преимущества модельного и безмодельного подходов, используя представления, линеаризующие функцию ценности. MR.Q показывает конкурентоспособные результаты на различных бенчмарках с единым набором гиперпараметров. Исследование направлено на создание универсального безмодельного алгоритма глубокого обучения с подкреплением.'}, 'en': {'title': 'Towards Universal Problem-Solving with MR.Q in Reinforcement Learning', 'desc': 'This paper presents a new model-free deep reinforcement learning algorithm called MR.Q, which aims to solve a wide range of problems without needing extensive tuning of hyperparameters. The authors utilize model-based representations to simplify the value function, allowing the algorithm to benefit from the advantages of model-based RL while avoiding the complexities of planning. MR.Q is evaluated across various standard RL benchmarks using a single set of hyperparameters, demonstrating competitive performance against both specialized and general algorithms. This work represents a significant advancement towards creating versatile and efficient model-free deep RL solutions.'}, 'zh': {'title': '构建通用的无模型深度强化学习算法', 'desc': '强化学习（RL）提供了一种通用问题解决框架，但在实际应用中，RL算法通常针对特定基准进行调整，依赖于精心调节的超参数和算法选择。最近，强大的基于模型的RL方法在多个基准上表现出色，但其复杂性和较慢的运行时间限制了其更广泛的应用。本文提出了一种统一的无模型深度RL算法MR.Q，旨在解决多样化的领域和问题设置。我们利用基于模型的表示方法，近似线性化价值函数，从而在避免规划或模拟轨迹相关成本的同时，利用基于模型的RL所使用的更密集的任务目标。'}}}, {'id': 'https://huggingface.co/papers/2501.15570', 'title': 'ARWKV: Pretrain is not what we need, an RNN-Attention-Based Language Model Born from Transformer', 'url': 'https://huggingface.co/papers/2501.15570', 'abstract': "As is known, hybrid quadratic and subquadratic attention models in multi-head architectures have surpassed both Transformer and Linear RNN models , with these works primarily focusing on reducing KV complexity and improving efficiency. For further research on expressiveness, we introduce our series of models distilled from Qwen 2.5, based on pure native RWKV-7 attention, which aims to make RNN more expressive and demonstrates state tracking ability beyond transformers. We work with QRWK 32B based on RWKV-6 architecture, another approach that reduces the entire knowledge processing time to just 8 hours using 16 AMD MI300X GPUs while maintaining Qwen 2.5's performance. In fact, the distillation process can utilize any LLM, not just Qwen, and enables knowledge transfer from larger LLMs to smaller ones with more fewer tokens. We will explain the detailed process and share our insights on building more powerful foundation models. Please note that this is an ongoing work that will be updated continuously. The model checkpoints and source code are available at https://github.com/yynil/RWKVInside{https://github.com/yynil/RWKVInside}, https://huggingface.co/RWKV-Red-Team/ARWKV-7B-Preview-0.1{https://huggingface.co/RWKV-Red-Team/ARWKV-7B-Preview-0.1}.", 'score': 4, 'issue_id': 1900, 'pub_date': '2025-01-26', 'pub_date_card': {'ru': '26 января', 'en': 'January 26', 'zh': '1月26日'}, 'hash': '063647dfe2bd7b63', 'authors': ['Lin Yueyu', 'Li Zhiyuan', 'Peter Yue', 'Liu Xiao'], 'affiliations': [], 'pdf_title_img': 'assets/pdf/title_img/2501.15570.jpg', 'data': {'categories': ['#transfer_learning', '#training', '#architecture', '#small_models', '#optimization', '#open_source'], 'emoji': '🧠', 'ru': {'title': 'Повышение эффективности и выразительности RNN через дистилляцию знаний', 'desc': 'Статья представляет новые модели, основанные на чистом нативном внимании RWKV-7, дистиллированные из Qwen 2.5. Цель исследования - повысить выразительность RNN и продемонстрировать способность отслеживания состояния, превосходящую трансформеры. Авторы работают с QRWK 32B на архитектуре RWKV-6, что позволяет сократить время обработки знаний до 8 часов на 16 GPU AMD MI300X. Процесс дистилляции может использовать любую большую языковую модель для передачи знаний меньшим моделям с меньшим количеством токенов.'}, 'en': {'title': 'Enhancing RNN Expressiveness with RWKV Attention', 'desc': 'This paper presents a new series of models derived from Qwen 2.5, focusing on enhancing the expressiveness of RNNs through a native RWKV-7 attention mechanism. The authors demonstrate that their hybrid quadratic and subquadratic attention models outperform traditional Transformer and Linear RNN architectures by significantly reducing key-value (KV) complexity. They introduce the QRWK 32B model, which achieves impressive efficiency by processing knowledge in just 8 hours using 16 AMD MI300X GPUs while retaining the performance of Qwen 2.5. Additionally, the distillation process allows for knowledge transfer from larger language models (LLMs) to smaller ones, making it a versatile approach for building more powerful foundation models.'}, 'zh': {'title': '提升RNN表达能力的新模型', 'desc': '本文介绍了一种新型的混合二次和亚二次注意力模型，旨在提高RNN的表达能力。我们基于RWKV-7注意力架构，提出了一系列从Qwen 2.5中提炼的模型，展示了超越Transformer的状态跟踪能力。通过使用16个AMD MI300X GPU，我们的QRWK 32B模型将知识处理时间缩短至仅8小时，同时保持了Qwen 2.5的性能。该提炼过程可以利用任何大型语言模型（LLM），实现从更大模型到更小模型的知识转移。'}}}, {'id': 'https://huggingface.co/papers/2501.15907', 'title': 'Emilia: A Large-Scale, Extensive, Multilingual, and Diverse Dataset for Speech Generation', 'url': 'https://huggingface.co/papers/2501.15907', 'abstract': 'Recent advancements in speech generation have been driven by the large-scale training datasets. However, current models fall short of capturing the spontaneity and variability inherent in real-world human speech, due to their reliance on audiobook datasets limited to formal read-aloud speech styles. To bridge this gap, we introduce Emilia-Pipe, an open-source preprocessing pipeline to extract high-quality training data from valuable yet underexplored in-the-wild data that capture spontaneous human speech in real-world contexts. By leveraging Emilia-Pipe, we construct Emilia, the first multilingual speech generation dataset derived from in-the-wild speech data. This dataset comprises over 101k hours of speech across six languages: English, Chinese, German, French, Japanese, and Korean. Besides, we expand Emilia to Emilia-Large, a dataset exceeding 216k hours, making it the largest open-source speech generation dataset available. Extensive experiments demonstrate that Emilia significantly outperforms traditional audiobook datasets in generating spontaneous and human-like speech, showcasing superior performance in capturing diverse speaker timbre and speaking styles of real-world human speech. Furthermore, this work underscores the importance of scaling dataset size to advance speech generation research and validates the effectiveness of Emilia for both multilingual and crosslingual speech generation.', 'score': 3, 'issue_id': 1903, 'pub_date': '2025-01-27', 'pub_date_card': {'ru': '27 января', 'en': 'January 27', 'zh': '1月27日'}, 'hash': 'bd221795c86585eb', 'authors': ['Haorui He', 'Zengqiang Shang', 'Chaoren Wang', 'Xuyuan Li', 'Yicheng Gu', 'Hua Hua', 'Liwei Liu', 'Chen Yang', 'Jiaqi Li', 'Peiyang Shi', 'Yuancheng Wang', 'Kai Chen', 'Pengyuan Zhang', 'Zhizheng Wu'], 'affiliations': ['Chinese University of Hong Kong, Shenzhen, China', 'Laboratory of Speech and Intelligent Information Processing, Institute of Acoustics, CAS, Beijing, China', 'Shanghai AI Laboratory, Shanghai, China', 'University of Chinese Academy of Sciences, Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2501.15907.jpg', 'data': {'categories': ['#data', '#audio', '#multilingual', '#dataset', '#open_source', '#low_resource'], 'emoji': '🗣️', 'ru': {'title': 'Emilia: новый этап в генерации естественной речи', 'desc': 'Исследователи представили Emilia-Pipe - открытый конвейер предобработки для извлечения высококачественных данных из спонтанной речи в реальных условиях. На его основе создан многоязычный датасет Emilia, содержащий более 101 тысячи часов речи на 6 языках. Расширенная версия Emilia-Large включает более 216 тысяч часов и является крупнейшим открытым датасетом для генерации речи. Эксперименты показали превосходство Emilia над традиционными аудиокнижными датасетами в генерации естественной и спонтанной речи.'}, 'en': {'title': 'Unlocking Spontaneous Speech with Emilia-Pipe', 'desc': 'This paper presents Emilia-Pipe, a preprocessing tool designed to extract high-quality training data from spontaneous human speech in real-world settings. The authors introduce Emilia, a multilingual speech generation dataset that includes over 101k hours of diverse speech data across six languages. They further expand this dataset to Emilia-Large, which contains more than 216k hours, making it the largest open-source resource for speech generation. The results show that models trained on Emilia outperform those trained on traditional audiobook datasets, effectively capturing the variability and naturalness of human speech.'}, 'zh': {'title': '打破传统，捕捉真实语音的多样性', 'desc': '近年来，语音生成的进展主要依赖于大规模的训练数据集。然而，目前的模型在捕捉真实人类语音的自发性和多样性方面存在不足，因为它们依赖于仅限于正式朗读风格的有声书数据集。为了解决这个问题，我们提出了Emilia-Pipe，这是一个开源的预处理管道，用于从有价值但未被充分探索的真实环境数据中提取高质量的训练数据。通过利用Emilia-Pipe，我们构建了Emilia，这是第一个基于真实环境语音数据的多语言语音生成数据集，包含超过101k小时的语音，涵盖六种语言。'}}}, {'id': 'https://huggingface.co/papers/2501.15369', 'title': 'iFormer: Integrating ConvNet and Transformer for Mobile Application', 'url': 'https://huggingface.co/papers/2501.15369', 'abstract': 'We present a new family of mobile hybrid vision networks, called iFormer, with a focus on optimizing latency and accuracy on mobile applications. iFormer effectively integrates the fast local representation capacity of convolution with the efficient global modeling ability of self-attention. The local interactions are derived from transforming a standard convolutional network, i.e., ConvNeXt, to design a more lightweight mobile network. Our newly introduced mobile modulation attention removes memory-intensive operations in MHA and employs an efficient modulation mechanism to boost dynamic global representational capacity. We conduct comprehensive experiments demonstrating that iFormer outperforms existing lightweight networks across various tasks. Notably, iFormer achieves an impressive Top-1 accuracy of 80.4\\% on ImageNet-1k with a latency of only 1.10 ms on an iPhone 13, surpassing the recently proposed MobileNetV4 under similar latency constraints. Additionally, our method shows significant improvements in downstream tasks, including COCO object detection, instance segmentation, and ADE20k semantic segmentation, while still maintaining low latency on mobile devices for high-resolution inputs in these scenarios.', 'score': 1, 'issue_id': 1898, 'pub_date': '2025-01-26', 'pub_date_card': {'ru': '26 января', 'en': 'January 26', 'zh': '1月26日'}, 'hash': '50e030854cdc071f', 'authors': ['Chuanyang Zheng'], 'affiliations': [], 'pdf_title_img': 'assets/pdf/title_img/2501.15369.jpg', 'data': {'categories': ['#optimization', '#training', '#cv', '#architecture'], 'emoji': '📱', 'ru': {'title': 'iFormer: Эффективные нейросети для мобильного компьютерного зрения', 'desc': 'iFormer - это новое семейство мобильных гибридных сетей компьютерного зрения, оптимизированных для мобильных приложений. Оно сочетает быструю локальную репрезентативную способность свёрточных сетей с эффективным глобальным моделированием механизма внимания. iFormer использует облегченную версию ConvNeXt и новый механизм модуляционного внимания для мобильных устройств. Эксперименты показывают, что iFormer превосходит существующие легковесные сети по точности и скорости работы на различных задачах, включая классификацию изображений, обнаружение объектов и сегментацию.'}, 'en': {'title': 'iFormer: Optimizing Mobile Vision with Speed and Accuracy', 'desc': 'The paper introduces iFormer, a new type of mobile hybrid vision network designed to enhance both speed and accuracy for mobile applications. It combines the quick local processing of convolutional networks with the effective global understanding of self-attention mechanisms. By modifying a standard convolutional architecture, ConvNeXt, iFormer creates a lightweight model that reduces memory usage while improving performance. Experimental results show that iFormer achieves high accuracy on ImageNet-1k and excels in various downstream tasks, all while maintaining low latency on mobile devices.'}, 'zh': {'title': 'iFormer：移动应用中的高效视觉网络', 'desc': '我们提出了一种新的移动混合视觉网络家族，称为iFormer，旨在优化移动应用的延迟和准确性。iFormer有效地结合了卷积的快速局部表示能力和自注意力的高效全局建模能力。通过将标准卷积网络ConvNeXt转化为更轻量级的移动网络，iFormer实现了局部交互的优化。我们的移动调制注意力机制去除了多头自注意力中的内存密集型操作，并采用高效的调制机制来增强动态全局表示能力。'}}}, {'id': 'https://huggingface.co/papers/2501.16295', 'title': 'Mixture-of-Mamba: Enhancing Multi-Modal State-Space Models with Modality-Aware Sparsity', 'url': 'https://huggingface.co/papers/2501.16295', 'abstract': 'State Space Models (SSMs) have emerged as efficient alternatives to Transformers for sequential modeling, but their inability to leverage modality-specific features limits their performance in multi-modal pretraining. Here, we propose Mixture-of-Mamba, a novel SSM architecture that introduces modality-aware sparsity through modality-specific parameterization of the Mamba block. Building on Mixture-of-Transformers (W. Liang et al. arXiv:2411.04996; 2024), we extend the benefits of modality-aware sparsity to SSMs while preserving their computational efficiency. We evaluate Mixture-of-Mamba across three multi-modal pretraining settings: Transfusion (interleaved text and continuous image tokens with diffusion loss), Chameleon (interleaved text and discrete image tokens), and an extended three-modality framework incorporating speech. Mixture-of-Mamba consistently reaches the same loss values at earlier training steps with significantly reduced computational costs. In the Transfusion setting, Mixture-of-Mamba achieves equivalent image loss using only 34.76% of the training FLOPs at the 1.4B scale. In the Chameleon setting, Mixture-of-Mamba reaches similar image loss with just 42.50% of the FLOPs at the 1.4B scale, and similar text loss with just 65.40% of the FLOPs. In the three-modality setting, MoM matches speech loss at 24.80% of the FLOPs at the 1.4B scale. Our ablation study highlights the synergistic effects of decoupling projection components, where joint decoupling yields greater gains than individual modifications. These results establish modality-aware sparsity as a versatile and effective design principle, extending its impact from Transformers to SSMs and setting new benchmarks in multi-modal pretraining. Our code can be accessed at https://github.com/Weixin-Liang/Mixture-of-Mamba', 'score': 1, 'issue_id': 1898, 'pub_date': '2025-01-27', 'pub_date_card': {'ru': '27 января', 'en': 'January 27', 'zh': '1月27日'}, 'hash': '011d06607305f0f8', 'authors': ['Weixin Liang', 'Junhong Shen', 'Genghan Zhang', 'Ning Dong', 'Luke Zettlemoyer', 'Lili Yu'], 'affiliations': ['Department of Computer Science, Stanford University', 'FAIR at Meta', 'Machine Learning Department, Carnegie Mellon University'], 'pdf_title_img': 'assets/pdf/title_img/2501.16295.jpg', 'data': {'categories': ['#multimodal', '#architecture', '#benchmark'], 'emoji': '🧠', 'ru': {'title': 'Mixture-of-Mamba: Эффективное мультимодальное обучение с модальность-специфической разреженностью', 'desc': 'В этой статье представлена новая архитектура модели состояний (SSM) под названием Mixture-of-Mamba, которая вводит модальность-специфическую разреженность для мультимодального предобучения. Mixture-of-Mamba расширяет преимущества модальность-осведомленной разреженности на SSM, сохраняя при этом их вычислительную эффективность. Модель была оценена в трех настройках мультимодального предобучения: Transfusion, Chameleon и расширенной трехмодальной системе, включающей речь. Результаты показывают, что Mixture-of-Mamba достигает тех же значений потерь на более ранних этапах обучения со значительно меньшими вычислительными затратами по сравнению с базовыми моделями.'}, 'en': {'title': 'Revolutionizing Multi-Modal Learning with Efficient SSMs', 'desc': 'This paper introduces Mixture-of-Mamba, a new State Space Model (SSM) that enhances multi-modal pretraining by incorporating modality-aware sparsity. By parameterizing the Mamba block specifically for different modalities, the model efficiently utilizes features from various data types like text, images, and speech. The results show that Mixture-of-Mamba achieves comparable performance to existing models while significantly reducing computational costs, using fewer floating point operations (FLOPs). This work demonstrates the effectiveness of modality-aware sparsity in improving SSMs, setting new benchmarks in the field of multi-modal learning.'}, 'zh': {'title': '模态感知稀疏性：提升SSM的多模态预训练效率', 'desc': '状态空间模型（SSMs）作为序列建模的有效替代方案，面临无法利用特定模态特征的问题。我们提出了一种新颖的SSM架构——Mixture-of-Mamba，通过对Mamba模块进行模态特定参数化，引入了模态感知稀疏性。该模型在多模态预训练中表现出色，能够在较早的训练步骤中达到相同的损失值，同时显著降低计算成本。我们的研究表明，模态感知稀疏性是一个有效的设计原则，能够将其影响从变换器扩展到SSMs，并在多模态预训练中设定新的基准。'}}}, {'id': 'https://huggingface.co/papers/2501.14912', 'title': 'Feasible Learning', 'url': 'https://huggingface.co/papers/2501.14912', 'abstract': 'We introduce Feasible Learning (FL), a sample-centric learning paradigm where models are trained by solving a feasibility problem that bounds the loss for each training sample. In contrast to the ubiquitous Empirical Risk Minimization (ERM) framework, which optimizes for average performance, FL demands satisfactory performance on every individual data point. Since any model that meets the prescribed performance threshold is a valid FL solution, the choice of optimization algorithm and its dynamics play a crucial role in shaping the properties of the resulting solutions. In particular, we study a primal-dual approach which dynamically re-weights the importance of each sample during training. To address the challenge of setting a meaningful threshold in practice, we introduce a relaxation of FL that incorporates slack variables of minimal norm. Our empirical analysis, spanning image classification, age regression, and preference optimization in large language models, demonstrates that models trained via FL can learn from data while displaying improved tail behavior compared to ERM, with only a marginal impact on average performance.', 'score': 0, 'issue_id': 1898, 'pub_date': '2025-01-24', 'pub_date_card': {'ru': '24 января', 'en': 'January 24', 'zh': '1月24日'}, 'hash': '7ded44debecf7694', 'authors': ['Juan Ramirez', 'Ignacio Hounie', 'Juan Elenter', 'Jose Gallego-Posada', 'Meraj Hashemizadeh', 'Alejandro Ribeiro', 'Simon Lacoste-Julien'], 'affiliations': ['Canada CIFAR AI Chair', 'Mila & Université de Montréal', 'Spotify', 'University of Pennsylvania'], 'pdf_title_img': 'assets/pdf/title_img/2501.14912.jpg', 'data': {'categories': ['#training', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Индивидуальный подход к каждому образцу данных', 'desc': 'В статье представлена новая парадигма обучения моделей машинного обучения - Feasible Learning (FL). В отличие от традиционного подхода минимизации эмпирического риска (ERM), FL стремится обеспечить удовлетворительную производительность для каждого отдельного образца данных. Авторы предлагают примально-двойственный подход, который динамически переопределяет важность каждого образца во время обучения. Эмпирический анализ на задачах классификации изображений, регрессии возраста и оптимизации предпочтений в больших языковых моделях показывает, что модели, обученные с помощью FL, демонстрируют улучшенное поведение на редких случаях по сравнению с ERM.'}, 'en': {'title': 'Ensuring Individual Sample Success with Feasible Learning', 'desc': "Feasible Learning (FL) is a new approach in machine learning that focuses on ensuring each training sample meets a specific performance standard, rather than just optimizing for overall average performance like traditional methods. This paradigm treats the training process as a feasibility problem, where any model that satisfies the performance criteria for all samples is considered valid. The paper explores a primal-dual optimization technique that adjusts the importance of each sample during training, enhancing the model's ability to learn effectively. Through various applications, including image classification and language model optimization, FL shows improved performance on challenging cases while maintaining similar average results compared to conventional methods."}, 'zh': {'title': '可行学习：每个样本都要优秀！', 'desc': '我们介绍了一种新的学习范式，称为可行学习（Feasible Learning，FL），它通过解决一个可行性问题来训练模型，从而限制每个训练样本的损失。与传统的经验风险最小化（Empirical Risk Minimization，ERM）框架不同，FL要求每个数据点都能达到满意的性能。FL的有效性依赖于优化算法的选择及其动态调整样本重要性的能力。我们的实证分析表明，使用FL训练的模型在图像分类、年龄回归和大语言模型的偏好优化中，能够在保持平均性能的同时，改善模型在极端情况下的表现。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents', '#agi', '#alignment', '#architecture (4)', '#audio (2)', '#benchmark (2)', '#cv (1)', '#data (2)', '#dataset (2)', '#diffusion', '#ethics', '#games (1)', '#graphs', '#hallucinations', '#healthcare', '#inference (1)', '#interpretability', '#leakage', '#long_context (1)', '#low_resource (1)', '#machine_translation', '#math', '#multilingual (1)', '#multimodal (2)', '#open_source (3)', '#optimization (5)', '#plp', '#rag', '#reasoning', '#rl (1)', '#rlhf', '#robotics', '#science', '#security', '#small_models (1)', '#story_generation', '#survey', '#synthetic', '#training (6)', '#transfer_learning (1)', '#video'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-01-28 12:18',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-01-28 12:18')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-01-28 12:18')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    