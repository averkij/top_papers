
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 1 paper. January 13.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">13 января</span> | <span id="title-articles-count">1 paper</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-01-10.html">⬅️ <span id="prev-date">10.01</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-01-14.html">➡️ <span id="next-date">14.01</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-01.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '13 января', 'en': 'January 13', 'zh': '1月13日'};
        let feedDateNext = {'ru': '14.01', 'en': '01/14', 'zh': '1月14日'};
        let feedDatePrev = {'ru': '10.01', 'en': '01/10', 'zh': '1月10日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': '2501.04519', 'title': 'rStar-Math: Small LLMs Can Master Math Reasoning with Self-Evolved Deep Thinking', 'url': 'https://huggingface.co/papers/2501.04519', 'abstract': 'We present rStar-Math to demonstrate that small language models (SLMs) can\nrival or even surpass the math reasoning capability of OpenAI o1, without\ndistillation from superior models. rStar-Math achieves this by exercising "deep\nthinking" through Monte Carlo Tree Search (MCTS), where a math policy SLM\nperforms test-time search guided by an SLM-based process reward model.\nrStar-Math introduces three innovations to tackle the challenges in training\nthe two SLMs: (1) a novel code-augmented CoT data sythesis method, which\nperforms extensive MCTS rollouts to generate step-by-step verified reasoning\ntrajectories used to train the policy SLM; (2) a novel process reward model\ntraining method that avoids na\\"ive step-level score annotation, yielding a\nmore effective process preference model (PPM); (3) a self-evolution recipe in\nwhich the policy SLM and PPM are built from scratch and iteratively evolved to\nimprove reasoning capabilities. Through 4 rounds of self-evolution with\nmillions of synthesized solutions for 747k math problems, rStar-Math boosts\nSLMs\' math reasoning to state-of-the-art levels. On the MATH benchmark, it\nimproves Qwen2.5-Math-7B from 58.8% to 90.0% and Phi3-mini-3.8B from 41.4% to\n86.4%, surpassing o1-preview by +4.5% and +0.9%. On the USA Math Olympiad\n(AIME), rStar-Math solves an average of 53.3% (8/15) of problems, ranking among\nthe top 20% the brightest high school math students. Code and data will be\navailable at https://github.com/microsoft/rStar.', 'score': 1, 'issue_id': 1, 'pub_date': '2025-01-08', 'pub_date_card': {'ru': '8 января', 'en': 'January 8', 'zh': '1月8日'}, 'hash': 'b065003de5fa3bde', 'authors': ['Xinyu Guan', 'Li Lyna Zhang', 'Yifei Liu', 'Ning Shang', 'Youran Sun', 'Yi Zhu', 'Fan Yang', 'Mao Yang'], 'affiliations': ['Microsoft', 'Peking University', 'Tsinghua University'], 'pdf_title_img': 'assets\\pdf\\title_img\\2501.04519.jpg', 'data': {'categories': ['#training', '#reasoning', '#optimization', '#benchmark', '#small_models', '#dataset'], 'emoji': '🧮', 'ru': {'title': 'Малые модели решают большие задачи: rStar-Math превосходит гигантов в математике', 'desc': 'Статья представляет rStar-Math - подход, позволяющий малым языковым моделям (SLM) достичь или превзойти способности крупных моделей в математических рассуждениях. Метод использует поиск по методу Монте-Карло (MCTS) с двумя специально обученными SLM: политикой и моделью вознаграждения. Авторы вводят новые методы синтеза обучающих данных, обучения модели вознаграждения и итеративного улучшения моделей. В результате rStar-Math значительно повышает эффективность SLM на математических тестах, превосходя более крупные модели.'}, 'en': {'title': 'Empowering Small Models to Excel in Math Reasoning', 'desc': 'The paper introduces rStar-Math, a framework that enhances the math reasoning abilities of small language models (SLMs) without relying on larger models. It employs Monte Carlo Tree Search (MCTS) to enable deep thinking, allowing the SLM to perform guided search during problem-solving. Key innovations include a code-augmented Chain of Thought (CoT) data synthesis method for generating verified reasoning paths, a refined process preference model (PPM) for better reward training, and a self-evolution strategy for iterative improvement. As a result, rStar-Math significantly boosts the performance of SLMs on math benchmarks, achieving state-of-the-art results in various assessments.'}, 'zh': {'title': '小型语言模型的数学推理新突破', 'desc': 'rStar-Math展示了小型语言模型（SLMs）在数学推理能力上可以与OpenAI的o1相媲美，甚至超越它，而无需从更强大的模型中蒸馏。该方法通过蒙特卡洛树搜索（MCTS）实现“深度思考”，在测试时由SLM驱动的过程奖励模型指导数学策略SLM进行搜索。rStar-Math引入了三项创新来解决训练两个SLM的挑战，包括新颖的代码增强的链式推理数据合成方法和更有效的过程偏好模型（PPM）训练方法。经过四轮自我进化，rStar-Math在747,000个数学问题上生成了数百万个合成解，使SLMs的数学推理能力达到了最先进的水平。'}}, 'clean_sections': [{'title': 'Abstract', 'content': 'We present rStar-Math to demonstrate that small language models (SLMs) can rival or even surpass the math reasoning capability of OpenAI o1, without distillation from superior models. rStar-Math achieves this by exercising "deep thinking" through Monte Carlo Tree Search (MCTS), where a math policy SLM performs test-time search guided by an SLM-based process reward model. rStar-Math introduces three innovations to tackle the challenges in training the two SLMs: (1) a novel code-augmented CoT data sythesis method, which performs extensive MCTS rollouts to generate step-by-step verified reasoning trajectories used to train the policy SLM; (2) a novel process reward model training method that avoids na\\"ive step-level score annotation, yielding a more effective process preference model (PPM); (3) a self-evolution recipe in which the policy SLM and PPM are built from scratch and iteratively evolved to improve reasoning capabilities. Through 4 rounds of self-evolution with millions of synthesized solutions for 747k math problems, rStar-Math boosts SLMs\' math reasoning to state-of-the-art levels. On the MATH benchmark, it improves Qwen2.5-Math-7B from 58.8% to 90.0% and Phi3-mini-3.8B from 41.4% to 86.4%, surpassing o1-preview by +4.5% and +0.9%. On the USA Math Olympiad (AIME), rStar-Math solves an average of 53.3% (8/15) of problems, ranking among the top 20% the brightest high school math students. Code and data will be available at https://github.com/microsoft/rStar.', 'summary': '<p>В данной работе представлен метод rStar-Math, демонстрирующий, что небольшие языковые модели (SLM) могут достигать или даже превосходить возможности OpenAI o1 в математических рассуждениях. Это достигается за счет "глубокого мышления" с использованием поиска Монте-Карло (MCTS). В этом подходе SLM, выступающая в роли "математической политики", проводит поиск во время тестирования, ориентируясь на модель вознаграждения процесса, также основанную на SLM.</p>\n<p>rStar-Math предлагает три ключевых нововведения для решения проблем обучения этих двух SLM:</p>\n<ol>\n<li><strong>Новый метод синтеза данных CoT с расширением кодом:</strong> Этот метод использует MCTS для генерации подробных, пошагово проверенных траекторий рассуждений. Эти траектории затем используются для обучения SLM, отвечающей за математическую политику. (CoT - Chain of Thought, метод, при котором модель выдает не только ответ, но и цепочку рассуждений, приведших к нему)</li>\n<li><strong>Новый метод обучения модели вознаграждения процесса:</strong> Этот метод избегает прямого присвоения оценок на каждом шаге рассуждения. Вместо этого, он обучает более эффективную модель предпочтений процесса (PPM). (Т.е. модель оценивает не отдельные шаги, а предпочтительность всей траектории рассуждений)</li>\n<li><strong>Рецепт саморазвития:</strong> В этом подходе SLM, отвечающая за политику, и PPM строятся с нуля и итеративно развиваются для улучшения возможностей рассуждения.</li>\n</ol>\n<p>Благодаря 4 раундам саморазвития с использованием миллионов синтезированных решений для 747 тысяч математических задач, rStar-Math повышает уровень математических рассуждений SLM до самых современных показателей. На бенчмарке MATH, rStar-Math улучшает результаты Qwen2.5-Math-7B с 58.8% до 90.0% и Phi3-mini-3.8B с 41.4% до 86.4%, превосходя o1-preview на +4.5% и +0.9% соответственно. На USA Math Olympiad (AIME) rStar-Math решает в среднем 53.3% (8 из 15) задач, что ставит его в топ 20% самых способных учеников старших классов в области математики. Код и данные будут доступны по ссылке https://github.com/microsoft/rStar.</p>'}, {'title': 'Recent Studies', 'content': 'Equal contribution. Project leader; correspondence to lzhani@microsoft.com Xinyu Guan and Youran Sun did this work during the internship at MSRA. Xinyu Guan (2001gxy@gmail.com) is with Peking University, Youran Sun is with Tsinghua University. Figure 1: The overview of rStar-Math. In the test-time compute paradigm, the key is to train powerful policy model that generates promising solution steps and reliable reward model that accurately evaluates them, both of which depend on high-quality training data. Unfortunately, it is well-known that off-the-shelf high-quality math reasoning data is scarce, and synthesizing high-quality math data faces fundamental challenges. For the policy model, it is challenging to distinguish erroneous reasoning steps from the correct ones, complicating the elimination of low-quality data. It is worth noting that in math reasoning, correct final answer does not ensure the correctness of the entire reasoning trace [Lanham et al., 2023]. Incorrect intermediate steps significantly decrease data quality. As for the reward model, process reward modeling (PRM) shows great potential by providing fine-grained feedback on intermediate steps [Lightman et al., 2023]. However, the training data is even scarcer in this regard: accurate step-by-step feedback requires intense human labeling efforts and is impractical to scale, while those automatic annotation attempts show limited gains due to noisy reward scores [Luo et al., 2024, Wang et al., 2024c, Chen et al., 2024]. Due to the above challenges, existing distill-based data synthesis approaches to training policy models, e.g., scaling up GPT4-distilled CoT data [Tang et al., 2024, Huang et al., 2024], have shown diminishing returns and cannot exceed the capability of their teacher model; meanwhile, as of today, training reliable PRMs for math reasoning remains an open question. In this work, we introduce rStar-Math, self-evolvable System 2-style reasoning approach that achieves the state-of-the-art math reasoning, rivaling and sometimes even surpassing OpenAI o1 on challenging math competition benchmarks with model size as small as 7 billion. Unlike solutions relying on superior LLMs for data synthesis, rStar-Math leverages smaller language models (SLMs) with Monte Carlo Tree Search (MCTS) to establish self-evolutionary process, iteratively generating higher-quality training data. To achieve self-evolution, rStar-Math introduces three key innovations. First, novel code-augmented CoT data synthesis method, which performs extensive MCTS rollouts to generate step-by-step verified reasoning trajectories with self-annotated MCTS Q-values. Specifically, math problem-solving is decomposed into multi-step generation within MCTS. At each step, the SLM serving as the policy model samples candidate nodes, each generating one-step CoT and the corresponding Python code. To verify the generation quality, only nodes with successful Python code execution are retained, thus mitigating errors in intermediate steps. Moreover, extensive MCTS rollouts automatically assign Q-value to each intermediate step based on its contribution: steps contributing to more trajectories that lead to the correct answer are given higher Q-values and considered higher quality. This ensures that the reasoning trajectories generated by SLMs consist of correct, high-quality intermediate steps. Second, novel method that trains an SLM acting as process preference model, i.e., PPM to implement the desired PRM, that reliably predicts reward label for each math reasoning step. The PPM leverages the fact that, although Q-values are still not precise enough to score each reasoning step despite using extensive MCTS rollouts, the Q-values can reliably distinguish positive (correct) steps from negative (irrelevant/incorrect) ones. Thus the training method constructs preference pairs for each step based on Q-values and uses pairwise ranking loss [Ouyang et al., 2022] to optimize PPMs score prediction for each reasoning step, achieving reliable labeling. This approach avoids conventional methods that directly use Q-values as reward labels [Luo et al., 2024, Chen et al., 2024], which are inherently noisy and imprecise in stepwise reward assignment. Finally, four-round self-evolution recipe that progressively builds both frontier policy model and PPM from scratch. We begin by curating dataset of 747k math word problems from publicly available sources. In each round, we use the latest policy model and PPM to perform MCTS, 2 generating increasingly high-quality training data using the above two methods to train stronger policy model and PPM for next round. Each round achieves progressive refinement: (1) stronger policy SLM, (2) more reliable PPM, (3) generating better reasoning trajectories via PPM-augmented MCTS, and (4) improving training data coverage to tackle more challenging and even competitionlevel math problems. Extensive experiments across four SLMs (1.5B-7B) and seven math reasoning tasks demonstrate the effectiveness of rStar-Math. Remarkably, rStar-Math improves all four SLMs, matching or even surpassing OpenAI o1 on challenging math benchmarks. On MATH benchmark, with 8 search trajectories, rStar-Math boosts Qwen2.5-Math-7B from 58.8% to 89.4% and Qwen2.5-Math-1.5B from 51.2% to 87.8%. With 64 trajectories, the scores rise to 90% and 88.4%, outperforming o1-preview by 4.5% and 2.6% and matching o1-minis 90%. On the Olympiad-level AIME 2024, rStar-Math solves on average 53.3% (8/15) of the problems, exceeding o1-preview by 8.7% and all other open-sourced LLMs. We further conduct comprehensive experiments to verify the superiority of step-by-step verified reasoning trajectories over state-of-the-art data synthesis baselines, as well as the PPMs effectiveness compared to outcome reward models and value-based PRMs. Finally, we present key findings from rStar-Math deep thinking, including the intrinsic self-reflection capability and PPMs preference for theorem-applications intermediate steps.', 'summary': '<p>В данной работе представлен rStar-Math, подход к решению математических задач, основанный на самообучении и имитирующий мышление второго типа (System 2). Этот подход позволяет достигать результатов на уровне лучших моделей, включая OpenAI o1, даже при использовании относительно небольших языковых моделей (до 7 миллиардов параметров).</p>\n<p>Основная проблема при обучении моделей для решения математических задач заключается в нехватке качественных данных.  Проблема в том, что даже если получен верный ответ, это не гарантирует правильность всех промежуточных шагов решения.  Ошибочные промежуточные шаги снижают качество обучающих данных. Кроме того, для обучения моделей, оценивающих промежуточные шаги решения, требуется разметка данных с подробным указанием правильности каждого шага, что очень трудоемко. Автоматическая разметка пока не дает удовлетворительных результатов из-за шума в оценках.  Поэтому, подходы, основанные на дистилляции знаний из больших моделей, достигают предела и не превосходят своих учителей.</p>\n<p>rStar-Math решает эту проблему, используя малые языковые модели (SLM) и поиск по дереву Монте-Карло (MCTS) для самообучения.  Процесс включает в себя три ключевых нововведения:</p>\n<ol>\n<li><strong>Генерация данных с проверкой кода:</strong>  Процесс решения задачи разбивается на несколько шагов в рамках MCTS. На каждом шаге SLM генерирует один шаг решения в виде цепочки рассуждений (CoT) и соответствующего кода на Python.  Для проверки качества, сохраняются только те шаги, для которых код успешно выполняется.  Это позволяет отсеять ошибочные промежуточные шаги. Кроме того, MCTS автоматически присваивает каждому шагу Q-значение, которое показывает вклад шага в получение правильного ответа. Шаги, которые чаще приводят к правильному ответу, получают более высокие Q-значения.</li>\n<li><strong>Обучение модели оценки промежуточных шагов (PPM):</strong> Эта модель предсказывает оценку (reward) для каждого шага решения.  Для обучения PPM используется тот факт, что Q-значения, хотя и не являются точными оценками, позволяют надежно отличать правильные шаги от неправильных.  Для каждого шага создаются пары предпочтений на основе Q-значений, и модель обучается с помощью ранжирующей функции потерь. Такой подход позволяет избежать прямого использования Q-значений в качестве оценок, которые изначально зашумлены.</li>\n<li><strong>Четырехэтапный процесс самообучения:</strong> Начинается со сбора 747 тысяч задач из открытых источников. На каждом этапе используется последняя версия модели решения (policy model) и PPM для выполнения MCTS и генерации улучшенных обучающих данных. Затем на этих данных обучаются более сильные модели.  Каждый этап приводит к усилению модели, повышению надежности PPM, улучшению траекторий решения и расширению охвата задач.</li>\n</ol>\n<p>Эксперименты с разными SLM (от 1.5 до 7 миллиардов параметров) на семи задачах показали эффективность rStar-Math.  На наборе данных MATH, rStar-Math повысил точность модели Qwen2.5-Math-7B с 58.8% до 89.4%, а Qwen2.5-Math-1.5B с 51.2% до 87.8%. С 64 траекториями поиска, результаты достигают 90% и 88.4% соответственно, превосходя o1-preview и приближаясь к o1-minis. На олимпиаде AIME 2024, rStar-Math решил 53.3% задач, что на 8.7% больше, чем o1-preview. Проведенные эксперименты подтвердили превосходство подхода rStar-Math по сравнению с другими методами синтеза данных и методами оценки промежуточных шагов.</p>'}, {'title': 'Related Works', 'content': 'Math Data Synthesis. Advancements in LLM math reasoning have largely relied on curating high-quality CoT data, with most leading approaches being GPT-distilled, using frontier models like GPT-4 for synthesis [Wang et al., 2024b, Gou et al., 2023, Luo et al., 2023]. Notable works include NuminaMath [Jia LI and Polu, 2024a] and MetaMath [Yu et al., 2023b]. While effective, this limits reasoning to the capabilities of the teacher LLM. Hard problems that the teacher LLM cannot solve are excluded in the training set. Even solvable problems may contain error-prone intermediate steps, which are hard to detect. Although rejection sampling methods [Yuan et al., 2023, Brown et al., 2024] can improve data quality, they do not guarantee correct intermediate steps. As result, scaling up CoT data has diminishing returns, with gains nearing saturatione.g., OpenMathInstruct-2 [Toshniwal et al., 2024] only sees 3.9% boost on MATH despite an 8 increase in dataset size. Scaling Test-time Compute has introduced new scaling laws, allowing LLMs to improve performance across by generating multiple samples and using reward models for best-solution selection [Snell et al., 2024, Wu et al., 2024, Brown et al., 2024]. Various test-time search methods have been proposed [Kang et al., 2024, Wang et al., 2024a], including random sampling [Wang et al., 2023] and tree-search methods [Yao et al., 2024, Hao et al., 2023, Zhang et al., 2024b, Qi et al., 2024] like MCTS. However, open-source methods for scaling test-time computation have shown limited gains in math reasoning, often due to policy LLM or reward model limitations. rStar-Math addresses this by iteratively evolving the policy LLM and reward model, achieving System 2 mathematical reasoning performance comparable to OpenAI o1 [OpenAI, 2024]. Reward Models are crucial for effective System 2 reasoning but are challenging to obtain. Recent works include LLM-as-a-Judge for verification [Zheng et al., 2023, Qi et al., 2024] and specialized reward models like Outcome Reward Model [Yang et al., 2024, Yu et al., 2023a] and Process Reward Model (PRM) [Lightman et al., 2024]. While PRMs offer promising dense, step-level reward signals for complex reasoning [Luo et al., 2024, Wang et al., 2024c], collecting step-level annotations remains an obstacle. While Kang et al. [2024], Wang et al. [2024a] rely on costly human-annotated datasets like PRM800k [Lightman et al., 2024], recent approaches [Wang et al., 2024c, Luo et al., 2024] explore automated annotation via Monte Carlo Sampling or MCTS. However, they struggle to generate precise reward scores, which limits performance gains. rStar-Math introduces novel process preference reward (PPM) that eliminates the need for accurate step-level reward score annotation.', 'summary': '<p><strong>Синтез математических данных</strong></p>\n<p>Успехи в области математических рассуждений с использованием больших языковых моделей (LLM) во многом зависят от создания высококачественных данных для обучения методу Chain-of-Thought (CoT). Большинство ведущих подходов используют дистилляцию знаний из продвинутых моделей, таких как GPT-4. Примеры таких работ включают NuminaMath и MetaMath. Однако, этот подход ограничивает возможности рассуждений способностями обучающей LLM. Сложные задачи, которые обучающая LLM не может решить, исключаются из обучающего набора данных. Даже в решаемых задачах могут содержаться ошибочные промежуточные шаги, которые трудно обнаружить.</p>\n<p>Методы отбора с отбраковкой могут улучшить качество данных, но не гарантируют правильность промежуточных шагов. В результате, увеличение объема данных CoT приводит к снижению отдачи, когда прирост производительности приближается к насыщению. Например, OpenMathInstruct-2 демонстрирует лишь 3.9% прирост на наборе данных MATH, несмотря на восьмикратное увеличение размера набора данных.</p>\n<p>Масштабирование вычислений во время тестирования (test-time compute) ввело новые законы масштабирования, позволяя LLM улучшать производительность за счет генерации нескольких образцов и использования моделей вознаграждения для выбора наилучшего решения. Были предложены различные методы поиска во время тестирования, включая случайную выборку и методы древовидного поиска, такие как MCTS. Однако открытые методы масштабирования вычислений во время тестирования показали ограниченные успехи в математических рассуждениях, часто из-за ограничений самой LLM или модели вознаграждения.</p>\n<p>rStar-Math решает эту проблему путем итеративного развития LLM и модели вознаграждения, достигая производительности в математических рассуждениях, сравнимой с OpenAI o1. Модели вознаграждения играют ключевую роль в эффективных рассуждениях, но их сложно получить. Недавние работы включают использование LLM в качестве "судьи" для проверки и специализированные модели вознаграждения, такие как Outcome Reward Model и Process Reward Model (PRM). PRM предлагают многообещающие сигналы вознаграждения на уровне шагов для сложных рассуждений, но сбор аннотаций на уровне шагов остается проблемой.</p>\n<p>В то время как некоторые работы полагаются на дорогостоящие наборы данных с аннотациями, другие исследуют автоматизированную аннотацию с помощью Monte Carlo Sampling или MCTS. Однако, они испытывают трудности с генерацией точных оценок вознаграждения, что ограничивает прирост производительности. rStar-Math представляет новый метод вознаграждения на основе предпочтений процесса (PPM), который устраняет необходимость в точной аннотации оценок вознаграждения на уровне шагов.</p>'}, {'title': 'Methodology', 'content': '3.1 Design Choices MCTS for Effective System 2 Reasoning. We aim to train math policy SLM and process reward model (PRM), and integrating both within Monte Carlo Tree Search (MCTS) for System 2 deep thinking. MCTS is chosen for two key reasons. First, it breaks down complex math problems into simpler single-step generation tasks, reducing the difficulty for the policy SLM compared to other 3 System 2 methods like Best-of-N [Brown et al., 2024] or self-consistency [Wang et al., 2023], which require generating full solutions in one inference. Second, the step-by-step generation in MCTS naturally yields step-level training data for both models. Standard MCTS rollout automatically assign Q-value to each step based on its contribution to the final correct answer, obviating the need for human-generated step-level annotations for process reward model training. Ideally, advanced LLMs such as GPT-4 could be integrated within MCTS to generate training data. However, this approach faces two key challenges. First, even these powerful models struggle to consistently solve difficult problems, such as Olympiad-level mathematics. Consequently, the resulting training data would primarily consist of simpler solvable problems, limiting its diversity and quality. Second, annotating per-step Q-values demands extensive MCTS rollouts; insufficient tree exploration can lead to spurious Q-value assignments, such as overestimating suboptimal steps. Given that each rollout involves multiple single-step generations and these models are computationally expensive, increasing rollouts significantly raises inference costs. Overview. To this end, we explore using two 7B SLMs (a policy SLM and PRM) to generate higherquality training data, with their smaller size allowing for extensive MCTS rollouts on accessible hardware (e.g., 440GB A100 GPUs). However, self-generating data presents greater challenges for SLMs, due to their weaker capabilities. SLMs frequently fail to generate correct solutions, and even when the final answer is correct, the intermediate steps are often flawed or of poor quality. Moreover, SLMs solve fewer challenging problems compared to advanced models like GPT-4. This section introduces our methodology, as illustrated in Fig. 1. To mitigate errors and low-quality intermediate steps, we introduce code-augmented CoT synthetic method, which performs extensive MCTS rollouts to generate step-by-step verified reasoning trajectories, annotated with Q-values. To further improve SLM performance on challenging problems, we introduce four-round self-evolution recipe. In each round, both the policy SLM and the reward model are updated to stronger versions, progressively tackling more difficult problems and generating higher-quality training data. Finally, we present novel process reward model training approach that eliminates the need for precise per-step reward annotations, yielding the more effective process preference model (PPM). 3.2 Step-by-Step Verified Reasoning Trajectory We start by introducing our method for generating step-by-step verified reasoning trajectories with per-step Q-value annotations. Given problem and policy model , we run the standard MCTS to incrementally construct search tree for step-by-step solution exploration. As shown in Fig. 1(a), the root node represents question x, while child nodes correspond to intermediate steps generated by . root-to-leaf path ending at terminal node sd forms trajectory = s1 s2 ... sd, with each step si assigned Q-value Q(si). From the search tree , we extract solution trajectories = {t1, t2, ..., tn}(n 1). Our goal is to select high-quality trajectories from to construct the training set. For this purpose, we introduce code-augmented CoT synthesis method to filter out low-quality generations and perform extensive rollouts to improve the reliability of Q-value accuracy. Code-augmented CoT Generation. Prior MCTS approaches primarily generate natural language (NL) CoTs [Qi et al., 2024, Zhang et al., 2024a]. However, LLMs often suffer from hallucination, producing incorrect or irrelevant steps yet still arrive at the correct answer by chance [Lanham et al., 2023]. These flawed steps are challenging to detect and eliminate. To address this, we propose novel code execution augmented CoT. As shown in Fig. 2, the policy model generates one-step NL CoT alongside its corresponding Python code, where the NL CoT is embedded as Python comment. Only generations with successfully executed Python code are retained as valid candidates. Figure 2: An example of Code-augmented CoT. Specifically, starting from the initial root node x, we perform multiple MCTS iterations through selection, expansion, rollout, and back-propagation. At step i, we collect the latest reasoning trajectory s1 s2 ... si1 as the current state. Based on this state, we prompt (see Appendix A.3) the policy model to generate candidates si,0, ..., si,n1 for step i. Python code execution is then employed to filter valid nodes. As shown in Fig. 2, each generation si,j is concatenated with the code from all previous steps, forming s1 s2 ... si1 si,j. Candidates that execute successfully are retained as valid nodes and scored by the PPM, which assigns Q-value q(si). Then, we use the well-known Upper Confidence bounds for Trees (UCT) [Kocsis and Szepesvári, 2006] to select the best node among the candidates. This selection process is mathematically represented as: UCT(s) = Q(s) + (cid:115) ln Nparent(s) (s) ; where Q(s) = q(s) (s) (1) where (s) denotes the number of visits to node s, and Nparent(s) is the visit count of ss parent node. The predicted reward q(s) is provided by the PPM and will be updated through back-propagation. is constant that balances exploitation and exploration. Extensive Rollouts for Q-value Annotation. Accurate Q-value Q(s) annotation in Eq. 1 is crucial for guiding MCTS node selection towards correct problem-solving paths and identifying high-quality steps within trajectories. To improve Q-value reliability, we draw inspiration from Go players, who retrospectively evaluate the reward of each move based on game outcomes. Although initial estimates may be imprecise, repeated gameplay refines these evaluations over time. Similarly, in each rollout, we update the Q-value of each step based on its contribution to achieving the correct final answer. After extensive MCTS rollouts, steps consistently leading to correct answers achieve higher Q-values, occasional successes yield moderate Q-values, and consistently incorrect steps receive low Q-values. Specifically, we introduce two self-annotation methods to obtain these step-level Q-values. Fig. 1(c) shows the detailed setting in the four rounds of self-evolution. Terminal-guided annotation. During the first two rounds, when the PPM is unavailable or insufficiently accurate, we use terminal-guided annotation. Formally, let q(si)k denote the value for step si after back-propagation in the kth rollout. Following AlphaGo [Silver et al., 2017] and rStar [Qi et al., 2024], we score each intermediate node based on its contribution to the final correct answer: q(si)k = q(si)k1 + q(sd)k; where the initial value q(si)0 = 0 in the first rollout. If this step frequently leads to correct answer, its value will increase; otherwise, it decreases. Terminal nodes are scored as q(sd) = 1 for correct answers and q(sd) = 1 otherwise, as shown in Fig. 1. (2) PRM-augmented annotation. Starting from the third round, we use PPM to score each step for more effective generation. Compared to terminal-guided annotation, which requires multiple rollouts for meaningful value, PPM directly predicts non-zero initial value. PPM-augmented MCTS also helps the policy model to generate higher-quality steps, guiding solutions towards correct paths. Formally, for step si, PPM predicts an initial q(si)0 value based on the partial trajectory: q(si)0 = (x s1 s2 ... si1 si) This value will be updated based on terminal nodes q(sd) value through MCTS back-propagation in Eq. 2. For terminal node sd, we do not use PRM for scoring during training data generation. Instead, we assign more accurate score based on ground truth labels as terminal-guided rewarding. (3) 3.3 Process Preference Model Process reward models, which provide granular step-level reward signals, is highly desirable for solving challenging math problems. However, obtaining high-quality step-level training data remains an open challenge. Existing methods rely on human annotations [Lightman et al., 2023] or MCTSgenerated scores [Zhang et al., 2024a, Chen et al., 2024] to assign score for each step. These scores then serve as training targets, with methods such as MSE loss [Chen et al., 2024] or pointwise loss [Wang et al., 2024c, Luo et al., 2024, Zhang et al., 2024a] used to minimize the difference between predicted and labeled scores. As result, the precision of these annotated step-level reward scores directly determines the effectiveness of the resulting process reward model. Unfortunately, precise per-step scoring remains unsolved challenge. Although our extensive MCTS rollouts improve the reliability of Q-values, precisely evaluating fine-grained step quality presents 5 major obstacle. For instance, among set of correct steps, it is difficult to rank them as best, secondbest, or average and then assign precise scores. Similarly, among incorrect steps, differentiating the worst from moderately poor steps poses analogous challenges. Even expert human annotation struggles with consistency, particularly at scale, leading to inherent noise in training labels. We introduce novel training method that trains process preference model (PPM) by constructing step-level positive-negative preference pairs. As shown in Fig. 1(b), instead of using Q-values as direct reward labels, we use them to select steps from MCTS tree for preference pair construction. For each step, we select two candidates with the highest Q-values as positive steps and two with the lowest as negative steps. Critically, the selected positive steps must lead to correct final answer, while negative steps must lead to incorrect answers. For intermediate steps (except the final answer step), the positive and negative pairs share the same preceding steps. For the final answer step, where identical reasoning trajectories rarely yield different final answers, we relax this restriction. We select two correct trajectories with the highest average Q-values as positive examples and two incorrect trajectories with the lowest average Q-values as negative examples. Following [Ouyang et al., 2022], we define our loss function using the standard Bradley-Terry model with pairwise ranking loss: Lppm(θ) = when is not final answer step, ypos E(x,ypos = s1 ... si1 spos (5) Here, rθ(x, yi) denotes the output of the PPM, where is the problem and is the trajectory from the first step to the ith step. D)[log(σ(rθ(x, ypos ,yneg ; yneg = s1 ... si1 sneg ) rθ(x, yneg )))] (4) i 1 2 2 3.4 Self-Evolved Deep Thinking 3.4.1 Training with Step-by-Step Verified Reasoning Trajectory Math Problems Collection. We collect large dataset of 747k math word problems with final answer ground-truth labels, primarily from NuminaMath [Jia LI and Polu, 2024a] and MetaMath [Yu et al., 2023b]. Notably, only competition-level problems (e.g., Olympiads and AIME/AMC) from NuminaMath are included, as we observe that grade-school-level problems do not significantly improve LLM complex math reasoning. To augment the limited competition-level problems, we follow [Li et al., 2024] and use GPT-4 to synthesize new problems based on the seed problems in 7.5k MATH train set and 3.6k AMC-AIME training split. However, GPT-4 often generated unsolvable problems or incorrect solutions for challenging seed problems. To filter these, we prompt GPT-4 to generate 10 solutions per problem, retaining only those with at least 3 consistent solutions. Reasoning Trajectories Collection. Instead of using the original solutions in the 747k math dataset, we conduct extensive MCTS rollouts (Sec. 3.2) to generate higher-quality step-by-step verified reasoning trajectories. In each self-evolution round, we perform 16 rollouts per math problem, which leads to 16 reasoning trajectories. Problems are then categories by difficulty based on the correct ratio of the generated trajectories: easy (all solutions are correct), medium (a mix of correct and incorrect solutions) and hard (all solutions are incorrect). For hard problems with no correct trajectories, an additional MCTS with 16 rollouts is performed. After that, all step-by-step trajectories and their annotated Q-values are collected and filtered to train the policy SLM and process preference model. Supervised Fine-tuning the Policy SLM. Through extensive experiments, we find that selecting high-quality reasoning trajectories is the key for fine-tuning frontier math LLM. While methods such as GPT-distillation and Best-of-N can include low-quality or erroneous intermediate steps, more effective approach ensures that every step in the trajectory is of high quality. To achieve this, we use per-step Q-values to select optimal trajectories from MCTS rollouts. Specifically, for each math problem, we select the top-2 trajectories with the highest average Q-values among those leading to correct answers as SFT training data. Training PPM. The PPM is initialized from the fine-tuned policy model, with its next-token prediction head replaced by scalar-value head consisting of linear layer and tanh function to constrain outputs to the range [-1, 1]. We filter out math problems where all solution trajectories are fully correct or incorrect. For problems with mixed outcomes, we select two positive and two negative examples for each step based on Q-values, which are used as preference pairs for training data. 3.4.2 Recipe for Self-Evolution Due to the weaker capabilities of SLMs, we perform four rounds of MCTS deep thinking to progressively generate higher-quality data and expand the training set with more challenging math problems. Table 2: Percentage of the 747k math problems correctly solved in each round. Only problems have correct solutions are included in the training set. The first round uses DeepSeek-Coder-Instruct as the policy LLM, while later rounds use our fine-tuned 7B policy SLM. # models in MCTS GSM-level MATH-level Olympiad-level All Round 1 DeepSeek-Coder-V2-Instruct Round 2 Round 3 Round policy SLM-r1 policy SLM-r2, PPM-r2 policy SLM-r3, PPM-r3 96.61% 97.88% 98.15% 98.15% 67.36% 67.40% 88.69% 94.53% 20.99% 56.04% 62.16% 80.58% 60.17% 66.60% 77.86% 90.25% Table 3: Pass@1 accuracy of the resulting policy SLM in each round, showing continuous improvement until surpassing the bootstrap model. Round# MATH AIME 2024 AMC 2023 Olympiad Bench College Math GSM8K GaokaoEn 2023 DeepSeek-Coder-V2-Instruct (bootstrap model) Base (Qwen2.5-Math-7B) policy SLM-r1 policy SLM-r2 policy SLM-r3 policy SLM-r4 75.3 58.8 69.6 73.6 75.8 78. 13.3 0.0 3.3 10.0 16.7 26.7 57.5 22.5 30.0 35.0 45.0 47.5 37.6 21.8 34.7 39.0 44.1 47. 46.2 41.6 44.5 45.7 49.6 52.5 94.9 91.6 88.4 89.1 89.3 89.7 64.7 51.7 57.4 59.7 62.8 65. Each round uses MCTS to generate step-by-step verified reasoning trajectories, which are then used to train the new policy SLM and PPM. The new models are then applied in next round to generate higher-quality training data. Fig. 1(c) and Table 2 detail the models used for data generation in each round, along with the identifiers of the trained policy model and PPM. Next, we outline the details and specific improvements targeted in each round. Round 1: Bootstrapping an initial strong policy SLM-r1. To enable SLMs to self-generate reasonably good training data, we perform bootstrap round to fine-tune an initial strong policy model, denoted as SLM-r1. As shown in Table 2, we run MCTS with DeepSeek-Coder-V2-Instruct (236B) to collect the SFT data. With no available reward model in this round, we use terminal-guided annotation for Q-values and limit MCTS to 8 rollouts for efficiency. For correct solutions, the top-2 trajectories with the highest average Q-values are selected as SFT data. We also train PPM-r1, but the limited rollouts yields unreliable Q-values, affecting the effectiveness of PPM-r1 ( Table 4). Round 2: Training reliable PPM-r2. In this round, with the policy model updated to the 7B SLM-r1, we conduct extensive MCTS rollouts for more reliable Q-value annotation and train the first reliable reward model, PPM-r2. Specifically, we perform 16 MCTS rollouts per problem. The resulting step-by-step verified reasoning trajectories show significant improvements in both quality and Q-value precision. As shown in Table 4, PPM-r2 is notably more effective than in the bootstrap round. Moreover, the policy SLM-r2 also continues to improve as expected  (Table 3)  . Round 3: PPM-augmented MCTS to significantly improve data quality. With the reliable PPM-r2, we perform PPM-augmented MCTS in this round to generate data, leading to significantly higher-quality trajectories that cover more math and Olympiad-level problems in the training set  (Table 2)  . The generated reasoning trajectories and self-annotated Q-values are then used to train the new policy SLM-r3 and PPM-r3, both of which show significant improvements. Round 4: Solving challenging math problems. After the third round, while grade school and MATH problems achieve high success rates, only 62.16% of Olympiad-level problems are included in the training set. This is NOT solely due to weak reasoning abilities in our SLMs, as many Olympiad problems remain unsolved by GPT-4 or o1. To improve coverage, we adopt straightforward strategy. For unsolved problems after 16 MCTS rollouts, we perform an additional 64 rollouts, and if needed, increase to 128. We also conduct multiple MCTS tree expansions with different random seeds. This boosts the success rate of Olympiad-level problems to 80.58%. After four rounds of self-evolution, 90.25% of the 747k math problems are successfully covered into the training set, as shown in Table 2. Among the remaining unsolved problems, significant portion consists of synthetic questions. We manually review random sample of 20 problems and find that 19 are incorrectly labeled with wrong answers. Based on this, we conclude that the remaining unsolved problems are of low quality and thus terminate the self-evolution at round 4. 7 Table 4: The quality of PPM consistently improves across rounds. The policy model has been fixed with policy SLM-r1 for fair comparison. Round# MATH AIME 2024 AMC 2023 Olympiad Bench College Math GSM8K GaokaoEn 2023 PPM-r1 PPM-r2 PPM-r3 PPM-r4 75.2 84.1 85.2 87. 10.0 26.7 33.3 43.3 57.5 75.0 77.5 77.5 35.7 52.7 59.5 61.5 45.4 54.2 55.6 56.8 90.9 93.3 93.9 94.2 60.3 73.0 76.6 77.', 'summary': '<h2>Изложение раздела 3.1-3.3 статьи о применении MCTS для решения математических задач</h2>\n<p>В этой работе предлагается подход к решению сложных математических задач, основанный на использовании метода Монте-Карло древовидного поиска (MCTS) в сочетании с двумя моделями: политикой (SLM) и моделью вознаграждения (PRM). MCTS выбран в качестве основного инструмента по двум причинам. Во-первых, он декомпозирует сложные задачи на более простые одношаговые задачи генерации, что облегчает работу модели политики по сравнению с другими методами, такими как Best-of-N или самосогласованность, которые требуют генерации полных решений за один проход. Во-вторых, пошаговая генерация в MCTS естественным образом предоставляет данные для обучения обеих моделей. Стандартный MCTS автоматически присваивает Q-значение каждому шагу, основываясь на его вкладе в итоговый правильный ответ, что избавляет от необходимости в ручной разметке данных для обучения модели вознаграждения.</p>\n<p>Использование продвинутых языковых моделей (LLM), таких как GPT-4, для генерации обучающих данных в рамках MCTS сталкивается с двумя проблемами. Во-первых, даже такие мощные модели не всегда могут стабильно решать сложные задачи, например, олимпиадного уровня. В результате, обучающие данные будут состоять в основном из простых, решаемых задач, что ограничит их разнообразие и качество. Во-вторых, аннотирование Q-значений для каждого шага требует большого количества прогонов MCTS; недостаточное исследование дерева может привести к ложным значениям, например, к переоценке неоптимальных шагов. Учитывая, что каждый прогон включает в себя несколько одношаговых генераций, а LLM являются вычислительно затратными, увеличение количества прогонов значительно повышает стоимость инференса.</p>\n<p>Для решения этих проблем авторы используют две 7B модели SLM (одна для политики и одна для PRM) для генерации более качественных обучающих данных. Меньший размер этих моделей позволяет проводить обширные прогоны MCTS на доступном оборудовании. Однако, самогенерация данных представляет собой большую проблему для SLM из-за их меньших возможностей. SLM часто не могут сгенерировать правильные решения, и даже если финальный ответ правильный, промежуточные шаги часто бывают ошибочными или низкого качества.</p>\n<p>Для смягчения ошибок и низкого качества промежуточных шагов, авторы вводят метод синтеза CoT, дополненный кодом, который выполняет обширные прогоны MCTS для генерации пошаговых проверенных траекторий рассуждений, аннотированных Q-значениями. Для дальнейшего улучшения производительности SLM на сложных задачах, авторы вводят рецепт самоэволюции в четыре раунда. В каждом раунде обновляются как модель политики, так и модель вознаграждения, что позволяет постепенно решать более сложные задачи и генерировать более качественные обучающие данные.</p>\n<p>Метод генерации проверенных траекторий рассуждений начинается с запуска стандартного MCTS для пошагового исследования решений. Корневой узел представляет собой вопрос, а дочерние узлы соответствуют промежуточным шагам, сгенерированным моделью политики. Путь от корня до конечного узла формирует траекторию, каждому шагу в которой присваивается Q-значение. Цель состоит в том, чтобы выбрать высококачественные траектории для построения обучающего набора. Для этого используется метод синтеза CoT, дополненный кодом, для отфильтровывания низкокачественных генераций и выполнения обширных прогонов для повышения надежности Q-значений.</p>\n<p>В отличие от предыдущих подходов, которые генерировали только текстовые CoT, здесь модель политики генерирует одношаговый CoT на естественном языке вместе с соответствующим кодом на Python, где CoT встроен в качестве комментария. Сохраняются только те генерации, код которых успешно выполняется. Это позволяет отфильтровать ошибочные шаги, которые могли бы привести к правильному ответу случайно. На каждом шаге MCTS, модель политики генерирует несколько кандидатов, которые затем фильтруются с помощью выполнения кода. Оставшиеся кандидаты оцениваются моделью PRM, которая присваивает Q-значение. Затем, с помощью алгоритма UCT выбирается лучший узел.</p>\n<p>Для улучшения надежности Q-значений используется подход, аналогичный игрокам в Го, которые оценивают ход на основе исхода игры. После обширных прогонов MCTS, шаги, которые постоянно приводят к правильным ответам, получают более высокие Q-значения, а шаги, которые приводят к неверным ответам, получают низкие Q-значения. Для этого используются два метода самоаннотации: терминально-ориентированная аннотация (используется в первых двух раундах, когда PRM недоступна или недостаточно точна) и аннотация, дополненная PRM (начиная с третьего раунда). В первом случае Q-значение шага обновляется на основе того, привел ли он к правильному ответу в конце траектории. Во втором случае PRM предсказывает начальное Q-значение, которое затем обновляется в процессе обратного распространения.</p>\n<p>Модели вознаграждения, предоставляющие гранулярные сигналы на уровне шагов, очень важны для решения сложных математических задач. Однако, получение высококачественных обучающих данных для них остается сложной задачей. Существующие методы полагаются на ручную разметку или на оценки, сгенерированные MCTS. Точность этих оценок напрямую влияет на эффективность модели вознаграждения. Авторы предлагают новый метод обучения модели предпочтений (PPM), который вместо использования Q-значений в качестве прямых меток вознаграждения, использует их для выбора шагов из дерева MCTS для построения пар предпочтений. Для каждого шага выбираются два кандидата с самыми высокими Q-значениями в качестве положительных шагов и два с самыми низкими в качестве отрицательных. Затем PPM обучается отличать положительные шаги от отрицательных. Этот подход устраняет необходимость в точных оценках на уровне шагов и позволяет обучать более эффективную модель вознаграждения.</p>'}, {'title': 'Evaluation', 'content': '4.1 Setup Evaluation Datasets. We evaluate rStar-Math on diverse mathematical benchmarks. In addition to the widely-used GSM8K [Cobbe et al., 2021], we include challenging benchmarks from multiple domains: (i) competition and Olympiad-level benchmarks, such as MATH-500 [Lightman et al., 2023], AIME 2024 [AI-MO, 2024a], AMC 2023 [AI-MO, 2024b] and Olympiad Bench [He et al., 2024]. Specifically, AIME is the exams designed to challenge the brightest high school math students in American, with the 2024 dataset comprising 30 problems from AIME and II exams; (ii) collegelevel math problems from College Math [Tang et al., 2024] and (iii) out-of-domain math benchmark: GaoKao (Chinese College Entrance Exam) En 2023 [Liao et al., 2024]. Base Models and Setup. rStar-Math is general approach applicable to various LLMs. To show its effectiveness and generalizability, we use SLMs of different sizes as the base policy models: Qwen2.5-Math-1.5B [Qwen, 2024b], Phi3-mini-Instruct (3B) [Microsoft, 2024, Abdin et al., 2024], Qwen2-Math-7B [Qwen, 2024a] and Qwen2.5-Math-7B [Qwen, 2024c]. Among these, Phi3-miniInstruct is general-purpose SLM without specialization in math reasoning. Due to limited GPU resources, we performed 4 rounds of self-evolution exclusively on Qwen2.5Math-7B, yielding 4 evolved policy SLMs  (Table 3)  and 4 PPMs  (Table 4)  . For the other 3 policy LLMs, we fine-tune them using step-by-step verified trajectories generated from Qwen2.5-Math-7Bs 4th round. The final PPM from this round is then used as the reward model for the 3 policy SLMs. Baselines. rStar-Math is System 2 method. We compare it against three strong baselines representing both System 1 and System 2 approaches: (i) Frontier LLMs, including GPT-4o, the latest Claude, OpenAI o1-preview and o1-mini. We measure their accuracy on AMC 2023, Olympiad Bench, College Math, Gaokao and GSM8K, with accuracy numbers for other benchmarks are taken from public technical reports [Team, 2024a]. (ii) Open-sourced superior reasoning models, including DeepSeek-Coder-v2-Instruct, Mathstral [Team, 2024b], NuminaMath-72B [Jia LI and Polu, 2024a], and LLaMA3.1 [Dubey et al., 2024], which represent the current mainstream System 1 approaches for improving LLM math reasoning. (iii) Both System 1 and System 2 performance of the base models trained from the original models teams, including Instruct versions (e.g., Qwen2.5-Math-7B-Instruct) and Best-of-N (e.g., Qwen2.5-Math-72B-Instruct+Qwen2.5-Math-RM-72B). Notably, the reward model used for the three Qwen base models is 72B ORM, significantly larger than our 7B PPM. Evaluation Metric. We report Pass@1 accuracy for all baselines. For System 2 baselines, we use default evaluation settings, such as default thinking time for o1-mini and o1-preview. For Qwen models with Best-of-N, we re-evaluate MATH-500, AIME/AMC accuracy; other benchmarks results are from their technical reports. For fair comparison, rStar-Math run MCTS to generate the same number of solutions as Qwen. Specifically, for AIME/AMC, we generate 16 trajectories for AIME/AMC and 8 for other benchmarks, using PPM to select the best solution. We also report performance with increased test-time computation using 64 trajectories, denoted as rStar-Math64. 4.2 Main Results Results on diverse challenging math benchmarks. Table 5 shows the results of rStar-Math with comparing to state-of-the-art reasoning models. We highlight three key observations: (1) rStar-Math significantly improves SLMs math reasoning capabilities, achieving performance comparable to or surpassing OpenAI o1 with substantially smaller model size (1.5B-7B). For example, Qwen2.5Math-7B, originally at 58.8% accuracy on MATH, improved dramatically to 90.0% with rStar-Math, outperforming o1-preview and Claude 3.5 Sonnet while matching o1-mini. On the College Math benchmark, rStar-Math exceeds o1-mini by 2.7%. On AIME 2024, rStar-Math scored 53.3%, ranking just below o1-mini, with the 7B model solving 8/15 problems in both AIME and II, placing in the top 20% of the brightest high school math students. Notably, 8 of the unsolved problems were 8 Table 5: The results of rStar-Math and other frontier LLMs on the most challenging math benchmarks. rStar-Math64 shows the Pass@1 accuracy achieved when sampling 64 trajectories. Competition and College Level Method MATH AIME 2024 AMC 2023 Olympiad Bench College Math GSM8K OOD Gaokao En 2023 Model Frontier LLMs GPT-4o Claude3.5-Sonnet GPT-o1-preview GPT-o1-mini Open-Sourced Reasoning LLMs System 1 DeepSeek-Coder-V2-Instruct System 1 Mathstral-7B-v0.1 System 1 NuminaMath-72B-CoT System 1 LLaMA3.1-8B-Instruct System 1 LLaMA3.1-70B-Instruct Qwen2.5-Math-72B-Instruct System 1 Qwen2.5-Math-72B-Instruct+72B ORM System System 1 System 1 - - 76.6 78.3 85.5 90.0 75.3 57.8 64.0 51.4 65.4 85.6 85.8 9.3 16.0 44.6 56.7 13.3 0.0 3.3 6.7 23.3 30.0 36.7 47.5 - 90.0 95. 57.5 37.5 70.0 25.0 50.0 70.0 72.5 43.3 - - 65.3 37.6 21.5 32.6 15.4 27.7 49.0 54.5 Phi3-mini-Instruct (base model) rStar-Math (3.8B SLM+7B PPM) rStar-Math64 (3.8B SLM+7B PPM) System 1 System 2 System 2 41.4 85.4 86. 3.33 40.0 43.3 7.5 77.5 80.0 12.3 59.3 60.3 General Base Model: Phi3-mini-Instruct (3.8B) System 1 Qwen2.5-Math-1.5B (base model) Qwen2.5-Math-1.5B-Instruct System 1 Qwen2.5-Math-1.5B-Instruct+72B ORM System 2 rStar-Math (1.5B SLM+7B PPM) System 2 rStar-Math64 (1.5B SLM+7B PPM) System 2 Math-Specialized Base Model: Qwen2.5-Math-1.5B 16.7 38.1 47.3 63.5 64. 51.2 60.0 83.4 87.8 88.6 22.5 60.0 72.5 80.0 85.0 0.0 10.0 20.0 46.7 46.7 Math-Specialized Base Model: Qwen2-Math-7B Qwen2-Math-7B (base model) Qwen2-Math-7B-Instruct Qwen2-Math-7B-Instruct+72B ORM rStar-Math (7B SLM+7B PPM) rStar-Math64 (7B SLM+7B PPM) System 1 System 1 System 2 System 2 System 53.4 73.2 83.4 88.2 88.6 3.3 13.3 23.3 43.3 46.7 25.0 62.5 62.5 80.0 85.0 17.3 38.2 47.6 63.1 63.4 System 1 Qwen2.5-Math-7B (base model) Qwen2.5-Math-7B-Instruct System 1 Qwen2.5-Math-7B-Instruct+72B ORM System 2 rStar-Math (7B SLM+7B PPM) System 2 rStar-Math64 (7B SLM+7B PPM) System 2 Math-Specialized Base Model: Qwen2.5-Math-7B 21.8 41.6 49.9 65.3 65. 58.8 82.6 88.4 89.4 90.0 22.5 62.5 75.0 87.5 87.5 0.0 6.0 26.7 50.0 53.3 48.5 - - 57.8 46.2 33.7 39.7 33.8 42.5 49.5 50.6 33.1 58.0 59. 38.4 47.7 50.2 59.0 59.3 39.4 45.9 47.9 58.4 59.3 41.6 46.8 49.6 59.0 60.5 92.9 96.4 - 94.8 94.9 84.9 90.8 76.6 94.1 95.9 96.4 85.7 94.5 94. 74.6 84.8 94.1 94.3 94.8 80.4 89.9 95.1 94.6 94.8 91.6 95.2 97.9 95.0 95.2 67.5 - - 78.4 64.7 46.0 58.4 38.4 54.0 71.9 76.9 37.1 77.1 77. 46.5 65.5 73.0 77.7 79.5 47.3 62.1 71.9 78.2 79.2 51.7 66.8 75.1 80.5 81.3 geometry-based, requiring visual understanding, capability rStar-Mathcurrently does not support. (2) Despite using smaller policy models (1.5B-7B) and reward models (7B), rStar-Math significantly outperforms state-of-the-art System 2 baselines. Compared to Qwen Best-of-N baselines, which use the same base models (Qwen2-Math-7B, Qwen2.5-Math-1.5B/7B) but 10 larger reward model (Qwen2.5-Math-RM-72B), rStar-Math consistently improves the reasoning accuracy of all base models to state-of-the-art levels. Even against Best-of-N with 10 larger Qwen2.5-Math-72BInstruct policy model, rStar-Math surpasses it on all benchmarks except GSM8K, using the same number of sampled solutions. (3) Beyond well-known benchmarks like MATH, GSM8K, and AIME, which may risk over-optimization, rStar-Math shows strong generalizability on other challenging math benchmarks, including Olympiad Bench, College Math, and the Chinese College Entrance Math Exam (Gaokao), setting new state-of-the-art scores. As discussed in Sec. 3.4, our training set is primarily sourced from public datasets, with no specific optimizations for these benchmarks. Scaling up test-time computation. rStar-Math uses MCTS to augment the policy model, searching solutions guided by the PPM. By increasing test-time computation, it explores more trajectories, potentially improving performance. In Fig. 3, we show the impact of test-time compute scaling by comparing the accuracy of the official Qwen Best-of-N across different numbers of sampled trajectories on four challenging math benchmarks. Sampling only one trajectory corresponds to the policy LLMs Pass@1 accuracy, indicating fallback to System 1 reasoning. We highlight two key Figure 3: Reasoning performance under scaling up the test-time compute. observations: (1) With only 4 trajectories, rStar-Math significantly outperforms Best-of-N baselines, exceeding o1-preview and approaching o1-mini, demonstrating its effectiveness. (2) Scaling test-time compute improves reasoning accuracy across all benchmarks, though with varying trends. On Math, AIME, and Olympiad Bench, rStar-Math shows saturation or slow improvement at 64 trajectories, while on College Math, performance continues to improve steadily. 4.3 Ablation Study and Analysis We ablate the effectiveness of our three innovations. For System 2-style inference, Pass@1 accuracy is measured with 16 trajectories for AIME and AMC, and 8 for other benchmarks. Table 6: The continuously improved math reasoning capabilities through rStar-Math self-evolved deep thinking. Starting from round 2, the 7B base model powered by rStar-Math surpasses GPT-4o. Round# GPT-4o Base 7B model rStar-Math Round 1 rStar-Math Round 2 rStar-Math Round 3 rStar-Math Round 4 MATH AIME 2024 AMC 2023 Olympiad Bench College Math GSM8K GaokaoEn 2023 76.6 58.8 75.2 86.6 87.0 89.4 9. 0.0 10.0 43.3 46.7 50.0 47.5 22.5 57.5 75.0 80.0 87.5 43.3 21.8 35.7 59.4 61.6 65.3 48. 41.6 45.4 55.6 56.5 59.0 92.9 91.6 90.9 94.0 94.2 95.0 67.5 51.7 60.3 76.4 77.1 80.5 The effectiveness of self-evolution. The impressive results in Table 5 are achieved after 4 rounds of rStar-Math self-evolved deep thinking. Table 6 shows the math reasoning performance in each round, demonstrating continuous improvement in accuracy. In round 1, the main improvement comes from applying SFT to the base model. Round 2 brings significant boost with the application of stronger PPM in MCTS, which unlocks the full potential of System 2 deep reasoning. Notably, starting from round 2, rStar-Math outperforms GPT-4o. Rounds 3 and 4 show further improvements, driven by stronger System 2 reasoning through better policy SLMs and PPMs. The effectiveness of step-by-step verified reasoning trajectory. rStar-Math generates step-by-step verified reasoning trajectories, which eliminate error intermediate steps and further expand training set with more challenging problems. To evaluate its effectiveness, we use the data generated from round 4 as SFT training data and compare it against three strong baselines: (i) GPT-distillation, which includes open-sourced CoT solutions synthesized using GPT-4, such as MetaMath [Yu et al., 2023b], NuminaMath-CoT [Jia LI and Polu, 2024b]; (ii) Random sampling from self-generation, which use the same policy model (i.e., policy SLM-r3) to randomly generate trajectories; (iii) Rejection sampling, where 32 trajectories are randomly sampled from the policy model, with high-quality solutions ranked by our trained ORM (appendix A.1). For fairness, we select two correct trajectories for each math problem in baseline (ii) and (iii). All SFT experiments use the same training recipe. Table 7 shows the math reasoning accuracy of Qwen2.5-Math-7B fine-tuned on different datasets. We highlight two observations: (i) Fine-tuning with our step-by-step verified trajectories significantly outperforms all other baselines. This is primarily due to our PPM-augmented MCTS for code-augmented CoT synthesis, which provides denser verification during math solution generation. It proves more effective than both random sampling, which lacks verification, and rejection sampling, 10 Table 7: Ablation study on the effectiveness of our step-by-step verified reasoning trajectories as the SFT dataset. We report the SFT accuracy of Qwen2.5-Math-7B fine-tuned with different datasets. Dataset MATH AIME AMC Olympiad Bench College Math GSM8K GaokaoEn GPT-4o - GPT4-distillation (Open-sourced) MetaMath NuminaMath-CoT 76.6 55.2 69. Self-generation by policy SLM-r3 Random sample Rejection sampling 72.4 73.4 Step-by-step verified (ours) 78.4 9.3 3.33 10.0 10.0 13.3 26. 47.5 32.5 50.0 45.0 47.5 47.5 43.3 19.1 37.2 41.0 44.7 47. 48.5 39.2 43.4 48.0 50.8 52.5 92.9 85.1 89.8 87.5 89.3 89. 67.5 43.6 59.5 57.1 61.7 65.7 where ORM provides only sparse verification. (ii) Even randomly sampled code-augmented CoT solutions from our SLM yields comparable or better performance than GPT-4 synthesized NuminaMath and MetaMath datasets. This indicates that our policy SLMs, after rounds of self-evolution, can generate high-quality math solutions. These results demonstrates the huge potential of our method to self-generate higher-quality reasoning data without relying on advanced LLM distillation. The effectiveness of PPM. We train both strong ORM and Q-value score-based PRM (PQM) for comparison. To ensure fair evaluation, we use the highest-quality training data: the step-by-step verified trajectories generated in round 4, with selected math problems matching those used for PPM training. Similar to PPM, we use step-level Q-values as to select positive and negative trajectories for each math problem. The ORM is trained using pairwise ranking loss [Ouyang et al., 2022], while the PQM follows [Chen et al., 2024, Zhang et al., 2024a] to use Q-values as reward labels and optimize with MSE loss. Detailed training settings are provided in Appendix A.1. Table 8: Ablation study on the reward model. Process reward models (PQM and PPM) outperform ORM, with PPM pushing the frontier of math reasoning capabilities. RM Inference MATH AIME AMC Olympiad Bench College Math GSM8K GaokaoEn o1-mini - ORM Best-of-N PQM PPM MCTS MCTS 90.0 82.6 88.2 89.4 56.7 26.7 46.7 50.0 95.0 65.0 85.0 87. 65.3 55.1 62.9 65.3 55.6 55.5 57.6 59.0 94.8 92.3 94.6 95. 78.6 72.5 79.5 80.5 Table 8 compares the performance of ORM, PQM, and PPM for System 2 reasoning using our final round policy model. ORM provides reward signals only at the end of problem solving, so we use the Best-of-N method, while PRM and PPM leverage MCTS-driven search. As shown in Table 8, both PQM and PPM outperform ORM by providing denser step-level reward signals, leading to higher accuracy on complex math reasoning tasks. However, PQM struggles on more challenging benchmarks, such as MATH and Olympiad Bench, due to the inherent imprecision of Q-values. In contrast, PPM constructs step-level preference data for training, enabling our 7B policy model to achieve comparable or superior performance to o1-mini across all benchmarks.', 'summary': '<h2>Изложение раздела 4.1 "Настройка оценочных наборов данных" и 4.2 "Основные результаты" статьи по машинному обучению.</h2>\n<p>В данном разделе описываются наборы данных и модели, используемые для оценки предложенного метода rStar-Math, а также приводятся основные результаты экспериментов.</p>\n<p><strong>4.1 Настройка оценочных наборов данных</strong></p>\n<p>Для оценки rStar-Math использовались разнообразные математические бенчмарки, включая:</p>\n<ul>\n<li><strong>GSM8K:</strong> широко используемый набор задач по математике.</li>\n<li><strong>Задачи уровня соревнований и олимпиад:</strong><ul>\n<li><strong>MATH-500:</strong> более сложный набор задач.</li>\n<li><strong>AIME 2024:</strong> задачи, предназначенные для проверки способностей лучших старшеклассников по математике в США.</li>\n<li><strong>AMC 2023:</strong> задачи математической олимпиады.</li>\n<li><strong>Olympiad Bench:</strong> набор задач олимпиадного уровня.</li>\n</ul>\n</li>\n<li><strong>Задачи по математике уровня колледжа:</strong><ul>\n<li><strong>College Math:</strong> набор задач из университетских курсов.</li>\n</ul>\n</li>\n<li><strong>Задачи из другой предметной области:</strong><ul>\n<li><strong>GaoKao (китайский вступительный экзамен в колледж) En 2023:</strong> задачи из китайского вступительного экзамена.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Базовые модели и настройка</strong></p>\n<p>rStar-Math является общим подходом, применимым к различным большим языковым моделям (LLM). Для демонстрации его эффективности и обобщаемости использовались малые языковые модели (SLM) разных размеров:</p>\n<ul>\n<li>Qwen2.5-Math-1.5B</li>\n<li>Phi3-mini-Instruct (3B) - общая модель без специализации в математике.</li>\n<li>Qwen2-Math-7B</li>\n<li>Qwen2.5-Math-7B</li>\n</ul>\n<p>Ограничения вычислительных ресурсов позволили провести 4 раунда самоэволюции только на модели Qwen2.5-Math-7B, в результате чего было получено 4 эволюционировавших модели политики (policy SLM) и 4 модели поощрения (PPM). Для остальных трех моделей политики использовалось дообучение на траекториях, сгенерированных Qwen2.5-Math-7B на 4 раунде. Итоговая PPM из этого раунда использовалась в качестве модели поощрения для этих трех моделей политики.</p>\n<p><strong>Базовые сравнения</strong></p>\n<p>rStar-Math относится к методам "Системы 2" (требующим более глубокого обдумывания). Он сравнивался с тремя сильными базовыми подходами, представляющими как "Систему 1" (быстрое интуитивное мышление), так и "Систему 2":</p>\n<ul>\n<li><strong>Передовые LLM:</strong> GPT-4o, Claude, OpenAI o1-preview и o1-mini.</li>\n<li><strong>Открытые модели для рассуждений:</strong> DeepSeek-Coder-v2-Instruct, Mathstral, NuminaMath-72B и LLaMA3.1.</li>\n<li><strong>Базовые модели, обученные командами разработчиков:</strong> включая версии Instruct (например, Qwen2.5-Math-7B-Instruct) и Best-of-N (например, Qwen2.5-Math-72B-Instruct+Qwen2.5-Math-RM-72B).</li>\n</ul>\n<p><strong>Метрика оценки</strong></p>\n<p>Для всех моделей использовалась метрика Pass@1 (доля правильно решенных задач с первой попытки). Для моделей "Системы 2" использовались стандартные настройки, такие как время обдумывания для o1-mini и o1-preview. Для моделей Qwen Best-of-N были переоценены результаты на MATH-500 и AIME/AMC. Для честного сравнения rStar-Math генерировал такое же количество решений, как и Qwen. В частности, для AIME/AMC генерировалось 16 траекторий, а для других бенчмарков - 8. Использовалась PPM для выбора лучшего решения. Также приведена производительность с увеличенным временем вычислений (64 траектории), обозначенная как rStar-Math64.</p>\n<p><strong>4.2 Основные результаты</strong></p>\n<p>В таблице 5 приведены результаты rStar-Math в сравнении с передовыми моделями. Основные наблюдения:</p>\n<ol>\n<li><strong>rStar-Math значительно улучшает математические способности SLM</strong>, достигая производительности, сравнимой или превосходящей OpenAI o1, при существенно меньшем размере модели (1.5B-7B). Например, Qwen2.5Math-7B, изначально показывавшая точность 58.8% на MATH, улучшилась до 90.0% с rStar-Math, превзойдя o1-preview и Claude 3.5 Sonnet и достигнув уровня o1-mini. На College Math rStar-Math превосходит o1-mini на 2.7%. На AIME 2024 rStar-Math набрал 53.3%, уступив только o1-mini.</li>\n<li><strong>rStar-Math превосходит "Систему 2"</strong>, несмотря на использование меньших моделей политики (1.5B-7B) и моделей поощрения (7B). По сравнению с Qwen Best-of-N, rStar-Math последовательно улучшает точность рассуждений всех базовых моделей. Даже по сравнению с Best-of-N с 72B моделью политики rStar-Math превосходит ее на всех бенчмарках, кроме GSM8K.</li>\n<li><strong>rStar-Math демонстрирует сильную обобщаемость на других сложных бенчмарках</strong>, включая Olympiad Bench, College Math и Gaokao, устанавливая новые рекорды.</li>\n</ol>\n<p><strong>Увеличение вычислительных ресурсов во время тестирования</strong></p>\n<p>rStar-Math использует MCTS для дополнения модели политики, осуществляя поиск решений под руководством PPM. Увеличение времени вычислений позволяет исследовать больше траекторий, потенциально улучшая производительность. На рисунке 3 показано влияние масштабирования вычислений во время тестирования. Основные наблюдения:</p>\n<ol>\n<li><strong>Уже с 4 траекториями rStar-Math значительно превосходит Best-of-N</strong>, приближаясь к o1-mini.</li>\n<li><strong>Масштабирование вычислений во время тестирования улучшает точность рассуждений</strong> на всех бенчмарках, хотя и с разными темпами. На Math, AIME и Olympiad Bench rStar-Math демонстрирует насыщение или медленное улучшение при 64 траекториях, в то время как на College Math производительность продолжает стабильно улучшаться.</li>\n</ol>'}, {'title': 'Findings and Discussions', 'content': 'The emergence of intrinsic self-reflection capability. key breakthrough in OpenAI o1 is its intrinsic self-reflection capability. When the model makes an error, it recognizes the mistake and can self-correct with correct answer [Noam Brown and Lightman, 2024]. Yet it has consistently been found to be largely ineffective in open-sourced LLMs. The community has actively explored various approaches, including self-correction [Huang et al., 2023, Kumar et al., 2024], self-reflection [Renze and Guven, 2024, Shinn et al., 2024], to explicitly train or prompt LLMs to develop such capability. In our experiments, we unexpectedly observe that our MCTS-driven deep thinking exhibits selfreflection during problem-solving. As shown in Fig. 4, the model initially formalizes an equation using SymPy in the first three steps, which would lead to an incorrect answer (left branch). Interestingly, in the fourth step (right branch), the policy model recognizes the low quality of its earlier steps and refrains from continuing along the initial problem-solving path. Instead, it backtracks and resolves the problem using new, simpler approach, ultimately arriving at the correct answer. An additional example of self-correction is provided in AppendixA.2. Notably, no self-reflection training data or prompt was included, suggesting that advanced System 2 reasoning can foster intrinsic self-reflection. 11 Figure 4: An example of intrinsic self-reflection during rStar-Math deep thinking. Figure 5: Pass@1 accuracy of policy models and their accuracy after applying System 2 reasoning with various reward models, shows that reward models primarily determine the final performance. PPM shapes the reasoning boundary in System 2 deep thinking. Both the policy and reward models are crucial for System 2 deep reasoning. Our experiments show that once the policy model attains reasonably strong capability level, (see Appendix A.1 ), the PPM becomes the key determinant of the upper performance limit. Fig. 5 summarizes the accuracy of policy models of different sizes, as well as the improvements achieved with reward models. Despite variations in Pass@1 accuracy due to differences in training strategies, datasets, and model scales, the reward model proves to be the dominant factor in System 2 reasoning. For instance, although the SFT accuracy of rStar-Math-7B is lower than Qwen2.5-Math-72B-Instruct, pairing it with our 7B PPM allows rStar-Math to outperform the 72B policy model with Qwen 72B ORM. Moreover, despite varying Pass@1 accuracy across our three policy SLM sizes, the final reasoning accuracy converges after applying the PPM. PPM spots theorem-application steps. When solving challenging math problems, identifying and applying relevant theorems or key conclusions often form the cornerstone of successful problemsolving [Xin et al., 2024]. In our experiments, we find that during rStar-Math problem-solving, our PPM effectively identifies critical theorem-application intermediate steps within policy models deep thinking process. These steps are predicted with high reward scores, guiding the policy model to generate the correct solution. Appendix A.2 provides examples where the PPM successfully identifies key theorems such as Fermats little theorem [Weisstein, a], Vietas formulas [Weisstein, b], the AM-GM inequality [amg], the Pythagorean theorem [pyt], and the Shoelace Theorem [sho], etc. 12 Generalization discussions. rStar-Math offers general methodology for improving LLM reasoning applicable to various domains. First, rStar-Math can generalize to more challenging math tasks, such as theorem proving, though its current focus is on word problems due to dataset limitations. Nonetheless, rStar-Math demonstrates the potential to prove mathematical statements. As shown in Appendix A.2, it successfully proves an Olympiad-level problem involving Fermats Little Theorem, providing step-by-step correct proof through its deep reasoning process. Second, rStar-Mathcan generalize to other domains, such as code and commonsense reasoning. Notably, synthesizing stepby-step verified training trajectories for general reasoning requires mechanism to provide feedback on whether given trajectory reaches the desired output at the end of MCTS rollout. For instance, in code reasoning, this could involve designing extensive test cases; in general reasoning, feedback could be obtained through human labeling or mutual verification with another LLM [Qi et al., 2024].', 'summary': '<p><strong>Возникновение способности к саморефлексии</strong></p>\n<p>Ключевым прорывом в модели OpenAI o1 является её способность к саморефлексии. Когда модель допускает ошибку, она распознаёт её и может самостоятельно исправить, выдав правильный ответ. Однако, в открытых LLM (больших языковых моделях) эта способность оказалась неэффективной. Сообщество активно исследовало различные подходы, включая самокоррекцию и саморефлексию, чтобы обучить или побудить LLM к развитию этой способности.</p>\n<p>В экспериментах, представленных в данной статье, было неожиданно обнаружено, что глубокое мышление, основанное на алгоритме MCTS (метод Монте-Карло для поиска дерева), проявляет саморефлексию в процессе решения задач. На примере, показанном на рисунке 4, модель сначала формализует уравнение, используя SymPy, что приводит к неверному ответу (левая ветвь). Однако, на четвёртом шаге (правая ветвь), модель распознаёт низкое качество своих предыдущих шагов и отказывается от продолжения решения по первоначальному пути. Вместо этого, она возвращается назад и решает задачу, используя новый, более простой подход, в итоге получая правильный ответ. Дополнительный пример самокоррекции приведён в приложении A.2. Примечательно, что никакие данные для обучения саморефлексии или подсказки не использовались, что говорит о том, что продвинутое мышление Системы 2 может способствовать возникновению внутренней саморефлексии.</p>\n<p><strong>Роль модели вознаграждения (PPM) в глубоком мышлении</strong></p>\n<p>Эксперименты показывают, что как модель политики, так и модель вознаграждения играют решающую роль в глубоком мышлении Системы 2. Однако, после того, как модель политики достигает достаточно высокого уровня, именно модель вознаграждения (PPM) становится ключевым фактором, определяющим верхний предел производительности. Рисунок 5 показывает точность моделей политики разных размеров, а также улучшения, достигнутые с помощью различных моделей вознаграждения. Несмотря на различия в точности Pass@1 (вероятность дать правильный ответ с первой попытки) из-за различий в стратегиях обучения, наборах данных и масштабах моделей, модель вознаграждения оказывается доминирующим фактором в рассуждениях Системы 2. Например, хотя точность SFT (обучение с учителем) модели rStar-Math-7B ниже, чем у Qwen2.5-Math-72B-Instruct, в сочетании с PPM 7B, rStar-Math превосходит модель политики 72B с Qwen 72B ORM. Кроме того, несмотря на различия в точности Pass@1 между тремя размерами моделей политики, точность рассуждений сходится после применения PPM.</p>\n<p><strong>PPM выявляет шаги применения теорем</strong></p>\n<p>При решении сложных математических задач, выявление и применение соответствующих теорем или ключевых выводов часто является основой успешного решения. В экспериментах было обнаружено, что во время решения задач rStar-Math, PPM эффективно выявляет важные промежуточные шаги применения теорем в процессе глубокого мышления моделей политики. Эти шаги прогнозируются с высокими оценками вознаграждения, направляя модель политики к генерации правильного решения. В приложении A.2 приведены примеры, где PPM успешно выявляет ключевые теоремы, такие как малая теорема Ферма, формулы Виета, неравенство Коши, теорема Пифагора и формула площади Гаусса.</p>\n<p><strong>Обсуждение обобщения</strong></p>\n<p>rStar-Math предлагает общую методологию для улучшения рассуждений LLM, применимую к различным областям. Во-первых, rStar-Math может обобщаться на более сложные математические задачи, такие как доказательство теорем, хотя в настоящее время основное внимание уделяется текстовым задачам из-за ограничений набора данных. Тем не менее, rStar-Math демонстрирует потенциал для доказательства математических утверждений. Как показано в приложении A.2, он успешно доказывает задачу уровня олимпиады с использованием малой теоремы Ферма, предоставляя пошаговое правильное доказательство в процессе глубокого рассуждения. Во-вторых, rStar-Math может обобщаться на другие области, такие как код и рассуждения здравого смысла. Примечательно, что синтез пошагово проверенных траекторий обучения для общих рассуждений требует механизма для обеспечения обратной связи о том, достигает ли данная траектория желаемого результата в конце развертывания MCTS. Например, в рассуждениях о коде это может включать разработку обширных тестовых примеров; в общих рассуждениях обратная связь может быть получена посредством ручной разметки или взаимной проверки с другой LLM.</p>'}, {'title': 'Conclusion', 'content': 'In this work, we present rStar-Math, self-evolved System 2 deep thinking approach that significantly boosts the math reasoning capabilities of small LLMs, achieving state-of-the-art OpenAI o1-level performance. Our approach demonstrates that SLMs can self-generate high-quality training data for frontier-level math reasoning. Extensive experiments across four different-sized SLMs and challenging math benchmarks demonstrate the superiority of rStar-Math, with achieving leading results while outperforming existing math reasoning LLMs and Best-of-N baselines. We also reveal key findings, including the emergence of self-reflection and the effectiveness of the PPM in identifying critical intermediate steps, such as theorem-application steps. Finally, rStar-Math can achieve further improvements by collecting more challenging math problems, we leave this as future work.', 'summary': '<p>В этой работе представлен метод rStar-Math, который представляет собой самостоятельно развивающийся подход "Системы 2" глубокого мышления. Этот метод значительно повышает способности к математическим рассуждениям у небольших языковых моделей (SLM), достигая производительности на уровне OpenAI o1, что является передовым результатом.</p>\n<p>Наш подход показывает, что SLM могут самостоятельно генерировать высококачественные обучающие данные для математических рассуждений на передовом уровне. Обширные эксперименты с четырьмя SLM разных размеров и сложными математическими тестами демонстрируют превосходство rStar-Math. Этот метод показывает лучшие результаты, превосходя существующие языковые модели для математических рассуждений и базовые показатели "Best-of-N".</p>\n<p>Также мы выявили ключевые результаты, включая появление саморефлексии и эффективность PPM (предположительно, Post-Processing Method) в определении критических промежуточных шагов, таких как шаги применения теорем. Наконец, rStar-Math может достичь дальнейших улучшений за счет сбора более сложных математических задач, что мы оставляем для будущих исследований.</p>\n<p><strong>Комментарии по сути статьи:</strong></p>\n<ul>\n<li><strong>Система 2 мышления:</strong> Это отсылка к концепции из психологии, где "Система 1" - это быстрое, интуитивное мышление, а "Система 2" - медленное, аналитическое. rStar-Math, видимо, имитирует более обдуманный подход к решению математических задач.</li>\n<li><strong>SLM (Small Language Models):</strong>  Речь идет о небольших языковых моделях, которые обычно уступают большим моделям в производительности, но rStar-Math позволяет им достигать высоких результатов в математике.</li>\n<li><strong>OpenAI o1-level performance:</strong> Это означает, что метод достигает уровня производительности, сравнимого с одной из моделей OpenAI, которая является эталоном в области ИИ.</li>\n<li><strong>Саморефлексия:</strong>  Интересный момент, указывающий на способность модели анализировать собственные рассуждения и улучшать их в процессе обучения.</li>\n<li><strong>PPM:</strong> Метод постобработки, который помогает выявлять ключевые шаги в решении.</li>\n<li><strong>Best-of-N baselines:</strong>  Базовый метод, который выбирает лучшее решение из N сгенерированных вариантов. rStar-Math превосходит этот метод.</li>\n</ul>'}]}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents', '#agi', '#alignment', '#architecture', '#audio', '#benchmark (1)', '#cv', '#data', '#dataset (1)', '#diffusion', '#ethics', '#games', '#graphs', '#hallucinations', '#healthcare', '#inference', '#interpretability', '#leakage', '#long_context', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal', '#open_source', '#optimization (1)', '#plp', '#rag', '#reasoning (1)', '#rl', '#rlhf', '#robotics', '#science', '#security', '#small_models (1)', '#story_generation', '#survey', '#synthetic', '#training (1)', '#transfer_learning', '#video'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            
            <div class="summaries">
                <div class="summary_title">Abstract</div>
                <div class="summary_text"><p>В данной работе представлен метод rStar-Math, демонстрирующий, что небольшие языковые модели (SLM) могут достигать или даже превосходить возможности OpenAI o1 в математических рассуждениях. Это достигается за счет "глубокого мышления" с использованием поиска Монте-Карло (MCTS). В этом подходе SLM, выступающая в роли "математической политики", проводит поиск во время тестирования, ориентируясь на модель вознаграждения процесса, также основанную на SLM.</p>
<p>rStar-Math предлагает три ключевых нововведения для решения проблем обучения этих двух SLM:</p>
<ol>
<li><strong>Новый метод синтеза данных CoT с расширением кодом:</strong> Этот метод использует MCTS для генерации подробных, пошагово проверенных траекторий рассуждений. Эти траектории затем используются для обучения SLM, отвечающей за математическую политику. (CoT - Chain of Thought, метод, при котором модель выдает не только ответ, но и цепочку рассуждений, приведших к нему)</li>
<li><strong>Новый метод обучения модели вознаграждения процесса:</strong> Этот метод избегает прямого присвоения оценок на каждом шаге рассуждения. Вместо этого, он обучает более эффективную модель предпочтений процесса (PPM). (Т.е. модель оценивает не отдельные шаги, а предпочтительность всей траектории рассуждений)</li>
<li><strong>Рецепт саморазвития:</strong> В этом подходе SLM, отвечающая за политику, и PPM строятся с нуля и итеративно развиваются для улучшения возможностей рассуждения.</li>
</ol>
<p>Благодаря 4 раундам саморазвития с использованием миллионов синтезированных решений для 747 тысяч математических задач, rStar-Math повышает уровень математических рассуждений SLM до самых современных показателей. На бенчмарке MATH, rStar-Math улучшает результаты Qwen2.5-Math-7B с 58.8% до 90.0% и Phi3-mini-3.8B с 41.4% до 86.4%, превосходя o1-preview на +4.5% и +0.9% соответственно. На USA Math Olympiad (AIME) rStar-Math решает в среднем 53.3% (8 из 15) задач, что ставит его в топ 20% самых способных учеников старших классов в области математики. Код и данные будут доступны по ссылке https://github.com/microsoft/rStar.</p></div>
                <div class="images"></div>
            </div>
            <div class="summaries">
                <div class="summary_title">Recent Studies</div>
                <div class="summary_text"><p>В данной работе представлен rStar-Math, подход к решению математических задач, основанный на самообучении и имитирующий мышление второго типа (System 2). Этот подход позволяет достигать результатов на уровне лучших моделей, включая OpenAI o1, даже при использовании относительно небольших языковых моделей (до 7 миллиардов параметров).</p>
<p>Основная проблема при обучении моделей для решения математических задач заключается в нехватке качественных данных.  Проблема в том, что даже если получен верный ответ, это не гарантирует правильность всех промежуточных шагов решения.  Ошибочные промежуточные шаги снижают качество обучающих данных. Кроме того, для обучения моделей, оценивающих промежуточные шаги решения, требуется разметка данных с подробным указанием правильности каждого шага, что очень трудоемко. Автоматическая разметка пока не дает удовлетворительных результатов из-за шума в оценках.  Поэтому, подходы, основанные на дистилляции знаний из больших моделей, достигают предела и не превосходят своих учителей.</p>
<p>rStar-Math решает эту проблему, используя малые языковые модели (SLM) и поиск по дереву Монте-Карло (MCTS) для самообучения.  Процесс включает в себя три ключевых нововведения:</p>
<ol>
<li><strong>Генерация данных с проверкой кода:</strong>  Процесс решения задачи разбивается на несколько шагов в рамках MCTS. На каждом шаге SLM генерирует один шаг решения в виде цепочки рассуждений (CoT) и соответствующего кода на Python.  Для проверки качества, сохраняются только те шаги, для которых код успешно выполняется.  Это позволяет отсеять ошибочные промежуточные шаги. Кроме того, MCTS автоматически присваивает каждому шагу Q-значение, которое показывает вклад шага в получение правильного ответа. Шаги, которые чаще приводят к правильному ответу, получают более высокие Q-значения.</li>
<li><strong>Обучение модели оценки промежуточных шагов (PPM):</strong> Эта модель предсказывает оценку (reward) для каждого шага решения.  Для обучения PPM используется тот факт, что Q-значения, хотя и не являются точными оценками, позволяют надежно отличать правильные шаги от неправильных.  Для каждого шага создаются пары предпочтений на основе Q-значений, и модель обучается с помощью ранжирующей функции потерь. Такой подход позволяет избежать прямого использования Q-значений в качестве оценок, которые изначально зашумлены.</li>
<li><strong>Четырехэтапный процесс самообучения:</strong> Начинается со сбора 747 тысяч задач из открытых источников. На каждом этапе используется последняя версия модели решения (policy model) и PPM для выполнения MCTS и генерации улучшенных обучающих данных. Затем на этих данных обучаются более сильные модели.  Каждый этап приводит к усилению модели, повышению надежности PPM, улучшению траекторий решения и расширению охвата задач.</li>
</ol>
<p>Эксперименты с разными SLM (от 1.5 до 7 миллиардов параметров) на семи задачах показали эффективность rStar-Math.  На наборе данных MATH, rStar-Math повысил точность модели Qwen2.5-Math-7B с 58.8% до 89.4%, а Qwen2.5-Math-1.5B с 51.2% до 87.8%. С 64 траекториями поиска, результаты достигают 90% и 88.4% соответственно, превосходя o1-preview и приближаясь к o1-minis. На олимпиаде AIME 2024, rStar-Math решил 53.3% задач, что на 8.7% больше, чем o1-preview. Проведенные эксперименты подтвердили превосходство подхода rStar-Math по сравнению с другими методами синтеза данных и методами оценки промежуточных шагов.</p></div>
                <div class="images"></div>
            </div>
            <div class="summaries">
                <div class="summary_title">Related Works</div>
                <div class="summary_text"><p><strong>Синтез математических данных</strong></p>
<p>Успехи в области математических рассуждений с использованием больших языковых моделей (LLM) во многом зависят от создания высококачественных данных для обучения методу Chain-of-Thought (CoT). Большинство ведущих подходов используют дистилляцию знаний из продвинутых моделей, таких как GPT-4. Примеры таких работ включают NuminaMath и MetaMath. Однако, этот подход ограничивает возможности рассуждений способностями обучающей LLM. Сложные задачи, которые обучающая LLM не может решить, исключаются из обучающего набора данных. Даже в решаемых задачах могут содержаться ошибочные промежуточные шаги, которые трудно обнаружить.</p>
<p>Методы отбора с отбраковкой могут улучшить качество данных, но не гарантируют правильность промежуточных шагов. В результате, увеличение объема данных CoT приводит к снижению отдачи, когда прирост производительности приближается к насыщению. Например, OpenMathInstruct-2 демонстрирует лишь 3.9% прирост на наборе данных MATH, несмотря на восьмикратное увеличение размера набора данных.</p>
<p>Масштабирование вычислений во время тестирования (test-time compute) ввело новые законы масштабирования, позволяя LLM улучшать производительность за счет генерации нескольких образцов и использования моделей вознаграждения для выбора наилучшего решения. Были предложены различные методы поиска во время тестирования, включая случайную выборку и методы древовидного поиска, такие как MCTS. Однако открытые методы масштабирования вычислений во время тестирования показали ограниченные успехи в математических рассуждениях, часто из-за ограничений самой LLM или модели вознаграждения.</p>
<p>rStar-Math решает эту проблему путем итеративного развития LLM и модели вознаграждения, достигая производительности в математических рассуждениях, сравнимой с OpenAI o1. Модели вознаграждения играют ключевую роль в эффективных рассуждениях, но их сложно получить. Недавние работы включают использование LLM в качестве "судьи" для проверки и специализированные модели вознаграждения, такие как Outcome Reward Model и Process Reward Model (PRM). PRM предлагают многообещающие сигналы вознаграждения на уровне шагов для сложных рассуждений, но сбор аннотаций на уровне шагов остается проблемой.</p>
<p>В то время как некоторые работы полагаются на дорогостоящие наборы данных с аннотациями, другие исследуют автоматизированную аннотацию с помощью Monte Carlo Sampling или MCTS. Однако, они испытывают трудности с генерацией точных оценок вознаграждения, что ограничивает прирост производительности. rStar-Math представляет новый метод вознаграждения на основе предпочтений процесса (PPM), который устраняет необходимость в точной аннотации оценок вознаграждения на уровне шагов.</p></div>
                <div class="images"></div>
            </div>
            <div class="summaries">
                <div class="summary_title">Methodology</div>
                <div class="summary_text"><h2>Изложение раздела 3.1-3.3 статьи о применении MCTS для решения математических задач</h2>
<p>В этой работе предлагается подход к решению сложных математических задач, основанный на использовании метода Монте-Карло древовидного поиска (MCTS) в сочетании с двумя моделями: политикой (SLM) и моделью вознаграждения (PRM). MCTS выбран в качестве основного инструмента по двум причинам. Во-первых, он декомпозирует сложные задачи на более простые одношаговые задачи генерации, что облегчает работу модели политики по сравнению с другими методами, такими как Best-of-N или самосогласованность, которые требуют генерации полных решений за один проход. Во-вторых, пошаговая генерация в MCTS естественным образом предоставляет данные для обучения обеих моделей. Стандартный MCTS автоматически присваивает Q-значение каждому шагу, основываясь на его вкладе в итоговый правильный ответ, что избавляет от необходимости в ручной разметке данных для обучения модели вознаграждения.</p>
<p>Использование продвинутых языковых моделей (LLM), таких как GPT-4, для генерации обучающих данных в рамках MCTS сталкивается с двумя проблемами. Во-первых, даже такие мощные модели не всегда могут стабильно решать сложные задачи, например, олимпиадного уровня. В результате, обучающие данные будут состоять в основном из простых, решаемых задач, что ограничит их разнообразие и качество. Во-вторых, аннотирование Q-значений для каждого шага требует большого количества прогонов MCTS; недостаточное исследование дерева может привести к ложным значениям, например, к переоценке неоптимальных шагов. Учитывая, что каждый прогон включает в себя несколько одношаговых генераций, а LLM являются вычислительно затратными, увеличение количества прогонов значительно повышает стоимость инференса.</p>
<p>Для решения этих проблем авторы используют две 7B модели SLM (одна для политики и одна для PRM) для генерации более качественных обучающих данных. Меньший размер этих моделей позволяет проводить обширные прогоны MCTS на доступном оборудовании. Однако, самогенерация данных представляет собой большую проблему для SLM из-за их меньших возможностей. SLM часто не могут сгенерировать правильные решения, и даже если финальный ответ правильный, промежуточные шаги часто бывают ошибочными или низкого качества.</p>
<p>Для смягчения ошибок и низкого качества промежуточных шагов, авторы вводят метод синтеза CoT, дополненный кодом, который выполняет обширные прогоны MCTS для генерации пошаговых проверенных траекторий рассуждений, аннотированных Q-значениями. Для дальнейшего улучшения производительности SLM на сложных задачах, авторы вводят рецепт самоэволюции в четыре раунда. В каждом раунде обновляются как модель политики, так и модель вознаграждения, что позволяет постепенно решать более сложные задачи и генерировать более качественные обучающие данные.</p>
<p>Метод генерации проверенных траекторий рассуждений начинается с запуска стандартного MCTS для пошагового исследования решений. Корневой узел представляет собой вопрос, а дочерние узлы соответствуют промежуточным шагам, сгенерированным моделью политики. Путь от корня до конечного узла формирует траекторию, каждому шагу в которой присваивается Q-значение. Цель состоит в том, чтобы выбрать высококачественные траектории для построения обучающего набора. Для этого используется метод синтеза CoT, дополненный кодом, для отфильтровывания низкокачественных генераций и выполнения обширных прогонов для повышения надежности Q-значений.</p>
<p>В отличие от предыдущих подходов, которые генерировали только текстовые CoT, здесь модель политики генерирует одношаговый CoT на естественном языке вместе с соответствующим кодом на Python, где CoT встроен в качестве комментария. Сохраняются только те генерации, код которых успешно выполняется. Это позволяет отфильтровать ошибочные шаги, которые могли бы привести к правильному ответу случайно. На каждом шаге MCTS, модель политики генерирует несколько кандидатов, которые затем фильтруются с помощью выполнения кода. Оставшиеся кандидаты оцениваются моделью PRM, которая присваивает Q-значение. Затем, с помощью алгоритма UCT выбирается лучший узел.</p>
<p>Для улучшения надежности Q-значений используется подход, аналогичный игрокам в Го, которые оценивают ход на основе исхода игры. После обширных прогонов MCTS, шаги, которые постоянно приводят к правильным ответам, получают более высокие Q-значения, а шаги, которые приводят к неверным ответам, получают низкие Q-значения. Для этого используются два метода самоаннотации: терминально-ориентированная аннотация (используется в первых двух раундах, когда PRM недоступна или недостаточно точна) и аннотация, дополненная PRM (начиная с третьего раунда). В первом случае Q-значение шага обновляется на основе того, привел ли он к правильному ответу в конце траектории. Во втором случае PRM предсказывает начальное Q-значение, которое затем обновляется в процессе обратного распространения.</p>
<p>Модели вознаграждения, предоставляющие гранулярные сигналы на уровне шагов, очень важны для решения сложных математических задач. Однако, получение высококачественных обучающих данных для них остается сложной задачей. Существующие методы полагаются на ручную разметку или на оценки, сгенерированные MCTS. Точность этих оценок напрямую влияет на эффективность модели вознаграждения. Авторы предлагают новый метод обучения модели предпочтений (PPM), который вместо использования Q-значений в качестве прямых меток вознаграждения, использует их для выбора шагов из дерева MCTS для построения пар предпочтений. Для каждого шага выбираются два кандидата с самыми высокими Q-значениями в качестве положительных шагов и два с самыми низкими в качестве отрицательных. Затем PPM обучается отличать положительные шаги от отрицательных. Этот подход устраняет необходимость в точных оценках на уровне шагов и позволяет обучать более эффективную модель вознаграждения.</p></div>
                <div class="images"><img class="summary_image" src='https://arxiv.org/html/2501.04519/x2.png'/></div>
            </div>
            <div class="summaries">
                <div class="summary_title">Evaluation</div>
                <div class="summary_text"><h2>Изложение раздела 4.1 "Настройка оценочных наборов данных" и 4.2 "Основные результаты" статьи по машинному обучению.</h2>
<p>В данном разделе описываются наборы данных и модели, используемые для оценки предложенного метода rStar-Math, а также приводятся основные результаты экспериментов.</p>
<p><strong>4.1 Настройка оценочных наборов данных</strong></p>
<p>Для оценки rStar-Math использовались разнообразные математические бенчмарки, включая:</p>
<ul>
<li><strong>GSM8K:</strong> широко используемый набор задач по математике.</li>
<li><strong>Задачи уровня соревнований и олимпиад:</strong><ul>
<li><strong>MATH-500:</strong> более сложный набор задач.</li>
<li><strong>AIME 2024:</strong> задачи, предназначенные для проверки способностей лучших старшеклассников по математике в США.</li>
<li><strong>AMC 2023:</strong> задачи математической олимпиады.</li>
<li><strong>Olympiad Bench:</strong> набор задач олимпиадного уровня.</li>
</ul>
</li>
<li><strong>Задачи по математике уровня колледжа:</strong><ul>
<li><strong>College Math:</strong> набор задач из университетских курсов.</li>
</ul>
</li>
<li><strong>Задачи из другой предметной области:</strong><ul>
<li><strong>GaoKao (китайский вступительный экзамен в колледж) En 2023:</strong> задачи из китайского вступительного экзамена.</li>
</ul>
</li>
</ul>
<p><strong>Базовые модели и настройка</strong></p>
<p>rStar-Math является общим подходом, применимым к различным большим языковым моделям (LLM). Для демонстрации его эффективности и обобщаемости использовались малые языковые модели (SLM) разных размеров:</p>
<ul>
<li>Qwen2.5-Math-1.5B</li>
<li>Phi3-mini-Instruct (3B) - общая модель без специализации в математике.</li>
<li>Qwen2-Math-7B</li>
<li>Qwen2.5-Math-7B</li>
</ul>
<p>Ограничения вычислительных ресурсов позволили провести 4 раунда самоэволюции только на модели Qwen2.5-Math-7B, в результате чего было получено 4 эволюционировавших модели политики (policy SLM) и 4 модели поощрения (PPM). Для остальных трех моделей политики использовалось дообучение на траекториях, сгенерированных Qwen2.5-Math-7B на 4 раунде. Итоговая PPM из этого раунда использовалась в качестве модели поощрения для этих трех моделей политики.</p>
<p><strong>Базовые сравнения</strong></p>
<p>rStar-Math относится к методам "Системы 2" (требующим более глубокого обдумывания). Он сравнивался с тремя сильными базовыми подходами, представляющими как "Систему 1" (быстрое интуитивное мышление), так и "Систему 2":</p>
<ul>
<li><strong>Передовые LLM:</strong> GPT-4o, Claude, OpenAI o1-preview и o1-mini.</li>
<li><strong>Открытые модели для рассуждений:</strong> DeepSeek-Coder-v2-Instruct, Mathstral, NuminaMath-72B и LLaMA3.1.</li>
<li><strong>Базовые модели, обученные командами разработчиков:</strong> включая версии Instruct (например, Qwen2.5-Math-7B-Instruct) и Best-of-N (например, Qwen2.5-Math-72B-Instruct+Qwen2.5-Math-RM-72B).</li>
</ul>
<p><strong>Метрика оценки</strong></p>
<p>Для всех моделей использовалась метрика Pass@1 (доля правильно решенных задач с первой попытки). Для моделей "Системы 2" использовались стандартные настройки, такие как время обдумывания для o1-mini и o1-preview. Для моделей Qwen Best-of-N были переоценены результаты на MATH-500 и AIME/AMC. Для честного сравнения rStar-Math генерировал такое же количество решений, как и Qwen. В частности, для AIME/AMC генерировалось 16 траекторий, а для других бенчмарков - 8. Использовалась PPM для выбора лучшего решения. Также приведена производительность с увеличенным временем вычислений (64 траектории), обозначенная как rStar-Math64.</p>
<p><strong>4.2 Основные результаты</strong></p>
<p>В таблице 5 приведены результаты rStar-Math в сравнении с передовыми моделями. Основные наблюдения:</p>
<ol>
<li><strong>rStar-Math значительно улучшает математические способности SLM</strong>, достигая производительности, сравнимой или превосходящей OpenAI o1, при существенно меньшем размере модели (1.5B-7B). Например, Qwen2.5Math-7B, изначально показывавшая точность 58.8% на MATH, улучшилась до 90.0% с rStar-Math, превзойдя o1-preview и Claude 3.5 Sonnet и достигнув уровня o1-mini. На College Math rStar-Math превосходит o1-mini на 2.7%. На AIME 2024 rStar-Math набрал 53.3%, уступив только o1-mini.</li>
<li><strong>rStar-Math превосходит "Систему 2"</strong>, несмотря на использование меньших моделей политики (1.5B-7B) и моделей поощрения (7B). По сравнению с Qwen Best-of-N, rStar-Math последовательно улучшает точность рассуждений всех базовых моделей. Даже по сравнению с Best-of-N с 72B моделью политики rStar-Math превосходит ее на всех бенчмарках, кроме GSM8K.</li>
<li><strong>rStar-Math демонстрирует сильную обобщаемость на других сложных бенчмарках</strong>, включая Olympiad Bench, College Math и Gaokao, устанавливая новые рекорды.</li>
</ol>
<p><strong>Увеличение вычислительных ресурсов во время тестирования</strong></p>
<p>rStar-Math использует MCTS для дополнения модели политики, осуществляя поиск решений под руководством PPM. Увеличение времени вычислений позволяет исследовать больше траекторий, потенциально улучшая производительность. На рисунке 3 показано влияние масштабирования вычислений во время тестирования. Основные наблюдения:</p>
<ol>
<li><strong>Уже с 4 траекториями rStar-Math значительно превосходит Best-of-N</strong>, приближаясь к o1-mini.</li>
<li><strong>Масштабирование вычислений во время тестирования улучшает точность рассуждений</strong> на всех бенчмарках, хотя и с разными темпами. На Math, AIME и Olympiad Bench rStar-Math демонстрирует насыщение или медленное улучшение при 64 траекториях, в то время как на College Math производительность продолжает стабильно улучшаться.</li>
</ol></div>
                <div class="images"><img class="summary_image" src='https://arxiv.org/html/2501.04519/extracted/6117756/scalinglaws.png'/></div>
            </div>
            <div class="summaries">
                <div class="summary_title">Findings and Discussions</div>
                <div class="summary_text"><p><strong>Возникновение способности к саморефлексии</strong></p>
<p>Ключевым прорывом в модели OpenAI o1 является её способность к саморефлексии. Когда модель допускает ошибку, она распознаёт её и может самостоятельно исправить, выдав правильный ответ. Однако, в открытых LLM (больших языковых моделях) эта способность оказалась неэффективной. Сообщество активно исследовало различные подходы, включая самокоррекцию и саморефлексию, чтобы обучить или побудить LLM к развитию этой способности.</p>
<p>В экспериментах, представленных в данной статье, было неожиданно обнаружено, что глубокое мышление, основанное на алгоритме MCTS (метод Монте-Карло для поиска дерева), проявляет саморефлексию в процессе решения задач. На примере, показанном на рисунке 4, модель сначала формализует уравнение, используя SymPy, что приводит к неверному ответу (левая ветвь). Однако, на четвёртом шаге (правая ветвь), модель распознаёт низкое качество своих предыдущих шагов и отказывается от продолжения решения по первоначальному пути. Вместо этого, она возвращается назад и решает задачу, используя новый, более простой подход, в итоге получая правильный ответ. Дополнительный пример самокоррекции приведён в приложении A.2. Примечательно, что никакие данные для обучения саморефлексии или подсказки не использовались, что говорит о том, что продвинутое мышление Системы 2 может способствовать возникновению внутренней саморефлексии.</p>
<p><strong>Роль модели вознаграждения (PPM) в глубоком мышлении</strong></p>
<p>Эксперименты показывают, что как модель политики, так и модель вознаграждения играют решающую роль в глубоком мышлении Системы 2. Однако, после того, как модель политики достигает достаточно высокого уровня, именно модель вознаграждения (PPM) становится ключевым фактором, определяющим верхний предел производительности. Рисунок 5 показывает точность моделей политики разных размеров, а также улучшения, достигнутые с помощью различных моделей вознаграждения. Несмотря на различия в точности Pass@1 (вероятность дать правильный ответ с первой попытки) из-за различий в стратегиях обучения, наборах данных и масштабах моделей, модель вознаграждения оказывается доминирующим фактором в рассуждениях Системы 2. Например, хотя точность SFT (обучение с учителем) модели rStar-Math-7B ниже, чем у Qwen2.5-Math-72B-Instruct, в сочетании с PPM 7B, rStar-Math превосходит модель политики 72B с Qwen 72B ORM. Кроме того, несмотря на различия в точности Pass@1 между тремя размерами моделей политики, точность рассуждений сходится после применения PPM.</p>
<p><strong>PPM выявляет шаги применения теорем</strong></p>
<p>При решении сложных математических задач, выявление и применение соответствующих теорем или ключевых выводов часто является основой успешного решения. В экспериментах было обнаружено, что во время решения задач rStar-Math, PPM эффективно выявляет важные промежуточные шаги применения теорем в процессе глубокого мышления моделей политики. Эти шаги прогнозируются с высокими оценками вознаграждения, направляя модель политики к генерации правильного решения. В приложении A.2 приведены примеры, где PPM успешно выявляет ключевые теоремы, такие как малая теорема Ферма, формулы Виета, неравенство Коши, теорема Пифагора и формула площади Гаусса.</p>
<p><strong>Обсуждение обобщения</strong></p>
<p>rStar-Math предлагает общую методологию для улучшения рассуждений LLM, применимую к различным областям. Во-первых, rStar-Math может обобщаться на более сложные математические задачи, такие как доказательство теорем, хотя в настоящее время основное внимание уделяется текстовым задачам из-за ограничений набора данных. Тем не менее, rStar-Math демонстрирует потенциал для доказательства математических утверждений. Как показано в приложении A.2, он успешно доказывает задачу уровня олимпиады с использованием малой теоремы Ферма, предоставляя пошаговое правильное доказательство в процессе глубокого рассуждения. Во-вторых, rStar-Math может обобщаться на другие области, такие как код и рассуждения здравого смысла. Примечательно, что синтез пошагово проверенных траекторий обучения для общих рассуждений требует механизма для обеспечения обратной связи о том, достигает ли данная траектория желаемого результата в конце развертывания MCTS. Например, в рассуждениях о коде это может включать разработку обширных тестовых примеров; в общих рассуждениях обратная связь может быть получена посредством ручной разметки или взаимной проверки с другой LLM.</p></div>
                <div class="images"><img class="summary_image" src='https://arxiv.org/html/2501.04519/x3.png'/></div>
            </div>
            <div class="summaries">
                <div class="summary_title">Conclusion</div>
                <div class="summary_text"><p>В этой работе представлен метод rStar-Math, который представляет собой самостоятельно развивающийся подход "Системы 2" глубокого мышления. Этот метод значительно повышает способности к математическим рассуждениям у небольших языковых моделей (SLM), достигая производительности на уровне OpenAI o1, что является передовым результатом.</p>
<p>Наш подход показывает, что SLM могут самостоятельно генерировать высококачественные обучающие данные для математических рассуждений на передовом уровне. Обширные эксперименты с четырьмя SLM разных размеров и сложными математическими тестами демонстрируют превосходство rStar-Math. Этот метод показывает лучшие результаты, превосходя существующие языковые модели для математических рассуждений и базовые показатели "Best-of-N".</p>
<p>Также мы выявили ключевые результаты, включая появление саморефлексии и эффективность PPM (предположительно, Post-Processing Method) в определении критических промежуточных шагов, таких как шаги применения теорем. Наконец, rStar-Math может достичь дальнейших улучшений за счет сбора более сложных математических задач, что мы оставляем для будущих исследований.</p>
<p><strong>Комментарии по сути статьи:</strong></p>
<ul>
<li><strong>Система 2 мышления:</strong> Это отсылка к концепции из психологии, где "Система 1" - это быстрое, интуитивное мышление, а "Система 2" - медленное, аналитическое. rStar-Math, видимо, имитирует более обдуманный подход к решению математических задач.</li>
<li><strong>SLM (Small Language Models):</strong>  Речь идет о небольших языковых моделях, которые обычно уступают большим моделям в производительности, но rStar-Math позволяет им достигать высоких результатов в математике.</li>
<li><strong>OpenAI o1-level performance:</strong> Это означает, что метод достигает уровня производительности, сравнимого с одной из моделей OpenAI, которая является эталоном в области ИИ.</li>
<li><strong>Саморефлексия:</strong>  Интересный момент, указывающий на способность модели анализировать собственные рассуждения и улучшать их в процессе обучения.</li>
<li><strong>PPM:</strong> Метод постобработки, который помогает выявлять ключевые шаги в решении.</li>
<li><strong>Best-of-N baselines:</strong>  Базовый метод, который выбирает лучшее решение из N сгенерированных вариантов. rStar-Math превосходит этот метод.</li>
</ul></div>
                <div class="images"></div>
            </div>

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-01-13 12:46',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-01-13 12:46')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-01-13 12:46')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    