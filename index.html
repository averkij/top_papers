
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 14 papers. February 20.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">20 февраля</span> | <span id="title-articles-count">14 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-02-19.html">⬅️ <span id="prev-date">19.02</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-02-21.html">➡️ <span id="next-date">21.02</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-02.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '20 февраля', 'en': 'February 20', 'zh': '2月20日'};
        let feedDateNext = {'ru': '21.02', 'en': '02/21', 'zh': '2月21日'};
        let feedDatePrev = {'ru': '19.02', 'en': '02/19', 'zh': '2月19日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2502.13923', 'title': 'Qwen2.5-VL Technical Report', 'url': 'https://huggingface.co/papers/2502.13923', 'abstract': 'We introduce Qwen2.5-VL, the latest flagship model of Qwen vision-language series, which demonstrates significant advancements in both foundational capabilities and innovative functionalities. Qwen2.5-VL achieves a major leap forward in understanding and interacting with the world through enhanced visual recognition, precise object localization, robust document parsing, and long-video comprehension. A standout feature of Qwen2.5-VL is its ability to localize objects using bounding boxes or points accurately. It provides robust structured data extraction from invoices, forms, and tables, as well as detailed analysis of charts, diagrams, and layouts. To handle complex inputs, Qwen2.5-VL introduces dynamic resolution processing and absolute time encoding, enabling it to process images of varying sizes and videos of extended durations (up to hours) with second-level event localization. This allows the model to natively perceive spatial scales and temporal dynamics without relying on traditional normalization techniques. By training a native dynamic-resolution Vision Transformer (ViT) from scratch and incorporating Window Attention, we reduce computational overhead while maintaining native resolution. As a result, Qwen2.5-VL excels not only in static image and document understanding but also as an interactive visual agent capable of reasoning, tool usage, and task execution in real-world scenarios such as operating computers and mobile devices. Qwen2.5-VL is available in three sizes, addressing diverse use cases from edge AI to high-performance computing. The flagship Qwen2.5-VL-72B model matches state-of-the-art models like GPT-4o and Claude 3.5 Sonnet, particularly excelling in document and diagram understanding. Additionally, Qwen2.5-VL maintains robust linguistic performance, preserving the core language competencies of the Qwen2.5 LLM.', 'score': 29, 'issue_id': 2311, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': 'b0f349bddafadc4c', 'authors': ['Shuai Bai', 'Keqin Chen', 'Xuejing Liu', 'Jialin Wang', 'Wenbin Ge', 'Sibo Song', 'Kai Dang', 'Peng Wang', 'Shijie Wang', 'Jun Tang', 'Humen Zhong', 'Yuanzhi Zhu', 'Mingkun Yang', 'Zhaohai Li', 'Jianqiang Wan', 'Pengfei Wang', 'Wei Ding', 'Zheren Fu', 'Yiheng Xu', 'Jiabo Ye', 'Xi Zhang', 'Tianbao Xie', 'Zesen Cheng', 'Hang Zhang', 'Zhibo Yang', 'Haiyang Xu', 'Junyang Lin'], 'affiliations': ['Alibaba Group'], 'pdf_title_img': 'assets/pdf/title_img/2502.13923.jpg', 'data': {'categories': ['#agi', '#architecture', '#cv', '#multimodal', '#long_context', '#agents', '#reasoning'], 'emoji': '🔍', 'ru': {'title': 'Новый уровень понимания визуальной информации с Qwen2.5-VL', 'desc': 'Qwen2.5-VL - это новая модель машинного обучения для обработки визуальной и текстовой информации. Она демонстрирует значительные улучшения в распознавании объектов, анализе документов и понимании длинных видео. Модель использует динамическое разрешение и абсолютное временное кодирование для обработки изображений и видео различных размеров. Qwen2.5-VL доступна в трех размерах и сравнима по производительности с современными мультимодальными языковыми моделями.'}, 'en': {'title': 'Revolutionizing Vision-Language Interaction with Qwen2.5-VL', 'desc': 'Qwen2.5-VL is a cutting-edge vision-language model that enhances the understanding and interaction with visual data. It features advanced capabilities like precise object localization, effective document parsing, and the ability to comprehend long videos. The model utilizes dynamic resolution processing and absolute time encoding to handle complex inputs, allowing it to analyze images and videos of various sizes efficiently. With its robust performance in both visual and linguistic tasks, Qwen2.5-VL serves as an interactive agent for real-world applications, from edge AI to high-performance computing.'}, 'zh': {'title': 'Qwen2.5-VL：视觉与语言的完美结合', 'desc': 'Qwen2.5-VL是Qwen视觉语言系列的最新旗舰模型，展示了基础能力和创新功能的显著进步。它在视觉识别、物体定位、文档解析和长视频理解方面取得了重大突破。该模型能够准确地使用边界框或点来定位物体，并从发票、表单和表格中提取结构化数据。通过动态分辨率处理和绝对时间编码，Qwen2.5-VL能够处理不同大小的图像和长达数小时的视频，成为一个能够在现实场景中进行推理和任务执行的互动视觉代理。'}}}, {'id': 'https://huggingface.co/papers/2502.13144', 'title': 'RAD: Training an End-to-End Driving Policy via Large-Scale 3DGS-based Reinforcement Learning', 'url': 'https://huggingface.co/papers/2502.13144', 'abstract': 'Existing end-to-end autonomous driving (AD) algorithms typically follow the Imitation Learning (IL) paradigm, which faces challenges such as causal confusion and the open-loop gap. In this work, we establish a 3DGS-based closed-loop Reinforcement Learning (RL) training paradigm. By leveraging 3DGS techniques, we construct a photorealistic digital replica of the real physical world, enabling the AD policy to extensively explore the state space and learn to handle out-of-distribution scenarios through large-scale trial and error. To enhance safety, we design specialized rewards that guide the policy to effectively respond to safety-critical events and understand real-world causal relationships. For better alignment with human driving behavior, IL is incorporated into RL training as a regularization term. We introduce a closed-loop evaluation benchmark consisting of diverse, previously unseen 3DGS environments. Compared to IL-based methods, RAD achieves stronger performance in most closed-loop metrics, especially 3x lower collision rate. Abundant closed-loop results are presented at https://hgao-cv.github.io/RAD.', 'score': 22, 'issue_id': 2309, 'pub_date': '2025-02-18', 'pub_date_card': {'ru': '18 февраля', 'en': 'February 18', 'zh': '2月18日'}, 'hash': '0db330614af75888', 'authors': ['Hao Gao', 'Shaoyu Chen', 'Bo Jiang', 'Bencheng Liao', 'Yiang Shi', 'Xiaoyang Guo', 'Yuechuan Pu', 'Haoran Yin', 'Xiangyu Li', 'Xinbang Zhang', 'Ying Zhang', 'Wenyu Liu', 'Qian Zhang', 'Xinggang Wang'], 'affiliations': ['Horizon Robotics', 'Huazhong University of Science & Technology'], 'pdf_title_img': 'assets/pdf/title_img/2502.13144.jpg', 'data': {'categories': ['#rl', '#benchmark', '#alignment', '#3d', '#games', '#reasoning', '#agents'], 'emoji': '🚗', 'ru': {'title': 'Революция в автономном вождении: обучение с подкреплением в фотореалистичных 3D-мирах', 'desc': 'Статья представляет новый подход к автономному вождению, основанный на обучении с подкреплением (RL) с использованием фотореалистичных 3D-моделей окружающей среды. Авторы разработали систему RAD, которая позволяет политике автономного вождения исследовать различные сценарии и учиться справляться с нестандартными ситуациями через масштабные эксперименты. Для повышения безопасности были разработаны специальные функции вознаграждения, а для лучшего соответствия человеческому поведению при вождении было включено обучение по имитации (IL) в качестве регуляризации. Результаты показывают, что RAD превосходит методы, основанные только на IL, особенно в снижении частоты столкновений.'}, 'en': {'title': 'Revolutionizing Autonomous Driving with Closed-Loop Reinforcement Learning', 'desc': "This paper presents a new approach to autonomous driving using a closed-loop Reinforcement Learning (RL) paradigm, addressing limitations of traditional Imitation Learning (IL). By creating a realistic 3D digital environment, the model can explore various driving scenarios and learn from trial and error, improving its ability to handle unexpected situations. The authors introduce specialized rewards to enhance safety by teaching the model to react appropriately to critical events and understand causal relationships in driving. Additionally, they incorporate IL as a regularization term to better align the model's behavior with human driving patterns, resulting in significantly improved performance metrics, including a lower collision rate."}, 'zh': {'title': '闭环强化学习提升自主驾驶安全性与性能', 'desc': '现有的端到端自主驾驶算法通常采用模仿学习（IL）方法，但面临因果混淆和开放环路差距等挑战。本文提出了一种基于3DGS的闭环强化学习（RL）训练范式，通过构建真实物理世界的逼真数字复制品，使自主驾驶策略能够广泛探索状态空间，并通过大规模试错学习处理分布外场景。为了提高安全性，我们设计了专门的奖励机制，引导策略有效应对安全关键事件，并理解现实世界的因果关系。同时，为了更好地与人类驾驶行为对齐，我们将模仿学习作为正则化项融入到强化学习训练中。'}}}, {'id': 'https://huggingface.co/papers/2502.13922', 'title': 'LongPO: Long Context Self-Evolution of Large Language Models through Short-to-Long Preference Optimization', 'url': 'https://huggingface.co/papers/2502.13922', 'abstract': 'Large Language Models (LLMs) have demonstrated remarkable capabilities through pretraining and alignment. However, superior short-context LLMs may underperform in long-context scenarios due to insufficient long-context alignment. This alignment process remains challenging due to the impracticality of human annotation for extended contexts and the difficulty in balancing short- and long-context performance. To address these challenges, we introduce LongPO, that enables short-context LLMs to self-evolve to excel on long-context tasks by internally transferring short-context capabilities. LongPO harnesses LLMs to learn from self-generated short-to-long preference data, comprising paired responses generated for identical instructions with long-context inputs and their compressed short-context counterparts, respectively. This preference reveals capabilities and potentials of LLMs cultivated during short-context alignment that may be diminished in under-aligned long-context scenarios. Additionally, LongPO incorporates a short-to-long KL constraint to mitigate short-context performance decline during long-context alignment. When applied to Mistral-7B-Instruct-v0.2 from 128K to 512K context lengths, LongPO fully retains short-context performance and largely outperforms naive SFT and DPO in both long- and short-context tasks. Specifically, \\ourMethod-trained models can achieve results on long-context benchmarks comparable to, or even surpassing, those of superior LLMs (e.g., GPT-4-128K) that involve extensive long-context annotation and larger parameter scales.', 'score': 14, 'issue_id': 2309, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': '93cf8365ba7edb80', 'authors': ['Guanzheng Chen', 'Xin Li', 'Michael Qizhe Shieh', 'Lidong Bing'], 'affiliations': ['DAMO Academy, Alibaba Group', 'Hupan Lab, 310023, Hangzhou, China', 'National University of Singapore', 'Shanda AI Research Institute'], 'pdf_title_img': 'assets/pdf/title_img/2502.13922.jpg', 'data': {'categories': ['#training', '#transfer_learning', '#benchmark', '#long_context', '#architecture', '#rlhf'], 'emoji': '📏', 'ru': {'title': 'LongPO: Самоэволюция языковых моделей для работы с длинным контекстом', 'desc': 'Статья представляет новый метод LongPO для улучшения работы языковых моделей с длинным контекстом. LongPO позволяет моделям, обученным на коротких контекстах, самостоятельно адаптироваться к длинным контекстам, используя самогенерируемые данные о предпочтениях. Метод включает ограничение KL для сохранения производительности на коротких контекстах. Эксперименты показывают, что LongPO превосходит наивные методы обучения на длинных и коротких контекстах.'}, 'en': {'title': 'Empowering Short-Context LLMs for Long-Context Mastery', 'desc': 'This paper presents LongPO, a method designed to enhance the performance of short-context Large Language Models (LLMs) on long-context tasks. The challenge arises from the difficulty of aligning LLMs for long contexts due to the lack of human-annotated data and the need to balance performance across different context lengths. LongPO allows LLMs to learn from their own generated data, creating a preference model that helps them adapt their short-context skills to long-context scenarios. The results show that models trained with LongPO maintain their short-context performance while significantly improving their long-context capabilities, even rivaling more advanced models like GPT-4.'}, 'zh': {'title': 'LongPO：短上下文模型的长上下文自我演化', 'desc': '大型语言模型（LLMs）在预训练和对齐方面表现出色，但在长上下文场景中可能表现不佳。为了解决这个问题，本文提出了LongPO方法，使短上下文的LLMs能够自我演化，以在长上下文任务中表现出色。LongPO通过生成短到长的偏好数据，帮助模型学习如何在长上下文中保持短上下文的能力。实验结果表明，使用LongPO的模型在长上下文基准测试中表现优异，甚至可以与更强大的LLMs相媲美。'}}}, {'id': 'https://huggingface.co/papers/2502.13128', 'title': 'SongGen: A Single Stage Auto-regressive Transformer for Text-to-Song Generation', 'url': 'https://huggingface.co/papers/2502.13128', 'abstract': 'Text-to-song generation, the task of creating vocals and accompaniment from textual inputs, poses significant challenges due to domain complexity and data scarcity. Existing approaches often employ multi-stage generation procedures, resulting in cumbersome training and inference pipelines. In this paper, we propose SongGen, a fully open-source, single-stage auto-regressive transformer designed for controllable song generation. The proposed model facilitates fine-grained control over diverse musical attributes, including lyrics and textual descriptions of instrumentation, genre, mood, and timbre, while also offering an optional three-second reference clip for voice cloning. Within a unified auto-regressive framework, SongGen supports two output modes: mixed mode, which generates a mixture of vocals and accompaniment directly, and dual-track mode, which synthesizes them separately for greater flexibility in downstream applications. We explore diverse token pattern strategies for each mode, leading to notable improvements and valuable insights. Furthermore, we design an automated data preprocessing pipeline with effective quality control. To foster community engagement and future research, we will release our model weights, training code, annotated data, and preprocessing pipeline. The generated samples are showcased on our project page at https://liuzh-19.github.io/SongGen/ , and the code will be available at https://github.com/LiuZH-19/SongGen .', 'score': 13, 'issue_id': 2312, 'pub_date': '2025-02-18', 'pub_date_card': {'ru': '18 февраля', 'en': 'February 18', 'zh': '2月18日'}, 'hash': '30ac46f3e428e6cf', 'authors': ['Zihan Liu', 'Shuangrui Ding', 'Zhixiong Zhang', 'Xiaoyi Dong', 'Pan Zhang', 'Yuhang Zang', 'Yuhang Cao', 'Dahua Lin', 'Jiaqi Wang'], 'affiliations': ['Beihang University, Beijing, China', 'Shanghai AI Laboratory, Shanghai, China', 'The Chinese University of Hong Kong, Hong Kong, China'], 'pdf_title_img': 'assets/pdf/title_img/2502.13128.jpg', 'data': {'categories': ['#story_generation', '#data', '#audio', '#training', '#open_source', '#dataset'], 'emoji': '🎵', 'ru': {'title': 'SongGen: Революция в генерации песен с помощью ИИ', 'desc': 'SongGen - это новая модель машинного обучения для генерации песен на основе текстового ввода. Она использует архитектуру трансформера и позволяет контролировать различные музыкальные атрибуты, включая текст песни, инструментовку, жанр и настроение. Модель может работать в двух режимах: смешанном (генерация вокала и аккомпанемента вместе) и двухдорожечном (раздельная генерация). Авторы также разработали автоматизированный конвейер предобработки данных и планируют открыть исходный код и веса модели для дальнейших исследований.'}, 'en': {'title': 'SongGen: Simplifying Text-to-Song Generation with a Unified Model', 'desc': 'This paper introduces SongGen, a novel model for generating songs from text inputs using a single-stage auto-regressive transformer. It addresses the challenges of text-to-song generation by allowing fine control over various musical elements such as lyrics, genre, and mood. The model offers two output modes: mixed mode for simultaneous vocal and accompaniment generation, and dual-track mode for separate synthesis, enhancing flexibility for users. Additionally, the authors provide an automated data preprocessing pipeline and commit to releasing their resources to support further research in this area.'}, 'zh': {'title': 'SongGen：可控的歌曲生成新方法', 'desc': '本文介绍了一种名为SongGen的文本到歌曲生成模型，旨在从文本输入中生成歌词和伴奏。该模型采用单阶段自回归变换器，能够对多种音乐属性进行精细控制，如歌词、乐器描述、风格、情绪和音色。SongGen支持两种输出模式：混合模式和双轨模式，提供了更大的灵活性以满足不同应用需求。此外，研究团队还设计了自动化的数据预处理管道，以确保生成样本的质量，并计划开放模型权重和训练代码以促进社区参与。'}}}, {'id': 'https://huggingface.co/papers/2502.13347', 'title': 'Craw4LLM: Efficient Web Crawling for LLM Pretraining', 'url': 'https://huggingface.co/papers/2502.13347', 'abstract': "Web crawl is a main source of large language models' (LLMs) pretraining data, but the majority of crawled web pages are discarded in pretraining due to low data quality. This paper presents Crawl4LLM, an efficient web crawling method that explores the web graph based on the preference of LLM pretraining. Specifically, it leverages the influence of a webpage in LLM pretraining as the priority score of the web crawler's scheduler, replacing the standard graph connectivity based priority. Our experiments on a web graph containing 900 million webpages from a commercial search engine's index demonstrate the efficiency of Crawl4LLM in obtaining high-quality pretraining data. With just 21% URLs crawled, LLMs pretrained on Crawl4LLM data reach the same downstream performances of previous crawls, significantly reducing the crawling waste and alleviating the burdens on websites. Our code is publicly available at https://github.com/cxcscmu/Crawl4LLM.", 'score': 13, 'issue_id': 2310, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': 'dd055f606e1ddfe2', 'authors': ['Shi Yu', 'Zhiyuan Liu', 'Chenyan Xiong'], 'affiliations': ['Department of Computer Science and Technology, Tsinghua University', 'School of Computer Science, Carnegie Mellon University'], 'pdf_title_img': 'assets/pdf/title_img/2502.13347.jpg', 'data': {'categories': ['#dataset', '#graphs', '#open_source', '#data'], 'emoji': '🕷️', 'ru': {'title': 'Умный веб-краулинг для эффективного обучения языковых моделей', 'desc': 'Статья представляет Crawl4LLM - эффективный метод веб-краулинга для предобучения больших языковых моделей (LLM). Метод использует влияние веб-страницы на предобучение LLM в качестве приоритета для планировщика краулера, заменяя стандартный подход на основе связности графа. Эксперименты на графе из 900 миллионов страниц показали эффективность Crawl4LLM в получении качественных данных для предобучения. При использовании всего 21% URL модели достигают тех же результатов, что и при предыдущих подходах к краулингу.'}, 'en': {'title': 'Crawl Smart: Boosting LLMs with Efficient Web Crawling', 'desc': 'This paper introduces Crawl4LLM, a novel web crawling technique designed to enhance the quality of pretraining data for large language models (LLMs). Instead of relying on traditional methods that prioritize web page connectivity, Crawl4LLM uses a priority score based on the potential influence of a webpage on LLM performance. The method was tested on a vast web graph with 900 million pages, showing that it can achieve comparable downstream performance with only 21% of the URLs crawled. This approach not only improves data quality but also minimizes the environmental impact of web crawling by reducing unnecessary data collection.'}, 'zh': {'title': '高效爬虫，提升LLM预训练数据质量', 'desc': '本论文提出了一种名为Crawl4LLM的高效网络爬虫方法，旨在提高大语言模型（LLM）预训练数据的质量。该方法通过网页在LLM预训练中的影响力作为优先级评分，优化了爬虫调度器的工作，而不是依赖于传统的图连接性优先级。实验结果表明，Crawl4LLM在仅爬取21%的网址的情况下，能够获得与之前爬取相同的下游性能，显著减少了爬取浪费。此方法不仅提高了数据质量，还减轻了对网站的负担。'}}}, {'id': 'https://huggingface.co/papers/2502.13965', 'title': 'Autellix: An Efficient Serving Engine for LLM Agents as General Programs', 'url': 'https://huggingface.co/papers/2502.13965', 'abstract': "Large language model (LLM) applications are evolving beyond simple chatbots into dynamic, general-purpose agentic programs, which scale LLM calls and output tokens to help AI agents reason, explore, and solve complex tasks. However, existing LLM serving systems ignore dependencies between programs and calls, missing significant opportunities for optimization. Our analysis reveals that programs submitted to LLM serving engines experience long cumulative wait times, primarily due to head-of-line blocking at both the individual LLM request and the program. To address this, we introduce Autellix, an LLM serving system that treats programs as first-class citizens to minimize their end-to-end latencies. Autellix intercepts LLM calls submitted by programs, enriching schedulers with program-level context. We propose two scheduling algorithms-for single-threaded and distributed programs-that preempt and prioritize LLM calls based on their programs' previously completed calls. Our evaluation demonstrates that across diverse LLMs and agentic workloads, Autellix improves throughput of programs by 4-15x at the same latency compared to state-of-the-art systems, such as vLLM.", 'score': 9, 'issue_id': 2310, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': 'f64be1cc6aba8b4c', 'authors': ['Michael Luo', 'Xiaoxiang Shi', 'Colin Cai', 'Tianjun Zhang', 'Justin Wong', 'Yichuan Wang', 'Chi Wang', 'Yanping Huang', 'Zhifeng Chen', 'Joseph E. Gonzalez', 'Ion Stoica'], 'affiliations': ['Google DeepMind', 'Shanghai Jiao Tong University', 'UC Berkeley'], 'pdf_title_img': 'assets/pdf/title_img/2502.13965.jpg', 'data': {'categories': ['#optimization', '#inference', '#agents', '#architecture'], 'emoji': '🚀', 'ru': {'title': 'Autellix: Революция в обслуживании LLM для агентных программ', 'desc': 'Статья представляет Autellix - систему обслуживания больших языковых моделей (LLM), оптимизирующую выполнение агентных программ. Autellix рассматривает программы как объекты первого класса, перехватывая вызовы LLM и обогащая планировщики контекстом на уровне программ. Предложены два алгоритма планирования для однопоточных и распределенных программ, которые приоритизируют вызовы LLM на основе ранее выполненных вызовов. Эксперименты показывают, что Autellix улучшает пропускную способность программ в 4-15 раз при той же задержке по сравнению с современными системами.'}, 'en': {'title': 'Autellix: Optimizing LLM Serving for Enhanced Throughput', 'desc': 'This paper discusses the evolution of large language models (LLMs) from simple chatbots to more complex, agentic programs that can perform a variety of tasks. It identifies a significant issue in current LLM serving systems, which overlook the dependencies between different programs and their calls, leading to inefficiencies and long wait times. The authors introduce Autellix, a new LLM serving system that optimizes these processes by treating programs as first-class entities and enhancing scheduling with program-level context. Their proposed scheduling algorithms significantly improve the throughput of LLM programs, achieving 4-15 times better performance compared to existing systems while maintaining similar latency.'}, 'zh': {'title': '优化LLM调用，提升程序性能的Autellix', 'desc': '这篇论文介绍了一种新的大型语言模型（LLM）服务系统，名为Autellix。Autellix通过将程序视为第一类公民，优化了LLM调用的调度，从而减少了整体延迟。研究表明，现有的LLM服务系统忽视了程序与调用之间的依赖关系，导致了长时间的等待。通过引入新的调度算法，Autellix在多种LLM和任务负载下，提升了程序的吞吐量，效果显著。'}}}, {'id': 'https://huggingface.co/papers/2502.12143', 'title': 'Small Models Struggle to Learn from Strong Reasoners', 'url': 'https://huggingface.co/papers/2502.12143', 'abstract': 'Large language models (LLMs) excel in complex reasoning tasks, and distilling their reasoning capabilities into smaller models has shown promise. However, we uncover an interesting phenomenon, which we term the Small Model Learnability Gap: small models (leq3B parameters) do not consistently benefit from long chain-of-thought (CoT) reasoning or distillation from larger models. Instead, they perform better when fine-tuned on shorter, simpler reasoning chains that better align with their intrinsic learning capacity. To address this, we propose Mix Distillation, a simple yet effective strategy that balances reasoning complexity by combining long and short CoT examples or reasoning from both larger and smaller models. Our experiments demonstrate that Mix Distillation significantly improves small model reasoning performance compared to training on either data alone. These findings highlight the limitations of direct strong model distillation and underscore the importance of adapting reasoning complexity for effective reasoning capability transfer.', 'score': 9, 'issue_id': 2309, 'pub_date': '2025-02-17', 'pub_date_card': {'ru': '17 февраля', 'en': 'February 17', 'zh': '2月17日'}, 'hash': '5abea4fb025815c2', 'authors': ['Yuetai Li', 'Xiang Yue', 'Zhangchen Xu', 'Fengqing Jiang', 'Luyao Niu', 'Bill Yuchen Lin', 'Bhaskar Ramasubramanian', 'Radha Poovendran'], 'affiliations': ['Carnegie Mellon University', 'University of Washington', 'Western Washington University'], 'pdf_title_img': 'assets/pdf/title_img/2502.12143.jpg', 'data': {'categories': ['#training', '#transfer_learning', '#optimization', '#reasoning', '#small_models'], 'emoji': '🧠', 'ru': {'title': 'Адаптация сложности рассуждений для эффективного обучения малых языковых моделей', 'desc': 'Исследование показывает, что маленькие языковые модели (до 3 млрд параметров) не всегда успешно обучаются на длинных цепочках рассуждений или при дистилляции от больших моделей. Авторы обнаружили, что такие модели лучше обучаются на более коротких и простых цепочках рассуждений. Для решения этой проблемы предложен метод Mix Distillation, сочетающий длинные и короткие примеры рассуждений. Эксперименты показывают, что этот подход значительно улучшает способность маленьких моделей к рассуждениям.'}, 'en': {'title': 'Bridging the Learnability Gap for Small Models with Mix Distillation', 'desc': 'This paper explores the challenges faced by small language models (with 3 billion parameters or fewer) in learning from complex reasoning tasks. It identifies a phenomenon called the Small Model Learnability Gap, where these smaller models do not gain advantages from long chain-of-thought (CoT) reasoning or direct distillation from larger models. Instead, they perform better when trained on shorter, simpler reasoning chains that match their learning abilities. To improve their performance, the authors propose a method called Mix Distillation, which combines both long and short reasoning examples, leading to better reasoning outcomes for small models.'}, 'zh': {'title': '混合蒸馏：提升小模型推理能力的有效策略', 'desc': '大型语言模型在复杂推理任务中表现出色，但我们发现小模型（参数小于等于3亿）在长链推理或从大模型蒸馏中并不总是受益。相反，它们在短小简单的推理链上微调时表现更好，这与它们的学习能力更为契合。为了解决这个问题，我们提出了混合蒸馏（Mix Distillation）策略，通过结合长短推理示例或来自大模型和小模型的推理，平衡推理复杂性。实验表明，混合蒸馏显著提高了小模型的推理性能，强调了直接强模型蒸馏的局限性，并突出了适应推理复杂性的重要性。'}}}, {'id': 'https://huggingface.co/papers/2502.13946', 'title': "Why Safeguarded Ships Run Aground? Aligned Large Language Models' Safety Mechanisms Tend to Be Anchored in The Template Region", 'url': 'https://huggingface.co/papers/2502.13946', 'abstract': "The safety alignment of large language models (LLMs) remains vulnerable, as their initial behavior can be easily jailbroken by even relatively simple attacks. Since infilling a fixed template between the input instruction and initial model output is a common practice for existing LLMs, we hypothesize that this template is a key factor behind their vulnerabilities: LLMs' safety-related decision-making overly relies on the aggregated information from the template region, which largely influences these models' safety behavior. We refer to this issue as template-anchored safety alignment. In this paper, we conduct extensive experiments and verify that template-anchored safety alignment is widespread across various aligned LLMs. Our mechanistic analyses demonstrate how it leads to models' susceptibility when encountering inference-time jailbreak attacks. Furthermore, we show that detaching safety mechanisms from the template region is promising in mitigating vulnerabilities to jailbreak attacks. We encourage future research to develop more robust safety alignment techniques that reduce reliance on the template region.", 'score': 7, 'issue_id': 2311, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': '72612658ea7eefab', 'authors': ['Chak Tou Leong', 'Qingyu Yin', 'Jian Wang', 'Wenjie Li'], 'affiliations': ['Department of Computing, The Hong Kong Polytechnic University', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2502.13946.jpg', 'data': {'categories': ['#alignment', '#security', '#training', '#inference', '#rlhf'], 'emoji': '🛡️', 'ru': {'title': 'Преодоление уязвимостей в безопасности языковых моделей', 'desc': "Это исследование посвящено проблеме безопасности больших языковых моделей (LLM) и их уязвимости к атакам типа 'jailbreak'. Авторы выдвигают гипотезу, что ключевым фактором уязвимости является чрезмерная зависимость механизмов безопасности LLM от шаблонного региона между инструкцией и начальным выводом модели. Эксперименты подтверждают, что эта проблема, названная 'привязкой выравнивания безопасности к шаблону', широко распространена среди различных LLM. Исследователи предлагают отделить механизмы безопасности от шаблонного региона для повышения устойчивости к атакам."}, 'en': {'title': 'Strengthening LLM Safety by Breaking Template Ties', 'desc': "This paper investigates the safety alignment of large language models (LLMs) and identifies a vulnerability linked to the use of fixed templates in their design. The authors propose that these templates anchor the models' safety decision-making, making them susceptible to simple jailbreak attacks. Through experiments, they confirm that this 'template-anchored safety alignment' is a common issue across various LLMs. The study suggests that improving safety mechanisms by detaching them from the template region could enhance the models' resilience against such attacks."}, 'zh': {'title': '模板锚定的安全对齐问题', 'desc': '大型语言模型（LLMs）的安全对齐仍然存在脆弱性，因为它们的初始行为容易受到简单攻击的影响。我们假设输入指令和初始模型输出之间的固定模板是导致这些脆弱性的关键因素，因为LLMs的安全决策过于依赖模板区域的信息。我们称这种问题为模板锚定的安全对齐。通过实验，我们发现这种现象在多种对齐的LLMs中普遍存在，并且分离安全机制与模板区域有助于减轻对攻击的脆弱性。'}}}, {'id': 'https://huggingface.co/papers/2502.13233', 'title': 'SearchRAG: Can Search Engines Be Helpful for LLM-based Medical Question Answering?', 'url': 'https://huggingface.co/papers/2502.13233', 'abstract': "Large Language Models (LLMs) have shown remarkable capabilities in general domains but often struggle with tasks requiring specialized knowledge. Conventional Retrieval-Augmented Generation (RAG) techniques typically retrieve external information from static knowledge bases, which can be outdated or incomplete, missing fine-grained clinical details essential for accurate medical question answering. In this work, we propose SearchRAG, a novel framework that overcomes these limitations by leveraging real-time search engines. Our method employs synthetic query generation to convert complex medical questions into search-engine-friendly queries and utilizes uncertainty-based knowledge selection to filter and incorporate the most relevant and informative medical knowledge into the LLM's input. Experimental results demonstrate that our method significantly improves response accuracy in medical question answering tasks, particularly for complex questions requiring detailed and up-to-date knowledge.", 'score': 6, 'issue_id': 2310, 'pub_date': '2025-02-18', 'pub_date_card': {'ru': '18 февраля', 'en': 'February 18', 'zh': '2月18日'}, 'hash': '58503159cb9ed740', 'authors': ['Yucheng Shi', 'Tianze Yang', 'Canyu Chen', 'Quanzheng Li', 'Tianming Liu', 'Xiang Li', 'Ninghao Liu'], 'affiliations': ['Illinois Institute of Technology', 'Massachusetts General Hospital and Harvard Medical School', 'University of Georgia'], 'pdf_title_img': 'assets/pdf/title_img/2502.13233.jpg', 'data': {'categories': ['#rag', '#synthetic', '#healthcare', '#science'], 'emoji': '🩺', 'ru': {'title': 'SearchRAG: Точные медицинские ответы с помощью актуального поиска', 'desc': 'Эта статья представляет SearchRAG - новый метод для улучшения ответов больших языковых моделей на медицинские вопросы. В отличие от традиционных подходов извлечения информации, SearchRAG использует поисковые системы в реальном времени для получения актуальных данных. Метод включает генерацию синтетических запросов и отбор релевантной информации на основе оценки неопределенности. Эксперименты показывают, что SearchRAG значительно повышает точность ответов на сложные медицинские вопросы, требующие детальных и современных знаний.'}, 'en': {'title': 'Enhancing Medical Q&A with Real-Time Search and Smart Querying', 'desc': 'This paper introduces SearchRAG, a new framework designed to enhance the performance of Large Language Models (LLMs) in medical question answering. Unlike traditional Retrieval-Augmented Generation (RAG) methods that rely on static knowledge bases, SearchRAG utilizes real-time search engines to access current and detailed medical information. The framework employs synthetic query generation to transform complex medical inquiries into queries suitable for search engines, and it uses uncertainty-based knowledge selection to ensure that only the most relevant information is included. Experimental results indicate that SearchRAG significantly boosts the accuracy of LLM responses, especially for intricate medical questions that demand precise and updated knowledge.'}, 'zh': {'title': '实时搜索提升医疗问答准确性', 'desc': '大型语言模型在一般领域表现出色，但在需要专业知识的任务中常常遇到困难。传统的检索增强生成（RAG）技术通常从静态知识库中检索外部信息，这些信息可能过时或不完整，缺乏准确医疗问答所需的细节。我们提出了一种新框架SearchRAG，通过利用实时搜索引擎来克服这些限制。实验结果表明，我们的方法在医疗问答任务中显著提高了响应准确性，尤其是对于需要详细和最新知识的复杂问题。'}}}, {'id': 'https://huggingface.co/papers/2502.13962', 'title': 'Is That Your Final Answer? Test-Time Scaling Improves Selective Question Answering', 'url': 'https://huggingface.co/papers/2502.13962', 'abstract': 'Scaling the test-time compute of large language models has demonstrated impressive performance on reasoning benchmarks. However, existing evaluations of test-time scaling make the strong assumption that a reasoning system should always give an answer to any question provided. This overlooks concerns about whether a model is confident in its answer, and whether it is appropriate to always provide a response. To address these concerns, we extract confidence scores during reasoning for thresholding model responses. We find that increasing compute budget at inference time not only helps models answer more questions correctly, but also increases confidence in correct responses. We then extend the current paradigm of zero-risk responses during evaluation by considering settings with non-zero levels of response risk, and suggest a recipe for reporting evaluations under these settings.', 'score': 5, 'issue_id': 2311, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': '06bee7f6d596d006', 'authors': ['William Jurayj', 'Jeffrey Cheng', 'Benjamin Van Durme'], 'affiliations': ['Johns Hopkins University'], 'pdf_title_img': 'assets/pdf/title_img/2502.13962.jpg', 'data': {'categories': ['#benchmark', '#interpretability', '#reasoning', '#inference'], 'emoji': '🧠', 'ru': {'title': 'Уверенность языковых моделей: больше вычислений - меньше рисков', 'desc': 'Статья исследует влияние увеличения вычислительных ресурсов на работу больших языковых моделей при тестировании. Авторы вводят оценку уверенности модели в своих ответах и рассматривают сценарии с ненулевым уровнем риска ответа. Обнаружено, что увеличение вычислительных ресурсов не только повышает точность ответов, но и увеличивает уверенность модели в правильных ответах. Предлагается новый подход к оценке языковых моделей с учетом этих факторов.'}, 'en': {'title': 'Boosting Confidence in AI Responses through Compute Scaling', 'desc': "This paper discusses how increasing the computational resources available to large language models during inference can improve their performance on reasoning tasks. It highlights the importance of not just providing answers, but also assessing the model's confidence in those answers. By extracting confidence scores, the authors propose a method to filter responses based on their reliability. The study also introduces a new evaluation framework that accounts for the risk associated with model responses, moving beyond the traditional zero-risk assumption."}, 'zh': {'title': '提升模型信心，优化推理回答', 'desc': '这篇论文探讨了在推理基准测试中，大型语言模型在测试时计算能力的扩展所带来的显著性能提升。现有的评估方法假设推理系统必须对每个问题都给出答案，但这忽视了模型对答案的信心和是否总是提供回答的适当性。为了解决这些问题，研究者在推理过程中提取了置信度分数，以便对模型的回答进行阈值处理。结果表明，增加推理时的计算预算不仅提高了模型正确回答问题的能力，还增强了对正确回答的信心。'}}}, {'id': 'https://huggingface.co/papers/2502.13943', 'title': 'AdaptiveStep: Automatically Dividing Reasoning Step through Model Confidence', 'url': 'https://huggingface.co/papers/2502.13943', 'abstract': "Current approaches for training Process Reward Models (PRMs) often involve breaking down responses into multiple reasoning steps using rule-based techniques, such as using predefined placeholder tokens or setting the reasoning step's length into a fixed size. These approaches overlook the fact that specific words do not typically mark true decision points in a text. To address this, we propose AdaptiveStep, a method that divides reasoning steps based on the model's confidence in predicting the next word. This division method provides more decision-making information at each step, enhancing downstream tasks, such as reward model learning. Moreover, our method does not require manual annotation. We demonstrate its effectiveness through experiments with AdaptiveStep-trained PRMs in mathematical reasoning and code generation tasks. Experimental results indicate that the outcome PRM achieves state-of-the-art Best-of-N performance, surpassing greedy search strategy with token-level value-guided decoding, while also reducing construction costs by over 30% compared to existing open-source PRMs. In addition, we provide a thorough analysis and case study on the PRM's performance, transferability, and generalization capabilities.", 'score': 4, 'issue_id': 2310, 'pub_date': '2025-02-19', 'pub_date_card': {'ru': '19 февраля', 'en': 'February 19', 'zh': '2月19日'}, 'hash': '41ab630e56147df2', 'authors': ['Yuliang Liu', 'Junjie Lu', 'Zhaoling Chen', 'Chaofeng Qu', 'Jason Klein Liu', 'Chonghan Liu', 'Zefan Cai', 'Yunhui Xia', 'Li Zhao', 'Jiang Bian', 'Chuheng Zhang', 'Wei Shen', 'Zhouhan Lin'], 'affiliations': ['MSRA', 'Nanjing University', 'Shanghai Jiaotong University', 'UW-Madison', 'University of Technology Sydney'], 'pdf_title_img': 'assets/pdf/title_img/2502.13943.jpg', 'data': {'categories': ['#reasoning', '#plp', '#training', '#open_source', '#math', '#transfer_learning'], 'emoji': '🧠', 'ru': {'title': 'AdaptiveStep: умное разбиение на шаги для эффективного обучения PRM', 'desc': 'Статья представляет новый метод AdaptiveStep для обучения моделей вознаграждения процессов (PRM). Вместо разбиения ответов на шаги фиксированной длины, AdaptiveStep использует уверенность модели в предсказании следующего слова для определения границ шагов рассуждения. Этот подход улучшает качество информации на каждом шаге и не требует ручной разметки. Эксперименты показали, что PRM, обученные с помощью AdaptiveStep, достигают лучших результатов в задачах математических рассуждений и генерации кода, превосходя существующие методы.'}, 'en': {'title': 'AdaptiveStep: Smarter Reasoning for Better Reward Models', 'desc': "This paper introduces AdaptiveStep, a novel method for training Process Reward Models (PRMs) that improves the way reasoning steps are defined. Instead of relying on fixed-length steps or predefined tokens, AdaptiveStep adjusts the reasoning process based on the model's confidence in predicting the next word. This approach enhances the decision-making information available at each step, leading to better performance in tasks like reward model learning. Experimental results show that PRMs trained with AdaptiveStep outperform traditional methods in mathematical reasoning and code generation, while also being more cost-effective."}, 'zh': {'title': '自适应步骤：提升奖励模型的决策能力', 'desc': '本文提出了一种新的训练过程奖励模型（PRM）的方法，称为AdaptiveStep。该方法通过根据模型对下一个单词预测的信心来划分推理步骤，从而提供更丰富的决策信息。与传统的基于规则的方法不同，AdaptiveStep不需要手动标注，且在数学推理和代码生成任务中表现出色。实验结果表明，使用AdaptiveStep训练的PRM在性能上超过了现有的开源PRM，并且构建成本降低了30%以上。'}}}, {'id': 'https://huggingface.co/papers/2502.13173', 'title': 'Thinking Preference Optimization', 'url': 'https://huggingface.co/papers/2502.13173', 'abstract': "Supervised Fine-Tuning (SFT) has been a go-to and effective method for enhancing long chain-of-thought (CoT) reasoning in relatively small LLMs by fine-tuning them with long CoT responses from larger LLMs. To continually improve reasoning abilities, we can either collect new high-quality long CoT reasoning SFT data or repeatedly train on existing SFT datasets. However, acquiring new long CoT SFT data is costly and limited, while repeated training often results in a performance plateau or decline. To further boost the performance with the SFT data, we propose Thinking Preference Optimization (ThinkPO), a simple yet effective post-SFT method that enhances long CoT reasoning without requiring new long CoT responses. Instead, ThinkPO utilizes readily available or easily obtainable short CoT reasoning responses as rejected answers and long CoT responses as chosen answers for the same question. It then applies direct preference optimization to encourage the model to favor longer reasoning outputs. Experiments show that ThinkPO further improves the reasoning performance of SFT-ed models, e.g. it increases math reasoning accuracy of SFT-ed models by 8.6% and output length by 25.9%. Notably, ThinkPO is capable of continually boosting the performance of the publicly distilled SFT model, e.g., increasing the official DeepSeek-R1-Distill-Qwen-7B's performance on MATH500 from 87.4% to 91.2%.", 'score': 3, 'issue_id': 2311, 'pub_date': '2025-02-17', 'pub_date_card': {'ru': '17 февраля', 'en': 'February 17', 'zh': '2月17日'}, 'hash': '6096d2396d4c584e', 'authors': ['Wang Yang', 'Hongye Jin', 'Jingfeng Yang', 'Vipin Chaudhary', 'Xiaotian Han'], 'affiliations': ['case.edu', 'gmail.com', 'tamu.edu'], 'pdf_title_img': 'assets/pdf/title_img/2502.13173.jpg', 'data': {'categories': ['#math', '#training', '#reasoning', '#long_context', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'Оптимизация предпочтений мышления: новый шаг в улучшении рассуждений ИИ', 'desc': 'Этот научный труд представляет новый метод под названием Thinking Preference Optimization (ThinkPO) для улучшения способностей моделей машинного обучения к длинным цепочкам рассуждений. ThinkPO использует короткие ответы с рассуждениями как отвергнутые и длинные ответы как предпочтительные для одного и того же вопроса. Метод применяет прямую оптимизацию предпочтений, чтобы поощрять модель выдавать более длинные рассуждения. Эксперименты показывают, что ThinkPO улучшает точность математических рассуждений моделей на 8.6% и увеличивает длину выходных данных на 25.9%.'}, 'en': {'title': 'Boosting Reasoning with Preference Optimization', 'desc': "This paper introduces Thinking Preference Optimization (ThinkPO), a method designed to enhance long chain-of-thought (CoT) reasoning in supervised fine-tuning (SFT) of language models. Instead of needing new long CoT data, ThinkPO leverages existing short CoT responses as negative examples and long CoT responses as positive examples to optimize the model's preferences. The approach leads to significant improvements in reasoning accuracy and output length, demonstrating its effectiveness in refining model performance. Experiments show that ThinkPO can consistently boost the capabilities of SFT-ed models, particularly in mathematical reasoning tasks."}, 'zh': {'title': '思维偏好优化：提升长链推理的有效方法', 'desc': '监督微调（SFT）是一种有效的方法，用于提升小型大语言模型（LLM）在长链推理（CoT）方面的能力。为了持续提高推理能力，通常需要收集新的高质量长CoT数据，但这成本高且有限。本文提出了一种名为思维偏好优化（ThinkPO）的后SFT方法，它利用短CoT推理作为拒绝答案，长CoT推理作为选择答案，通过直接偏好优化来增强模型对长推理输出的偏好。实验表明，ThinkPO显著提高了经过SFT训练模型的推理性能，尤其在数学推理准确率上提升了8.6%。'}}}, {'id': 'https://huggingface.co/papers/2502.12638', 'title': 'NExT-Mol: 3D Diffusion Meets 1D Language Modeling for 3D Molecule Generation', 'url': 'https://huggingface.co/papers/2502.12638', 'abstract': "3D molecule generation is crucial for drug discovery and material design. While prior efforts focus on 3D diffusion models for their benefits in modeling continuous 3D conformers, they overlook the advantages of 1D SELFIES-based Language Models (LMs), which can generate 100% valid molecules and leverage the billion-scale 1D molecule datasets. To combine these advantages for 3D molecule generation, we propose a foundation model -- NExT-Mol: 3D Diffusion Meets 1D Language Modeling for 3D Molecule Generation. NExT-Mol uses an extensively pretrained molecule LM for 1D molecule generation, and subsequently predicts the generated molecule's 3D conformers with a 3D diffusion model. We enhance NExT-Mol's performance by scaling up the LM's model size, refining the diffusion neural architecture, and applying 1D to 3D transfer learning. Notably, our 1D molecule LM significantly outperforms baselines in distributional similarity while ensuring validity, and our 3D diffusion model achieves leading performances in conformer prediction. Given these improvements in 1D and 3D modeling, NExT-Mol achieves a 26% relative improvement in 3D FCD for de novo 3D generation on GEOM-DRUGS, and a 13% average relative gain for conditional 3D generation on QM9-2014. Our codes and pretrained checkpoints are available at https://github.com/acharkq/NExT-Mol.", 'score': 3, 'issue_id': 2311, 'pub_date': '2025-02-18', 'pub_date_card': {'ru': '18 февраля', 'en': 'February 18', 'zh': '2月18日'}, 'hash': 'eb0d7b097262b590', 'authors': ['Zhiyuan Liu', 'Yanchen Luo', 'Han Huang', 'Enzhi Zhang', 'Sihang Li', 'Junfeng Fang', 'Yaorui Shi', 'Xiang Wang', 'Kenji Kawaguchi', 'Tat-Seng Chua'], 'affiliations': ['Chinese University of Hong Kong', 'Hokkaido University', 'National University of Singapore', 'University of Science and Technology of China'], 'pdf_title_img': 'assets/pdf/title_img/2502.12638.jpg', 'data': {'categories': ['#open_source', '#transfer_learning', '#architecture', '#diffusion', '#dataset', '#3d'], 'emoji': '🧪', 'ru': {'title': 'NExT-Mol: объединение языкового и диффузионного моделирования для генерации 3D-молекул', 'desc': 'NExT-Mol - это модель для генерации трехмерных молекул, сочетающая преимущества одномерных языковых моделей и трехмерных диффузионных моделей. Языковая модель используется для генерации валидных молекулярных структур в формате SELFIES, а диффузионная модель предсказывает их 3D-конформации. Авторы улучшили производительность, увеличив размер языковой модели, оптимизировав архитектуру диффузионной сети и применив трансферное обучение. NExT-Mol показала значительное улучшение результатов по сравнению с базовыми моделями в задачах de novo генерации и условной генерации 3D-молекул.'}, 'en': {'title': 'NExT-Mol: Bridging 1D Language Models and 3D Diffusion for Molecule Generation', 'desc': 'This paper presents NExT-Mol, a novel foundation model that integrates 1D SELFIES-based Language Models (LMs) with 3D diffusion models for generating 3D molecular structures. By leveraging the strengths of both approaches, NExT-Mol first generates valid 1D molecular representations and then predicts their corresponding 3D conformers. The model is enhanced through scaling the LM, refining the diffusion architecture, and employing transfer learning from 1D to 3D. The results show significant improvements in both 3D generation and conformer prediction, outperforming existing methods in terms of distributional similarity and validity.'}, 'zh': {'title': 'NExT-Mol：结合1D语言模型与3D扩散模型的分子生成新方法', 'desc': '3D分子生成对药物发现和材料设计至关重要。以往的研究主要集中在3D扩散模型上，但忽视了基于1D SELFIES的语言模型的优势，这些模型能够生成100%有效的分子并利用大规模的1D分子数据集。为此，我们提出了基础模型NExT-Mol，它结合了1D语言建模和3D扩散模型的优点，能够有效生成3D分子。通过扩大语言模型的规模、优化扩散神经网络架构以及应用1D到3D的迁移学习，NExT-Mol在3D生成和条件生成上都取得了显著的性能提升。'}}}, {'id': 'https://huggingface.co/papers/2502.11995', 'title': 'Presumed Cultural Identity: How Names Shape LLM Responses', 'url': 'https://huggingface.co/papers/2502.11995', 'abstract': 'Names are deeply tied to human identity. They can serve as markers of individuality, cultural heritage, and personal history. However, using names as a core indicator of identity can lead to over-simplification of complex identities. When interacting with LLMs, user names are an important point of information for personalisation. Names can enter chatbot conversations through direct user input (requested by chatbots), as part of task contexts such as CV reviews, or as built-in memory features that store user information for personalisation. We study biases associated with names by measuring cultural presumptions in the responses generated by LLMs when presented with common suggestion-seeking queries, which might involve making assumptions about the user. Our analyses demonstrate strong assumptions about cultural identity associated with names present in LLM generations across multiple cultures. Our work has implications for designing more nuanced personalisation systems that avoid reinforcing stereotypes while maintaining meaningful customisation.', 'score': 0, 'issue_id': 2313, 'pub_date': '2025-02-17', 'pub_date_card': {'ru': '17 февраля', 'en': 'February 17', 'zh': '2月17日'}, 'hash': '8bcbe61536105828', 'authors': ['Siddhesh Pawar', 'Arnav Arora', 'Lucie-Aimée Kaffee', 'Isabelle Augenstein'], 'affiliations': ['Hugging Face', 'University of Copenhagen, Denmark'], 'pdf_title_img': 'assets/pdf/title_img/2502.11995.jpg', 'data': {'categories': ['#multimodal', '#ethics', '#alignment', '#healthcare'], 'emoji': '👤', 'ru': {'title': 'Имена в ИИ: преодоление культурных стереотипов', 'desc': 'Статья исследует влияние имен на взаимодействие с языковыми моделями (LLM). Авторы изучают, как LLM делают предположения о культурной идентичности пользователей на основе их имен. Результаты показывают, что LLM демонстрируют сильные культурные предубеждения, связанные с именами. Исследование подчеркивает необходимость разработки более нюансированных систем персонализации, избегающих стереотипов.'}, 'en': {'title': 'Rethinking Personalization: Beyond Names and Stereotypes in LLMs', 'desc': "This paper explores how names influence identity and personalization in interactions with large language models (LLMs). It highlights that while names can provide valuable information for tailoring responses, they can also lead to oversimplified assumptions about a user's cultural background. The authors analyze biases in LLM outputs when names are used in suggestion-seeking queries, revealing strong cultural stereotypes linked to names. The findings suggest the need for more sophisticated personalization systems that respect individual identities without perpetuating stereotypes."}, 'zh': {'title': '名字与身份：个性化系统中的文化偏见', 'desc': '这篇论文探讨了名字与人类身份之间的深刻联系。名字不仅是个体性、文化遗产和个人历史的标志，还可能导致对复杂身份的过度简化。研究表明，在与大型语言模型（LLMs）互动时，名字会影响个性化的响应，可能引发文化偏见。我们的分析显示，LLMs在生成响应时对名字的文化身份有强烈的假设，这对设计更细致的个性化系统具有重要意义。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (2)', '#agents (3)', '#agi (1)', '#alignment (3)', '#architecture (4)', '#audio (1)', '#benchmark (3)', '#cv (1)', '#data (2)', '#dataset (3)', '#diffusion (1)', '#ethics (1)', '#games (1)', '#graphs (1)', '#hallucinations', '#healthcare (2)', '#inference (3)', '#interpretability (1)', '#leakage', '#long_context (3)', '#low_resource', '#machine_translation', '#math (2)', '#multilingual', '#multimodal (2)', '#open_source (4)', '#optimization (3)', '#plp (1)', '#rag (1)', '#reasoning (6)', '#rl (1)', '#rlhf (2)', '#robotics', '#science (1)', '#security (1)', '#small_models (1)', '#story_generation (1)', '#survey', '#synthetic (1)', '#training (6)', '#transfer_learning (4)', '#video'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-02-20 07:10',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-02-20 07:10')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-02-20 07:10')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    