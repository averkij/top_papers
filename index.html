
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 11 papers. December 26.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">26 декабря</span> | <span id="title-articles-count">11 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2024-12-25.html">⬅️ <span id="prev-date">25.12</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-12-27.html">➡️ <span id="next-date">27.12</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2024-12.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '26 декабря', 'en': 'December 26', 'zh': '12月26日'};
        let feedDateNext = {'ru': '27.12', 'en': '12/27', 'zh': '12月27日'};
        let feedDatePrev = {'ru': '25.12', 'en': '12/25', 'zh': '12月25日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2412.18450', 'title': '3DGraphLLM: Combining Semantic Graphs and Large Language Models for 3D Scene Understanding', 'url': 'https://huggingface.co/papers/2412.18450', 'abstract': 'A 3D scene graph represents a compact scene model, storing information about the objects and the semantic relationships between them, making its use promising for robotic tasks. When interacting with a user, an embodied intelligent agent should be capable of responding to various queries about the scene formulated in natural language. Large Language Models (LLMs) are beneficial solutions for user-robot interaction due to their natural language understanding and reasoning abilities. Recent methods for creating learnable representations of 3D scenes have demonstrated the potential to improve the quality of LLMs responses by adapting to the 3D world. However, the existing methods do not explicitly utilize information about the semantic relationships between objects, limiting themselves to information about their coordinates. In this work, we propose a method 3DGraphLLM for constructing a learnable representation of a 3D scene graph. The learnable representation is used as input for LLMs to perform 3D vision-language tasks. In our experiments on popular ScanRefer, RIORefer, Multi3DRefer, ScanQA, Sqa3D, and Scan2cap datasets, we demonstrate the advantage of this approach over baseline methods that do not use information about the semantic relationships between objects. The code is publicly available at https://github.com/CognitiveAISystems/3DGraphLLM.', 'score': 21, 'issue_id': 1311, 'pub_date': '2024-12-24', 'pub_date_card': {'ru': '24 декабря', 'en': 'December 24', 'zh': '12月24日'}, 'hash': '3d80e95d793a8b5e', 'authors': ['Tatiana Zemskova', 'Dmitry Yudin'], 'affiliations': ['Artificial Intelligence Research Institute', 'Moscow Institute of Physics and Technology'], 'pdf_title_img': 'assets/pdf/title_img/2412.18450.jpg', 'data': {'categories': ['#3d', '#multimodal', '#reasoning', '#open_source', '#agents', '#games', '#graphs'], 'emoji': '🤖', 'ru': {'title': '3D-графы сцен улучшают понимание пространства языковыми моделями', 'desc': 'Статья представляет метод 3DGraphLLM для создания обучаемого представления трехмерного графа сцены. Это представление используется в качестве входных данных для больших языковых моделей (LLM) для выполнения задач 3D-зрения и языка. Авторы демонстрируют преимущество этого подхода над базовыми методами, которые не используют информацию о семантических отношениях между объектами. Эксперименты проводились на популярных наборах данных, таких как ScanRefer, RIORefer и другие.'}, 'en': {'title': 'Enhancing Robot Understanding with 3D Scene Graphs and Language Models', 'desc': 'This paper introduces 3DGraphLLM, a method for creating a learnable representation of 3D scene graphs that captures both object information and their semantic relationships. By integrating this representation with Large Language Models (LLMs), the approach enhances user-robot interactions, allowing robots to better understand and respond to natural language queries about 3D scenes. The authors demonstrate that their method outperforms existing techniques that only consider object coordinates, highlighting the importance of semantic relationships in improving LLM responses. Experiments conducted on various datasets show the effectiveness of 3DGraphLLM in performing 3D vision-language tasks.'}, 'zh': {'title': '提升机器人交互的3D场景理解', 'desc': '这篇论文提出了一种名为3DGraphLLM的方法，用于构建3D场景图的可学习表示。该表示能够有效地捕捉对象之间的语义关系，从而提升大型语言模型（LLMs）在3D视觉-语言任务中的表现。通过在多个数据集上的实验，研究表明，利用语义关系的信息可以显著改善模型的响应质量。该方法为机器人与用户的自然语言交互提供了更强大的支持。'}}}, {'id': 'https://huggingface.co/papers/2412.18153', 'title': 'DepthLab: From Partial to Complete', 'url': 'https://huggingface.co/papers/2412.18153', 'abstract': 'Missing values remain a common challenge for depth data across its wide range of applications, stemming from various causes like incomplete data acquisition and perspective alteration. This work bridges this gap with DepthLab, a foundation depth inpainting model powered by image diffusion priors. Our model features two notable strengths: (1) it demonstrates resilience to depth-deficient regions, providing reliable completion for both continuous areas and isolated points, and (2) it faithfully preserves scale consistency with the conditioned known depth when filling in missing values. Drawing on these advantages, our approach proves its worth in various downstream tasks, including 3D scene inpainting, text-to-3D scene generation, sparse-view reconstruction with DUST3R, and LiDAR depth completion, exceeding current solutions in both numerical performance and visual quality. Our project page with source code is available at https://johanan528.github.io/depthlab_web/.', 'score': 21, 'issue_id': 1305, 'pub_date': '2024-12-24', 'pub_date_card': {'ru': '24 декабря', 'en': 'December 24', 'zh': '12月24日'}, 'hash': 'c319c831137b3ce6', 'authors': ['Zhiheng Liu', 'Ka Leong Cheng', 'Qiuyu Wang', 'Shuzhe Wang', 'Hao Ouyang', 'Bin Tan', 'Kai Zhu', 'Yujun Shen', 'Qifeng Chen', 'Ping Luo'], 'affiliations': ['Aalto University', 'Ant Group', 'HKU', 'HKUST', 'Tongyi Lab'], 'pdf_title_img': 'assets/pdf/title_img/2412.18153.jpg', 'data': {'categories': ['#diffusion', '#3d', '#open_source', '#dataset'], 'emoji': '🕳️', 'ru': {'title': 'DepthLab: Восполнение пробелов в данных глубины с помощью ИИ', 'desc': 'DepthLab - это модель для восстановления глубины изображения, основанная на диффузионных приорах. Она способна надежно заполнять как большие области, так и отдельные точки с отсутствующими данными глубины. Модель сохраняет согласованность масштаба с известной глубиной при заполнении пропусков. DepthLab превосходит существующие решения в различных задачах, включая инпейнтинг 3D-сцен и дополнение данных LiDAR.'}, 'en': {'title': 'DepthLab: Bridging the Gap in Depth Data Completion', 'desc': 'This paper presents DepthLab, a novel model designed to address the issue of missing values in depth data, which often occurs due to incomplete data collection or changes in perspective. DepthLab utilizes image diffusion priors to effectively inpaint depth information, ensuring that both continuous and isolated missing regions are filled accurately. The model maintains scale consistency with known depth values, which is crucial for realistic depth completion. DepthLab outperforms existing methods in various applications, such as 3D scene inpainting and LiDAR depth completion, demonstrating superior numerical and visual results.'}, 'zh': {'title': '深度修复新突破：DepthLab模型', 'desc': '本论文提出了一种名为DepthLab的深度图像修复模型，旨在解决深度数据中的缺失值问题。该模型利用图像扩散先验，能够有效填补深度不足的区域，确保连续区域和孤立点的可靠修复。DepthLab在填补缺失值时，能够保持与已知深度的一致性，确保尺度的准确性。通过这些优势，该模型在3D场景修复、文本到3D场景生成、稀疏视图重建和LiDAR深度补全等任务中表现优异，超越了现有的解决方案。'}}}, {'id': 'https://huggingface.co/papers/2412.17739', 'title': "Fourier Position Embedding: Enhancing Attention's Periodic Extension for Length Generalization", 'url': 'https://huggingface.co/papers/2412.17739', 'abstract': "Extending the context length of Language Models (LMs) by improving Rotary Position Embedding (RoPE) has become a trend. While existing works mainly address RoPE's limitations within attention mechanism, this paper provides an analysis across nearly all parts of LMs, uncovering their adverse effects on length generalization for RoPE-based attention. Using Discrete Signal Processing theory, we show that RoPE enables periodic attention by implicitly achieving Non-Uniform Discrete Fourier Transform. However, this periodicity is undermined by the spectral damage caused by: 1) linear layers and activation functions outside of attention; 2) insufficiently trained frequency components brought by time-domain truncation. Building on our observations, we propose Fourier Position Embedding (FoPE), which enhances attention's frequency-domain properties to improve both its periodic extension and length generalization. FoPE constructs Fourier Series and zero-outs the destructive frequency components, increasing model robustness against the spectrum damage. Experiments across various model scales show that, within varying context windows, FoPE can maintain a more stable perplexity and a more consistent accuracy in a needle-in-haystack task compared to RoPE and ALiBi. Several analyses and ablations bring further support to our method and theoretical modeling.", 'score': 17, 'issue_id': 1306, 'pub_date': '2024-12-23', 'pub_date_card': {'ru': '23 декабря', 'en': 'December 23', 'zh': '12月23日'}, 'hash': '1ce9c827a32ec3c5', 'authors': ['Ermo Hua', 'Che Jiang', 'Xingtai Lv', 'Kaiyan Zhang', 'Ning Ding', 'Youbang Sun', 'Biqing Qi', 'Yuchen Fan', 'Xue Kai Zhu', 'Bowen Zhou'], 'affiliations': ['Northeastern University', 'Shanghai AI Laboratory', 'Shanghai Jiaotong University', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2412.17739.jpg', 'data': {'categories': ['#training', '#optimization', '#long_context', '#architecture'], 'emoji': '🌊', 'ru': {'title': 'Улучшение обработки длинных последовательностей с помощью преобразования Фурье', 'desc': 'Эта статья представляет новый метод позиционного кодирования для языковых моделей - Fourier Position Embedding (FoPE). FoPE улучшает частотные свойства механизма внимания, что позволяет более эффективно обрабатывать длинные последовательности. Авторы анализируют ограничения существующего метода Rotary Position Embedding (RoPE) с точки зрения теории обработки дискретных сигналов. Предложенный метод FoPE конструирует ряды Фурье и обнуляет деструктивные частотные компоненты, повышая устойчивость модели к искажениям спектра. Эксперименты показывают, что FoPE обеспечивает более стабильную перплексию и точность на различных длинах контекста по сравнению с RoPE и ALiBi.'}, 'en': {'title': 'Enhancing Language Models with Fourier Position Embedding for Better Context Handling', 'desc': 'This paper explores the limitations of Rotary Position Embedding (RoPE) in Language Models (LMs) and its impact on length generalization. It reveals that while RoPE allows for periodic attention through Non-Uniform Discrete Fourier Transform, this capability is compromised by linear layers and insufficient training of frequency components. The authors introduce Fourier Position Embedding (FoPE), which improves the frequency-domain characteristics of attention by eliminating harmful frequency components. Experimental results demonstrate that FoPE outperforms RoPE and ALiBi in maintaining stability in perplexity and accuracy across different context lengths.'}, 'zh': {'title': '提升语言模型的上下文长度与泛化能力', 'desc': '本论文探讨了通过改进旋转位置嵌入（RoPE）来扩展语言模型（LM）的上下文长度。我们分析了RoPE在注意力机制之外的各个部分的影响，发现其对长度泛化的负面效应。基于离散信号处理理论，我们提出了傅里叶位置嵌入（FoPE），它通过构建傅里叶级数来增强注意力的频域特性，从而提高模型的鲁棒性。实验结果表明，FoPE在不同上下文窗口下能够保持更稳定的困惑度和一致的准确性。'}}}, {'id': 'https://huggingface.co/papers/2412.18597', 'title': 'DiTCtrl: Exploring Attention Control in Multi-Modal Diffusion Transformer for Tuning-Free Multi-Prompt Longer Video Generation', 'url': 'https://huggingface.co/papers/2412.18597', 'abstract': "Sora-like video generation models have achieved remarkable progress with a Multi-Modal Diffusion Transformer MM-DiT architecture. However, the current video generation models predominantly focus on single-prompt, struggling to generate coherent scenes with multiple sequential prompts that better reflect real-world dynamic scenarios. While some pioneering works have explored multi-prompt video generation, they face significant challenges including strict training data requirements, weak prompt following, and unnatural transitions. To address these problems, we propose DiTCtrl, a training-free multi-prompt video generation method under MM-DiT architectures for the first time. Our key idea is to take the multi-prompt video generation task as temporal video editing with smooth transitions. To achieve this goal, we first analyze MM-DiT's attention mechanism, finding that the 3D full attention behaves similarly to that of the cross/self-attention blocks in the UNet-like diffusion models, enabling mask-guided precise semantic control across different prompts with attention sharing for multi-prompt video generation. Based on our careful design, the video generated by DiTCtrl achieves smooth transitions and consistent object motion given multiple sequential prompts without additional training. Besides, we also present MPVBench, a new benchmark specially designed for multi-prompt video generation to evaluate the performance of multi-prompt generation. Extensive experiments demonstrate that our method achieves state-of-the-art performance without additional training.", 'score': 10, 'issue_id': 1307, 'pub_date': '2024-12-24', 'pub_date_card': {'ru': '24 декабря', 'en': 'December 24', 'zh': '12月24日'}, 'hash': '210ce3ba0e7e45d2', 'authors': ['Minghong Cai', 'Xiaodong Cun', 'Xiaoyu Li', 'Wenze Liu', 'Zhaoyang Zhang', 'Yong Zhang', 'Ying Shan', 'Xiangyu Yue'], 'affiliations': ['ARC Lab, Tencent PCG', 'GVC Lab, Great Bay University', 'MMLab, The Chinese University of Hong Kong', 'Tencent AI Lab'], 'pdf_title_img': 'assets/pdf/title_img/2412.18597.jpg', 'data': {'categories': ['#video', '#multimodal', '#games', '#diffusion', '#benchmark'], 'emoji': '🎬', 'ru': {'title': 'Плавная генерация видео по нескольким запросам без переобучения', 'desc': 'Статья представляет новый метод DiTCtrl для генерации видео по нескольким последовательным текстовым запросам без дополнительного обучения. Авторы анализируют механизм внимания в архитектуре Multi-Modal Diffusion Transformer (MM-DiT) и используют его для точного семантического контроля при переходе между разными запросами. Метод позволяет создавать видео с плавными переходами и согласованным движением объектов. Также предлагается новый бенчмарк MPVBench для оценки качества генерации видео по нескольким запросам.'}, 'en': {'title': 'Revolutionizing Video Generation with Multi-Prompt Control', 'desc': 'This paper introduces DiTCtrl, a novel method for generating videos using multiple prompts without the need for additional training. It leverages the Multi-Modal Diffusion Transformer (MM-DiT) architecture to facilitate smooth transitions and coherent object motion across sequential prompts. By analyzing the attention mechanism of MM-DiT, the authors enable precise semantic control, allowing for effective multi-prompt video generation. The proposed method outperforms existing techniques and is evaluated using a new benchmark called MPVBench, specifically designed for this purpose.'}, 'zh': {'title': '无训练的多提示视频生成新方法', 'desc': '本论文提出了一种新的多提示视频生成方法DiTCtrl，旨在解决现有模型在处理多个顺序提示时的困难。我们利用MM-DiT架构，通过分析其注意力机制，实现了在多提示视频生成中平滑过渡和一致的物体运动。DiTCtrl不需要额外的训练，能够在多个提示下生成自然流畅的视频。我们还引入了MPVBench基准，以评估多提示生成的性能，实验结果表明该方法在无额外训练的情况下达到了最先进的性能。'}}}, {'id': 'https://huggingface.co/papers/2412.17758', 'title': "In Case You Missed It: ARC 'Challenge' Is Not That Challenging", 'url': 'https://huggingface.co/papers/2412.17758', 'abstract': 'ARC Challenge appears more difficult than ARC Easy for modern LLMs primarily due to an evaluation setup that prevents direct comparison of answer choices rather than inherent complexity. Although some researchers have quietly shifted to a more appropriate scheme over the last year, the implications of this change have yet to be widely acknowledged. We highlight this overlooked shift, show how similar evaluation practices falsely imply reasoning deficits in other benchmarks, and demonstrate that fairer methods dramatically reduce performance gaps (e.g. on SIQA) and even yield superhuman results (OpenBookQA). In doing so, we reveal how evaluation shapes perceived difficulty and offer guidelines to ensure that multiple-choice evaluations accurately reflect actual model capabilities.', 'score': 7, 'issue_id': 1311, 'pub_date': '2024-12-23', 'pub_date_card': {'ru': '23 декабря', 'en': 'December 23', 'zh': '12月23日'}, 'hash': '38b823b470857f90', 'authors': ['Łukasz Borchmann'], 'affiliations': ['Snowflake AI Research'], 'pdf_title_img': 'assets/pdf/title_img/2412.17758.jpg', 'data': {'categories': ['#training', '#reasoning', '#interpretability', '#benchmark'], 'emoji': '🔍', 'ru': {'title': 'Переосмысление сложности AI-тестов: роль методики оценки', 'desc': 'Статья анализирует причины кажущейся сложности теста ARC Challenge для современных моделей машинного обучения. Авторы утверждают, что основная проблема заключается в методике оценки, а не в сложности самих задач. Они демонстрируют, как более справедливые методы оценки значительно сокращают разрыв в производительности между моделями и людьми на различных бенчмарках. Исследование подчеркивает важность правильного выбора методов оценки для точного отражения реальных возможностей языковых моделей.'}, 'en': {'title': 'Reevaluating Evaluation: Uncovering True Model Capabilities', 'desc': 'The paper discusses the challenges faced by modern language models (LLMs) when evaluating their performance on the ARC Challenge compared to ARC Easy. It argues that the evaluation setup, which does not allow for direct comparison of answer choices, is the main reason for the perceived difficulty, rather than the tasks themselves being inherently harder. The authors highlight a recent shift in evaluation practices that has not been widely recognized, showing that adopting fairer methods can significantly improve performance metrics. They emphasize the importance of accurate evaluation methods to truly reflect the capabilities of models and avoid misleading conclusions about their reasoning abilities.'}, 'zh': {'title': '评估方法影响模型表现的认知', 'desc': 'ARC挑战对现代大语言模型（LLM）来说似乎比ARC简单更困难，主要是因为评估设置阻止了对答案选择的直接比较，而不是固有的复杂性。尽管一些研究人员在过去一年中悄然转向更合适的评估方案，但这一变化的影响尚未被广泛认可。我们强调了这一被忽视的转变，展示了类似的评估实践如何错误地暗示其他基准中的推理缺陷，并证明更公平的方法显著减少了性能差距（例如在SIQA上），甚至产生超人类的结果（OpenBookQA）。通过这样做，我们揭示了评估如何影响感知的难度，并提供了确保多项选择评估准确反映模型实际能力的指导方针。'}}}, {'id': 'https://huggingface.co/papers/2412.14711', 'title': 'ReMoE: Fully Differentiable Mixture-of-Experts with ReLU Routing', 'url': 'https://huggingface.co/papers/2412.14711', 'abstract': "Sparsely activated Mixture-of-Experts (MoE) models are widely adopted to scale up model capacity without increasing the computation budget. However, vanilla TopK routers are trained in a discontinuous, non-differentiable way, limiting their performance and scalability. To address this issue, we propose ReMoE, a fully differentiable MoE architecture that offers a simple yet effective drop-in replacement for the conventional TopK+Softmax routing, utilizing ReLU as the router instead. We further propose methods to regulate the router's sparsity while balancing the load among experts. ReMoE's continuous nature enables efficient dynamic allocation of computation across tokens and layers, while also exhibiting domain specialization. Our experiments demonstrate that ReMoE consistently outperforms vanilla TopK-routed MoE across various model sizes, expert counts, and levels of granularity. Furthermore, ReMoE exhibits superior scalability with respect to the number of experts, surpassing traditional MoE architectures. The implementation based on Megatron-LM is available at https://github.com/thu-ml/ReMoE.", 'score': 7, 'issue_id': 1305, 'pub_date': '2024-12-19', 'pub_date_card': {'ru': '19 декабря', 'en': 'December 19', 'zh': '12月19日'}, 'hash': '0b43c3f140601a96', 'authors': ['Ziteng Wang', 'Jianfei Chen', 'Jun Zhu'], 'affiliations': ['Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2412.14711.jpg', 'data': {'categories': ['#training', '#architecture', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'ReMoE: Дифференцируемая архитектура для эффективных моделей Mixture-of-Experts', 'desc': 'Статья представляет новую архитектуру ReMoE для моделей Mixture-of-Experts (MoE). ReMoE использует полностью дифференцируемый маршрутизатор на основе ReLU вместо традиционного TopK+Softmax. Это позволяет эффективно распределять вычисления между токенами и слоями, а также обеспечивает специализацию по доменам. Эксперименты показывают, что ReMoE превосходит обычные MoE по производительности и масштабируемости при различных размерах моделей и количестве экспертов.'}, 'en': {'title': 'ReMoE: Revolutionizing Mixture-of-Experts with Differentiable Routing', 'desc': 'This paper introduces ReMoE, a new architecture for Mixture-of-Experts (MoE) models that improves upon traditional TopK routers by making them fully differentiable. By using ReLU as the routing mechanism, ReMoE allows for continuous optimization, which enhances performance and scalability. The authors also present techniques to manage the sparsity of the router and ensure an even distribution of workload among experts. Experimental results show that ReMoE outperforms conventional MoE models in various scenarios, demonstrating better scalability with an increasing number of experts.'}, 'zh': {'title': 'ReMoE：提升混合专家模型的性能与可扩展性', 'desc': '本文提出了一种新的稀疏激活混合专家模型ReMoE，旨在提高模型的性能和可扩展性。与传统的TopK路由器不同，ReMoE采用了完全可微分的架构，使用ReLU作为路由器，从而克服了非连续性带来的限制。我们还提出了调节路由器稀疏性的方法，以平衡专家之间的负载。实验结果表明，ReMoE在不同模型规模和专家数量下，均优于传统的TopK路由混合专家模型。'}}}, {'id': 'https://huggingface.co/papers/2412.15443', 'title': 'SKETCH: Structured Knowledge Enhanced Text Comprehension for Holistic Retrieval', 'url': 'https://huggingface.co/papers/2412.15443', 'abstract': "Retrieval-Augmented Generation (RAG) systems have become pivotal in leveraging vast corpora to generate informed and contextually relevant responses, notably reducing hallucinations in Large Language Models. Despite significant advancements, these systems struggle to efficiently process and retrieve information from large datasets while maintaining a comprehensive understanding of the context. This paper introduces SKETCH, a novel methodology that enhances the RAG retrieval process by integrating semantic text retrieval with knowledge graphs, thereby merging structured and unstructured data for a more holistic comprehension. SKETCH, demonstrates substantial improvements in retrieval performance and maintains superior context integrity compared to traditional methods. Evaluated across four diverse datasets: QuALITY, QASPER, NarrativeQA, and Italian Cuisine-SKETCH consistently outperforms baseline approaches on key RAGAS metrics such as answer_relevancy, faithfulness, context_precision and context_recall. Notably, on the Italian Cuisine dataset, SKETCH achieved an answer relevancy of 0.94 and a context precision of 0.99, representing the highest performance across all evaluated metrics. These results highlight SKETCH's capability in delivering more accurate and contextually relevant responses, setting new benchmarks for future retrieval systems.", 'score': 6, 'issue_id': 1305, 'pub_date': '2024-12-19', 'pub_date_card': {'ru': '19 декабря', 'en': 'December 19', 'zh': '12月19日'}, 'hash': '2d16e57527037cb7', 'authors': ['Aakash Mahalingam', 'Vinesh Kumar Gande', 'Aman Chadha', 'Vinija Jain', 'Divya Chaudhary'], 'affiliations': ['Amazon AI', 'Meta', 'Northeastern University', 'Stanford University'], 'pdf_title_img': 'assets/pdf/title_img/2412.15443.jpg', 'data': {'categories': ['#graphs', '#dataset', '#hallucinations', '#benchmark', '#rag', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'SKETCH: Революция в извлечении информации для генеративных моделей', 'desc': 'Данная статья представляет новый метод SKETCH, улучшающий процесс извлечения информации в системах генерации с аугментацией извлечения (RAG). SKETCH объединяет семантический поиск текста с графами знаний, интегрируя структурированные и неструктурированные данные для более целостного понимания контекста. Метод показывает значительные улучшения в производительности извлечения и сохранении целостности контекста по сравнению с традиционными подходами. SKETCH превосходит базовые методы по ключевым метрикам RAGAS на четырех различных наборах данных, демонстрируя высокую точность и контекстуальную релевантность ответов.'}, 'en': {'title': 'SKETCH: Elevating RAG with Semantic and Structured Data Integration', 'desc': 'This paper presents SKETCH, a new method that improves Retrieval-Augmented Generation (RAG) systems by combining semantic text retrieval with knowledge graphs. This integration allows for better processing of large datasets while ensuring a deeper understanding of context. SKETCH shows significant enhancements in retrieval performance and context integrity compared to traditional RAG methods. The results from various datasets demonstrate that SKETCH achieves high scores in answer relevancy and context precision, establishing new standards for retrieval systems.'}, 'zh': {'title': 'SKETCH：提升检索增强生成系统的新方法', 'desc': '本论文介绍了一种名为SKETCH的新方法，旨在提升检索增强生成（RAG）系统的性能。SKETCH通过将语义文本检索与知识图谱相结合，能够更有效地处理和检索大数据集中的信息，同时保持对上下文的全面理解。研究表明，SKETCH在多个数据集上表现优异，尤其是在意大利美食数据集上，达到了0.94的答案相关性和0.99的上下文精度。这些结果表明，SKETCH能够提供更准确和上下文相关的响应，为未来的检索系统设定了新的基准。'}}}, {'id': 'https://huggingface.co/papers/2412.18608', 'title': 'PartGen: Part-level 3D Generation and Reconstruction with Multi-View Diffusion Models', 'url': 'https://huggingface.co/papers/2412.18608', 'abstract': 'Text- or image-to-3D generators and 3D scanners can now produce 3D assets with high-quality shapes and textures. These assets typically consist of a single, fused representation, like an implicit neural field, a Gaussian mixture, or a mesh, without any useful structure. However, most applications and creative workflows require assets to be made of several meaningful parts that can be manipulated independently. To address this gap, we introduce PartGen, a novel approach that generates 3D objects composed of meaningful parts starting from text, an image, or an unstructured 3D object. First, given multiple views of a 3D object, generated or rendered, a multi-view diffusion model extracts a set of plausible and view-consistent part segmentations, dividing the object into parts. Then, a second multi-view diffusion model takes each part separately, fills in the occlusions, and uses those completed views for 3D reconstruction by feeding them to a 3D reconstruction network. This completion process considers the context of the entire object to ensure that the parts integrate cohesively. The generative completion model can make up for the information missing due to occlusions; in extreme cases, it can hallucinate entirely invisible parts based on the input 3D asset. We evaluate our method on generated and real 3D assets and show that it outperforms segmentation and part-extraction baselines by a large margin. We also showcase downstream applications such as 3D part editing.', 'score': 5, 'issue_id': 1308, 'pub_date': '2024-12-24', 'pub_date_card': {'ru': '24 декабря', 'en': 'December 24', 'zh': '12月24日'}, 'hash': '7f6d99dea7ea25bc', 'authors': ['Minghao Chen', 'Roman Shapovalov', 'Iro Laina', 'Tom Monnier', 'Jianyuan Wang', 'David Novotny', 'Andrea Vedaldi'], 'affiliations': ['Meta AI', 'Visual Geometry Group, University of Oxford'], 'pdf_title_img': 'assets/pdf/title_img/2412.18608.jpg', 'data': {'categories': ['#3d', '#hallucinations', '#diffusion'], 'emoji': '🧩', 'ru': {'title': 'PartGen: Генерация структурированных 3D-объектов из неструктурированных данных', 'desc': 'PartGen - это новый подход к генерации 3D-объектов, состоящих из значимых частей, на основе текста, изображения или неструктурированного 3D-объекта. Метод использует мультивидовую диффузионную модель для сегментации объекта на части, а затем применяет вторую модель для заполнения окклюзий и реконструкции 3D-формы каждой части. PartGen может даже воссоздавать полностью невидимые части объекта на основе контекста. Авторы демонстрируют превосходство метода над базовыми подходами к сегментации и извлечению частей, а также показывают его применимость для редактирования 3D-частей.'}, 'en': {'title': 'PartGen: Transforming 3D Generation with Meaningful Parts', 'desc': 'This paper presents PartGen, a new method for generating 3D objects that are composed of meaningful, manipulable parts from various inputs like text, images, or unstructured 3D objects. It utilizes a multi-view diffusion model to segment the 3D object into plausible parts based on multiple views, ensuring consistency across different perspectives. A second diffusion model then reconstructs each part by filling in occlusions and integrating them into a cohesive whole, even generating parts that are not visible in the input. The results demonstrate that PartGen significantly outperforms existing methods for segmentation and part extraction, enabling advanced applications like 3D part editing.'}, 'zh': {'title': 'PartGen：生成可操作的3D物体部分', 'desc': '本文介绍了一种名为PartGen的新方法，旨在从文本、图像或非结构化3D对象生成由有意义部分组成的3D物体。该方法首先利用多视角扩散模型提取3D对象的部分分割，将对象划分为多个可独立操作的部分。接着，第二个多视角扩散模型对每个部分进行填充和3D重建，确保各部分在整体上下文中和谐融合。实验结果表明，PartGen在生成和真实3D资产上均显著优于现有的分割和部分提取方法。'}}}, {'id': 'https://huggingface.co/papers/2412.17847', 'title': 'Bridging the Data Provenance Gap Across Text, Speech and Video', 'url': 'https://huggingface.co/papers/2412.17847', 'abstract': 'Progress in AI is driven largely by the scale and quality of training data. Despite this, there is a deficit of empirical analysis examining the attributes of well-established datasets beyond text. In this work we conduct the largest and first-of-its-kind longitudinal audit across modalities--popular text, speech, and video datasets--from their detailed sourcing trends and use restrictions to their geographical and linguistic representation. Our manual analysis covers nearly 4000 public datasets between 1990-2024, spanning 608 languages, 798 sources, 659 organizations, and 67 countries. We find that multimodal machine learning applications have overwhelmingly turned to web-crawled, synthetic, and social media platforms, such as YouTube, for their training sets, eclipsing all other sources since 2019. Secondly, tracing the chain of dataset derivations we find that while less than 33% of datasets are restrictively licensed, over 80% of the source content in widely-used text, speech, and video datasets, carry non-commercial restrictions. Finally, counter to the rising number of languages and geographies represented in public AI training datasets, our audit demonstrates measures of relative geographical and multilingual representation have failed to significantly improve their coverage since 2013. We believe the breadth of our audit enables us to empirically examine trends in data sourcing, restrictions, and Western-centricity at an ecosystem-level, and that visibility into these questions are essential to progress in responsible AI. As a contribution to ongoing improvements in dataset transparency and responsible use, we release our entire multimodal audit, allowing practitioners to trace data provenance across text, speech, and video.', 'score': 2, 'issue_id': 1322, 'pub_date': '2024-12-19', 'pub_date_card': {'ru': '19 декабря', 'en': 'December 19', 'zh': '12月19日'}, 'hash': 'a67cb86f2c58f7e0', 'authors': ['Shayne Longpre', 'Nikhil Singh', 'Manuel Cherep', 'Kushagra Tiwary', 'Joanna Materzynska', 'William Brannon', 'Robert Mahari', 'Manan Dey', 'Mohammed Hamdy', 'Nayan Saxena', 'Ahmad Mustafa Anis', 'Emad A. Alghamdi', 'Vu Minh Chien', 'Naana Obeng-Marnu', 'Da Yin', 'Kun Qian', 'Yizhi Li', 'Minnie Liang', 'An Dinh', 'Shrestha Mohanty', 'Deividas Mataciunas', 'Tobin South', 'Jianguo Zhang', 'Ariel N. Lee', 'Campbell S. Lund', 'Christopher Klamm', 'Damien Sileo', 'Diganta Misra', 'Enrico Shippole', 'Kevin Klyman', 'Lester JV Miranda', 'Niklas Muennighoff', 'Seonghyeon Ye', 'Seungone Kim', 'Vipul Gupta', 'Vivek Sharma', 'Xuhui Zhou', 'Caiming Xiong', 'Luis Villa', 'Stella Biderman', 'Alex Pentland', 'Sara Hooker', 'Jad Kabbara'], 'affiliations': ['The Data Provenance Initiative'], 'pdf_title_img': 'assets/pdf/title_img/2412.17847.jpg', 'data': {'categories': ['#multimodal', '#data', '#ethics', '#dataset', '#synthetic', '#low_resource'], 'emoji': '🌐', 'ru': {'title': 'Большой аудит датасетов: тренды и проблемы в обучении мультимодальных ИИ-моделей', 'desc': 'Статья представляет собой масштабный аудит наборов данных для машинного обучения в различных модальностях: текст, речь и видео. Авторы проанализировали около 4000 публичных датасетов с 1990 по 2024 год, охватывающих 608 языков и 67 стран. Исследование выявило тенденцию к использованию данных из веб-краулинга, синтетических данных и социальных медиа, особенно YouTube, для обучения мультимодальных моделей. Также отмечается, что несмотря на рост представленности различных языков и географий в датасетах, относительное разнообразие не улучшилось значительно с 2013 года.'}, 'en': {'title': 'Unveiling the Landscape of AI Training Datasets', 'desc': 'This paper presents a comprehensive analysis of nearly 4000 public datasets used in machine learning, focusing on text, speech, and video modalities. The study reveals that since 2019, most datasets have been sourced from web-crawled content, synthetic data, and social media, particularly YouTube. It also highlights that while the number of languages and regions represented in datasets has increased, the actual geographical and multilingual coverage has not improved significantly since 2013. The authors emphasize the importance of dataset transparency and responsible AI practices, providing their findings to help practitioners understand data sourcing and restrictions better.'}, 'zh': {'title': '数据透明度与负责任的AI进步', 'desc': '这篇论文分析了人工智能训练数据集的属性，特别是文本、语音和视频数据集。研究发现，自2019年以来，多模态机器学习应用主要依赖于网络爬虫、合成数据和社交媒体平台（如YouTube）作为训练集来源。尽管公共AI训练数据集中语言和地理覆盖面有所增加，但相对的地理和多语言代表性并没有显著改善。论文的审计结果为数据来源、使用限制和西方中心主义提供了实证分析，强调了数据透明度和负责任使用的重要性。'}}}, {'id': 'https://huggingface.co/papers/2412.16153', 'title': 'MotiF: Making Text Count in Image Animation with Motion Focal Loss', 'url': 'https://huggingface.co/papers/2412.16153', 'abstract': "Text-Image-to-Video (TI2V) generation aims to generate a video from an image following a text description, which is also referred to as text-guided image animation. Most existing methods struggle to generate videos that align well with the text prompts, particularly when motion is specified. To overcome this limitation, we introduce MotiF, a simple yet effective approach that directs the model's learning to the regions with more motion, thereby improving the text alignment and motion generation. We use optical flow to generate a motion heatmap and weight the loss according to the intensity of the motion. This modified objective leads to noticeable improvements and complements existing methods that utilize motion priors as model inputs. Additionally, due to the lack of a diverse benchmark for evaluating TI2V generation, we propose TI2V Bench, a dataset consists of 320 image-text pairs for robust evaluation. We present a human evaluation protocol that asks the annotators to select an overall preference between two videos followed by their justifications. Through a comprehensive evaluation on TI2V Bench, MotiF outperforms nine open-sourced models, achieving an average preference of 72%. The TI2V Bench is released in https://wang-sj16.github.io/motif/.", 'score': 2, 'issue_id': 1319, 'pub_date': '2024-12-20', 'pub_date_card': {'ru': '20 декабря', 'en': 'December 20', 'zh': '12月20日'}, 'hash': '48c7cc6d9e1fa27b', 'authors': ['Shijie Wang', 'Samaneh Azadi', 'Rohit Girdhar', 'Saketh Rambhatla', 'Chen Sun', 'Xi Yin'], 'affiliations': ['Brown University', 'GenAI, Meta'], 'pdf_title_img': 'assets/pdf/title_img/2412.16153.jpg', 'data': {'categories': ['#video', '#dataset', '#open_source', '#optimization', '#games', '#multimodal', '#benchmark'], 'emoji': '🎬', 'ru': {'title': 'MotiF: улучшение генерации видео с помощью анализа движения', 'desc': 'Статья представляет новый подход MotiF для генерации видео из изображения по текстовому описанию. Метод использует оптический поток для создания карты интенсивности движения и взвешивания функции потерь. Это улучшает соответствие генерируемого видео текстовому запросу и качество анимации. Авторы также предлагают новый набор данных TI2V Bench для оценки таких моделей, содержащий 320 пар изображение-текст.'}, 'en': {'title': 'MotiF: Enhancing Video Generation with Motion Awareness', 'desc': "The paper presents MotiF, a novel approach for generating videos from images based on text descriptions, addressing the challenge of aligning generated videos with specified motions. By utilizing optical flow to create a motion heatmap, MotiF enhances the model's focus on areas with significant motion, leading to better text alignment and motion generation. The authors also introduce TI2V Bench, a new dataset with 320 image-text pairs designed for evaluating text-image-to-video generation methods. Comprehensive evaluations show that MotiF significantly outperforms existing models, achieving a 72% preference rate in human assessments."}, 'zh': {'title': 'MotiF：提升文本引导视频生成的运动对齐', 'desc': '本文介绍了一种新的文本引导图像动画方法，称为MotiF，旨在从图像生成符合文本描述的视频。现有方法在生成与文本提示一致的视频时，尤其是在运动指定方面存在困难。MotiF通过关注运动区域来改善文本对齐和运动生成，使用光流生成运动热图并根据运动强度加权损失。我们还提出了TI2V Bench数据集，以便对TI2V生成进行更全面的评估，并展示了MotiF在多个模型中的优越性能。'}}}, {'id': 'https://huggingface.co/papers/2412.15797', 'title': 'Ensembling Large Language Models with Process Reward-Guided Tree Search for Better Complex Reasoning', 'url': 'https://huggingface.co/papers/2412.15797', 'abstract': 'Despite recent advances in large language models, open-source models often struggle to consistently perform well on complex reasoning tasks. Existing ensemble methods, whether applied at the token or output levels, fail to address these challenges. In response, we present Language model Ensemble with Monte Carlo Tree Search (LE-MCTS), a novel framework for process-level ensembling of language models. LE-MCTS formulates step-by-step reasoning with an ensemble of language models as a Markov decision process. In this framework, states represent intermediate reasoning paths, while actions consist of generating the next reasoning step using one of the language models selected from a predefined pool. Guided by a process-based reward model, LE-MCTS performs a tree search over the reasoning steps generated by different language models, identifying the most accurate reasoning chain. Experimental results on five mathematical reasoning benchmarks demonstrate that our approach outperforms both single language model decoding algorithms and language model ensemble methods. Notably, LE-MCTS improves performance by 3.6% and 4.3% on the MATH and MQA datasets, respectively, highlighting its effectiveness in solving complex reasoning problems.', 'score': 1, 'issue_id': 1315, 'pub_date': '2024-12-20', 'pub_date_card': {'ru': '20 декабря', 'en': 'December 20', 'zh': '12月20日'}, 'hash': 'ed8cd715177d35d0', 'authors': ['Sungjin Park', 'Xiao Liu', 'Yeyun Gong', 'Edward Choi'], 'affiliations': ['KAIST AI', 'Microsoft Research'], 'pdf_title_img': 'assets/pdf/title_img/2412.15797.jpg', 'data': {'categories': ['#benchmark', '#dataset', '#training', '#math', '#optimization', '#reasoning'], 'emoji': '🧠', 'ru': {'title': 'LE-MCTS: Ансамблирование языковых моделей на уровне процесса для улучшения сложных рассуждений', 'desc': 'Статья представляет новый метод под названием LE-MCTS для улучшения производительности языковых моделей в задачах сложного рассуждения. LE-MCTS формулирует пошаговое рассуждение с ансамблем языковых моделей как марковский процесс принятия решений. Метод использует поиск по дереву Монте-Карло для выбора наиболее точной цепочки рассуждений. Эксперименты на пяти эталонных наборах данных по математическим рассуждениям показали, что LE-MCTS превосходит как отдельные языковые модели, так и другие методы ансамблирования.'}, 'en': {'title': 'Enhancing Reasoning in Language Models with LE-MCTS', 'desc': 'This paper introduces a new method called Language model Ensemble with Monte Carlo Tree Search (LE-MCTS) to improve the reasoning abilities of open-source language models. LE-MCTS treats the reasoning process as a Markov decision process, where different states represent various reasoning paths and actions involve selecting a language model to generate the next step. By using a reward model to guide the search for the best reasoning chain, LE-MCTS effectively combines the strengths of multiple models. The results show that this approach significantly enhances performance on complex reasoning tasks compared to traditional methods.'}, 'zh': {'title': '通过LE-MCTS提升语言模型推理能力', 'desc': '尽管大型语言模型取得了进展，开源模型在复杂推理任务上仍然表现不佳。现有的集成方法无法有效解决这些挑战。我们提出了一种新的框架，称为语言模型集成与蒙特卡洛树搜索（LE-MCTS），用于语言模型的过程级集成。LE-MCTS将逐步推理建模为马尔可夫决策过程，通过树搜索识别最准确的推理链，从而显著提高了推理性能。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (3)', '#agents (1)', '#agi', '#alignment', '#architecture (2)', '#audio', '#benchmark (5)', '#cv', '#data (1)', '#dataset (5)', '#diffusion (3)', '#ethics (1)', '#games (3)', '#graphs (2)', '#hallucinations (2)', '#healthcare', '#inference', '#interpretability (1)', '#leakage', '#long_context (1)', '#low_resource (1)', '#machine_translation', '#math (1)', '#multilingual', '#multimodal (4)', '#open_source (3)', '#optimization (5)', '#plp', '#rag (1)', '#reasoning (3)', '#rl', '#rlhf', '#robotics', '#science', '#security', '#small_models', '#story_generation', '#survey', '#synthetic (1)', '#training (4)', '#transfer_learning', '#video (2)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-12-26 00:45',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2024-12-26 00:45')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2024-12-26 00:45')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    