
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 11 papers. October 9.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">9 октября</span> | <span id="title-articles-count">11 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-10-08.html">⬅️ <span id="prev-date">08.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-10-10.html">➡️ <span id="next-date">10.10</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-10.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'};
        let feedDateNext = {'ru': '10.10', 'en': '10/10', 'zh': '10月10日'};
        let feedDatePrev = {'ru': '08.10', 'en': '10/08', 'zh': '10月8日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2510.07315', 'title': 'Vibe Checker: Aligning Code Evaluation with Human Preference', 'url': 'https://huggingface.co/papers/2510.07315', 'abstract': "Vibe Checker evaluates LLMs by combining functional correctness and instruction following to better align with human coding preferences.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have catalyzed vibe coding, where users leverage LLMs to generate and iteratively refine code through natural language interactions until it passes their vibe check. Vibe check is tied to real-world human preference and goes beyond functionality: the solution should feel right, read cleanly, preserve intent, and remain correct. However, current code evaluation remains anchored to pass@k and captures only functional correctness, overlooking the non-functional instructions that users routinely apply. In this paper, we hypothesize that instruction following is the missing piece underlying vibe check that represents human preference in coding besides functional correctness. To quantify models' code instruction following capabilities with measurable signals, we present VeriCode, a taxonomy of 30 verifiable code instructions together with corresponding deterministic verifiers. We use the taxonomy to augment established evaluation suites, resulting in Vibe Checker, a testbed to assess both code instruction following and functional correctness. Upon evaluating 31 leading LLMs, we show that even the strongest models struggle to comply with multiple instructions and exhibit clear functional regression. Most importantly, a composite score of functional correctness and instruction following correlates the best with human preference, with the latter emerging as the primary differentiator on real-world programming tasks. Our work identifies core factors of the vibe check, providing a concrete path for benchmarking and developing models that better align with user preferences in coding.", 'score': 7, 'issue_id': 6321, 'pub_date': '2025-10-08', 'pub_date_card': {'ru': '8 октября', 'en': 'October 8', 'zh': '10月8日'}, 'hash': '664f235019a59971', 'pdf_title_img': 'assets/pdf/title_img/2510.07315.jpg', 'data': {'categories': ['#interpretability', '#alignment', '#training', '#benchmark', '#plp'], 'emoji': '✨', 'ru': {'title': 'Vibe Check: когда код должен не только работать, но и нравиться', 'desc': 'Исследователи представили Vibe Checker — новый подход к оценке LLM для генерации кода, который учитывает не только функциональную корректность, но и следование инструкциям. Они создали VeriCode — таксономию из 30 проверяемых инструкций для кода с автоматическими верификаторами, чтобы измерить способность моделей следовать требованиям пользователя. Тестирование 31 ведущей LLM показало, что даже лучшие модели испытывают трудности с выполнением множественных инструкций, причём именно следование инструкциям оказалось главным фактором, отличающим предпочтения пользователей. Работа показывает, что человеческие предпочтения в программировании определяются комбинацией корректности и того, насколько код «ощущается правильным» — читается чисто и сохраняет изначальный замысел.'}, 'en': {'title': 'Aligning AI with Human Coding Preferences', 'desc': 'This paper introduces Vibe Checker, a new method for evaluating Large Language Models (LLMs) that combines functional correctness with instruction following to align better with human coding preferences. It highlights the importance of not just passing functional tests but also ensuring that code feels right and meets user expectations. The authors present VeriCode, a taxonomy of 30 verifiable code instructions, to measure how well models follow these instructions. Their findings show that a composite score of functional correctness and instruction following is a better predictor of human preference in coding tasks, revealing that instruction following is crucial for improving LLM performance in real-world applications.'}, 'zh': {'title': 'Vibe Checker：更贴近人类编码偏好的评估方法', 'desc': '本文提出了一种名为Vibe Checker的评估方法，用于评估大型语言模型（LLMs）在代码生成中的表现。Vibe Checker结合了功能正确性和指令遵循，旨在更好地符合人类的编码偏好。我们引入了VeriCode，一个包含30个可验证代码指令的分类法，以量化模型的指令遵循能力。研究表明，功能正确性和指令遵循的综合得分与人类偏好高度相关，后者在实际编程任务中成为主要的区分因素。'}}}, {'id': 'https://huggingface.co/papers/2510.06917', 'title': 'SHANKS: Simultaneous Hearing and Thinking for Spoken Language Models', 'url': 'https://huggingface.co/papers/2510.06917', 'abstract': 'SHANKS, a general inference framework, enables spoken language models to generate unspoken reasoning while listening to user input, enhancing real-time interaction and task completion.  \t\t\t\t\tAI-generated summary \t\t\t\t Current large language models (LLMs) and spoken language models (SLMs) begin thinking and taking actions only after the user has finished their turn. This prevents the model from interacting during the user\'s turn and can lead to high response latency while it waits to think. Consequently, thinking after receiving the full input is not suitable for speech-to-speech interaction, where real-time, low-latency exchange is important. We address this by noting that humans naturally "think while listening." In this paper, we propose SHANKS, a general inference framework that enables SLMs to generate unspoken chain-of-thought reasoning while listening to the user input. SHANKS streams the input speech in fixed-duration chunks and, as soon as a chunk is received, generates unspoken reasoning based on all previous speech and reasoning, while the user continues speaking. SHANKS uses this unspoken reasoning to decide whether to interrupt the user and to make tool calls to complete the task. We demonstrate that SHANKS enhances real-time user-SLM interaction in two scenarios: (1) when the user is presenting a step-by-step solution to a math problem, SHANKS can listen, reason, and interrupt when the user makes a mistake, achieving 37.1% higher interruption accuracy than a baseline that interrupts without thinking; and (2) in a tool-augmented dialogue, SHANKS can complete 56.9% of the tool calls before the user finishes their turn. Overall, SHANKS moves toward models that keep thinking throughout the conversation, not only after a turn ends. Animated illustrations of Shanks can be found at https://d223302.github.io/SHANKS/', 'score': 7, 'issue_id': 6321, 'pub_date': '2025-10-08', 'pub_date_card': {'ru': '8 октября', 'en': 'October 8', 'zh': '10月8日'}, 'hash': '8587217f59423924', 'authors': ['Cheng-Han Chiang', 'Xiaofei Wang', 'Linjie Li', 'Chung-Ching Lin', 'Kevin Lin', 'Shujie Liu', 'Zhendong Wang', 'Zhengyuan Yang', 'Hung-yi Lee', 'Lijuan Wang'], 'affiliations': ['Microsoft', 'National Taiwan University'], 'pdf_title_img': 'assets/pdf/title_img/2510.06917.jpg', 'data': {'categories': ['#multimodal', '#reasoning', '#inference', '#long_context'], 'emoji': '🎧', 'ru': {'title': 'Думай пока слушаешь: рассуждения в реальном времени для разговорных моделей', 'desc': 'В статье представлен SHANKS — фреймворк для spoken language models (SLM), который позволяет моделям генерировать невысказанные цепочки рассуждений (chain-of-thought) во время прослушивания речи пользователя, а не после завершения его реплики. Система обрабатывает входной аудиопоток фиксированными чанками и на основе предыдущих рассуждений принимает решения о прерывании пользователя или выполнении вызовов инструментов в реальном времени. Эксперименты показали, что SHANKS достигает на 37.1% более высокой точности прерывания при обнаружении ошибок в математических решениях и завершает 56.9% вызовов инструментов до окончания речи пользователя. Подход приближает AI-модели к естественному человеческому поведению — способности думать во время слушания, что критично важно для низколатентного речевого взаимодействия.'}, 'en': {'title': 'SHANKS: Real-Time Reasoning for Smarter Conversations', 'desc': 'The paper introduces SHANKS, a novel inference framework designed for spoken language models (SLMs) that allows them to engage in unspoken reasoning while listening to user input. This approach addresses the limitation of current large language models, which only process information after the user has finished speaking, leading to delays in interaction. By streaming input in chunks, SHANKS enables real-time reasoning and decision-making, allowing the model to interrupt users when necessary and complete tasks more efficiently. The results show significant improvements in interruption accuracy and tool call completion, demonstrating the potential for more dynamic and responsive conversational AI.'}, 'zh': {'title': '实时思考，提升交互效率', 'desc': 'SHANKS是一个通用推理框架，旨在提升语音语言模型在用户输入时的实时交互能力。它允许模型在用户说话时生成未说出的推理，从而减少响应延迟。SHANKS通过将输入语音分成固定时长的块进行处理，能够在接收每个块时进行推理。实验表明，SHANKS在用户解决数学问题时能够更准确地中断用户，并在对话中提前完成工具调用，显著提高了交互效率。'}}}, {'id': 'https://huggingface.co/papers/2510.04678', 'title': 'Multi-Agent Tool-Integrated Policy Optimization', 'url': 'https://huggingface.co/papers/2510.04678', 'abstract': 'MATPO, a reinforcement learning method, optimizes tool-integrated multi-agent roles within a single LLM, improving performance and robustness over single-agent systems.  \t\t\t\t\tAI-generated summary \t\t\t\t Large language models (LLMs) increasingly rely on multi-turn tool-integrated planning for knowledge-intensive and complex reasoning tasks. Existing implementations typically rely on a single agent, but they suffer from limited context length and noisy tool responses. A natural solution is to adopt a multi-agent framework with planner- and worker-agents to manage context. However, no existing methods support effective reinforcement learning post-training of tool-integrated multi-agent frameworks. To address this gap, we propose Multi-Agent Tool-Integrated Policy Optimization (MATPO), which enables distinct roles (planner and worker) to be trained within a single LLM instance using role-specific prompts via reinforcement learning. MATPO is derived from a principled credit assignment mechanism across planner and worker rollouts. This design eliminates the need to deploy multiple LLMs, which would be memory-intensive, while preserving the benefits of specialization. Experiments on GAIA-text, WebWalkerQA, and FRAMES show that MATPO consistently outperforms single-agent baselines by an average of 18.38% relative improvement in performance and exhibits greater robustness to noisy tool outputs. Our findings highlight the effectiveness of unifying multiple agent roles within a single LLM and provide practical insights for stable and efficient multi-agent RL training.', 'score': 7, 'issue_id': 6321, 'pub_date': '2025-10-06', 'pub_date_card': {'ru': '6 октября', 'en': 'October 6', 'zh': '10月6日'}, 'hash': 'a8d8251d93e429c4', 'authors': ['Zhanfeng Mo', 'Xingxuan Li', 'Yuntao Chen', 'Lidong Bing'], 'affiliations': ['MiroMind AI'], 'pdf_title_img': 'assets/pdf/title_img/2510.04678.jpg', 'data': {'categories': ['#training', '#reasoning', '#optimization', '#agents', '#rl'], 'emoji': '🎭', 'ru': {'title': 'Один LLM в роли целой команды агентов', 'desc': 'Исследователи представили MATPO — метод обучения с подкреплением для оптимизации мультиагентных систем внутри одной языковой модели. Традиционные подходы используют либо одного агента с ограниченным контекстом, либо несколько отдельных LLM, что требует много памяти. MATPO позволяет одной модели играть разные роли (планировщик и исполнитель) через специальные промпты, используя механизм распределения наград между ролями. Эксперименты показали улучшение производительности на 18,38% по сравнению с одноагентными системами и большую устойчивость к шуму в ответах инструментов.'}, 'en': {'title': 'Optimizing Multi-Agent Roles in LLMs for Enhanced Performance', 'desc': 'MATPO is a novel reinforcement learning approach that enhances the performance of large language models (LLMs) by integrating multiple agent roles within a single model. It introduces a planner-worker framework, where the planner strategizes and the worker executes tasks, allowing for better management of context and tool responses. This method leverages a credit assignment mechanism to optimize the training of these roles, avoiding the need for multiple LLMs and thus saving memory. Experimental results demonstrate that MATPO significantly improves performance and robustness compared to traditional single-agent systems, making it a promising solution for complex reasoning tasks.'}, 'zh': {'title': '多代理工具集成优化，提升LLM性能与鲁棒性', 'desc': 'MATPO是一种强化学习方法，旨在优化单个大型语言模型（LLM）中的多代理角色，提升其性能和鲁棒性。该方法通过角色特定的提示，允许规划者和工作者在同一LLM实例中进行训练，解决了现有单代理系统在上下文长度和工具响应噪声方面的局限。MATPO采用了一种原则性的信用分配机制，避免了部署多个LLM所需的高内存消耗，同时保留了专业化的优势。实验结果表明，MATPO在多个任务上相较于单代理基线平均提高了18.38%的性能，并对噪声工具输出表现出更强的鲁棒性。'}}}, {'id': 'https://huggingface.co/papers/2510.07318', 'title': 'Artificial Hippocampus Networks for Efficient Long-Context Modeling', 'url': 'https://huggingface.co/papers/2510.07318', 'abstract': "A memory framework combining short-term and long-term memory in neural networks improves long-sequence modeling efficiency and performance.  \t\t\t\t\tAI-generated summary \t\t\t\t Long-sequence modeling faces a fundamental trade-off between the efficiency of compressive fixed-size memory in RNN-like models and the fidelity of lossless growing memory in attention-based Transformers. Inspired by the Multi-Store Model in cognitive science, we introduce a memory framework of artificial neural networks. Our method maintains a sliding window of the Transformer's KV cache as lossless short-term memory, while a learnable module termed Artificial Hippocampus Network (AHN) recurrently compresses out-of-window information into a fixed-size compact long-term memory. To validate this framework, we instantiate AHNs using modern RNN-like architectures, including Mamba2, DeltaNet, and Gated DeltaNet. Extensive experiments on long-context benchmarks LV-Eval and InfiniteBench demonstrate that AHN-augmented models consistently outperform sliding window baselines and achieve performance comparable or even superior to full-attention models, while substantially reducing computational and memory requirements. For instance, augmenting the Qwen2.5-3B-Instruct with AHNs reduces inference FLOPs by 40.5% and memory cache by 74.0%, while improving its average score on LV-Eval (128k sequence length) from 4.41 to 5.88. Code is available at: https://github.com/ByteDance-Seed/AHN.", 'score': 3, 'issue_id': 6321, 'pub_date': '2025-10-08', 'pub_date_card': {'ru': '8 октября', 'en': 'October 8', 'zh': '10月8日'}, 'hash': '95c7f8990db3ab94', 'authors': ['Yunhao Fang', 'Weihao Yu', 'Shu Zhong', 'Qinghao Ye', 'Xuehan Xiong', 'Lai Wei'], 'affiliations': ['ByteDance'], 'pdf_title_img': 'assets/pdf/title_img/2510.07318.jpg', 'data': {'categories': ['#architecture', '#training', '#benchmark', '#optimization', '#long_context'], 'emoji': '🧠', 'ru': {'title': 'Искусственный гиппокамп для эффективной памяти нейросетей', 'desc': 'Исследователи предложили архитектуру памяти для нейросетей, вдохновлённую моделью многокомпонентной памяти из когнитивной психологии. Система сочетает кратковременную память (скользящее окно KV-кеша Transformer) и долговременную память (компактное представление, сжимаемое модулем Artificial Hippocampus Network). AHN реализован на базе современных RNN-подобных архитектур, включая Mamba2, DeltaNet и Gated DeltaNet. Эксперименты показали, что модели с AHN превосходят базовые методы со скользящим окном и сопоставимы с full-attention моделями, при этом снижая вычислительные затраты на 40.5% и использование памяти на 74%.'}, 'en': {'title': 'Enhancing Long-Sequence Modeling with Memory Integration', 'desc': 'This paper presents a new memory framework for neural networks that combines short-term and long-term memory to enhance the modeling of long sequences. The framework uses a sliding window for short-term memory, which retains recent information, while an Artificial Hippocampus Network (AHN) compresses older data into a fixed-size long-term memory. By integrating this approach into existing RNN-like architectures, the models show improved efficiency and performance on long-context tasks. Experiments reveal that these models not only outperform traditional methods but also significantly reduce computational costs and memory usage.'}, 'zh': {'title': '提升长序列建模效率的记忆框架', 'desc': '本论文提出了一种结合短期和长期记忆的神经网络记忆框架，以提高长序列建模的效率和性能。该框架借鉴了认知科学中的多存储模型，使用变换器的KV缓存作为无损短期记忆，同时通过人工海马体网络（AHN）将超出窗口的信息压缩为固定大小的长期记忆。实验结果表明，使用AHN的模型在长上下文基准测试中表现优于传统的滑动窗口模型，并且在计算和内存需求上显著降低。具体来说，Qwen2.5-3B-Instruct模型在引入AHN后，推理计算量减少了40.5%，内存缓存减少了74.0%，同时在LV-Eval上的平均得分从4.41提高到5.88。'}}}, {'id': 'https://huggingface.co/papers/2510.03215', 'title': 'Cache-to-Cache: Direct Semantic Communication Between Large Language\n  Models', 'url': 'https://huggingface.co/papers/2510.03215', 'abstract': "Cache-to-Cache (C2C) enables direct semantic communication between LLMs using neural network projections, improving accuracy and reducing latency compared to text-based communication.  \t\t\t\t\tAI-generated summary \t\t\t\t Multi-LLM systems harness the complementary strengths of diverse Large Language Models, achieving performance and efficiency gains unattainable by a single model. In existing designs, LLMs communicate through text, forcing internal representations to be transformed into output token sequences. This process both loses rich semantic information and incurs token-by-token generation latency. Motivated by these limitations, we ask: Can LLMs communicate beyond text? Oracle experiments show that enriching the KV-Cache semantics can improve response quality without increasing cache size, supporting KV-Cache as an effective medium for inter-model communication. Thus, we propose Cache-to-Cache (C2C), a new paradigm for direct semantic communication between LLMs. C2C uses a neural network to project and fuse the source model's KV-cache with that of the target model to enable direct semantic transfer. A learnable gating mechanism selects the target layers that benefit from cache communication. Compared with text communication, C2C utilizes the deep, specialized semantics from both models, while avoiding explicit intermediate text generation. Experiments show that C2C achieves 8.5-10.5% higher average accuracy than individual models. It further outperforms the text communication paradigm by approximately 3.0-5.0%, while delivering an average 2.0x speedup in latency. Our code is available at https://github.com/thu-nics/C2C.", 'score': 3, 'issue_id': 6321, 'pub_date': '2025-10-03', 'pub_date_card': {'ru': '3 октября', 'en': 'October 3', 'zh': '10月3日'}, 'hash': '3453eb2a78f90630', 'authors': ['Tianyu Fu', 'Zihan Min', 'Hanling Zhang', 'Jichao Yan', 'Guohao Dai', 'Wanli Ouyang', 'Yu Wang'], 'affiliations': ['Infinigence AI', 'Shanghai AI Laboratory', 'Shanghai Jiao Tong University', 'The Chinese University of Hong Kong', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2510.03215.jpg', 'data': {'categories': ['#architecture', '#training', '#multimodal', '#optimization', '#agi'], 'emoji': '🔄', 'ru': {'title': 'Общение LLM без слов: прямая передача семантики через кэш', 'desc': 'Статья предлагает новый подход Cache-to-Cache (C2C) для коммуникации между несколькими LLM, который позволяет моделям обмениваться информацией напрямую через KV-Cache вместо текста. Специальная нейронная сеть проецирует и объединяет кэши разных моделей, сохраняя богатую семантическую информацию, которая теряется при генерации текста. Метод показывает улучшение точности на 8.5-10.5% по сравнению с отдельными моделями и на 3.0-5.0% по сравнению с текстовой коммуникацией. При этом C2C обеспечивает двукратное ускорение благодаря отсутствию необходимости генерировать промежуточный текст токен за токеном.'}, 'en': {'title': 'Direct Semantic Communication for Enhanced LLM Collaboration', 'desc': 'Cache-to-Cache (C2C) introduces a novel method for Large Language Models (LLMs) to communicate directly using their internal KV-caches instead of relying on text. This approach enhances the semantic richness of the communication, allowing models to share information more effectively and efficiently. By employing a neural network to project and merge the KV-caches, C2C minimizes the loss of information and reduces latency associated with text-based exchanges. Experimental results demonstrate that C2C improves accuracy by 8.5-10.5% and speeds up communication by approximately 2.0x compared to traditional methods.'}, 'zh': {'title': '直接语义通信，提升模型效率', 'desc': 'Cache-to-Cache (C2C) 是一种新方法，允许大型语言模型（LLMs）之间直接进行语义通信。通过神经网络投影，C2C 可以提高准确性并减少延迟，避免了传统文本通信中信息损失和逐字生成的延迟。该方法通过融合源模型和目标模型的KV缓存，直接传递语义信息，从而实现更高效的模型间交流。实验结果表明，C2C 在准确性和速度上均优于传统的文本通信方式。'}}}, {'id': 'https://huggingface.co/papers/2510.05862', 'title': 'Revisiting Long-context Modeling from Context Denoising Perspective', 'url': 'https://huggingface.co/papers/2510.05862', 'abstract': "Context Denoising Training (CDT) improves long-context models' performance by mitigating contextual noise and enhancing attention on critical tokens.  \t\t\t\t\tAI-generated summary \t\t\t\t Long-context models (LCMs) have demonstrated great potential in processing long sequences, facilitating many real-world applications. The success of LCMs can be attributed to their ability to locate implicit critical information within the context for further prediction. However, recent research reveals that LCMs are often susceptible to contextual noise, i.e., irrelevant tokens, that can mislead model attention. In this paper, we conduct a fine-grained analysis of the context noise and propose an effective metric, the Integrated Gradient (IG) score, to detect and quantify the noise information within the context. Our findings reveal that even simple mitigation of detected context noise can substantially boost the model's attention on critical tokens and benefit subsequent predictions. Building on this insight, we propose Context Denoising Training (CDT), a straightforward yet effective training strategy that improves attention on critical tokens while reinforcing their influence on model predictions. Extensive experiments across four tasks, under both context window scaling and long-context alignment settings, demonstrate the superiority of CDT. Notably, when trained with CDT, an open-source 8B model can achieve performance (50.92) comparable to GPT-4o (51.00).", 'score': 2, 'issue_id': 6321, 'pub_date': '2025-10-07', 'pub_date_card': {'ru': '7 октября', 'en': 'October 7', 'zh': '10月7日'}, 'hash': 'efa8b7d057b81865', 'authors': ['Zecheng Tang', 'Baibei Ji', 'Juntao Li', 'Lijun Wu', 'Haijia Gui', 'Min Zhang'], 'affiliations': ['LCM Laboratory', 'Shanghai Artificial Intelligence Laboratory', 'Soochow University'], 'pdf_title_img': 'assets/pdf/title_img/2510.05862.jpg', 'data': {'categories': ['#training', '#long_context', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Обучение с очисткой контекста: фокус на важном', 'desc': 'Исследователи предлагают метод Context Denoising Training (CDT) для улучшения работы моделей с длинным контекстом. Проблема заключается в том, что модели часто отвлекаются на нерелевантные токены (контекстный шум), что мешает им сосредоточиться на критически важной информации. Авторы используют метрику Integrated Gradient для обнаружения такого шума и предлагают стратегию обучения, которая усиливает внимание модели на ключевых токенах. Эксперименты показывают, что open-source модель на 8B параметров, обученная с CDT, достигает результатов, сопоставимых с GPT-4o.'}, 'en': {'title': 'Enhancing Long-Context Models with Context Denoising Training', 'desc': "Context Denoising Training (CDT) is a novel approach designed to enhance the performance of long-context models (LCMs) by reducing the impact of contextual noise. This noise, which consists of irrelevant tokens, can distract the model from focusing on important information needed for accurate predictions. The paper introduces the Integrated Gradient (IG) score as a metric to identify and measure this noise, allowing for targeted mitigation strategies. By implementing CDT, the model's attention on critical tokens is improved, leading to better overall performance in various tasks, even achieving results comparable to advanced models like GPT-4o."}, 'zh': {'title': '上下文去噪，提升模型性能！', 'desc': '上下文去噪训练（CDT）通过减少上下文噪声，提升了长上下文模型的性能。长上下文模型（LCMs）在处理长序列方面表现出色，但容易受到无关标记的干扰。本文提出了一种有效的度量标准——积分梯度（IG）分数，用于检测和量化上下文中的噪声信息。通过简单的噪声缓解方法，CDT显著增强了模型对关键标记的关注，从而改善了后续的预测效果。'}}}, {'id': 'https://huggingface.co/papers/2510.04212', 'title': 'Why Low-Precision Transformer Training Fails: An Analysis on Flash\n  Attention', 'url': 'https://huggingface.co/papers/2510.04212', 'abstract': 'Low-precision training of transformer models with flash attention suffers from catastrophic loss explosions due to low-rank representations and biased rounding errors, which are addressed by a minimal modification to the flash attention mechanism.  \t\t\t\t\tAI-generated summary \t\t\t\t The pursuit of computational efficiency has driven the adoption of low-precision formats for training transformer models. However, this progress is often hindered by notorious training instabilities. This paper provides the first mechanistic explanation for a long-standing and unresolved failure case where training with flash attention in low-precision settings leads to catastrophic loss explosions. Our in-depth analysis reveals that the failure is not a random artifact but caused by two intertwined phenomena: the emergence of similar low-rank representations within the attention mechanism and the compounding effect of biased rounding errors inherent in low-precision arithmetic. We demonstrate how these factors create a vicious cycle of error accumulation that corrupts weight updates, ultimately derailing the training dynamics. To validate our findings, we introduce a minimal modification to the flash attention that mitigates the bias in rounding errors. This simple change stabilizes the training process, confirming our analysis and offering a practical solution to this persistent problem.', 'score': 2, 'issue_id': 6321, 'pub_date': '2025-10-05', 'pub_date_card': {'ru': '5 октября', 'en': 'October 5', 'zh': '10月5日'}, 'hash': 'e0a5e1e23247359f', 'authors': ['Haiquan Qiu', 'Quanming Yao'], 'affiliations': ['Department of Electronic Engineering, Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2510.04212.jpg', 'data': {'categories': ['#architecture', '#training', '#optimization'], 'emoji': '💥', 'ru': {'title': 'Укрощение взрывов: стабильная тренировка трансформеров с низкой точностью', 'desc': 'Исследователи выяснили, почему обучение transformer-моделей с flash attention в низкой точности приводит к катастрофическим взрывам функции потерь. Проблема возникает из-за двух связанных факторов: появления похожих low-rank представлений в механизме attention и накопления смещённых ошибок округления при арифметике низкой точности. Эти явления создают порочный круг накопления ошибок, который искажает обновления весов и разрушает динамику обучения. Авторы предложили минимальную модификацию flash attention, которая снижает смещение в ошибках округления и стабилизирует процесс тренировки.'}, 'en': {'title': 'Stabilizing Low-Precision Training in Transformers', 'desc': 'This paper addresses the challenges of training transformer models using low-precision formats, which often lead to significant training instabilities. It identifies the root cause of catastrophic loss explosions during low-precision training with flash attention, linking it to low-rank representations and biased rounding errors. The authors explain how these issues create a cycle of error accumulation that disrupts weight updates and training dynamics. To resolve this, they propose a minimal modification to the flash attention mechanism that reduces rounding bias, stabilizing the training process effectively.'}, 'zh': {'title': '低精度训练中的闪存注意力稳定性解决方案', 'desc': '本论文探讨了在低精度训练变换器模型时，使用闪存注意力机制所面临的灾难性损失爆炸问题。研究发现，这种问题并非偶然，而是由于注意力机制中出现的相似低秩表示和低精度算术中固有的偏差舍入误差相互作用所导致。我们提出了一种对闪存注意力机制的最小修改，能够减轻舍入误差的偏差，从而稳定训练过程。通过这一简单的改动，我们验证了分析结果，并为这一长期存在的问题提供了实用的解决方案。'}}}, {'id': 'https://huggingface.co/papers/2510.07310', 'title': 'MATRIX: Mask Track Alignment for Interaction-aware Video Generation', 'url': 'https://huggingface.co/papers/2510.07310', 'abstract': 'MATRIX-11K dataset and MATRIX regularization enhance interaction fidelity and semantic alignment in video DiTs by aligning attention with multi-instance mask tracks.  \t\t\t\t\tAI-generated summary \t\t\t\t Video DiTs have advanced video generation, yet they still struggle to model multi-instance or subject-object interactions. This raises a key question: How do these models internally represent interactions? To answer this, we curate MATRIX-11K, a video dataset with interaction-aware captions and multi-instance mask tracks. Using this dataset, we conduct a systematic analysis that formalizes two perspectives of video DiTs: semantic grounding, via video-to-text attention, which evaluates whether noun and verb tokens capture instances and their relations; and semantic propagation, via video-to-video attention, which assesses whether instance bindings persist across frames. We find both effects concentrate in a small subset of interaction-dominant layers. Motivated by this, we introduce MATRIX, a simple and effective regularization that aligns attention in specific layers of video DiTs with multi-instance mask tracks from the MATRIX-11K dataset, enhancing both grounding and propagation. We further propose InterGenEval, an evaluation protocol for interaction-aware video generation. In experiments, MATRIX improves both interaction fidelity and semantic alignment while reducing drift and hallucination. Extensive ablations validate our design choices. Codes and weights will be released.', 'score': 1, 'issue_id': 6321, 'pub_date': '2025-10-08', 'pub_date_card': {'ru': '8 октября', 'en': 'October 8', 'zh': '10月8日'}, 'hash': '1dfefa942d4dfe75', 'authors': ['Siyoon Jin', 'Seongchan Kim', 'Dahyun Chung', 'Jaeho Lee', 'Hyunwook Choi', 'Jisu Nam', 'Jiyoung Kim', 'Seungryong Kim'], 'affiliations': ['KAIST AI'], 'pdf_title_img': 'assets/pdf/title_img/2510.07310.jpg', 'data': {'categories': ['#dataset', '#hallucinations', '#benchmark', '#video', '#interpretability'], 'emoji': '🎭', 'ru': {'title': 'Улучшение взаимодействий в видео через выравнивание внимания по маскам объектов', 'desc': 'Исследователи создали датасет MATRIX-11K с видео, содержащими описания взаимодействий и треки масок нескольких объектов. Они проанализировали, как video DiT модели представляют взаимодействия между объектами, изучив semantic grounding (связь токенов с объектами) и semantic propagation (сохранение связей между кадрами). Оказалось, что эти эффекты концентрируются в небольшом числе специфичных слоёв модели. На основе этого была предложена регуляризация MATRIX, которая выравнивает attention механизм с масками объектов, что улучшает точность взаимодействий и уменьшает hallucination в генерируемом видео.'}, 'en': {'title': 'Enhancing Video Generation with MATRIX Regularization', 'desc': 'This paper introduces the MATRIX-11K dataset, which includes interaction-aware captions and multi-instance mask tracks to improve video generation models known as video DiTs. The authors analyze how these models represent interactions through two main perspectives: semantic grounding and semantic propagation, focusing on how well they capture and maintain relationships between objects over time. They propose a new regularization technique called MATRIX that aligns the attention mechanisms in specific layers of video DiTs with the multi-instance mask tracks from their dataset. The results show that MATRIX enhances interaction fidelity and semantic alignment, leading to better video generation outcomes while minimizing issues like drift and hallucination.'}, 'zh': {'title': '提升视频生成模型的交互保真度与语义对齐', 'desc': '本论文介绍了MATRIX-11K数据集和MATRIX正则化如何提高视频生成模型（DiTs）在交互保真度和语义对齐方面的表现。研究发现，视频生成模型在处理多实例或主体-对象交互时存在困难，因此我们创建了一个包含交互意识字幕和多实例掩码轨迹的数据集。通过系统分析，我们提出了语义基础和语义传播两个视角，评估模型在视频到文本和视频到视频的注意力机制。最终，MATRIX正则化通过对齐特定层的注意力与多实例掩码轨迹，显著提升了模型的性能。'}}}, {'id': 'https://huggingface.co/papers/2510.07041', 'title': 'U-Bench: A Comprehensive Understanding of U-Net through 100-Variant\n  Benchmarking', 'url': 'https://huggingface.co/papers/2510.07041', 'abstract': 'U-Bench is a comprehensive benchmark evaluating 100 U-Net variants across 28 datasets and 10 imaging modalities, focusing on statistical robustness, zero-shot generalization, and computational efficiency.  \t\t\t\t\tAI-generated summary \t\t\t\t Over the past decade, U-Net has been the dominant architecture in medical image segmentation, leading to the development of thousands of U-shaped variants. Despite its widespread adoption, there is still no comprehensive benchmark to systematically evaluate their performance and utility, largely because of insufficient statistical validation and limited consideration of efficiency and generalization across diverse datasets. To bridge this gap, we present U-Bench, the first large-scale, statistically rigorous benchmark that evaluates 100 U-Net variants across 28 datasets and 10 imaging modalities. Our contributions are threefold: (1) Comprehensive Evaluation: U-Bench evaluates models along three key dimensions: statistical robustness, zero-shot generalization, and computational efficiency. We introduce a novel metric, U-Score, which jointly captures the performance-efficiency trade-off, offering a deployment-oriented perspective on model progress. (2) Systematic Analysis and Model Selection Guidance: We summarize key findings from the large-scale evaluation and systematically analyze the impact of dataset characteristics and architectural paradigms on model performance. Based on these insights, we propose a model advisor agent to guide researchers in selecting the most suitable models for specific datasets and tasks. (3) Public Availability: We provide all code, models, protocols, and weights, enabling the community to reproduce our results and extend the benchmark with future methods. In summary, U-Bench not only exposes gaps in previous evaluations but also establishes a foundation for fair, reproducible, and practically relevant benchmarking in the next decade of U-Net-based segmentation models. The project can be accessed at: https://fenghetan9.github.io/ubench. Code is available at: https://github.com/FengheTan9/U-Bench.', 'score': 1, 'issue_id': 6321, 'pub_date': '2025-10-08', 'pub_date_card': {'ru': '8 октября', 'en': 'October 8', 'zh': '10月8日'}, 'hash': '382dc490ec7534fd', 'authors': ['Fenghe Tang', 'Chengqi Dong', 'Wenxin Ma', 'Zikang Xu', 'Heqin Zhu', 'Zihang Jiang', 'Rongsheng Wang', 'Yuhao Wang', 'Chenxu Wu', 'Shaohua Kevin Zhou'], 'affiliations': ['HCNS', 'MIRACLE Center', 'University of Science and Technology of China'], 'pdf_title_img': 'assets/pdf/title_img/2510.07041.jpg', 'data': {'categories': ['#cv', '#open_source', '#dataset', '#benchmark', '#optimization', '#survey'], 'emoji': '🏥', 'ru': {'title': 'U-Bench: всесторонний бенчмарк для U-Net архитектур в медицинской сегментации', 'desc': 'U-Bench представляет собой первый масштабный бенчмарк для систематической оценки U-Net архитектур в медицинской сегментации изображений. Исследователи протестировали 100 вариантов U-Net на 28 датасетах и 10 типах медицинских изображений, оценивая статистическую надёжность, zero-shot обобщение и вычислительную эффективность. Введена новая метрика U-Score, которая учитывает баланс между производительностью и эффективностью моделей. На основе результатов создан агент-советник для помощи исследователям в выборе оптимальной модели под конкретную задачу.'}, 'en': {'title': 'U-Bench: A New Standard for Evaluating U-Net Models in Medical Imaging', 'desc': 'U-Bench is a new benchmark designed to evaluate 100 different U-Net models across 28 datasets and 10 types of imaging. It focuses on three main areas: how robust the models are statistically, how well they can generalize to new data without prior training (zero-shot), and how efficient they are in terms of computation. The benchmark introduces a unique metric called U-Score, which helps to balance performance and efficiency, making it easier to choose the right model for specific tasks. By providing comprehensive evaluations and public access to resources, U-Bench aims to improve the way U-Net models are assessed and utilized in medical image segmentation.'}, 'zh': {'title': 'U-Bench：U-Net变体的全面评估基准', 'desc': 'U-Bench是一个全面的基准测试，评估100种U-Net变体在28个数据集和10种成像模式下的表现，重点关注统计稳健性、零样本泛化和计算效率。该基准测试填补了以往缺乏系统评估的空白，提供了一个新的度量标准U-Score，帮助研究者理解性能与效率之间的权衡。通过系统分析数据集特征和模型架构对性能的影响，U-Bench为研究者提供了模型选择的指导。所有代码、模型和协议均已公开，促进了社区的再现性和未来方法的扩展。'}}}, {'id': 'https://huggingface.co/papers/2510.05891', 'title': 'D^3QE: Learning Discrete Distribution Discrepancy-aware\n  Quantization Error for Autoregressive-Generated Image Detection', 'url': 'https://huggingface.co/papers/2510.05891', 'abstract': 'A novel method using Discrete Distribution Discrepancy-aware Quantization Error (D$^3$QE) detects images generated by visual autoregressive models by analyzing codebook frequency statistics and quantization errors.  \t\t\t\t\tAI-generated summary \t\t\t\t The emergence of visual autoregressive (AR) models has revolutionized image generation while presenting new challenges for synthetic image detection. Unlike previous GAN or diffusion-based methods, AR models generate images through discrete token prediction, exhibiting both marked improvements in image synthesis quality and unique characteristics in their vector-quantized representations. In this paper, we propose to leverage Discrete Distribution Discrepancy-aware Quantization Error (D^3QE) for autoregressive-generated image detection that exploits the distinctive patterns and the frequency distribution bias of the codebook existing in real and fake images. We introduce a discrete distribution discrepancy-aware transformer that integrates dynamic codebook frequency statistics into its attention mechanism, fusing semantic features and quantization error latent. To evaluate our method, we construct a comprehensive dataset termed ARForensics covering 7 mainstream visual AR models. Experiments demonstrate superior detection accuracy and strong generalization of D^3QE across different AR models, with robustness to real-world perturbations. Code is available at https://github.com/Zhangyr2022/D3QE{https://github.com/Zhangyr2022/D3QE}.', 'score': 1, 'issue_id': 6321, 'pub_date': '2025-10-07', 'pub_date_card': {'ru': '7 октября', 'en': 'October 7', 'zh': '10月7日'}, 'hash': 'b5fce1a59c0d659b', 'authors': ['Yanran Zhang', 'Bingyao Yu', 'Yu Zheng', 'Wenzhao Zheng', 'Yueqi Duan', 'Lei Chen', 'Jie Zhou', 'Jiwen Lu'], 'affiliations': ['Department of Automation, Tsinghua University, China', 'Department of Electronic Engineering, Tsinghua University, China'], 'pdf_title_img': 'assets/pdf/title_img/2510.05891.jpg', 'data': {'categories': ['#security', '#synthetic', '#cv', '#dataset', '#inference'], 'emoji': '🔍', 'ru': {'title': 'Поиск искусственного через анализ квантизации', 'desc': 'Исследователи предложили новый метод D³QE для обнаружения изображений, сгенерированных визуальными autoregressive моделями. Метод анализирует паттерны распределения частот в codebook и ошибки квантизации, которые отличаются у реальных и синтетических изображений. Для этого используется специальный transformer, который учитывает статистику частот codebook в механизме attention и объединяет семантические признаки с латентными представлениями ошибок квантизации. Эксперименты на датасете ARForensics из 7 моделей показали высокую точность детекции и хорошую обобщающую способность метода.'}, 'en': {'title': 'Detecting AI-Generated Images with D^3QE', 'desc': 'This paper presents a new method called Discrete Distribution Discrepancy-aware Quantization Error (D^3QE) for detecting images created by visual autoregressive models. It focuses on analyzing the frequency statistics of codebooks and the quantization errors that arise during image generation. By using a transformer that incorporates these frequency statistics into its attention mechanism, the method effectively distinguishes between real and synthetic images. The proposed approach shows high accuracy and generalization across various autoregressive models, making it robust against real-world image variations.'}, 'zh': {'title': '利用D^3QE检测自回归生成图像的创新方法', 'desc': '本文提出了一种新方法，利用离散分布差异感知量化误差（D^3QE）来检测由视觉自回归模型生成的图像。该方法通过分析代码本频率统计和量化误差，识别真实与伪造图像之间的独特模式和频率分布偏差。与传统的生成对抗网络（GAN）或扩散模型不同，自回归模型通过离散标记预测生成图像，展现出更高的合成质量。实验结果表明，D^3QE在不同自回归模型中具有优越的检测准确性和强大的泛化能力。'}}}, {'id': 'https://huggingface.co/papers/2510.04999', 'title': 'Bridging Text and Video Generation: A Survey', 'url': 'https://huggingface.co/papers/2510.04999', 'abstract': 'A survey of text-to-video generative models from GANs and VAEs to hybrid Diffusion-Transformer architectures, detailing their development, limitations, and future directions.  \t\t\t\t\tAI-generated summary \t\t\t\t Text-to-video (T2V) generation technology holds potential to transform multiple domains such as education, marketing, entertainment, and assistive technologies for individuals with visual or reading comprehension challenges, by creating coherent visual content from natural language prompts. From its inception, the field has advanced from adversarial models to diffusion-based models, yielding higher-fidelity, temporally consistent outputs. Yet challenges persist, such as alignment, long-range coherence, and computational efficiency. Addressing this evolving landscape, we present a comprehensive survey of text-to-video generative models, tracing their development from early GANs and VAEs to hybrid Diffusion-Transformer (DiT) architectures, detailing how these models work, what limitations they addressed in their predecessors, and why shifts toward new architectural paradigms were necessary to overcome challenges in quality, coherence, and control. We provide a systematic account of the datasets, which the surveyed text-to-video models were trained and evaluated on, and, to support reproducibility and assess the accessibility of training such models, we detail their training configurations, including their hardware specifications, GPU counts, batch sizes, learning rates, optimizers, epochs, and other key hyperparameters. Further, we outline the evaluation metrics commonly used for evaluating such models and present their performance across standard benchmarks, while also discussing the limitations of these metrics and the emerging shift toward more holistic, perception-aligned evaluation strategies. Finally, drawing from our analysis, we outline the current open challenges and propose a few promising future directions, laying out a perspective for future researchers to explore and build upon in advancing T2V research and applications.', 'score': 1, 'issue_id': 6321, 'pub_date': '2025-10-06', 'pub_date_card': {'ru': '6 октября', 'en': 'October 6', 'zh': '10月6日'}, 'hash': '2ff1fd3dd4354c0a', 'authors': ['Nilay Kumar', 'Priyansh Bhandari', 'G. Maragatham'], 'affiliations': ['Department of Computational Intelligence SRM Institute of Science and Technology'], 'pdf_title_img': 'assets/pdf/title_img/2510.04999.jpg', 'data': {'categories': ['#architecture', '#training', '#dataset', '#benchmark', '#video', '#diffusion', '#survey'], 'emoji': '🎬', 'ru': {'title': 'От GAN к Diffusion: эволюция генерации видео из текста', 'desc': 'Статья представляет обзор моделей генерации видео из текста (text-to-video), прослеживая их развитие от ранних GAN и VAE до современных гибридных Diffusion-Transformer архитектур. Авторы детально анализируют принципы работы этих моделей, ограничения предшественников и причины перехода к новым архитектурным парадигмам для улучшения качества, согласованности и контроля. Особое внимание уделяется датасетам, конфигурациям обучения, метрикам оценки и их ограничениям, а также сравнению производительности моделей на стандартных бенчмарках. В заключение обсуждаются текущие открытые проблемы, включая выравнивание с текстом, долгосрочную когерентность и вычислительную эффективность, и предлагаются перспективные направления будущих исследований.'}, 'en': {'title': 'Transforming Text into Video: A Journey Through Generative Models', 'desc': 'This paper surveys the evolution of text-to-video (T2V) generative models, highlighting the transition from Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs) to advanced Diffusion-Transformer architectures. It discusses the potential applications of T2V technology in various fields and the improvements in output quality and coherence achieved through these newer models. The paper also addresses ongoing challenges such as alignment, long-range coherence, and computational efficiency, while providing insights into training configurations and evaluation metrics used in the field. Finally, it outlines future research directions and open challenges to guide further advancements in T2V generation.'}, 'zh': {'title': '文本生成视频技术的未来探索', 'desc': '本文对文本生成视频（T2V）模型进行了全面的调查，涵盖了从对抗生成网络（GANs）和变分自编码器（VAEs）到混合扩散-变换器架构的发展历程。尽管该领域已经取得了显著进展，但仍面临对齐、长时间一致性和计算效率等挑战。我们详细介绍了这些模型的工作原理、解决的局限性以及为何需要向新架构范式转变。最后，我们提出了当前的开放挑战和未来的研究方向，以推动T2V技术的发展。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents (1)', '#agi (1)', '#alignment (1)', '#architecture (4)', '#audio', '#benchmark (5)', '#cv (2)', '#data', '#dataset (4)', '#diffusion (1)', '#ethics', '#games', '#graphs', '#hallucinations (1)', '#healthcare', '#inference (2)', '#interpretability (2)', '#leakage', '#long_context (3)', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal (2)', '#open_source (1)', '#optimization (6)', '#plp (1)', '#rag', '#reasoning (2)', '#rl (1)', '#rlhf', '#robotics', '#science', '#security (1)', '#small_models', '#story_generation', '#survey (2)', '#synthetic (1)', '#training (7)', '#transfer_learning', '#video (2)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-10-09 02:18',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-10-09 02:18')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-10-09 02:18')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    