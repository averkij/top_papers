
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 18 papers. August 13.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">13 августа</span> | <span id="title-articles-count">18 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-08-12.html">⬅️ <span id="prev-date">12.08</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-08-14.html">➡️ <span id="next-date">14.08</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-08.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '13 августа', 'en': 'August 13', 'zh': '8月13日'};
        let feedDateNext = {'ru': '14.08', 'en': '08/14', 'zh': '8月14日'};
        let feedDatePrev = {'ru': '12.08', 'en': '08/12', 'zh': '8月12日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2508.05748', 'title': 'WebWatcher: Breaking New Frontier of Vision-Language Deep Research Agent', 'url': 'https://huggingface.co/papers/2508.05748', 'abstract': 'WebWatcher, a multimodal agent with enhanced visual-language reasoning, outperforms existing agents in complex visual and textual information retrieval tasks using synthetic trajectories and reinforcement learning.  \t\t\t\t\tAI-generated summary \t\t\t\t Web agents such as Deep Research have demonstrated superhuman cognitive abilities, capable of solving highly challenging information-seeking problems. However, most research remains primarily text-centric, overlooking visual information in the real world. This makes multimodal Deep Research highly challenging, as such agents require much stronger reasoning abilities in perception, logic, knowledge, and the use of more sophisticated tools compared to text-based agents. To address this limitation, we introduce WebWatcher, a multi-modal Agent for Deep Research equipped with enhanced visual-language reasoning capabilities. It leverages high-quality synthetic multimodal trajectories for efficient cold start training, utilizes various tools for deep reasoning, and further enhances generalization through reinforcement learning. To better evaluate the capabilities of multimodal agents, we propose BrowseComp-VL, a benchmark with BrowseComp-style that requires complex information retrieval involving both visual and textual information. Experimental results show that WebWatcher significantly outperforms proprietary baseline, RAG workflow and open-source agents in four challenging VQA benchmarks, which paves the way for solving complex multimodal information-seeking tasks.', 'score': 62, 'issue_id': 5318, 'pub_date': '2025-08-07', 'pub_date_card': {'ru': '7 августа', 'en': 'August 7', 'zh': '8月7日'}, 'hash': '937594202a5b31b7', 'authors': ['Xinyu Geng', 'Peng Xia', 'Zhen Zhang', 'Xinyu Wang', 'Qiuchen Wang', 'Ruixue Ding', 'Chenxi Wang', 'Jialong Wu', 'Yida Zhao', 'Kuan Li', 'Yong Jiang', 'Pengjun Xie', 'Fei Huang', 'Jingren Zhou'], 'affiliations': ['Tongyi Lab, Alibaba Group'], 'pdf_title_img': 'assets/pdf/title_img/2508.05748.jpg', 'data': {'categories': ['#reasoning', '#synthetic', '#multimodal', '#agents', '#rl', '#benchmark', '#open_source'], 'emoji': '🕵️', 'ru': {'title': 'WebWatcher: Мультимодальный агент для глубокого исследования визуальной и текстовой информации', 'desc': 'WebWatcher - это мультимодальный агент с улучшенными возможностями визуально-языкового рассуждения. Он превосходит существующие агенты в сложных задачах поиска визуальной и текстовой информации, используя синтетические траектории и обучение с подкреплением. WebWatcher использует высококачественные синтетические мультимодальные траектории для эффективного холодного старта обучения и применяет различные инструменты для глубокого рассуждения. Для оценки возможностей мультимодальных агентов авторы предлагают бенчмарк BrowseComp-VL, требующий сложного поиска информации с использованием как визуальных, так и текстовых данных.'}, 'en': {'title': 'WebWatcher: Revolutionizing Multimodal Information Retrieval', 'desc': 'WebWatcher is a multimodal agent designed to improve the retrieval of complex visual and textual information. It utilizes synthetic trajectories and reinforcement learning to enhance its visual-language reasoning capabilities. Unlike traditional text-centric agents, WebWatcher effectively integrates visual data, allowing for better reasoning and problem-solving. The introduction of the BrowseComp-VL benchmark further validates its superior performance in multimodal tasks compared to existing agents.'}, 'zh': {'title': 'WebWatcher：超越文本的多模态智能体', 'desc': 'WebWatcher是一种多模态智能体，具备增强的视觉语言推理能力，能够在复杂的视觉和文本信息检索任务中超越现有智能体。该系统利用高质量的合成多模态轨迹进行高效的冷启动训练，并通过强化学习进一步提升其泛化能力。WebWatcher在多个视觉问答基准测试中表现优异，显示出其在处理复杂多模态信息检索任务方面的潜力。为评估多模态智能体的能力，本文还提出了BrowseComp-VL基准，专注于视觉和文本信息的复杂检索。'}}}, {'id': 'https://huggingface.co/papers/2508.08086', 'title': 'Matrix-3D: Omnidirectional Explorable 3D World Generation', 'url': 'https://huggingface.co/papers/2508.08086', 'abstract': 'Matrix-3D generates wide-coverage 3D worlds from single images or text using panoramic video diffusion and reconstruction models.  \t\t\t\t\tAI-generated summary \t\t\t\t Explorable 3D world generation from a single image or text prompt forms a cornerstone of spatial intelligence. Recent works utilize video model to achieve wide-scope and generalizable 3D world generation. However, existing approaches often suffer from a limited scope in the generated scenes. In this work, we propose Matrix-3D, a framework that utilize panoramic representation for wide-coverage omnidirectional explorable 3D world generation that combines conditional video generation and panoramic 3D reconstruction. We first train a trajectory-guided panoramic video diffusion model that employs scene mesh renders as condition, to enable high-quality and geometrically consistent scene video generation. To lift the panorama scene video to 3D world, we propose two separate methods: (1) a feed-forward large panorama reconstruction model for rapid 3D scene reconstruction and (2) an optimization-based pipeline for accurate and detailed 3D scene reconstruction. To facilitate effective training, we also introduce the Matrix-Pano dataset, the first large-scale synthetic collection comprising 116K high-quality static panoramic video sequences with depth and trajectory annotations. Extensive experiments demonstrate that our proposed framework achieves state-of-the-art performance in panoramic video generation and 3D world generation. See more in https://matrix-3d.github.io.', 'score': 37, 'issue_id': 5317, 'pub_date': '2025-08-11', 'pub_date_card': {'ru': '11 августа', 'en': 'August 11', 'zh': '8月11日'}, 'hash': '70a9a4327de06f04', 'authors': ['Zhongqi Yang', 'Wenhang Ge', 'Yuqi Li', 'Jiaqi Chen', 'Haoyuan Li', 'Mengyin An', 'Fei Kang', 'Hua Xue', 'Baixin Xu', 'Yuyang Yin', 'Eric Li', 'Yang Liu', 'Yikai Wang', 'Hao-Xiang Guo', 'Yahui Zhou'], 'affiliations': ['Hong Kong University of Science and Technology (Guangzhou)', 'Institute of Computing Technology, Chinese Academy of Sciences', 'School of Artificial Intelligence, Beijing Normal University', 'Skywork AI'], 'pdf_title_img': 'assets/pdf/title_img/2508.08086.jpg', 'data': {'categories': ['#dataset', '#diffusion', '#3d', '#synthetic'], 'emoji': '🌐', 'ru': {'title': 'Генерация исследуемых 3D-миров из одного изображения или текста', 'desc': 'Matrix-3D - это система для создания исследуемых трехмерных миров на основе одного изображения или текстового запроса. Она использует панорамную видеодиффузию и модели реконструкции для генерации широкоохватных 3D-сцен. Система включает в себя условную генерацию видео с учетом траектории и два метода реконструкции 3D: быстрый прямой и точный оптимизационный. Для обучения был создан набор данных Matrix-Pano из 116 тысяч синтетических панорамных видеопоследовательностей.'}, 'en': {'title': 'Transforming Images into Immersive 3D Worlds', 'desc': 'Matrix-3D is a novel framework designed to create expansive 3D environments from a single image or text input by leveraging advanced panoramic video diffusion and reconstruction techniques. It addresses the limitations of previous methods by employing a trajectory-guided video diffusion model that generates high-quality scene videos, ensuring geometric consistency. The framework includes two distinct approaches for converting panoramic videos into 3D worlds: a fast feed-forward model for quick reconstructions and an optimization-based method for detailed accuracy. Additionally, the introduction of the Matrix-Pano dataset, which contains a large collection of panoramic video sequences with depth and trajectory data, supports effective training and enhances the overall performance of the system.'}, 'zh': {'title': '从单图像生成全景 3D 世界的创新框架', 'desc': 'Matrix-3D 是一个生成广泛覆盖的 3D 世界的框架，能够从单张图像或文本提示中生成可探索的 3D 世界。该框架结合了条件视频生成和全景 3D 重建，利用全景表示来实现全方位的 3D 世界生成。我们首先训练了一个基于轨迹引导的全景视频扩散模型，以场景网格渲染作为条件，从而实现高质量和几何一致的场景视频生成。为了将全景场景视频提升为 3D 世界，我们提出了两种方法：快速的前馈全景重建模型和基于优化的精确 3D 场景重建流程。'}}}, {'id': 'https://huggingface.co/papers/2508.07976', 'title': 'Beyond Ten Turns: Unlocking Long-Horizon Agentic Search with Large-Scale\n  Asynchronous RL', 'url': 'https://huggingface.co/papers/2508.07976', 'abstract': 'ASearcher is an open-source project that uses scalable asynchronous RL training to enhance search agents, achieving high performance on QA tasks with long-horizon search capabilities.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advancements in LLM-based agents have demonstrated remarkable capabilities in handling complex, knowledge-intensive tasks by integrating external tools. Among diverse choices of tools, search tools play a pivotal role in accessing vast external knowledge. However, open-source agents still fall short of achieving expert-level Search Intelligence, the ability to resolve ambiguous queries, generate precise searches, analyze results, and conduct thorough exploration. Existing approaches fall short in scalability, efficiency, and data quality. For example, small turn limits in existing online RL methods, e.g. <=10, restrict complex strategy learning. This paper introduces ASearcher, an open-source project for large-scale RL training of search agents. Our key contributions include: (1) Scalable fully asynchronous RL training that enables long-horizon search while maintaining high training efficiency. (2) A prompt-based LLM agent that autonomously synthesizes high-quality and challenging QAs, creating a large-scale QA dataset. Through RL training, our prompt-based QwQ-32B agent achieves substantial improvements, with 46.7% and 20.8% Avg@4 gains on xBench and GAIA, respectively. Notably, our agent exhibits extreme long-horizon search, with tool calls exceeding 40 turns and output tokens exceeding 150k during training time. With a simple agent design and no external LLMs, ASearcher-Web-QwQ achieves Avg@4 scores of 42.1 on xBench and 52.8 on GAIA, surpassing existing open-source 32B agents. We open-source our models, training data, and codes in https://github.com/inclusionAI/ASearcher.', 'score': 23, 'issue_id': 5318, 'pub_date': '2025-08-11', 'pub_date_card': {'ru': '11 августа', 'en': 'August 11', 'zh': '8月11日'}, 'hash': '22a9c1c0433f2764', 'authors': ['Jiaxuan Gao', 'Wei Fu', 'Minyang Xie', 'Shusheng Xu', 'Chuyi He', 'Zhiyu Mei', 'Banghua Zhu', 'Yi Wu'], 'affiliations': ['Ant Research, RL Lab', 'IIIS, Tsinghua University', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2508.07976.jpg', 'data': {'categories': ['#dataset', '#training', '#agents', '#rl', '#long_context', '#open_source'], 'emoji': '🔍', 'ru': {'title': 'ASearcher: Революция в обучении поисковых ИИ-агентов', 'desc': 'ASearcher - это проект с открытым исходным кодом, использующий масштабируемое асинхронное обучение с подкреплением для улучшения поисковых агентов. Он достигает высокой производительности в задачах вопросно-ответного типа с возможностью долгосрочного поиска. Ключевые особенности включают полностью асинхронное обучение с подкреплением и агент на основе языковой модели, который автономно создает качественные наборы данных вопросов и ответов. ASearcher превосходит существующие открытые агенты на 32 миллиарда параметров в бенчмарках xBench и GAIA.'}, 'en': {'title': 'Unlocking Expert-Level Search Intelligence with ASearcher', 'desc': 'ASearcher is an innovative open-source project that enhances search agents through scalable asynchronous reinforcement learning (RL) training. It addresses the limitations of existing methods by enabling long-horizon search capabilities, allowing agents to learn complex strategies over extended interactions. The project introduces a prompt-based large language model (LLM) agent that autonomously generates high-quality question-answer pairs, significantly improving the dataset for training. As a result, ASearcher achieves impressive performance metrics, outperforming previous open-source agents in various QA tasks.'}, 'zh': {'title': 'ASearcher：提升搜索智能的开源强化学习项目', 'desc': 'ASearcher是一个开源项目，利用可扩展的异步强化学习（RL）训练来增强搜索代理的能力，特别是在长时间搜索的问答任务中表现出色。该项目的关键贡献包括可扩展的完全异步RL训练，能够在保持高训练效率的同时进行长时间搜索。通过基于提示的LLM代理，ASearcher能够自主合成高质量的问答，创建大规模的问答数据集。经过RL训练，ASearcher的代理在多个基准测试中显著提高了性能，展示了其在复杂搜索任务中的强大能力。'}}}, {'id': 'https://huggingface.co/papers/2508.09138', 'title': 'Time Is a Feature: Exploiting Temporal Dynamics in Diffusion Language\n  Models', 'url': 'https://huggingface.co/papers/2508.09138', 'abstract': 'Two methods, Temporal Self-Consistency Voting and Temporal Consistency Reinforcement, improve diffusion large language models by leveraging temporal consistency in intermediate predictions.  \t\t\t\t\tAI-generated summary \t\t\t\t Diffusion large language models (dLLMs) generate text through iterative denoising, yet current decoding strategies discard rich intermediate predictions in favor of the final output. Our work here reveals a critical phenomenon, temporal oscillation, where correct answers often emerge in the middle process, but are overwritten in later denoising steps. To address this issue, we introduce two complementary methods that exploit temporal consistency: 1) Temporal Self-Consistency Voting, a training-free, test-time decoding strategy that aggregates predictions across denoising steps to select the most consistent output; and 2) a post-training method termed Temporal Consistency Reinforcement, which uses Temporal Semantic Entropy (TSE), a measure of semantic stability across intermediate predictions, as a reward signal to encourage stable generations. Empirical results across multiple benchmarks demonstrate the effectiveness of our approach. Using the negative TSE reward alone, we observe a remarkable average improvement of 24.7% on the Countdown dataset over an existing dLLM. Combined with the accuracy reward, we achieve absolute gains of 2.0% on GSM8K, 4.3% on MATH500, 6.6% on SVAMP, and 25.3% on Countdown, respectively. Our findings underscore the untapped potential of temporal dynamics in dLLMs and offer two simple yet effective tools to harness them.', 'score': 19, 'issue_id': 5317, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': 'fc4661402e36332d', 'authors': ['Wen Wang', 'Bozhen Fang', 'Chenchen Jing', 'Yongliang Shen', 'Yangyi Shen', 'Qiuyu Wang', 'Hao Ouyang', 'Hao Chen', 'Chunhua Shen'], 'affiliations': ['Ant Group', 'Stanford University', 'Zhejiang University', 'Zhejiang University of Technology'], 'pdf_title_img': 'assets/pdf/title_img/2508.09138.jpg', 'data': {'categories': ['#training', '#optimization', '#diffusion', '#benchmark', '#rl'], 'emoji': '⏳', 'ru': {'title': 'Использование временной динамики для улучшения диффузионных языковых моделей', 'desc': 'Статья представляет два метода улучшения диффузионных больших языковых моделей (dLLM): Временное самосогласованное голосование и Усиление временной согласованности. Эти методы используют временную согласованность в промежуточных предсказаниях модели для повышения качества генерации текста. Авторы обнаружили феномен временных осцилляций, когда правильные ответы часто появляются в середине процесса, но перезаписываются на последних шагах. Эмпирические результаты показывают значительное улучшение производительности на нескольких бенчмарках, включая GSM8K, MATH500, SVAMP и Countdown.'}, 'en': {'title': 'Harnessing Temporal Consistency for Better Language Model Outputs', 'desc': 'This paper presents two innovative methods to enhance diffusion large language models (dLLMs) by focusing on the temporal consistency of their predictions. The authors identify a problem called temporal oscillation, where valuable intermediate outputs are lost during the final denoising process. To combat this, they propose Temporal Self-Consistency Voting, which aggregates predictions from various steps to find the most reliable output, and Temporal Consistency Reinforcement, which uses a reward based on Temporal Semantic Entropy to promote stable outputs. Their experiments show significant improvements in performance across several benchmarks, highlighting the importance of leveraging temporal dynamics in language model generation.'}, 'zh': {'title': '利用时间一致性提升大语言模型的性能', 'desc': '本文提出了两种方法，时间自一致性投票和时间一致性强化，旨在通过利用中间预测的时间一致性来改进扩散大语言模型（dLLMs）。研究发现，在去噪的过程中，正确答案往往在中间步骤中出现，但在后续步骤中被覆盖。为了解决这个问题，提出的时间自一致性投票方法在测试时聚合多个去噪步骤的预测，以选择最一致的输出；而时间一致性强化则使用时间语义熵作为奖励信号，鼓励生成稳定的结果。实验证明，这些方法在多个基准测试中显著提高了模型的性能。'}}}, {'id': 'https://huggingface.co/papers/2508.07409', 'title': 'CharacterShot: Controllable and Consistent 4D Character Animation', 'url': 'https://huggingface.co/papers/2508.07409', 'abstract': 'CharacterShot is a 4D character animation framework that uses a DiT-based model and dual-attention module to generate consistent 3D animations from a single image and 2D pose sequence.  \t\t\t\t\tAI-generated summary \t\t\t\t In this paper, we propose CharacterShot, a controllable and consistent 4D character animation framework that enables any individual designer to create dynamic 3D characters (i.e., 4D character animation) from a single reference character image and a 2D pose sequence. We begin by pretraining a powerful 2D character animation model based on a cutting-edge DiT-based image-to-video model, which allows for any 2D pose sequnce as controllable signal. We then lift the animation model from 2D to 3D through introducing dual-attention module together with camera prior to generate multi-view videos with spatial-temporal and spatial-view consistency. Finally, we employ a novel neighbor-constrained 4D gaussian splatting optimization on these multi-view videos, resulting in continuous and stable 4D character representations. Moreover, to improve character-centric performance, we construct a large-scale dataset Character4D, containing 13,115 unique characters with diverse appearances and motions, rendered from multiple viewpoints. Extensive experiments on our newly constructed benchmark, CharacterBench, demonstrate that our approach outperforms current state-of-the-art methods. Code, models, and datasets will be publicly available at https://github.com/Jeoyal/CharacterShot.', 'score': 19, 'issue_id': 5320, 'pub_date': '2025-08-10', 'pub_date_card': {'ru': '10 августа', 'en': 'August 10', 'zh': '8月10日'}, 'hash': '9990661aef1ea53c', 'authors': ['Junyao Gao', 'Jiaxing Li', 'Wenran Liu', 'Yanhong Zeng', 'Fei Shen', 'Kai Chen', 'Yanan Sun', 'Cairong Zhao'], 'affiliations': ['Nanyang Technological University', 'National University of Singapore', 'Shanghai AI Lab', 'Tongji University'], 'pdf_title_img': 'assets/pdf/title_img/2508.07409.jpg', 'data': {'categories': ['#dataset', '#benchmark', '#3d', '#optimization', '#open_source'], 'emoji': '🎭', 'ru': {'title': 'Оживление персонажей в 3D из одного изображения', 'desc': 'CharacterShot - это фреймворк для 4D-анимации персонажей, использующий модель на основе DiT и модуль двойного внимания. Он позволяет создавать согласованные 3D-анимации из одного изображения и последовательности 2D-поз. Фреймворк включает предобученную модель 2D-анимации персонажей и механизм преобразования 2D в 3D с помощью двойного внимания и камерного приора. Для улучшения результатов авторы создали масштабный датасет Character4D и новый бенчмарк CharacterBench.'}, 'en': {'title': 'Transforming 2D Images into Dynamic 4D Animations!', 'desc': 'CharacterShot is a novel framework for creating 4D character animations from a single image and a sequence of 2D poses. It utilizes a DiT-based model to pretrain a 2D animation model, allowing designers to control the animation process effectively. The framework incorporates a dual-attention module and camera prior to enhance the transition from 2D to 3D, ensuring consistency in both spatial and temporal dimensions. Additionally, it introduces a neighbor-constrained 4D Gaussian splatting optimization to produce stable and continuous character representations, supported by a large dataset of diverse characters.'}, 'zh': {'title': '从单图像生成动态3D角色动画的创新框架', 'desc': 'CharacterShot是一个基于DiT模型和双重注意力模块的4D角色动画框架，能够从单一图像和2D姿势序列生成一致的3D动画。该框架允许设计师控制动画过程，通过预训练的2D角色动画模型来处理任意2D姿势序列。通过引入双重注意力模块和相机先验，模型将动画从2D提升到3D，生成具有时空和视角一致性的多视角视频。最后，采用新颖的邻域约束4D高斯点云优化，确保生成的4D角色表现连续稳定。'}}}, {'id': 'https://huggingface.co/papers/2508.08088', 'title': 'HierSearch: A Hierarchical Enterprise Deep Search Framework Integrating\n  Local and Web Searches', 'url': 'https://huggingface.co/papers/2508.08088', 'abstract': 'HierSearch, a hierarchical agentic deep search framework using hierarchical RL, improves performance in multi-source retrieval tasks by coordinating local and Web search agents and refining knowledge.  \t\t\t\t\tAI-generated summary \t\t\t\t Recently, large reasoning models have demonstrated strong mathematical and coding abilities, and deep search leverages their reasoning capabilities in challenging information retrieval tasks. Existing deep search works are generally limited to a single knowledge source, either local or the Web. However, enterprises often require private deep search systems that can leverage search tools over both local and the Web corpus. Simply training an agent equipped with multiple search tools using flat reinforcement learning (RL) is a straightforward idea, but it has problems such as low training data efficiency and poor mastery of complex tools. To address the above issue, we propose a hierarchical agentic deep search framework, HierSearch, trained with hierarchical RL. At the low level, a local deep search agent and a Web deep search agent are trained to retrieve evidence from their corresponding domains. At the high level, a planner agent coordinates low-level agents and provides the final answer. Moreover, to prevent direct answer copying and error propagation, we design a knowledge refiner that filters out hallucinations and irrelevant evidence returned by low-level agents. Experiments show that HierSearch achieves better performance compared to flat RL, and outperforms various deep search and multi-source retrieval-augmented generation baselines in six benchmarks across general, finance, and medical domains.', 'score': 18, 'issue_id': 5317, 'pub_date': '2025-08-11', 'pub_date_card': {'ru': '11 августа', 'en': 'August 11', 'zh': '8月11日'}, 'hash': '7e2ae00381bb3360', 'authors': ['Jiejun Tan', 'Zhicheng Dou', 'Yan Yu', 'Jiehan Cheng', 'Qiang Ju', 'Jian Xie', 'Ji-Rong Wen'], 'affiliations': ['Baichuan Intelligent Technology', 'Gaoling School of Artificial Intelligence, Renmin University of China'], 'pdf_title_img': 'assets/pdf/title_img/2508.08088.jpg', 'data': {'categories': ['#hallucinations', '#rag', '#reasoning', '#agents', '#benchmark', '#rl', '#healthcare'], 'emoji': '🔍', 'ru': {'title': 'Иерархический глубокий поиск для эффективного многоисточникового извлечения информации', 'desc': 'HierSearch - это иерархическая система глубокого поиска, использующая иерархическое обучение с подкреплением для улучшения многоисточникового поиска. Она координирует локальных и веб-агентов поиска, а также уточняет полученные знания. HierSearch превосходит плоское обучение с подкреплением и другие методы в шести тестах в общей, финансовой и медицинской областях. Система предотвращает прямое копирование ответов и распространение ошибок с помощью специального фильтра знаний.'}, 'en': {'title': 'HierSearch: Elevating Multi-Source Retrieval with Hierarchical RL', 'desc': 'HierSearch is a hierarchical framework that enhances multi-source information retrieval by using hierarchical reinforcement learning (RL). It consists of local and Web search agents that work together to gather relevant information from different sources. A planner agent oversees these agents to ensure accurate and coherent answers, while a knowledge refiner filters out incorrect or irrelevant data. This approach significantly improves performance over traditional flat RL methods and outperforms existing deep search systems across various domains.'}, 'zh': {'title': '层次化智能深度搜索，提升多源检索性能', 'desc': 'HierSearch是一种层次化的智能深度搜索框架，利用层次化强化学习来提升多源检索任务的性能。该框架通过协调本地搜索代理和网络搜索代理，优化知识获取过程。与传统的单一知识源深度搜索不同，HierSearch能够同时利用本地和网络数据，满足企业对私有深度搜索系统的需求。此外，HierSearch还设计了知识精炼器，以过滤低级代理返回的错误信息和无关证据，从而提高最终答案的准确性。'}}}, {'id': 'https://huggingface.co/papers/2508.05615', 'title': 'Test-Time Reinforcement Learning for GUI Grounding via Region\n  Consistency', 'url': 'https://huggingface.co/papers/2508.05615', 'abstract': 'GUI-RC and GUI-RCPO enhance GUI grounding accuracy by leveraging spatial consistency and reinforcement learning without additional training data.  \t\t\t\t\tAI-generated summary \t\t\t\t Graphical User Interface (GUI) grounding, the task of mapping natural language instructions to precise screen coordinates, is fundamental to autonomous GUI agents. While existing methods achieve strong performance through extensive supervised training or reinforcement learning with labeled rewards, they remain constrained by the cost and availability of pixel-level annotations. We observe that when models generate multiple predictions for the same GUI element, the spatial overlap patterns reveal implicit confidence signals that can guide more accurate localization. Leveraging this insight, we propose GUI-RC (Region Consistency), a test-time scaling method that constructs spatial voting grids from multiple sampled predictions to identify consensus regions where models show highest agreement. Without any training, GUI-RC improves accuracy by 2-3% across various architectures on ScreenSpot benchmarks. We further introduce GUI-RCPO (Region Consistency Policy Optimization), which transforms these consistency patterns into rewards for test-time reinforcement learning. By computing how well each prediction aligns with the collective consensus, GUI-RCPO enables models to iteratively refine their outputs on unlabeled data during inference. Extensive experiments demonstrate the generality of our approach: GUI-RC boosts Qwen2.5-VL-3B-Instruct from 80.11% to 83.57% on ScreenSpot-v2, while GUI-RCPO further improves it to 85.14% through self-supervised optimization. Our approach reveals the untapped potential of test-time scaling and test-time reinforcement learning for GUI grounding, offering a promising path toward more robust and data-efficient GUI agents.', 'score': 10, 'issue_id': 5317, 'pub_date': '2025-08-07', 'pub_date_card': {'ru': '7 августа', 'en': 'August 7', 'zh': '8月7日'}, 'hash': 'b571750771c4ba60', 'authors': ['Yong Du', 'Yuchen Yan', 'Fei Tang', 'Zhengxi Lu', 'Chang Zong', 'Weiming Lu', 'Shengpei Jiang', 'Yongliang Shen'], 'affiliations': ['Central South University', 'SF Technology', 'Zhejiang University', 'Zhejiang University of Science and Technology'], 'pdf_title_img': 'assets/pdf/title_img/2508.05615.jpg', 'data': {'categories': ['#inference', '#optimization', '#agents', '#rlhf', '#rl'], 'emoji': '🖥️', 'ru': {'title': 'Повышение точности ИИ-агентов для GUI без дополнительных данных', 'desc': 'В статье представлены методы GUI-RC и GUI-RCPO для повышения точности привязки графического интерфейса без использования дополнительных обучающих данных. GUI-RC использует пространственную согласованность для идентификации областей с наибольшим согласием модели. GUI-RCPO применяет обучение с подкреплением во время вывода, используя сигналы согласованности в качестве награды. Эксперименты показывают значительное улучшение точности на бенчмарке ScreenSpot для различных архитектур моделей.'}, 'en': {'title': 'Enhancing GUI Grounding with Spatial Consistency and Reinforcement Learning', 'desc': 'This paper presents GUI-RC and GUI-RCPO, two innovative methods that improve the accuracy of GUI grounding by utilizing spatial consistency and reinforcement learning without needing extra training data. GUI grounding involves translating natural language commands into specific screen coordinates, which is crucial for autonomous GUI agents. The authors propose a technique called GUI-RC that uses spatial voting grids to identify areas of agreement among multiple predictions, enhancing localization accuracy. Additionally, GUI-RCPO applies reinforcement learning to refine predictions based on how well they align with the consensus, leading to significant performance improvements on benchmark tests.'}, 'zh': {'title': '提升GUI定位准确性的创新方法', 'desc': '本文提出了GUI-RC和GUI-RCPO两种方法，以提高图形用户界面（GUI）定位的准确性。这些方法利用空间一致性和强化学习，而无需额外的训练数据。GUI-RC通过构建空间投票网格，从多个预测中识别共识区域，从而在测试时提高准确性。GUI-RCPO则将一致性模式转化为奖励，允许模型在推理过程中对未标记数据进行自我优化。'}}}, {'id': 'https://huggingface.co/papers/2508.05399', 'title': 'UNCAGE: Contrastive Attention Guidance for Masked Generative\n  Transformers in Text-to-Image Generation', 'url': 'https://huggingface.co/papers/2508.05399', 'abstract': 'UNCAGE, a training-free method using contrastive attention guidance, enhances compositional fidelity in text-to-image generation by prioritizing the unmasking of object-representing tokens.  \t\t\t\t\tAI-generated summary \t\t\t\t Text-to-image (T2I) generation has been actively studied using Diffusion Models and Autoregressive Models. Recently, Masked Generative Transformers have gained attention as an alternative to Autoregressive Models to overcome the inherent limitations of causal attention and autoregressive decoding through bidirectional attention and parallel decoding, enabling efficient and high-quality image generation. However, compositional T2I generation remains challenging, as even state-of-the-art Diffusion Models often fail to accurately bind attributes and achieve proper text-image alignment. While Diffusion Models have been extensively studied for this issue, Masked Generative Transformers exhibit similar limitations but have not been explored in this context. To address this, we propose Unmasking with Contrastive Attention Guidance (UNCAGE), a novel training-free method that improves compositional fidelity by leveraging attention maps to prioritize the unmasking of tokens that clearly represent individual objects. UNCAGE consistently improves performance in both quantitative and qualitative evaluations across multiple benchmarks and metrics, with negligible inference overhead. Our code is available at https://github.com/furiosa-ai/uncage.', 'score': 9, 'issue_id': 5317, 'pub_date': '2025-08-07', 'pub_date_card': {'ru': '7 августа', 'en': 'August 7', 'zh': '8月7日'}, 'hash': '2e4f45b5a135f498', 'authors': ['Wonjun Kang', 'Byeongkeun Ahn', 'Minjae Lee', 'Kevin Galim', 'Seunghyuk Oh', 'Hyung Il Koo', 'Nam Ik Cho'], 'affiliations': ['Ajou University', 'FuriosaAI', 'Independent Researcher', 'Seoul National University'], 'pdf_title_img': 'assets/pdf/title_img/2508.05399.jpg', 'data': {'categories': ['#training', '#optimization', '#diffusion', '#benchmark', '#cv'], 'emoji': '🎭', 'ru': {'title': 'Точная композиция в генерации изображений через умное раскрытие токенов', 'desc': 'UNCAGE - это новый метод без дополнительного обучения, улучшающий композиционную точность в генерации изображений по тексту. Он использует контрастное управление вниманием для приоритизации раскрытия токенов, представляющих отдельные объекты. Метод применяется к маскированным генеративным трансформерам, которые ранее не исследовались в контексте композиционной генерации. UNCAGE показывает улучшение производительности по количественным и качественным оценкам на различных бенчмарках.'}, 'en': {'title': 'Enhancing Text-to-Image Generation with UNCAGE', 'desc': 'The paper introduces UNCAGE, a novel method that enhances the quality of text-to-image (T2I) generation without requiring additional training. It utilizes contrastive attention guidance to focus on unmasking tokens that represent distinct objects, improving compositional fidelity in generated images. This approach addresses the limitations of existing models, particularly in accurately binding attributes and achieving text-image alignment. The results show that UNCAGE outperforms previous methods in both quantitative and qualitative assessments while maintaining low computational overhead.'}, 'zh': {'title': 'UNCAGE：提升文本到图像生成的组合保真度', 'desc': 'UNCAGE是一种无训练的方法，利用对比注意力引导来增强文本到图像生成中的组合保真度。该方法通过优先解码清晰表示单个对象的标记，来改善文本与图像的对齐。尽管现有的扩散模型在组合生成方面存在挑战，UNCAGE在多个基准测试中表现出色，提升了生成质量。该方法在推理时几乎没有额外开销，展示了其高效性和实用性。'}}}, {'id': 'https://huggingface.co/papers/2508.09062', 'title': 'VertexRegen: Mesh Generation with Continuous Level of Detail', 'url': 'https://huggingface.co/papers/2508.09062', 'abstract': 'VertexRegen generates meshes with continuous detail by reversing edge collapse through a generative model, offering anytime generation and flexibility in detail levels.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce VertexRegen, a novel mesh generation framework that enables generation at a continuous level of detail. Existing autoregressive methods generate meshes in a partial-to-complete manner and thus intermediate steps of generation represent incomplete structures. VertexRegen takes inspiration from progressive meshes and reformulates the process as the reversal of edge collapse, i.e. vertex split, learned through a generative model. Experimental results demonstrate that VertexRegen produces meshes of comparable quality to state-of-the-art methods while uniquely offering anytime generation with the flexibility to halt at any step to yield valid meshes with varying levels of detail.', 'score': 8, 'issue_id': 5320, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': '1881627a4d7d9e0c', 'authors': ['Xiang Zhang', 'Yawar Siddiqui', 'Armen Avetisyan', 'Chris Xie', 'Jakob Engel', 'Henry Howard-Jenkins'], 'affiliations': ['Meta Reality Labs Research', 'UC San Diego'], 'pdf_title_img': 'assets/pdf/title_img/2508.09062.jpg', 'data': {'categories': ['#games', '#optimization', '#3d'], 'emoji': '🔍', 'ru': {'title': 'Гибкая генерация 3D-сеток с любым уровнем детализации', 'desc': 'VertexRegen - это новая система генерации трехмерных сеток с непрерывным уровнем детализации. Она использует обратный процесс схлопывания ребер, обучаемый с помощью генеративной модели. В отличие от существующих авторегрессивных методов, VertexRegen позволяет получать полноценные сетки на любом этапе генерации. Эксперименты показывают, что качество получаемых сеток сопоставимо с современными методами, но при этом обеспечивается гибкость в выборе уровня детализации.'}, 'en': {'title': 'VertexRegen: Anytime Mesh Generation with Continuous Detail', 'desc': 'VertexRegen is a new framework for generating 3D meshes that allows for continuous detail levels. Unlike traditional methods that build meshes from incomplete structures, VertexRegen reverses the edge collapse process, effectively splitting vertices to create detailed meshes. This approach is guided by a generative model, which learns how to produce high-quality meshes. The framework also supports anytime generation, meaning users can stop the process at any point to obtain valid meshes with different levels of detail.'}, 'zh': {'title': 'VertexRegen：灵活的连续细节网格生成', 'desc': 'VertexRegen是一种新颖的网格生成框架，能够以连续的细节级别生成网格。与现有的自回归方法不同，VertexRegen通过逆向边缘合并的方式进行生成，即通过顶点分裂来实现。该方法借鉴了渐进式网格的思想，并通过生成模型进行学习。实验结果表明，VertexRegen生成的网格质量与最先进的方法相当，同时提供了随时生成的灵活性，可以在任意步骤停止以获得不同细节级别的有效网格。'}}}, {'id': 'https://huggingface.co/papers/2508.08665', 'title': 'Aryabhata: An exam-focused language model for JEE Math', 'url': 'https://huggingface.co/papers/2508.08665', 'abstract': 'Aryabhata 1.0, a compact math reasoning model, outperforms existing models on educational exams and benchmarks by using supervised fine-tuning, reinforcement learning with verifiable rewards, and novel exploration strategies.  \t\t\t\t\tAI-generated summary \t\t\t\t We present Aryabhata 1.0, a compact 7B parameter math reasoning model optimized for the Indian academic exam, the Joint Entrance Examination (JEE). Despite rapid progress in large language models (LLMs), current models often remain unsuitable for educational use. Aryabhata 1.0 is built by merging strong open-weight reasoning models, followed by supervised fine-tuning (SFT) with curriculum learning on verified chain-of-thought (CoT) traces curated through best-of-n rejection sampling. To further boost performance, we apply reinforcement learning with verifiable rewards (RLVR) using A2C objective with group-relative advantage estimation alongwith novel exploration strategies such as Adaptive Group Resizing and Temperature Scaling. Evaluated on both in-distribution (JEE Main 2025) and out-of-distribution (MATH, GSM8K) benchmarks, Aryabhata outperforms existing models in accuracy and efficiency, while offering pedagogically useful step-by-step reasoning. We release Aryabhata as a foundation model to advance exam-centric, open-source small language models. This marks our first open release for community feedback (https://huggingface.co/PhysicsWallahAI/Aryabhata-1.0{Aryabhata 1.0 on Hugging Face}); PW is actively training future models to further improve learning outcomes for students.', 'score': 7, 'issue_id': 5323, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': 'c9693974b3ce4cf2', 'authors': ['Ritvik Rastogi', 'Sachin Dharashivkar', 'Sandeep Varma'], 'affiliations': ['AthenaAgent', 'PhysicsWallah'], 'pdf_title_img': 'assets/pdf/title_img/2508.08665.jpg', 'data': {'categories': ['#small_models', '#dataset', '#reasoning', '#training', '#open_source', '#rl', '#math'], 'emoji': '🧮', 'ru': {'title': 'Компактная ИИ-модель превосходит аналоги в математических рассуждениях', 'desc': 'Представлена модель Aryabhata 1.0 - компактная языковая модель для математических рассуждений с 7 миллиардами параметров. Модель оптимизирована для индийского вступительного экзамена JEE и превосходит существующие модели на образовательных тестах. Aryabhata 1.0 использует контролируемое обучение, обучение с подкреплением с проверяемыми наградами и новые стратегии исследования. Модель демонстрирует высокую точность и эффективность как на целевых, так и на сторонних наборах данных, предоставляя пошаговые рассуждения.'}, 'en': {'title': 'Revolutionizing Math Reasoning for Education with Aryabhata 1.0', 'desc': 'Aryabhata 1.0 is a compact math reasoning model designed specifically for the Joint Entrance Examination (JEE) in India. It utilizes supervised fine-tuning and reinforcement learning with verifiable rewards to enhance its performance on educational tasks. The model incorporates innovative exploration strategies to improve its reasoning capabilities, allowing it to provide detailed step-by-step solutions. Evaluated against various benchmarks, Aryabhata 1.0 demonstrates superior accuracy and efficiency compared to existing models, making it a valuable tool for educational purposes.'}, 'zh': {'title': 'Aryabhata 1.0：教育考试的数学推理新标杆', 'desc': 'Aryabhata 1.0 是一个紧凑的数学推理模型，专为印度的联合入学考试（JEE）优化。它通过监督微调、可验证奖励的强化学习和新颖的探索策略，超越了现有模型的表现。该模型结合了强大的开放权重推理模型，并采用了课程学习和链式思维的验证样本进行训练。经过评估，Aryabhata 在准确性和效率上均优于现有模型，同时提供了有助于教学的逐步推理过程。'}}}, {'id': 'https://huggingface.co/papers/2508.08940', 'title': 'Train Long, Think Short: Curriculum Learning for Efficient Reasoning', 'url': 'https://huggingface.co/papers/2508.08940', 'abstract': 'A curriculum learning strategy using Group Relative Policy Optimization (GRPO) enhances the reasoning abilities of large language models by progressively tightening token budgets, improving accuracy and token efficiency.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent work on enhancing the reasoning abilities of large language models (LLMs) has introduced explicit length control as a means of constraining computational cost while preserving accuracy. However, existing approaches rely on fixed-length training budgets, which do not take advantage of the natural progression from exploration to compression during learning. In this work, we propose a curriculum learning strategy for length-controlled reasoning using Group Relative Policy Optimization (GRPO). Our method starts with generous token budgets and gradually tightens them over training, encouraging models to first discover effective solution strategies and then distill them into more concise reasoning traces. We augment GRPO with a reward function that balances three signals: task correctness (via verifier feedback), length efficiency, and formatting adherence (via structural tags). Experiments on GSM8K, MATH500, SVAMP, College Math, and GSM+ demonstrate that curriculum-based training consistently outperforms fixed-budget baselines at the same final budget, achieving higher accuracy and significantly improved token efficiency. We further ablate the impact of reward weighting and decay schedule design, showing that progressive constraint serves as a powerful inductive bias for training efficient reasoning models. Our code and checkpoints are released at: https://github.com/hammoudhasan/curriculum_grpo.', 'score': 5, 'issue_id': 5323, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': '72998e00bb3562ea', 'authors': ['Hasan Abed Al Kader Hammoud', 'Kumail Alhamoud', 'Abed Hammoud', 'Elie Bou-Zeid', 'Marzyeh Ghassemi', 'Bernard Ghanem'], 'affiliations': ['King Abdullah University of Science and Technology (KAUST), Saudi Arabia', 'Massachusetts Institute of Technology (MIT), Cambridge, MA, USA', 'Princeton University, Princeton, NJ, USA'], 'pdf_title_img': 'assets/pdf/title_img/2508.08940.jpg', 'data': {'categories': ['#reasoning', '#rlhf', '#optimization', '#training', '#math'], 'emoji': '🧠', 'ru': {'title': 'Эффективное обучение языковых моделей через постепенное сжатие рассуждений', 'desc': 'Эта статья представляет стратегию обучения с учителем, использующую Group Relative Policy Optimization (GRPO) для улучшения способностей больших языковых моделей к рассуждению. Метод постепенно ужесточает ограничения на количество токенов, что позволяет моделям сначала находить эффективные стратегии решения, а затем сжимать их в более краткие цепочки рассуждений. Авторы дополняют GRPO функцией вознаграждения, учитывающей правильность задачи, эффективность длины и соблюдение форматирования. Эксперименты на нескольких наборах данных показывают, что этот подход превосходит базовые модели с фиксированным бюджетом токенов, достигая более высокой точности и значительно улучшенной эффективности использования токенов.'}, 'en': {'title': 'Progressive Learning for Efficient Reasoning in LLMs', 'desc': 'This paper presents a novel curriculum learning strategy that utilizes Group Relative Policy Optimization (GRPO) to enhance the reasoning capabilities of large language models (LLMs). The approach involves starting with a generous token budget and progressively tightening it, allowing models to first explore various solution strategies before refining them into concise reasoning. By incorporating a reward function that balances task correctness, length efficiency, and formatting adherence, the method improves both accuracy and token efficiency. Experiments demonstrate that this curriculum-based training consistently outperforms traditional fixed-budget methods across multiple datasets, highlighting the effectiveness of progressive constraints in model training.'}, 'zh': {'title': '课程学习提升推理能力的策略', 'desc': '本文提出了一种基于课程学习策略的长度控制推理方法，使用群体相对策略优化（GRPO）来增强大型语言模型的推理能力。该方法通过逐步收紧令牌预算，鼓励模型首先探索有效的解决策略，然后将其提炼为更简洁的推理过程。我们引入了一种奖励函数，平衡任务正确性、长度效率和格式遵循三个信号。实验结果表明，基于课程的训练在相同的最终预算下，始终优于固定预算的基线，达到了更高的准确性和显著提高的令牌效率。'}}}, {'id': 'https://huggingface.co/papers/2508.06964', 'title': 'Adversarial Video Promotion Against Text-to-Video Retrieval', 'url': 'https://huggingface.co/papers/2508.06964', 'abstract': 'The Video Promotion attack (ViPro) enhances the robustness of text-to-video retrieval (T2VR) by promoting videos towards selected queries, demonstrating significant improvements over existing baselines in various attack scenarios.  \t\t\t\t\tAI-generated summary \t\t\t\t Thanks to the development of cross-modal models, text-to-video retrieval (T2VR) is advancing rapidly, but its robustness remains largely unexamined. Existing attacks against T2VR are designed to push videos away from queries, i.e., suppressing the ranks of videos, while the attacks that pull videos towards selected queries, i.e., promoting the ranks of videos, remain largely unexplored. These attacks can be more impactful as attackers may gain more views/clicks for financial benefits and widespread (mis)information. To this end, we pioneer the first attack against T2VR to promote videos adversarially, dubbed the Video Promotion attack (ViPro). We further propose Modal Refinement (MoRe) to capture the finer-grained, intricate interaction between visual and textual modalities to enhance black-box transferability. Comprehensive experiments cover 2 existing baselines, 3 leading T2VR models, 3 prevailing datasets with over 10k videos, evaluated under 3 scenarios. All experiments are conducted in a multi-target setting to reflect realistic scenarios where attackers seek to promote the video regarding multiple queries simultaneously. We also evaluated our attacks for defences and imperceptibility. Overall, ViPro surpasses other baselines by over 30/10/4% for white/grey/black-box settings on average. Our work highlights an overlooked vulnerability, provides a qualitative analysis on the upper/lower bound of our attacks, and offers insights into potential counterplays. Code will be publicly available at https://github.com/michaeltian108/ViPro.', 'score': 5, 'issue_id': 5323, 'pub_date': '2025-08-09', 'pub_date_card': {'ru': '9 августа', 'en': 'August 9', 'zh': '8月9日'}, 'hash': '25b0548ad7d6f59c', 'authors': ['Qiwei Tian', 'Chenhao Lin', 'Zhengyu Zhao', 'Qian Li', 'Shuai Liu', 'Chao Shen'], 'affiliations': ['Xian Jiaotong University'], 'pdf_title_img': 'assets/pdf/title_img/2508.06964.jpg', 'data': {'categories': ['#multimodal', '#security', '#video'], 'emoji': '🎥', 'ru': {'title': 'ViPro: Новый метод атаки для продвижения видео в системах поиска', 'desc': 'Эта статья представляет новый метод атаки на системы поиска видео по текстовому запросу, названный Video Promotion (ViPro). В отличие от существующих подходов, ViPro нацелен на продвижение видео к определенным запросам, а не на их подавление. Авторы предлагают технику Modal Refinement (MoRe) для улучшения переносимости атаки между различными моделями. Эксперименты показывают значительное превосходство ViPro над базовыми методами в различных сценариях атак.'}, 'en': {'title': 'Promoting Videos: A New Threat to Text-to-Video Retrieval', 'desc': 'The Video Promotion attack (ViPro) introduces a novel approach to enhance the robustness of text-to-video retrieval (T2VR) systems by promoting videos towards specific queries. Unlike traditional attacks that aim to suppress video rankings, ViPro focuses on increasing the visibility of videos, which can lead to greater financial gains for attackers. The paper also presents Modal Refinement (MoRe), a technique that improves the interaction between visual and textual data, enhancing the effectiveness of the attack across different scenarios. Comprehensive experiments demonstrate that ViPro significantly outperforms existing methods, revealing a critical vulnerability in T2VR systems and suggesting avenues for future defenses.'}, 'zh': {'title': '视频推广攻击：提升T2VR鲁棒性的创新方法', 'desc': '视频推广攻击（ViPro）通过将视频向选定查询推广，增强了文本到视频检索（T2VR）的鲁棒性。与现有的攻击方法不同，ViPro专注于提升视频的排名，而不是将其压制。我们还提出了模态精炼（MoRe）方法，以捕捉视觉和文本模态之间更细致的交互，从而提高黑箱转移性。实验结果显示，ViPro在多种攻击场景下的表现优于现有基线，展示了这一领域被忽视的脆弱性。'}}}, {'id': 'https://huggingface.co/papers/2508.09101', 'title': 'AutoCodeBench: Large Language Models are Automatic Code Benchmark\n  Generators', 'url': 'https://huggingface.co/papers/2508.09101', 'abstract': 'AutoCodeGen creates a large-scale, multilingual code generation benchmark, AutoCodeBench, to evaluate LLMs on diverse and complex tasks without manual annotations.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have demonstrated remarkable capabilities across various domains, with code generation emerging as a key area of focus. While numerous benchmarks have been proposed to evaluate their code generation abilities, these benchmarks face several critical limitations. First, they often rely on manual annotations, which are time-consuming and difficult to scale across different programming languages and problem complexities. Second, most existing benchmarks focus primarily on Python, while the few multilingual benchmarks suffer from limited difficulty and uneven language distribution. To address these challenges, we propose AutoCodeGen, an automated method for generating high-difficulty multilingual code generation datasets without manual annotations. AutoCodeGen ensures the correctness and completeness of test cases by generating test inputs with LLMs and obtaining test outputs through a multilingual sandbox, while achieving high data quality through reverse-order problem generation and multiple filtering steps. Using this novel method, we introduce AutoCodeBench, a large-scale code generation benchmark comprising 3,920 problems evenly distributed across 20 programming languages. It is specifically designed to evaluate LLMs on challenging, diverse, and practical multilingual tasks. We evaluate over 30 leading open-source and proprietary LLMs on AutoCodeBench and its simplified version AutoCodeBench-Lite. The results show that even the most advanced LLMs struggle with the complexity, diversity, and multilingual nature of these tasks. Besides, we introduce AutoCodeBench-Complete, specifically designed for base models to assess their few-shot code generation capabilities. We hope the AutoCodeBench series will serve as a valuable resource and inspire the community to focus on more challenging and practical multilingual code generation scenarios.', 'score': 4, 'issue_id': 5318, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': '6dd7cffc5f881c6a', 'authors': ['Jason Chou', 'Ao Liu', 'Yuchi Deng', 'Zhiying Zeng', 'Tao Zhang', 'Haotian Zhu', 'Jianwei Cai', 'Yue Mao', 'Chenchen Zhang', 'Lingyun Tan', 'Ziyan Xu', 'Bohui Zhai', 'Hengyi Liu', 'Speed Zhu', 'Wiggin Zhou', 'Fengzong Lian'], 'affiliations': ['Hunyuan Team, Tencent'], 'pdf_title_img': 'assets/pdf/title_img/2508.09101.jpg', 'data': {'categories': ['#dataset', '#multilingual', '#games', '#benchmark', '#open_source'], 'emoji': '🖥️', 'ru': {'title': 'AutoCodeBench: автоматизированный многоязычный бенчмарк для оценки генерации кода ИИ', 'desc': 'AutoCodeGen представляет собой метод автоматического создания многоязычного бенчмарка для оценки генерации кода языковыми моделями без ручной аннотации. Он создает набор данных AutoCodeBench, содержащий 3920 задач на 20 языках программирования. AutoCodeBench позволяет оценивать способности больших языковых моделей решать сложные и разнообразные задачи кодирования на разных языках. Результаты показывают, что даже самые продвинутые модели испытывают трудности с комплексностью и многоязычностью этих задач.'}, 'en': {'title': 'Revolutionizing Code Generation Evaluation with AutoCodeBench', 'desc': 'The paper introduces AutoCodeGen, a method for creating a large-scale, multilingual benchmark called AutoCodeBench to evaluate the code generation capabilities of Large Language Models (LLMs). Unlike existing benchmarks that rely on manual annotations and focus mainly on Python, AutoCodeBench offers a diverse set of 3,920 problems across 20 programming languages, ensuring a balanced difficulty level. The benchmark is generated automatically, ensuring high data quality through advanced techniques like reverse-order problem generation and multiple filtering steps. The evaluation of over 30 LLMs on this benchmark reveals that even the most advanced models face challenges with the complexity and diversity of the tasks, highlighting the need for more rigorous testing in multilingual code generation.'}, 'zh': {'title': '自动化多语言代码生成基准的创新', 'desc': 'AutoCodeGen 是一种自动化方法，用于生成高难度的多语言代码生成数据集，而无需人工注释。它通过大型语言模型（LLMs）生成测试输入，并通过多语言沙箱获取测试输出，从而确保测试用例的正确性和完整性。我们推出的 AutoCodeBench 是一个大规模的代码生成基准，包含3920个问题，均匀分布在20种编程语言中，旨在评估 LLMs 在复杂、多样和实际的多语言任务上的表现。研究结果表明，即使是最先进的 LLMs 在这些任务的复杂性和多样性面前也面临挑战。'}}}, {'id': 'https://huggingface.co/papers/2508.08244', 'title': 'Cut2Next: Generating Next Shot via In-Context Tuning', 'url': 'https://huggingface.co/papers/2508.08244', 'abstract': 'Cut2Next, a framework using a Diffusion Transformer with in-context tuning and hierarchical prompting, generates high-quality, cinematically coherent shots that adhere to professional editing patterns.  \t\t\t\t\tAI-generated summary \t\t\t\t Effective multi-shot generation demands purposeful, film-like transitions and strict cinematic continuity. Current methods, however, often prioritize basic visual consistency, neglecting crucial editing patterns (e.g., shot/reverse shot, cutaways) that drive narrative flow for compelling storytelling. This yields outputs that may be visually coherent but lack narrative sophistication and true cinematic integrity. To bridge this, we introduce Next Shot Generation (NSG): synthesizing a subsequent, high-quality shot that critically conforms to professional editing patterns while upholding rigorous cinematic continuity. Our framework, Cut2Next, leverages a Diffusion Transformer (DiT). It employs in-context tuning guided by a novel Hierarchical Multi-Prompting strategy. This strategy uses Relational Prompts to define overall context and inter-shot editing styles. Individual Prompts then specify per-shot content and cinematographic attributes. Together, these guide Cut2Next to generate cinematically appropriate next shots. Architectural innovations, Context-Aware Condition Injection (CACI) and Hierarchical Attention Mask (HAM), further integrate these diverse signals without introducing new parameters. We construct RawCuts (large-scale) and CuratedCuts (refined) datasets, both with hierarchical prompts, and introduce CutBench for evaluation. Experiments show Cut2Next excels in visual consistency and text fidelity. Crucially, user studies reveal a strong preference for Cut2Next, particularly for its adherence to intended editing patterns and overall cinematic continuity, validating its ability to generate high-quality, narratively expressive, and cinematically coherent subsequent shots.', 'score': 4, 'issue_id': 5320, 'pub_date': '2025-08-11', 'pub_date_card': {'ru': '11 августа', 'en': 'August 11', 'zh': '8月11日'}, 'hash': '172314ad94a655f4', 'authors': ['Jingwen He', 'Hongbo Liu', 'Jiajun Li', 'Ziqi Huang', 'Yu Qiao', 'Wanli Ouyang', 'Ziwei Liu'], 'affiliations': ['S-Lab, Nanyang Technological University', 'Shanghai Artificial Intelligence Laboratory', 'The Chinese University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2508.08244.jpg', 'data': {'categories': ['#cv', '#diffusion', '#benchmark', '#story_generation', '#dataset', '#architecture'], 'emoji': '🎬', 'ru': {'title': 'Искусственный интеллект освоил профессиональный киномонтаж', 'desc': 'Cut2Next - это фреймворк для генерации высококачественных кинематографических кадров с использованием диффузионного трансформера. Он применяет in-context tuning и иерархическое промптирование для создания последовательностей кадров, соответствующих профессиональным паттернам монтажа. Cut2Next использует реляционные промпты для определения общего контекста и стилей монтажа, а также индивидуальные промпты для задания содержания и кинематографических атрибутов каждого кадра. Эксперименты показали превосходство Cut2Next в визуальной согласованности и соответствии текстовым описаниям.'}, 'en': {'title': 'Cinematic Continuity in AI-Generated Shots', 'desc': "Cut2Next is a novel framework that utilizes a Diffusion Transformer to generate high-quality video shots that follow professional editing patterns. It addresses the limitations of existing methods that focus mainly on visual consistency, often overlooking essential cinematic techniques that enhance storytelling. By implementing Next Shot Generation (NSG) with in-context tuning and hierarchical prompting, Cut2Next ensures that each generated shot maintains narrative flow and cinematic integrity. The framework's architectural innovations and the creation of specialized datasets enable it to produce visually coherent and narratively rich outputs, as confirmed by user studies favoring its performance."}, 'zh': {'title': '生成高质量电影镜头的智能框架', 'desc': 'Cut2Next是一个框架，利用扩散变换器和上下文调优生成高质量的镜头，符合专业的剪辑模式。该方法解决了当前生成技术在叙事流畅性和剪辑模式上的不足，确保生成的镜头不仅视觉一致，还具备叙事的复杂性。通过引入层次化多提示策略，Cut2Next能够定义整体上下文和镜头间的编辑风格，从而生成符合电影连续性的后续镜头。实验结果表明，Cut2Next在视觉一致性和文本保真度方面表现优异，用户研究也显示出对其剪辑模式的强烈偏好。'}}}, {'id': 'https://huggingface.co/papers/2508.09123', 'title': 'OpenCUA: Open Foundations for Computer-Use Agents', 'url': 'https://huggingface.co/papers/2508.09123', 'abstract': 'OpenCUA is an open-source framework for vision-language models as computer-use agents, featuring an annotation infrastructure, a large-scale dataset, and a scalable pipeline that achieves state-of-the-art performance.  \t\t\t\t\tAI-generated summary \t\t\t\t Vision-language models have demonstrated impressive capabilities as computer-use agents (CUAs) capable of automating diverse computer tasks. As their commercial potential grows, critical details of the most capable CUA systems remain closed. As these agents will increasingly mediate digital interactions and execute consequential decisions on our behalf, the research community needs access to open CUA frameworks to study their capabilities, limitations, and risks. To bridge this gap, we propose OpenCUA, a comprehensive open-source framework for scaling CUA data and foundation models. Our framework consists of: (1) an annotation infrastructure that seamlessly captures human computer-use demonstrations; (2) AgentNet, the first large-scale computer-use task dataset spanning 3 operating systems and 200+ applications and websites; (3) a scalable pipeline that transforms demonstrations into state-action pairs with reflective long Chain-of-Thought reasoning that sustain robust performance gains as data scales. Our end-to-end agent models demonstrate strong performance across CUA benchmarks. In particular, OpenCUA-32B achieves an average success rate of 34.8% on OSWorld-Verified, establishing a new state-of-the-art (SOTA) among open-source models and surpassing OpenAI CUA (GPT-4o). Further analysis confirms that our approach generalizes well across domains and benefits significantly from increased test-time computation. We release our annotation tool, datasets, code, and models to build open foundations for further CUA research.', 'score': 3, 'issue_id': 5323, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': '111b2e6f3de484b8', 'authors': ['Xinyuan Wang', 'Bowen Wang', 'Dunjie Lu', 'Junlin Yang', 'Tianbao Xie', 'Junli Wang', 'Jiaqi Deng', 'Xiaole Guo', 'Yiheng Xu', 'Chen Henry Wu', 'Zhennan Shen', 'Zhuokai Li', 'Ryan Li', 'Xiaochuan Li', 'Junda Chen', 'Boyuan Zheng', 'Peihang Li', 'Fangyu Lei', 'Ruisheng Cao', 'Yeqiao Fu', 'Dongchan Shin', 'Martin Shin', 'Jiarui Hu', 'Yuyan Wang', 'Jixuan Chen', 'Yuxiao Ye', 'Danyang Zhang', 'Dikang Du', 'Hao Hu', 'Huarong Chen', 'Zaida Zhou', 'Yipu Wang', 'Heng Wang', 'Diyi Yang', 'Victor Zhong', 'Flood Sung', 'Y. Charles', 'Zhilin Yang', 'Tao Yu'], 'affiliations': ['Carnegie Mellon University', 'Moonshot AI', 'Stanford University', 'University of Waterloo', 'XLANG Lab, University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2508.09123.jpg', 'data': {'categories': ['#agents', '#dataset', '#reasoning', '#multimodal', '#agi', '#benchmark', '#open_source'], 'emoji': '🖥️', 'ru': {'title': 'OpenCUA: открытая платформа для создания ИИ-ассистентов нового поколения', 'desc': 'OpenCUA - это открытая инфраструктура для моделей компьютерного зрения и обработки естественного языка, действующих как агенты для использования компьютера. Она включает систему аннотирования, масштабный набор данных и расширяемый конвейер, достигающий передовых результатов. Фреймворк состоит из инструмента для записи действий человека на компьютере, датасета AgentNet с задачами для 3 операционных систем и более 200 приложений, а также pipeline для преобразования демонстраций в пары состояние-действие с рефлексивными рассуждениями. Модель OpenCUA-32B достигает нового уровня производительности среди открытых моделей на бенчмарке OSWorld-Verified.'}, 'en': {'title': 'Empowering Research with OpenCUA: The Future of Computer-Use Agents', 'desc': 'OpenCUA is an innovative open-source framework designed for vision-language models that function as computer-use agents (CUAs). It includes a robust annotation infrastructure, a large-scale dataset called AgentNet, and a scalable pipeline that enhances performance through reflective reasoning. The framework allows researchers to access and study the capabilities and limitations of CUAs, which are becoming increasingly important in automating digital tasks. With state-of-the-art results, OpenCUA-32B sets a new benchmark in the field, promoting further research and development in open CUA systems.'}, 'zh': {'title': '开放源代码，推动计算机使用代理的未来', 'desc': 'OpenCUA是一个开源框架，专为视觉-语言模型作为计算机使用代理而设计。它提供了一个注释基础设施、大规模数据集和可扩展的管道，能够实现最先进的性能。该框架包括捕捉人类计算机使用演示的注释工具，以及涵盖多个操作系统和应用程序的大规模计算机使用任务数据集。我们的研究表明，OpenCUA在多个基准测试中表现出色，推动了开放源代码模型的发展。'}}}, {'id': 'https://huggingface.co/papers/2508.08791', 'title': 'Feedback-Driven Tool-Use Improvements in Large Language Models via\n  Automated Build Environments', 'url': 'https://huggingface.co/papers/2508.08791', 'abstract': "An automated pipeline for constructing training environments and a verifiable reward mechanism enhance large language models' tool-use performance without compromising general capabilities.  \t\t\t\t\tAI-generated summary \t\t\t\t Effective tool use is essential for large language models (LLMs) to interact meaningfully with their environment. However, progress is limited by the lack of efficient reinforcement learning (RL) frameworks specifically designed for tool use, due to challenges in constructing stable training environments and designing verifiable reward mechanisms. To address this, we propose an automated environment construction pipeline, incorporating scenario decomposition, document generation, function integration, complexity scaling, and localized deployment. This enables the creation of high-quality training environments that provide detailed and measurable feedback without relying on external tools. Additionally, we introduce a verifiable reward mechanism that evaluates both the precision of tool use and the completeness of task execution. When combined with trajectory data collected from the constructed environments, this mechanism integrates seamlessly with standard RL algorithms to facilitate feedback-driven model training. Experiments on LLMs of varying scales demonstrate that our approach significantly enhances the models' tool-use performance without degrading their general capabilities, regardless of inference modes or training algorithms. Our analysis suggests that these gains result from improved context understanding and reasoning, driven by updates to the lower-layer MLP parameters in models.", 'score': 3, 'issue_id': 5319, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': 'd6c6aa0f12a1c869', 'authors': ['Junjie Ye', 'Changhao Jiang', 'Zhengyin Du', 'Yufei Xu', 'Xuesong Yao', 'Zhiheng Xi', 'Xiaoran Fan', 'Qi Zhang', 'Xuanjing Huang', 'Jiecao Chen'], 'affiliations': ['ByteDance Seed', 'Fudan University'], 'pdf_title_img': 'assets/pdf/title_img/2508.08791.jpg', 'data': {'categories': ['#training', '#reasoning', '#optimization', '#rl'], 'emoji': '🛠️', 'ru': {'title': 'Автоматизация обучения LLM эффективному использованию инструментов', 'desc': 'Предложена автоматизированная система для создания обучающих сред и механизма проверяемого вознаграждения, улучшающая способности больших языковых моделей (LLM) использовать инструменты. Система включает декомпозицию сценариев, генерацию документов, интеграцию функций и масштабирование сложности. Введен механизм вознаграждения, оценивающий точность использования инструментов и полноту выполнения задач. Эксперименты показали значительное улучшение навыков использования инструментов LLM без ухудшения общих возможностей.'}, 'en': {'title': 'Enhancing Tool Use in LLMs with Automated Training Environments', 'desc': 'This paper presents a new method to improve how large language models (LLMs) use tools effectively. It introduces an automated system for creating training environments that are stable and provide clear feedback, which is crucial for reinforcement learning (RL). Additionally, the authors propose a verifiable reward mechanism that assesses how well the models use tools and complete tasks. The results show that this approach enhances the tool-use abilities of LLMs without harming their overall performance.'}, 'zh': {'title': '提升工具使用性能的自动化训练环境', 'desc': '本文提出了一种自动化的训练环境构建管道，旨在提升大型语言模型（LLMs）在工具使用方面的表现，同时保持其通用能力不受影响。该管道通过场景分解、文档生成、功能集成、复杂度扩展和本地部署等步骤，创建高质量的训练环境，并提供详细的可测量反馈。我们还引入了一种可验证的奖励机制，评估工具使用的准确性和任务执行的完整性。实验结果表明，该方法显著提升了模型的工具使用性能，且不影响其整体能力。'}}}, {'id': 'https://huggingface.co/papers/2508.09050', 'title': 'Bridging Theory and Practice in Quantum Game Theory: Optimized\n  Implementation of the Battle of the Sexes with Error Mitigation on NISQ\n  Hardware', 'url': 'https://huggingface.co/papers/2508.09050', 'abstract': "Quantum game theory demonstrated on IBM Quantum hardware using the Eisert-Wilkens-Lewenstein framework shows persistent quantum advantages in strategic coordination despite noise and decoherence.  \t\t\t\t\tAI-generated summary \t\t\t\t Implementing quantum game theory on real hardware is challenging due to noise, decoherence, and limited qubit connectivity, yet such demonstrations are essential to validate theoretical predictions. We present one of the first full experimental realizations of the Battle of the Sexes game under the Eisert-Wilkens-Lewenstein (EWL) framework on IBM Quantum's ibm sherbrooke superconducting processor. Four quantum strategies (I, H, R(pi/4), R(pi)) were evaluated across 31 entanglement values gamma in [0, pi] using 2048 shots per configuration, enabling a direct comparison between analytical predictions and hardware execution. To mitigate noise and variability, we introduce a Guided Circuit Mapping (GCM) method that dynamically selects qubit pairs and optimizes routing based on real-time topology and calibration data. The analytical model forecasts up to 108% payoff improvement over the classical equilibrium, and despite hardware-induced deviations, experimental results with GCM preserve the expected payoff trends within 3.5%-12% relative error. These findings show that quantum advantages in strategic coordination can persist under realistic NISQ conditions, providing a pathway toward practical applications of quantum game theory in multi-agent, economic, and distributed decision-making systems.", 'score': 1, 'issue_id': 5322, 'pub_date': '2025-08-12', 'pub_date_card': {'ru': '12 августа', 'en': 'August 12', 'zh': '8月12日'}, 'hash': '107a4a0916cff223', 'authors': ['Germán Díaz Agreda', 'Carlos Andres Duran Paredes', 'Mateo Buenaventura Samboni', 'Jhon Alejandro Andrade', 'Sebastián Andrés Cajas Ordoñez'], 'affiliations': ['Facultad de Ciencias Naturales, Exactas de la Educacion Universidad del Cauca Popayan, Colombia', 'National Irish Centre for AI (CeADAR) University College Dublin (UCD) Dublin, Ireland'], 'pdf_title_img': 'assets/pdf/title_img/2508.09050.jpg', 'data': {'categories': ['#agents', '#games', '#optimization', '#math'], 'emoji': '🎮', 'ru': {'title': 'Квантовая теория игр побеждает шум: эксперимент на IBM Quantum', 'desc': "В этой статье представлена одна из первых полных экспериментальных реализаций квантовой теории игр на реальном квантовом оборудовании IBM. Исследователи использовали структуру Эйзерта-Вилкенса-Левенштейна для игры 'Битва полов', оценивая четыре квантовые стратегии при различных уровнях запутанности. Для уменьшения влияния шума и декогеренции был разработан метод Guided Circuit Mapping, динамически оптимизирующий маршрутизацию кубитов. Несмотря на аппаратные отклонения, экспериментальные результаты сохранили ожидаемые тенденции выигрыша, демонстрируя устойчивость квантовых преимуществ в стратегической координации в условиях NISQ."}, 'en': {'title': 'Harnessing Quantum Strategies for Real-World Decision Making', 'desc': 'This paper explores the implementation of quantum game theory on IBM Quantum hardware, specifically using the Eisert-Wilkens-Lewenstein framework. It presents an experimental realization of the Battle of the Sexes game, evaluating various quantum strategies while addressing challenges like noise and decoherence. The authors introduce a Guided Circuit Mapping method to optimize qubit routing and mitigate errors, achieving results that align closely with theoretical predictions. The findings suggest that quantum advantages in strategic coordination can be maintained even in real-world conditions, paving the way for future applications in complex decision-making scenarios.'}, 'zh': {'title': '量子博弈理论的优势在现实条件下依然存在', 'desc': '这篇论文展示了在IBM量子硬件上实现量子博弈理论的实验，使用了Eisert-Wilkens-Lewenstein框架。尽管存在噪声和退相干的挑战，实验结果表明量子策略在协调决策中仍然具有优势。研究中采用了引导电路映射方法，以优化量子比特的连接和路由，从而减少噪声影响。结果显示，在实际的NISQ条件下，量子博弈理论的优势依然存在，为多智能体和经济决策系统的实际应用提供了可能的路径。'}}}, {'id': 'https://huggingface.co/papers/2508.04195', 'title': 'NVSpeech: An Integrated and Scalable Pipeline for Human-Like Speech\n  Modeling with Paralinguistic Vocalizations', 'url': 'https://huggingface.co/papers/2508.04195', 'abstract': 'NVSpeech is a pipeline that integrates the recognition and synthesis of paralinguistic vocalizations in Mandarin, using a large annotated dataset and models that treat these cues as decodable tokens.  \t\t\t\t\tAI-generated summary \t\t\t\t Paralinguistic vocalizations-including non-verbal sounds like laughter and breathing, as well as lexicalized interjections such as "uhm" and "oh"-are integral to natural spoken communication. Despite their importance in conveying affect, intent, and interactional cues, such cues remain largely overlooked in conventional automatic speech recognition (ASR) and text-to-speech (TTS) systems. We present NVSpeech, an integrated and scalable pipeline that bridges the recognition and synthesis of paralinguistic vocalizations, encompassing dataset construction, ASR modeling, and controllable TTS. (1) We introduce a manually annotated dataset of 48,430 human-spoken utterances with 18 word-level paralinguistic categories. (2) We develop the paralinguistic-aware ASR model, which treats paralinguistic cues as inline decodable tokens (e.g., "You\'re so funny [Laughter]"), enabling joint lexical and non-verbal transcription. This model is then used to automatically annotate a large corpus, the first large-scale Chinese dataset of 174,179 utterances (573 hours) with word-level alignment and paralingustic cues. (3) We finetune zero-shot TTS models on both human- and auto-labeled data to enable explicit control over paralinguistic vocalizations, allowing context-aware insertion at arbitrary token positions for human-like speech synthesis. By unifying the recognition and generation of paralinguistic vocalizations, NVSpeech offers the first open, large-scale, word-level annotated pipeline for expressive speech modeling in Mandarin, integrating recognition and synthesis in a scalable and controllable manner. Dataset and audio demos are available at https://nvspeech170k.github.io/.', 'score': 0, 'issue_id': 5322, 'pub_date': '2025-08-06', 'pub_date_card': {'ru': '6 августа', 'en': 'August 6', 'zh': '8月6日'}, 'hash': 'b4eb7f9d017ec3fd', 'authors': ['Huan Liao', 'Qinke Ni', 'Yuancheng Wang', 'Yiheng Lu', 'Haoyue Zhan', 'Pengyuan Xie', 'Qiang Zhang', 'Zhizheng Wu'], 'affiliations': ['Guangzhou Quwan Network Technology', 'The Chinese University of Hong Kong, Shenzhen'], 'pdf_title_img': 'assets/pdf/title_img/2508.04195.jpg', 'data': {'categories': ['#dataset', '#open_source', '#data', '#audio'], 'emoji': '🗣️', 'ru': {'title': 'Единая система распознавания и синтеза паралингвистических сигналов в речи', 'desc': 'NVSpeech - это комплексный конвейер для распознавания и синтеза паралингвистических вокализаций в мандаринском китайском языке. Он включает в себя создание большого аннотированного датасета с 18 категориями паралингвистических сигналов на уровне слов. Система использует модели автоматического распознавания речи (ASR) и синтеза речи (TTS), которые обрабатывают паралингвистические сигналы как декодируемые токены. NVSpeech позволяет осуществлять контролируемый синтез экспрессивной речи с вставкой паралингвистических элементов в произвольных позициях.'}, 'en': {'title': 'Bridging Speech Recognition and Synthesis with Paralinguistic Cues', 'desc': 'NVSpeech is a novel pipeline designed to enhance the recognition and synthesis of paralinguistic vocalizations in Mandarin, which include non-verbal sounds and interjections. It utilizes a large, manually annotated dataset of over 48,000 utterances categorized into 18 paralinguistic types, enabling a more nuanced understanding of spoken communication. The system features a paralinguistic-aware automatic speech recognition (ASR) model that treats these vocal cues as decodable tokens, allowing for joint transcription of verbal and non-verbal elements. Additionally, it incorporates a controllable text-to-speech (TTS) model that can insert these vocalizations contextually, resulting in more expressive and human-like speech synthesis.'}, 'zh': {'title': 'NVSpeech：普通话副语言声音的识别与合成新突破', 'desc': 'NVSpeech是一个集成了普通话中副语言声音识别和合成的管道，使用了一个大型标注数据集和将这些线索视为可解码标记的模型。副语言声音包括非语言声音（如笑声和呼吸）以及词汇化的插入语（如“嗯”和“哦”），在自然口语交流中至关重要。该系统通过构建一个包含48,430个人工发音的标注数据集，开发了一个副语言感知的自动语音识别（ASR）模型，并在此基础上生成了一个大规模的中文数据集。NVSpeech实现了副语言声音的识别与合成的统一，为普通话的表达性语音建模提供了首个开放的大规模标注管道。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (3)', '#agents (6)', '#agi (1)', '#alignment', '#architecture (1)', '#audio (1)', '#benchmark (8)', '#cv (2)', '#data (1)', '#dataset (8)', '#diffusion (4)', '#ethics', '#games (3)', '#graphs', '#hallucinations (1)', '#healthcare (1)', '#inference (1)', '#interpretability', '#leakage', '#long_context (1)', '#low_resource', '#machine_translation', '#math (3)', '#multilingual (1)', '#multimodal (3)', '#open_source (7)', '#optimization (8)', '#plp', '#rag (1)', '#reasoning (6)', '#rl (7)', '#rlhf (2)', '#robotics', '#science', '#security (1)', '#small_models (1)', '#story_generation (1)', '#survey', '#synthetic (2)', '#training (6)', '#transfer_learning', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-08-13 08:16',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-08-13 08:16')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-08-13 08:16')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    