
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 10 papers. July 21.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">21 июля</span> | <span id="title-articles-count">10 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-07-18.html">⬅️ <span id="prev-date">18.07</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-07-22.html">➡️ <span id="next-date">22.07</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-07.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '21 июля', 'en': 'July 21', 'zh': '7月21日'};
        let feedDateNext = {'ru': '22.07', 'en': '07/22', 'zh': '7月22日'};
        let feedDatePrev = {'ru': '18.07', 'en': '07/18', 'zh': '7月18日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2507.13563', 'title': 'A Data-Centric Framework for Addressing Phonetic and Prosodic Challenges\n  in Russian Speech Generative Models', 'url': 'https://huggingface.co/papers/2507.13563', 'abstract': 'Balalaika, a large Russian speech dataset with detailed annotations, improves performance in speech synthesis and enhancement tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t Russian speech synthesis presents distinctive challenges, including vowel reduction, consonant devoicing, variable stress patterns, homograph ambiguity, and unnatural intonation. This paper introduces Balalaika, a novel dataset comprising more than 2,000 hours of studio-quality Russian speech with comprehensive textual annotations, including punctuation and stress markings. Experimental results show that models trained on Balalaika significantly outperform those trained on existing datasets in both speech synthesis and enhancement tasks. We detail the dataset construction pipeline, annotation methodology, and results of comparative evaluations.', 'score': 39, 'issue_id': 4921, 'pub_date': '2025-07-17', 'pub_date_card': {'ru': '17 июля', 'en': 'July 17', 'zh': '7月17日'}, 'hash': '8737d8bc0b245da4', 'authors': ['Kirill Borodin', 'Nikita Vasiliev', 'Vasiliy Kudryavtsev', 'Maxim Maslov', 'Mikhail Gorodnichev', 'Oleg Rogov', 'Grach Mkrtchian'], 'affiliations': ['Artificial Intelligence Research Institute', 'Moscow Technical University of Communication and Informatics'], 'pdf_title_img': 'assets/pdf/title_img/2507.13563.jpg', 'data': {'categories': ['#data', '#low_resource', '#dataset', '#audio', '#synthetic'], 'emoji': '🎻', 'ru': {'title': 'Balalaika: мощный инструмент для улучшения русского речевого ИИ', 'desc': 'Статья представляет новый набор данных для русской речи под названием Balalaika. Этот датасет содержит более 2000 часов высококачественной речи с подробными аннотациями, включая пунктуацию и ударения. Модели, обученные на Balalaika, показывают значительно лучшие результаты в задачах синтеза и улучшения речи по сравнению с существующими датасетами. Авторы описывают процесс создания датасета, методологию аннотирования и результаты сравнительных оценок.'}, 'en': {'title': 'Balalaika: Elevating Russian Speech Synthesis with Quality Data', 'desc': 'The paper presents Balalaika, a large dataset designed to improve Russian speech synthesis and enhancement. It contains over 2,000 hours of high-quality speech recordings with detailed annotations, addressing specific challenges in Russian phonetics. The authors demonstrate that models trained on this dataset achieve superior performance compared to those trained on existing datasets. The paper also outlines the methods used for dataset construction and annotation, along with comparative evaluation results.'}, 'zh': {'title': 'Balalaika：提升俄罗斯语音合成的新数据集', 'desc': 'Balalaika是一个大型的俄罗斯语语音数据集，包含详细的注释，旨在提高语音合成和增强任务的性能。该数据集包含超过2000小时的高质量录音，提供了全面的文本注释，包括标点符号和重音标记。研究表明，使用Balalaika训练的模型在语音合成和增强任务中显著优于现有数据集训练的模型。本文详细介绍了数据集的构建流程、注释方法以及比较评估的结果。'}}}, {'id': 'https://huggingface.co/papers/2507.11097', 'title': 'The Devil behind the mask: An emergent safety vulnerability of Diffusion\n  LLMs', 'url': 'https://huggingface.co/papers/2507.11097', 'abstract': 'DIJA is a framework that exploits safety weaknesses in diffusion-based large language models by constructing adversarial prompts, demonstrating significant vulnerabilities in their alignment mechanisms.  \t\t\t\t\tAI-generated summary \t\t\t\t Diffusion-based large language models (dLLMs) have recently emerged as a powerful alternative to autoregressive LLMs, offering faster inference and greater interactivity via parallel decoding and bidirectional modeling. However, despite strong performance in code generation and text infilling, we identify a fundamental safety concern: existing alignment mechanisms fail to safeguard dLLMs against context-aware, masked-input adversarial prompts, exposing novel vulnerabilities. To this end, we present DIJA, the first systematic study and jailbreak attack framework that exploits unique safety weaknesses of dLLMs. Specifically, our proposed DIJA constructs adversarial interleaved mask-text prompts that exploit the text generation mechanisms of dLLMs, i.e., bidirectional modeling and parallel decoding. Bidirectional modeling drives the model to produce contextually consistent outputs for masked spans, even when harmful, while parallel decoding limits model dynamic filtering and rejection sampling of unsafe content. This causes standard alignment mechanisms to fail, enabling harmful completions in alignment-tuned dLLMs, even when harmful behaviors or unsafe instructions are directly exposed in the prompt. Through comprehensive experiments, we demonstrate that DIJA significantly outperforms existing jailbreak methods, exposing a previously overlooked threat surface in dLLM architectures. Notably, our method achieves up to 100% keyword-based ASR on Dream-Instruct, surpassing the strongest prior baseline, ReNeLLM, by up to 78.5% in evaluator-based ASR on JailbreakBench and by 37.7 points in StrongREJECT score, while requiring no rewriting or hiding of harmful content in the jailbreak prompt. Our findings underscore the urgent need for rethinking safety alignment in this emerging class of language models. Code is available at https://github.com/ZichenWen1/DIJA.', 'score': 39, 'issue_id': 4917, 'pub_date': '2025-07-15', 'pub_date_card': {'ru': '15 июля', 'en': 'July 15', 'zh': '7月15日'}, 'hash': 'a104a398841ff4ff', 'authors': ['Zichen Wen', 'Jiashu Qu', 'Dongrui Liu', 'Zhiyuan Liu', 'Ruixi Wu', 'Yicun Yang', 'Xiangqi Jin', 'Haoyun Xu', 'Xuyang Liu', 'Weijia Li', 'Chaochao Lu', 'Jing Shao', 'Conghui He', 'Linfeng Zhang'], 'affiliations': ['EPIC Lab, Shanghai Jiao Tong University', 'Shanghai AI Laboratory', 'Sun Yat-sen University'], 'pdf_title_img': 'assets/pdf/title_img/2507.11097.jpg', 'data': {'categories': ['#training', '#architecture', '#diffusion', '#alignment', '#security'], 'emoji': '🕵️', 'ru': {'title': 'Уязвимости диффузионных языковых моделей: новый фронт в безопасности ИИ', 'desc': 'DIJA - это фреймворк для создания состязательных промптов, который использует уязвимости в механизмах безопасности диффузионных языковых моделей. Он демонстрирует, что существующие методы выравнивания не защищают эти модели от вредоносных запросов с маскированным вводом. DIJA конструирует промпты, чередуя маскированный и обычный текст, что позволяет обойти стандартные механизмы безопасности. Эксперименты показывают, что DIJA значительно превосходит существующие методы взлома языковых моделей, раскрывая новую поверхность угроз.'}, 'en': {'title': 'Unmasking Vulnerabilities in Diffusion-Based Language Models with DIJA', 'desc': 'DIJA is a novel framework that identifies and exploits safety vulnerabilities in diffusion-based large language models (dLLMs) through the use of adversarial prompts. It reveals that existing alignment mechanisms are inadequate in preventing harmful outputs when faced with context-aware, masked-input prompts. By leveraging the unique features of dLLMs, such as bidirectional modeling and parallel decoding, DIJA demonstrates how these models can produce unsafe content despite alignment efforts. The framework significantly outperforms previous methods, highlighting the critical need for improved safety measures in the design of dLLMs.'}, 'zh': {'title': '揭示扩散型大语言模型的安全脆弱性', 'desc': 'DIJA是一个框架，利用扩散型大语言模型中的安全弱点，通过构造对抗性提示，展示了其对齐机制的显著脆弱性。尽管扩散型大语言模型在代码生成和文本填充方面表现出色，但我们发现现有的对齐机制无法有效防护针对上下文的对抗性提示。DIJA通过构建对抗性交错掩码文本提示，利用了扩散型大语言模型的文本生成机制，导致标准对齐机制失效。我们的实验表明，DIJA在揭示扩散型大语言模型架构中的新威胁方面，显著优于现有的越狱方法。'}}}, {'id': 'https://huggingface.co/papers/2507.14137', 'title': 'Franca: Nested Matryoshka Clustering for Scalable Visual Representation\n  Learning', 'url': 'https://huggingface.co/papers/2507.14137', 'abstract': 'Franca, an open-source vision foundation model, achieves high performance using a transparent training pipeline and novel clustering and disentanglement techniques.  \t\t\t\t\tAI-generated summary \t\t\t\t We present Franca (pronounced Fran-ka): free one; the first fully open-source (data, code, weights) vision foundation model that matches and in many cases surpasses the performance of state-of-the-art proprietary models, e.g., DINOv2, CLIP, SigLIPv2, etc. Our approach is grounded in a transparent training pipeline inspired by Web-SSL and uses publicly available data: ImageNet-21K and a subset of ReLAION-2B. Beyond model release, we tackle critical limitations in SSL clustering methods. While modern models rely on assigning image features to large codebooks via clustering algorithms like Sinkhorn-Knopp, they fail to account for the inherent ambiguity in clustering semantics. To address this, we introduce a parameter-efficient, multi-head clustering projector based on nested Matryoshka representations. This design progressively refines features into increasingly fine-grained clusters without increasing the model size, enabling both performance and memory efficiency. Additionally, we propose a novel positional disentanglement strategy that explicitly removes positional biases from dense representations, thereby improving the encoding of semantic content. This leads to consistent gains on several downstream benchmarks, demonstrating the utility of cleaner feature spaces. Our contributions establish a new standard for transparent, high-performance vision models and open a path toward more reproducible and generalizable foundation models for the broader AI community. The code and model checkpoints are available at https://github.com/valeoai/Franca.', 'score': 14, 'issue_id': 4918, 'pub_date': '2025-07-18', 'pub_date_card': {'ru': '18 июля', 'en': 'July 18', 'zh': '7月18日'}, 'hash': '9435de131fc3d757', 'authors': ['Shashanka Venkataramanan', 'Valentinos Pariza', 'Mohammadreza Salehi', 'Lukas Knobel', 'Spyros Gidaris', 'Elias Ramzi', 'Andrei Bursuc', 'Yuki M. Asano'], 'affiliations': ['Fundamental AI Lab, UTN', 'VIS Lab, UvA', 'valeo.ai, Paris'], 'pdf_title_img': 'assets/pdf/title_img/2507.14137.jpg', 'data': {'categories': ['#training', '#cv', '#optimization', '#dataset', '#architecture', '#open_source'], 'emoji': '👁️', 'ru': {'title': 'Открытая модель компьютерного зрения нового поколения', 'desc': 'Franca - это первая полностью открытая модель компьютерного зрения, которая соответствует или превосходит производительность современных проприетарных моделей. Она использует прозрачный конвейер обучения и общедоступные данные, включая ImageNet-21K и подмножество ReLAION-2B. Авторы представили новый многоголовый кластеризующий проектор на основе вложенных матрешечных представлений, который позволяет постепенно уточнять признаки в более детальные кластеры без увеличения размера модели. Кроме того, они предложили стратегию позиционного разделения, которая явно удаляет позиционные смещения из плотных представлений, улучшая кодирование семантического содержания.'}, 'en': {'title': 'Franca: The Open-Source Vision Model Redefining Performance Standards', 'desc': 'Franca is an open-source vision foundation model that achieves competitive performance with leading proprietary models by utilizing a transparent training pipeline. It employs innovative clustering and disentanglement techniques to enhance the quality of feature representations. The model addresses limitations in self-supervised learning (SSL) clustering methods by introducing a multi-head clustering projector that refines features into detailed clusters efficiently. Additionally, a positional disentanglement strategy is implemented to eliminate biases, resulting in improved semantic encoding and better performance on various benchmarks.'}, 'zh': {'title': 'Franca：开源视觉模型的新标准', 'desc': 'Franca是一个开源的视觉基础模型，采用透明的训练流程和新颖的聚类与解缠技术，取得了高性能。它是第一个完全开源的视觉基础模型，性能与许多最先进的专有模型相当，甚至在某些情况下超越它们。Franca使用公开可用的数据进行训练，并引入了一种基于嵌套马特ryoshka表示的多头聚类投影器，以提高聚类的精确度。通过消除密集表示中的位置偏差，Franca在多个下游基准测试中表现出一致的提升，展示了更清晰特征空间的实用性。'}}}, {'id': 'https://huggingface.co/papers/2507.12566', 'title': 'Mono-InternVL-1.5: Towards Cheaper and Faster Monolithic Multimodal\n  Large Language Models', 'url': 'https://huggingface.co/papers/2507.12566', 'abstract': 'Mono-InternVL, an advanced monolithic Multimodal Large Language Model, integrates visual experts and improved pre-training strategies to enhance visual learning and reduce computational costs while maintaining competitive performance.  \t\t\t\t\tAI-generated summary \t\t\t\t This paper focuses on monolithic Multimodal Large Language Models (MLLMs), which integrate visual encoding and language decoding into a single model. Existing structures and pre-training strategies for monolithic MLLMs often suffer from unstable optimization and catastrophic forgetting. To address these challenges, our key idea is to embed a new visual parameter space into a pre-trained LLM, enabling stable learning of visual knowledge from noisy data via delta tuning. Based on this principle, we first introduce Mono-InternVL, an advanced monolithic MLLM that incorporates a set of visual experts through a multimodal mixture-of-experts architecture. In addition, we design an innovative Endogenous Visual Pre-training (EViP) for Mono-InternVL to maximize its visual capabilities via progressive learning. Mono-InternVL achieves competitive performance against existing MLLMs but also leads to relatively expensive data cost. Therefore, we further present Mono-InternVL-1.5, a cheaper and stronger monolithic MLLM equipped with an improved EViP (EViP++). EViP++ introduces additional visual attention experts to Mono-InternVL-1.5 and re-organizes the pre-training process in an efficient manner. During inference, it includes a fused CUDA kernel to speed up its MoE operations. With these designs, Mono-InternVL-1.5 significantly reduces training and inference costs, while still maintaining competitive performance with Mono-InternVL. To evaluate our approach, we conduct extensive experiments across 15 benchmarks. Results demonstrate that Mono-InternVL outperforms existing monolithic MLLMs on 12 out of 15 benchmarks, e.g., +114-point improvement over Emu3 on OCRBench. Compared to its modular counterpart, i.e., InternVL-1.5, Mono-InternVL-1.5 achieves similar multimodal performance while reducing first-token latency by up to 69%. Code and models are released at https://github.com/OpenGVLab/Mono-InternVL.', 'score': 9, 'issue_id': 4917, 'pub_date': '2025-07-16', 'pub_date_card': {'ru': '16 июля', 'en': 'July 16', 'zh': '7月16日'}, 'hash': 'fdd7f0b217aa40b2', 'authors': ['Gen Luo', 'Wenhan Dou', 'Wenhao Li', 'Zhaokai Wang', 'Xue Yang', 'Changyao Tian', 'Hao Li', 'Weiyun Wang', 'Wenhai Wang', 'Xizhou Zhu', 'Yu Qiao', 'Jifeng Dai'], 'affiliations': ['Shanghai Artificial Intelligence Laboratory', 'Shanghai Jiao Tong University', 'The Chinese University of Hong Kong', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2507.12566.jpg', 'data': {'categories': ['#multimodal', '#training', '#architecture', '#agi', '#optimization', '#benchmark'], 'emoji': '🧠', 'ru': {'title': 'Mono-InternVL: Монолитная мультимодальная модель с улучшенным визуальным обучением', 'desc': 'Mono-InternVL - это усовершенствованная монолитная мультимодальная большая языковая модель (MLLM), которая объединяет визуальное кодирование и языковое декодирование в единую модель. Она использует визуальных экспертов и улучшенные стратегии предобучения для повышения визуального обучения и снижения вычислительных затрат. Mono-InternVL применяет архитектуру смеси экспертов и инновационное эндогенное визуальное предобучение (EViP) для максимизации своих визуальных возможностей. Модель демонстрирует конкурентоспособную производительность по сравнению с существующими MLLM, значительно улучшая результаты на различных бенчмарках.'}, 'en': {'title': 'Revolutionizing Visual Learning with Mono-InternVL', 'desc': 'The paper introduces Mono-InternVL, a monolithic Multimodal Large Language Model (MLLM) that combines visual and language processing into one model. It addresses issues like unstable optimization and catastrophic forgetting by embedding a new visual parameter space into a pre-trained language model, allowing for stable learning from noisy data. The model incorporates a multimodal mixture-of-experts architecture and an innovative Endogenous Visual Pre-training (EViP) strategy to enhance visual capabilities. Additionally, Mono-InternVL-1.5 is presented as a more efficient version that reduces training costs while maintaining competitive performance across multiple benchmarks.'}, 'zh': {'title': 'Mono-InternVL：高效的单体多模态大语言模型', 'desc': 'Mono-InternVL是一种先进的单体多模态大语言模型，结合了视觉专家和改进的预训练策略，以增强视觉学习并降低计算成本，同时保持竞争力的性能。该模型通过将新的视觉参数空间嵌入到预训练的语言模型中，解决了不稳定优化和灾难性遗忘的问题。Mono-InternVL-1.5在此基础上进一步优化，采用了改进的内生视觉预训练（EViP++），引入了额外的视觉注意力专家，并高效地重新组织了预训练过程。实验结果表明，Mono-InternVL在多个基准测试中表现优于现有的单体多模态大语言模型，且在推理时显著降低了延迟。'}}}, {'id': 'https://huggingface.co/papers/2507.13984', 'title': 'CSD-VAR: Content-Style Decomposition in Visual Autoregressive Models', 'url': 'https://huggingface.co/papers/2507.13984', 'abstract': 'CSD-VAR, a Visual Autoregressive Modeling approach, enhances content-style decomposition by introducing scale-aware optimization, SVD-based rectification, and augmented K-V memory, outperforming diffusion models in content preservation and stylization.  \t\t\t\t\tAI-generated summary \t\t\t\t Disentangling content and style from a single image, known as content-style decomposition (CSD), enables recontextualization of extracted content and stylization of extracted styles, offering greater creative flexibility in visual synthesis. While recent personalization methods have explored the decomposition of explicit content style, they remain tailored for diffusion models. Meanwhile, Visual Autoregressive Modeling (VAR) has emerged as a promising alternative with a next-scale prediction paradigm, achieving performance comparable to that of diffusion models. In this paper, we explore VAR as a generative framework for CSD, leveraging its scale-wise generation process for improved disentanglement. To this end, we propose CSD-VAR, a novel method that introduces three key innovations: (1) a scale-aware alternating optimization strategy that aligns content and style representation with their respective scales to enhance separation, (2) an SVD-based rectification method to mitigate content leakage into style representations, and (3) an Augmented Key-Value (K-V) memory enhancing content identity preservation. To benchmark this task, we introduce CSD-100, a dataset specifically designed for content-style decomposition, featuring diverse subjects rendered in various artistic styles. Experiments demonstrate that CSD-VAR outperforms prior approaches, achieving superior content preservation and stylization fidelity.', 'score': 7, 'issue_id': 4921, 'pub_date': '2025-07-18', 'pub_date_card': {'ru': '18 июля', 'en': 'July 18', 'zh': '7月18日'}, 'hash': '0b3986b86b2e5406', 'authors': ['Quang-Binh Nguyen', 'Minh Luu', 'Quang Nguyen', 'Anh Tran', 'Khoi Nguyen'], 'affiliations': ['MovianAI', 'Qualcomm AI Research'], 'pdf_title_img': 'assets/pdf/title_img/2507.13984.jpg', 'data': {'categories': ['#dataset', '#optimization', '#benchmark', '#synthetic', '#cv'], 'emoji': '🎨', 'ru': {'title': 'CSD-VAR: Революция в разделении контента и стиля изображений', 'desc': 'CSD-VAR - это новый подход к визуальному авторегрессионному моделированию для декомпозиции контента и стиля изображений. Метод вводит три ключевые инновации: оптимизацию с учетом масштаба, SVD-ректификацию и расширенную память ключ-значение. CSD-VAR превосходит диффузионные модели в сохранении контента и стилизации. Для оценки метода авторы создали специальный датасет CSD-100 с разнообразными сюжетами в различных художественных стилях.'}, 'en': {'title': 'CSD-VAR: Mastering Content and Style Separation in Visual Synthesis', 'desc': "CSD-VAR is a new method for separating content and style in images, which is important for creative tasks in visual synthesis. It uses a Visual Autoregressive Modeling approach that improves how content and style are handled by focusing on their different scales. The method includes innovations like a scale-aware optimization strategy, an SVD-based technique to prevent content from leaking into style, and an enhanced memory system to keep the content's identity intact. Experiments show that CSD-VAR performs better than previous methods, especially in maintaining the quality of both content and style."}, 'zh': {'title': 'CSD-VAR：提升内容与风格分解的新方法', 'desc': 'CSD-VAR是一种视觉自回归建模方法，旨在通过引入规模感知优化、基于SVD的修正和增强的K-V记忆来提升内容与风格的分解效果。内容风格分解（CSD）允许从单一图像中提取内容和风格，从而实现更大的创作灵活性。与传统的扩散模型相比，CSD-VAR在内容保留和风格化方面表现更佳。我们还提出了CSD-100数据集，以便于评估内容风格分解的效果。'}}}, {'id': 'https://huggingface.co/papers/2507.13158', 'title': 'Inverse Reinforcement Learning Meets Large Language Model Post-Training:\n  Basics, Advances, and Opportunities', 'url': 'https://huggingface.co/papers/2507.13158', 'abstract': 'A review of advancements in aligning large language models using inverse reinforcement learning, emphasizing challenges and opportunities in neural reward modeling and sparse-reward reinforcement learning.  \t\t\t\t\tAI-generated summary \t\t\t\t In the era of Large Language Models (LLMs), alignment has emerged as a fundamental yet challenging problem in the pursuit of more reliable, controllable, and capable machine intelligence. The recent success of reasoning models and conversational AI systems has underscored the critical role of reinforcement learning (RL) in enhancing these systems, driving increased research interest at the intersection of RL and LLM alignment. This paper provides a comprehensive review of recent advances in LLM alignment through the lens of inverse reinforcement learning (IRL), emphasizing the distinctions between RL techniques employed in LLM alignment and those in conventional RL tasks. In particular, we highlight the necessity of constructing neural reward models from human data and discuss the formal and practical implications of this paradigm shift. We begin by introducing fundamental concepts in RL to provide a foundation for readers unfamiliar with the field. We then examine recent advances in this research agenda, discussing key challenges and opportunities in conducting IRL for LLM alignment. Beyond methodological considerations, we explore practical aspects, including datasets, benchmarks, evaluation metrics, infrastructure, and computationally efficient training and inference techniques. Finally, we draw insights from the literature on sparse-reward RL to identify open questions and potential research directions. By synthesizing findings from diverse studies, we aim to provide a structured and critical overview of the field, highlight unresolved challenges, and outline promising future directions for improving LLM alignment through RL and IRL techniques.', 'score': 5, 'issue_id': 4923, 'pub_date': '2025-07-17', 'pub_date_card': {'ru': '17 июля', 'en': 'July 17', 'zh': '7月17日'}, 'hash': '2f87de19df04c9a4', 'authors': ['Hao Sun', 'Mihaela van der Schaar'], 'affiliations': ['Department of Applied Mathematics and Theoretical Physics University of Cambridge Cambridge, United Kingdom'], 'pdf_title_img': 'assets/pdf/title_img/2507.13158.jpg', 'data': {'categories': ['#rlhf', '#training', '#rl', '#survey', '#benchmark', '#alignment'], 'emoji': '🧠', 'ru': {'title': 'Выравнивание языковых моделей через призму обратного обучения с подкреплением', 'desc': 'Статья представляет обзор последних достижений в области выравнивания больших языковых моделей (LLM) с использованием обратного обучения с подкреплением (IRL). Авторы подчеркивают важность создания нейронных моделей вознаграждения на основе данных о поведении человека. Рассматриваются ключевые проблемы и возможности применения IRL для выравнивания LLM, а также практические аспекты, включая наборы данных, метрики оценки и эффективные методы обучения. Статья также анализирует связь с исследованиями в области обучения с подкреплением с разреженным вознаграждением.'}, 'en': {'title': 'Aligning Language Models: Challenges and Opportunities in Reinforcement Learning', 'desc': 'This paper reviews the progress in aligning large language models (LLMs) using inverse reinforcement learning (IRL), focusing on the unique challenges and opportunities in this area. It emphasizes the importance of developing neural reward models based on human data to improve the alignment of LLMs, which is crucial for creating more reliable AI systems. The authors discuss the differences between traditional reinforcement learning methods and those specifically tailored for LLM alignment, providing insights into practical aspects like datasets and evaluation metrics. By synthesizing existing research, the paper aims to highlight unresolved issues and suggest future research directions in the field of LLM alignment through reinforcement learning techniques.'}, 'zh': {'title': '逆强化学习助力大型语言模型对齐的未来', 'desc': '本文回顾了使用逆强化学习（IRL）对大型语言模型（LLM）进行对齐的最新进展，强调了神经奖励建模和稀疏奖励强化学习中的挑战与机遇。在大型语言模型的时代，对齐问题变得尤为重要，影响着机器智能的可靠性和可控性。文章介绍了强化学习的基本概念，并探讨了IRL在LLM对齐中的应用，特别是如何从人类数据中构建神经奖励模型。最后，文章总结了当前研究中的关键挑战和未来的研究方向。'}}}, {'id': 'https://huggingface.co/papers/2507.10605', 'title': 'RedOne: Revealing Domain-specific LLM Post-Training in Social Networking\n  Services', 'url': 'https://huggingface.co/papers/2507.10605', 'abstract': 'RedOne, a domain-specific LLM, enhances performance across multiple SNS tasks through a three-stage training strategy, improving generalization and reducing harmful content exposure.  \t\t\t\t\tAI-generated summary \t\t\t\t As a primary medium for modern information dissemination, social networking services (SNS) have experienced rapid growth, which has proposed significant challenges for platform content management and interaction quality improvement. Recently, the development of large language models (LLMs) has offered potential solutions but existing studies focus on isolated tasks, which not only encounter diminishing benefit from the data scaling within individual scenarios but also fail to flexibly adapt to diverse real-world context. To address these challenges, we introduce RedOne, a domain-specific LLM designed to break the performance bottleneck of single-task baselines and establish a comprehensive foundation for the SNS. RedOne was developed through a three-stage training strategy consisting of continue pretraining, supervised fine-tuning, and preference optimization, using a large-scale real-world dataset. Through extensive experiments, RedOne maintains strong general capabilities, and achieves an average improvement up to 14.02% across 8 major SNS tasks and 7.56% in SNS bilingual evaluation benchmark, compared with base models. Furthermore, through online testing, RedOne reduced the exposure rate in harmful content detection by 11.23% and improved the click page rate in post-view search by 14.95% compared with single-tasks finetuned baseline models. These results establish RedOne as a robust domain-specific LLM for SNS, demonstrating excellent generalization across various tasks and promising applicability in real-world scenarios.', 'score': 4, 'issue_id': 4914, 'pub_date': '2025-07-13', 'pub_date_card': {'ru': '13 июля', 'en': 'July 13', 'zh': '7月13日'}, 'hash': '0f03049bcdca7ad4', 'authors': ['Fei Zhao', 'Chonggang Lu', 'Yue Wang', 'Zheyong Xie', 'Ziyan Liu', 'Haofu Qian', 'JianZhao Huang', 'Fangcheng Shi', 'Zijie Meng', 'Hongcheng Guo', 'Mingqian He', 'Xinze Lyu', 'Yiming Lu', 'Ziyang Xiang', 'Zheyu Ye', 'Chengqiang Lu', 'Zhe Xu', 'Yi Wu', 'Yao Hu', 'Yan Gao', 'Jun Fan', 'Xiaolong Jiang', 'Weiting Liu', 'Boyang Wang', 'Shaosheng Cao'], 'affiliations': ['NLP Team, Xiaohongshu Inc., China'], 'pdf_title_img': 'assets/pdf/title_img/2507.10605.jpg', 'data': {'categories': ['#training', '#alignment', '#optimization', '#dataset', '#multilingual', '#science'], 'emoji': '🚀', 'ru': {'title': 'RedOne: универсальная языковая модель для революции в социальных сетях', 'desc': 'RedOne - это специализированная языковая модель для социальных сетей, разработанная с использованием трехэтапной стратегии обучения. Модель демонстрирует улучшение производительности в среднем на 14.02% по 8 основным задачам SNS по сравнению с базовыми моделями. RedOne также показывает хорошие результаты в обнаружении вредоносного контента и повышении кликабельности в поисковой выдаче. Модель обладает отличной обобщающей способностью для различных задач SNS и перспективна для применения в реальных сценариях.'}, 'en': {'title': 'RedOne: Elevating SNS Performance with Domain-Specific LLMs', 'desc': 'RedOne is a specialized large language model (LLM) designed to improve performance on various social networking service (SNS) tasks. It employs a three-stage training strategy that includes continued pretraining, supervised fine-tuning, and preference optimization, which helps it generalize better across different tasks. The model shows significant improvements, achieving up to 14.02% better performance on major SNS tasks and reducing harmful content exposure by 11.23%. Overall, RedOne demonstrates its effectiveness as a domain-specific LLM, enhancing interaction quality and content management in real-world SNS applications.'}, 'zh': {'title': 'RedOne：社交网络服务的强大语言模型', 'desc': 'RedOne是一种特定领域的大型语言模型（LLM），通过三阶段的训练策略提升了社交网络服务（SNS）任务的表现。该模型的训练包括持续预训练、监督微调和偏好优化，使用了大规模的真实世界数据集。实验结果显示，RedOne在8个主要SNS任务上平均提升了14.02%的性能，并在有害内容检测中减少了11.23%的曝光率。这些成果表明RedOne在多任务上具有良好的泛化能力，适用于实际应用场景。'}}}, {'id': 'https://huggingface.co/papers/2507.12455', 'title': 'Mitigating Object Hallucinations via Sentence-Level Early Intervention', 'url': 'https://huggingface.co/papers/2507.12455', 'abstract': 'SENTINEL reduces hallucinations in multimodal large language models by iteratively generating and validating sentence-level outputs using in-domain preference learning and context-aware preference loss.  \t\t\t\t\tAI-generated summary \t\t\t\t Multimodal large language models (MLLMs) have revolutionized cross-modal understanding but continue to struggle with hallucinations - fabricated content contradicting visual inputs. Existing hallucination mitigation methods either incur prohibitive computational costs or introduce distribution mismatches between training data and model outputs. We identify a critical insight: hallucinations predominantly emerge at the early stages of text generation and propagate through subsequent outputs. To address this, we propose **SENTINEL** (**S**entence-level **E**arly i**N**tervention **T**hrough **IN**-domain pr**E**ference **L**earning), a framework that eliminates dependency on human annotations. Specifically, we first bootstrap high-quality in-domain preference pairs by iteratively sampling model outputs, validating object existence through cross-checking with two open-vocabulary detectors, and classifying sentences into hallucinated/non-hallucinated categories. Subsequently, we use context-coherent positive samples and hallucinated negative samples to build context-aware preference data iteratively. Finally, we train models using a context-aware preference loss (C-DPO) that emphasizes discriminative learning at the sentence level where hallucinations initially manifest. Experimental results show that SENTINEL can reduce hallucinations by over 90\\% compared to the original model and outperforms the previous state-of-the-art method on both hallucination benchmarks and general capabilities benchmarks, demonstrating its superiority and generalization ability. The models, datasets, and code are available at https://github.com/pspdada/SENTINEL.', 'score': 3, 'issue_id': 4922, 'pub_date': '2025-07-16', 'pub_date_card': {'ru': '16 июля', 'en': 'July 16', 'zh': '7月16日'}, 'hash': 'f80b51f3876eeca6', 'authors': ['Shangpin Peng', 'Senqiao Yang', 'Li Jiang', 'Zhuotao Tian'], 'affiliations': ['Harbin Institute of Technology, Shenzhen', 'The Chinese University of Hong Kong', 'The Chinese University of Hong Kong, Shenzhen'], 'pdf_title_img': 'assets/pdf/title_img/2507.12455.jpg', 'data': {'categories': ['#hallucinations', '#multimodal', '#open_source', '#benchmark', '#data', '#training'], 'emoji': '🛡️', 'ru': {'title': 'Защита от галлюцинаций в мультимодальных ИИ-моделях', 'desc': 'SENTINEL - это фреймворк для снижения галлюцинаций в мультимодальных больших языковых моделях. Он использует итеративную генерацию и валидацию выходных данных на уровне предложений с помощью обучения предпочтениям в предметной области. SENTINEL применяет контекстно-зависимую функцию потерь предпочтений для акцентирования дискриминативного обучения на уровне предложений. Экспериментальные результаты показывают, что SENTINEL может снизить галлюцинации более чем на 90% по сравнению с исходной моделью.'}, 'en': {'title': 'SENTINEL: Early Intervention to Combat Hallucinations in MLLMs', 'desc': "SENTINEL is a framework designed to reduce hallucinations in multimodal large language models (MLLMs) by focusing on early intervention during text generation. It utilizes in-domain preference learning to create high-quality preference pairs without needing human annotations, validating outputs through cross-checking with open-vocabulary detectors. By classifying sentences as hallucinated or non-hallucinated, SENTINEL builds context-aware preference data that enhances the model's ability to distinguish between accurate and fabricated content. The approach significantly decreases hallucinations by over 90% and outperforms existing methods, showcasing its effectiveness in improving MLLM performance."}, 'zh': {'title': 'SENTINEL：消除多模态模型中的幻觉', 'desc': 'SENTINEL 是一种新框架，旨在减少多模态大语言模型中的幻觉现象。它通过迭代生成和验证句子级输出，利用领域内偏好学习和上下文感知偏好损失来实现这一目标。研究发现，幻觉主要在文本生成的早期阶段出现，并会在后续输出中传播。通过构建上下文一致的正样本和幻觉负样本，SENTINEL 显著提高了模型的准确性，减少了超过90%的幻觉现象。'}}}, {'id': 'https://huggingface.co/papers/2507.13302', 'title': 'The Generative Energy Arena (GEA): Incorporating Energy Awareness in\n  Large Language Model (LLM) Human Evaluations', 'url': 'https://huggingface.co/papers/2507.13302', 'abstract': 'GEA, a public arena that includes energy consumption data, shows that users often prefer smaller, more energy-efficient language models over larger, more complex ones.  \t\t\t\t\tAI-generated summary \t\t\t\t The evaluation of large language models is a complex task, in which several approaches have been proposed. The most common is the use of automated benchmarks in which LLMs have to answer multiple-choice questions of different topics. However, this method has certain limitations, being the most concerning, the poor correlation with the humans. An alternative approach, is to have humans evaluate the LLMs. This poses scalability issues as there is a large and growing number of models to evaluate making it impractical (and costly) to run traditional studies based on recruiting a number of evaluators and having them rank the responses of the models. An alternative approach is the use of public arenas, such as the popular LM arena, on which any user can freely evaluate models on any question and rank the responses of two models. The results are then elaborated into a model ranking. An increasingly important aspect of LLMs is their energy consumption and, therefore, evaluating how energy awareness influences the decisions of humans in selecting a model is of interest. In this paper, we present GEA, the Generative Energy Arena, an arena that incorporates information on the energy consumption of the model in the evaluation process. Preliminary results obtained with GEA are also presented, showing that for most questions, when users are aware of the energy consumption, they favor smaller and more energy efficient models. This suggests that for most user interactions, the extra cost and energy incurred by the more complex and top-performing models do not provide an increase in the perceived quality of the responses that justifies their use.', 'score': 1, 'issue_id': 4919, 'pub_date': '2025-07-17', 'pub_date_card': {'ru': '17 июля', 'en': 'July 17', 'zh': '7月17日'}, 'hash': 'ae45d08b563bfedc', 'authors': ['Carlos Arriaga', 'Gonzalo Martínez', 'Eneko Sendin', 'Javier Conde', 'Pedro Reviriego'], 'affiliations': ['ETSI de Telecomunicación, Universidad Politécnica de Madrid, Spain'], 'pdf_title_img': 'assets/pdf/title_img/2507.13302.jpg', 'data': {'categories': ['#ethics', '#dataset', '#benchmark', '#small_models', '#optimization'], 'emoji': '🌿', 'ru': {'title': 'Эффективность важнее размера: пользователи выбирают энергоэкономичные языковые модели', 'desc': 'В статье представлена GEA (Generative Energy Arena) - публичная арена для оценки языковых моделей, учитывающая их энергопотребление. Результаты показывают, что пользователи часто предпочитают меньшие и более энергоэффективные модели более крупным и сложным. Это свидетельствует о том, что для большинства пользовательских взаимодействий дополнительные затраты и энергия, потребляемые более сложными моделями, не оправданы с точки зрения воспринимаемого качества ответов. GEA предлагает альтернативный подход к оценке языковых моделей, учитывающий важный аспект энергопотребления.'}, 'en': {'title': 'Choose Efficiency: Users Prefer Smaller Language Models!', 'desc': 'The paper introduces GEA, the Generative Energy Arena, which allows users to evaluate language models while considering their energy consumption. It highlights the limitations of traditional evaluation methods, such as automated benchmarks and human evaluations, particularly in terms of scalability and correlation with human judgment. The findings suggest that users tend to prefer smaller, more energy-efficient models over larger ones when they are aware of energy costs. This indicates that the perceived quality of responses does not always justify the higher energy usage of more complex models.'}, 'zh': {'title': '选择更小更高效的语言模型', 'desc': '本文介绍了生成能量竞技场（GEA），这是一个包含能量消耗数据的公共评估平台。研究表明，用户在选择语言模型时，往往更倾向于选择较小且能效更高的模型，而不是更大更复杂的模型。传统的评估方法存在局限性，尤其是与人类评估结果的相关性较差。通过GEA，用户可以在了解模型能耗的情况下进行评估，初步结果显示，用户在意识到能耗后，倾向于选择能效更高的模型。'}}}, {'id': 'https://huggingface.co/papers/2507.13391', 'title': 'Quantitative Risk Management in Volatile Markets with an Expectile-Based\n  Framework for the FTSE Index', 'url': 'https://huggingface.co/papers/2507.13391', 'abstract': 'This research presents a framework for quantitative risk management in volatile markets, specifically focusing on expectile-based methodologies applied to the FTSE 100 index. Traditional risk measures such as Value-at-Risk (VaR) have demonstrated significant limitations during periods of market stress, as evidenced during the 2008 financial crisis and subsequent volatile periods. This study develops an advanced expectile-based framework that addresses the shortcomings of conventional quantile-based approaches by providing greater sensitivity to tail losses and improved stability in extreme market conditions. The research employs a dataset spanning two decades of FTSE 100 returns, incorporating periods of high volatility, market crashes, and recovery phases. Our methodology introduces novel mathematical formulations for expectile regression models, enhanced threshold determination techniques using time series analysis, and robust backtesting procedures. The empirical results demonstrate that expectile-based Value-at-Risk (EVaR) consistently outperforms traditional VaR measures across various confidence levels and market conditions. The framework exhibits superior performance during volatile periods, with reduced model risk and enhanced predictive accuracy. Furthermore, the study establishes practical implementation guidelines for financial institutions and provides evidence-based recommendations for regulatory compliance and portfolio management. The findings contribute significantly to the literature on financial risk management and offer practical tools for practitioners dealing with volatile market environments.', 'score': 0, 'issue_id': 4919, 'pub_date': '2025-07-16', 'pub_date_card': {'ru': '16 июля', 'en': 'July 16', 'zh': '7月16日'}, 'hash': '08b61c33b30fa00a', 'authors': ['Abiodun Finbarrs Oketunji'], 'affiliations': ['University of Oxford, Oxford, United Kingdom'], 'pdf_title_img': 'assets/pdf/title_img/2507.13391.jpg', 'data': {'categories': ['#dataset', '#math'], 'emoji': '📊', 'ru': {'title': 'Экспектиль-базированное управление рисками: новый стандарт для волатильных рынков', 'desc': 'Это исследование представляет новый подход к управлению рисками на волатильных рынках, основанный на методологии экспектилей, применяемой к индексу FTSE 100. Разработанная система решает проблемы традиционных мер риска, таких как Value-at-Risk (VaR), обеспечивая большую чувствительность к экстремальным потерям и улучшенную стабильность в условиях рыночного стресса. Эмпирические результаты показывают, что экспектиль-базированный VaR (EVaR) стабильно превосходит традиционные меры VaR при различных уровнях доверия и рыночных условиях. Исследование вносит значительный вклад в литературу по управлению финансовыми рисками и предлагает практические инструменты для работы в волатильной рыночной среде.'}, 'en': {'title': 'Enhancing Risk Management with Expectile-Based Approaches', 'desc': 'This research introduces a new framework for managing financial risk in unstable markets, focusing on expectile-based methods for the FTSE 100 index. Unlike traditional Value-at-Risk (VaR), which struggles during market stress, the expectile-based approach offers better sensitivity to extreme losses and stability in turbulent times. The study uses two decades of data to develop advanced expectile regression models and robust backtesting techniques, showing that expectile-based Value-at-Risk (EVaR) outperforms traditional measures. The findings provide valuable insights and practical guidelines for financial institutions to enhance risk management and comply with regulations in volatile environments.'}, 'zh': {'title': '基于期望值的风险管理新框架', 'desc': '本研究提出了一种用于波动市场的定量风险管理框架，特别关注基于期望值的方法，应用于FTSE 100指数。传统的风险度量方法如风险价值（VaR）在市场压力期间表现出显著的局限性，尤其是在2008年金融危机及其后的波动时期。该研究开发了一种先进的基于期望值的框架，解决了传统分位数方法的不足，提供了对尾部损失的更高敏感性和在极端市场条件下的更好稳定性。实证结果表明，基于期望值的风险价值（EVaR）在各种置信水平和市场条件下始终优于传统的VaR度量。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents', '#agi (1)', '#alignment (3)', '#architecture (3)', '#audio (1)', '#benchmark (5)', '#cv (2)', '#data (2)', '#dataset (6)', '#diffusion (1)', '#ethics (1)', '#games', '#graphs', '#hallucinations (1)', '#healthcare', '#inference', '#interpretability', '#leakage', '#long_context', '#low_resource (1)', '#machine_translation', '#math (1)', '#multilingual (1)', '#multimodal (2)', '#open_source (2)', '#optimization (5)', '#plp', '#rag', '#reasoning', '#rl (1)', '#rlhf (1)', '#robotics', '#science (1)', '#security (1)', '#small_models (1)', '#story_generation', '#survey (1)', '#synthetic (2)', '#training (6)', '#transfer_learning', '#video'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-07-21 21:12',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-07-21 21:12')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-07-21 21:12')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    