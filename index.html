
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 9 papers. April 23.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">23 апреля</span> | <span id="title-articles-count">9 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-04-22.html">⬅️ <span id="prev-date">22.04</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-04-24.html">➡️ <span id="next-date">24.04</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-04.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '23 апреля', 'en': 'April 23', 'zh': '4月23日'};
        let feedDateNext = {'ru': '24.04', 'en': '04/24', 'zh': '4月24日'};
        let feedDatePrev = {'ru': '22.04', 'en': '04/22', 'zh': '4月22日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2504.16072', 'title': 'Describe Anything: Detailed Localized Image and Video Captioning', 'url': 'https://huggingface.co/papers/2504.16072', 'abstract': 'Generating detailed and accurate descriptions for specific regions in images and videos remains a fundamental challenge for vision-language models. We introduce the Describe Anything Model (DAM), a model designed for detailed localized captioning (DLC). DAM preserves both local details and global context through two key innovations: a focal prompt, which ensures high-resolution encoding of targeted regions, and a localized vision backbone, which integrates precise localization with its broader context. To tackle the scarcity of high-quality DLC data, we propose a Semi-supervised learning (SSL)-based Data Pipeline (DLC-SDP). DLC-SDP starts with existing segmentation datasets and expands to unlabeled web images using SSL. We introduce DLC-Bench, a benchmark designed to evaluate DLC without relying on reference captions. DAM sets new state-of-the-art on 7 benchmarks spanning keyword-level, phrase-level, and detailed multi-sentence localized image and video captioning.', 'score': 8, 'issue_id': 3380, 'pub_date': '2025-04-22', 'pub_date_card': {'ru': '22 апреля', 'en': 'April 22', 'zh': '4月22日'}, 'hash': '1749ec1e79ed8810', 'authors': ['Long Lian', 'Yifan Ding', 'Yunhao Ge', 'Sifei Liu', 'Hanzi Mao', 'Boyi Li', 'Marco Pavone', 'Ming-Yu Liu', 'Trevor Darrell', 'Adam Yala', 'Yin Cui'], 'affiliations': ['NVIDIA', 'UC Berkeley', 'UCSF'], 'pdf_title_img': 'assets/pdf/title_img/2504.16072.jpg', 'data': {'categories': ['#benchmark', '#dataset', '#cv', '#data'], 'emoji': '🔍', 'ru': {'title': 'DAM: Точное описание любой детали изображения', 'desc': 'Модель DAM (Describe Anything Model) представляет собой инновационный подход к детальному локализованному описанию изображений и видео. Она использует фокальный промпт и локализованный визуальный бэкбон для сохранения как локальных деталей, так и глобального контекста. Авторы также предлагают полу-контролируемый конвейер данных DLC-SDP для решения проблемы нехватки качественных данных. DAM устанавливает новый state-of-the-art на 7 бенчмарках, охватывающих различные уровни локализованного описания изображений и видео.'}, 'en': {'title': 'Capturing Details Anywhere: The Describe Anything Model', 'desc': 'The Describe Anything Model (DAM) addresses the challenge of generating detailed captions for specific areas in images and videos. It utilizes a focal prompt for high-resolution encoding of targeted regions and a localized vision backbone to combine local details with global context. To enhance the training data for detailed localized captioning, the model employs a Semi-supervised learning (SSL)-based Data Pipeline (DLC-SDP) that leverages existing segmentation datasets and expands to unlabeled web images. DAM achieves state-of-the-art performance across multiple benchmarks for keyword, phrase, and multi-sentence captioning tasks.'}, 'zh': {'title': '描述任何事物，精准本地化！', 'desc': '本文介绍了一种新的模型，称为描述任何事物模型（DAM），旨在为图像和视频中的特定区域生成详细的本地化描述。DAM通过两个关键创新来保持局部细节和全局上下文：焦点提示确保对目标区域的高分辨率编码，而本地化视觉骨干网络则将精确定位与更广泛的上下文相结合。为了应对高质量本地化描述数据的稀缺，本文提出了一种基于半监督学习的数据管道（DLC-SDP），该管道利用现有的分割数据集并扩展到未标记的网络图像。DAM在七个基准测试中设定了新的最先进水平，涵盖了关键词级、短语级和详细的多句本地化图像和视频描述。'}}}, {'id': 'https://huggingface.co/papers/2504.15521', 'title': 'The Bitter Lesson Learned from 2,000+ Multilingual Benchmarks', 'url': 'https://huggingface.co/papers/2504.15521', 'abstract': 'As large language models (LLMs) continue to advance in linguistic capabilities, robust multilingual evaluation has become essential for promoting equitable technological progress. This position paper examines over 2,000 multilingual (non-English) benchmarks from 148 countries, published between 2021 and 2024, to evaluate past, present, and future practices in multilingual benchmarking. Our findings reveal that, despite significant investments amounting to tens of millions of dollars, English remains significantly overrepresented in these benchmarks. Additionally, most benchmarks rely on original language content rather than translations, with the majority sourced from high-resource countries such as China, India, Germany, the UK, and the USA. Furthermore, a comparison of benchmark performance with human judgments highlights notable disparities. STEM-related tasks exhibit strong correlations with human evaluations (0.70 to 0.85), while traditional NLP tasks like question answering (e.g., XQuAD) show much weaker correlations (0.11 to 0.30). Moreover, translating English benchmarks into other languages proves insufficient, as localized benchmarks demonstrate significantly higher alignment with local human judgments (0.68) than their translated counterparts (0.47). This underscores the importance of creating culturally and linguistically tailored benchmarks rather than relying solely on translations. Through this comprehensive analysis, we highlight six key limitations in current multilingual evaluation practices, propose the guiding principles accordingly for effective multilingual benchmarking, and outline five critical research directions to drive progress in the field. Finally, we call for a global collaborative effort to develop human-aligned benchmarks that prioritize real-world applications.', 'score': 7, 'issue_id': 3380, 'pub_date': '2025-04-22', 'pub_date_card': {'ru': '22 апреля', 'en': 'April 22', 'zh': '4月22日'}, 'hash': '4d1809408c9b3e49', 'authors': ['Minghao Wu', 'Weixuan Wang', 'Sinuo Liu', 'Huifeng Yin', 'Xintong Wang', 'Yu Zhao', 'Chenyang Lyu', 'Longyue Wang', 'Weihua Luo', 'Kaifu Zhang'], 'affiliations': ['Alibaba International Digital Commerce', 'Monash University', 'The University of Edinburgh', 'Tsinghua University', 'Universität Hamburg'], 'pdf_title_img': 'assets/pdf/title_img/2504.15521.jpg', 'data': {'categories': ['#benchmark', '#low_resource', '#multilingual', '#translation'], 'emoji': '🌐', 'ru': {'title': 'За справедливую оценку многоязычных ИИ-моделей', 'desc': 'Статья анализирует более 2000 многоязычных бенчмарков для оценки языковых моделей, выявляя перекос в сторону английского языка. Исследование показывает, что бенчмарки на основе оригинального контента лучше коррелируют с оценками людей, чем переведенные. Авторы выделяют шесть ключевых ограничений в текущих практиках многоязычной оценки и предлагают принципы для эффективного многоязычного бенчмаркинга. Статья призывает к глобальному сотрудничеству для разработки бенчмарков, ориентированных на реальные приложения и учитывающих культурные особенности.'}, 'en': {'title': 'Towards Equitable Multilingual Benchmarking for LLMs', 'desc': 'This paper discusses the need for better multilingual evaluation in large language models (LLMs) as they improve in language skills. It analyzes over 2,000 multilingual benchmarks from various countries and finds that English is still overly dominant in these evaluations. The study shows that benchmarks based on original language content are more effective than translated ones, especially for local contexts. The authors propose new guidelines and research directions to create benchmarks that align more closely with human judgments and real-world applications.'}, 'zh': {'title': '推动多语言评估的公平进步', 'desc': '随着大型语言模型（LLMs）在语言能力上的不断进步，进行稳健的多语言评估变得至关重要。本文分析了2021年至2024年间来自148个国家的2000多个多语言基准，评估了多语言基准测试的过去、现在和未来的实践。研究发现，尽管投入了数千万美元，英语在这些基准中仍然占据了过高的比例，且大多数基准依赖于原始语言内容而非翻译。我们强调了创建文化和语言定制基准的重要性，并提出了有效的多语言基准测试指导原则。'}}}, {'id': 'https://huggingface.co/papers/2504.15466', 'title': 'Learning Adaptive Parallel Reasoning with Language Models', 'url': 'https://huggingface.co/papers/2504.15466', 'abstract': 'Scaling inference-time computation has substantially improved the reasoning capabilities of language models. However, existing methods have significant limitations: serialized chain-of-thought approaches generate overly long outputs, leading to increased latency and exhausted context windows, while parallel methods such as self-consistency suffer from insufficient coordination, resulting in redundant computations and limited performance gains. To address these shortcomings, we propose Adaptive Parallel Reasoning (APR), a novel reasoning framework that enables language models to orchestrate both serialized and parallel computations end-to-end. APR generalizes existing reasoning methods by enabling adaptive multi-threaded inference using spawn() and join() operations. A key innovation is our end-to-end reinforcement learning strategy, optimizing both parent and child inference threads to enhance task success rate without requiring predefined reasoning structures. Experiments on the Countdown reasoning task demonstrate significant benefits of APR: (1) higher performance within the same context window (83.4% vs. 60.0% at 4k context); (2) superior scalability with increased computation (80.1% vs. 66.6% at 20k total tokens); (3) improved accuracy at equivalent latency (75.2% vs. 57.3% at approximately 5,000ms). APR represents a step towards enabling language models to autonomously optimize their reasoning processes through adaptive allocation of computation.', 'score': 6, 'issue_id': 3380, 'pub_date': '2025-04-21', 'pub_date_card': {'ru': '21 апреля', 'en': 'April 21', 'zh': '4月21日'}, 'hash': '4eaf94a6429e3102', 'authors': ['Jiayi Pan', 'Xiuyu Li', 'Long Lian', 'Charlie Snell', 'Yifei Zhou', 'Adam Yala', 'Trevor Darrell', 'Kurt Keutzer', 'Alane Suhr'], 'affiliations': ['UC Berkeley', 'UCSF'], 'pdf_title_img': 'assets/pdf/title_img/2504.15466.jpg', 'data': {'categories': ['#inference', '#rl', '#optimization', '#reasoning'], 'emoji': '🧠', 'ru': {'title': 'Адаптивное параллельное рассуждение: новый шаг к автономной оптимизации вычислений в языковых моделях', 'desc': 'Эта статья представляет новый метод рассуждений для языковых моделей - Адаптивное Параллельное Рассуждение (APR). APR позволяет моделям оркестровать как последовательные, так и параллельные вычисления, используя операции spawn() и join(). Метод оптимизируется с помощью обучения с подкреплением, улучшая показатели успешности задач без предопределенных структур рассуждений. Эксперименты на задаче Countdown показали значительные преимущества APR в производительности, масштабируемости и точности по сравнению с существующими методами.'}, 'en': {'title': 'Adaptive Parallel Reasoning: Optimizing Language Model Inference', 'desc': 'This paper introduces Adaptive Parallel Reasoning (APR), a new framework designed to enhance the reasoning capabilities of language models during inference. APR combines both serialized and parallel computation methods, allowing for more efficient processing without the drawbacks of existing approaches. The framework utilizes an end-to-end reinforcement learning strategy to optimize inference threads, improving task success rates without needing fixed reasoning structures. Experimental results show that APR significantly outperforms traditional methods in terms of performance, scalability, and accuracy while maintaining similar latency levels.'}, 'zh': {'title': '自适应并行推理：提升语言模型推理能力的创新框架', 'desc': '本文提出了一种新的推理框架，称为自适应并行推理（APR），旨在解决现有语言模型推理方法的局限性。APR结合了串行和并行计算，允许模型在推理过程中灵活调整计算方式。通过使用spawn()和join()操作，APR实现了自适应的多线程推理，优化了推理线程的成功率。实验结果表明，APR在相同上下文窗口内表现更好，并且在计算量增加时具有更好的可扩展性和准确性。'}}}, {'id': 'https://huggingface.co/papers/2504.14992', 'title': 'Efficient Pretraining Length Scaling', 'url': 'https://huggingface.co/papers/2504.14992', 'abstract': 'Recent advances in large language models have demonstrated the effectiveness of length scaling during post-training, yet its potential in pre-training remains underexplored. We present the Parallel Hidden Decoding Transformer (PHD-Transformer), a novel framework that enables efficient length scaling during pre-training while maintaining inference efficiency. PHD-Transformer achieves this through an innovative KV cache management strategy that distinguishes between original tokens and hidden decoding tokens. By retaining only the KV cache of original tokens for long-range dependencies while immediately discarding hidden decoding tokens after use, our approach maintains the same KV cache size as the vanilla transformer while enabling effective length scaling. To further enhance performance, we introduce two optimized variants: PHD-SWA employs sliding window attention to preserve local dependencies, while PHD-CSWA implements chunk-wise sliding window attention to eliminate linear growth in pre-filling time. Extensive experiments demonstrate consistent improvements across multiple benchmarks.', 'score': 4, 'issue_id': 3380, 'pub_date': '2025-04-21', 'pub_date_card': {'ru': '21 апреля', 'en': 'April 21', 'zh': '4月21日'}, 'hash': 'a0f15db68dba9035', 'authors': ['Bohong Wu', 'Shen Yan', 'Sijun Zhang', 'Jianqiao Lu', 'Yutao Zeng', 'Ya Wang', 'Xun Zhou'], 'affiliations': ['ByteDance Seed', 'Hong Kong University', 'Peking University'], 'pdf_title_img': 'assets/pdf/title_img/2504.14992.jpg', 'data': {'categories': ['#optimization', '#long_context', '#training', '#benchmark', '#architecture'], 'emoji': '🚀', 'ru': {'title': 'Эффективное масштабирование длины в трансформерах с параллельным скрытым декодированием', 'desc': 'Эта статья представляет новый подход к масштабированию длины последовательности в языковых моделях во время предварительного обучения. Авторы предлагают Parallel Hidden Decoding Transformer (PHD-Transformer), который эффективно управляет кэшем ключей и значений, различая исходные токены и скрытые токены декодирования. Представлены две оптимизированные версии: PHD-SWA с использованием скользящего окна внимания и PHD-CSWA с чанковым скользящим окном внимания. Эксперименты показывают последовательное улучшение результатов на различных бенчмарках.'}, 'en': {'title': 'Efficient Length Scaling in Pre-Training with PHD-Transformer', 'desc': 'This paper introduces the Parallel Hidden Decoding Transformer (PHD-Transformer), which enhances pre-training of large language models by implementing efficient length scaling. The framework utilizes a unique key-value (KV) cache management strategy that differentiates between original tokens and hidden decoding tokens, optimizing memory usage. By retaining only the KV cache of original tokens, it effectively manages long-range dependencies without increasing cache size. Additionally, two optimized variants, PHD-SWA and PHD-CSWA, are proposed to improve local dependencies and reduce pre-filling time, leading to better performance across various benchmarks.'}, 'zh': {'title': '提升预训练效率的创新变换器', 'desc': '本文介绍了一种新的框架，称为并行隐藏解码变换器（PHD-Transformer），旨在提高预训练阶段的长度缩放效率。该方法通过创新的KV缓存管理策略，区分原始标记和隐藏解码标记，从而在保持推理效率的同时实现有效的长度缩放。PHD-Transformer 仅保留原始标记的KV缓存，以处理长距离依赖关系，并在使用后立即丢弃隐藏解码标记。实验结果表明，该方法在多个基准测试中均表现出一致的性能提升。'}}}, {'id': 'https://huggingface.co/papers/2504.15681', 'title': 'Vidi: Large Multimodal Models for Video Understanding and Editing', 'url': 'https://huggingface.co/papers/2504.15681', 'abstract': 'Humans naturally share information with those they are connected to, and video has become one of the dominant mediums for communication and expression on the Internet. To support the creation of high-quality large-scale video content, a modern pipeline requires a comprehensive understanding of both the raw input materials (e.g., the unedited footage captured by cameras) and the editing components (e.g., visual effects). In video editing scenarios, models must process multiple modalities (e.g., vision, audio, text) with strong background knowledge and handle flexible input lengths (e.g., hour-long raw videos), which poses significant challenges for traditional models. In this report, we introduce Vidi, a family of Large Multimodal Models (LMMs) for a wide range of video understand editing scenarios. The first release focuses on temporal retrieval, i.e., identifying the time ranges within the input videos corresponding to a given text query, which plays a critical role in intelligent editing. The model is capable of processing hour-long videos with strong temporal understanding capability, e.g., retrieve time ranges for certain queries. To support a comprehensive evaluation in real-world scenarios, we also present the VUE-TR benchmark, which introduces five key advancements. 1) Video duration: significantly longer than existing temporal retrival datasets, 2) Audio support: includes audio-based queries, 3) Query format: diverse query lengths/formats, 4) Annotation quality: ground-truth time ranges are manually annotated. 5) Evaluation metric: a refined IoU metric to support evaluation over multiple time ranges. Remarkably, Vidi significantly outperforms leading proprietary models, e.g., GPT-4o and Gemini, on the temporal retrieval task, indicating its superiority in video editing scenarios.', 'score': 3, 'issue_id': 3380, 'pub_date': '2025-04-22', 'pub_date_card': {'ru': '22 апреля', 'en': 'April 22', 'zh': '4月22日'}, 'hash': '58868b4baf82fddf', 'authors': ['Vidi Team', 'Celong Liu', 'Chia-Wen Kuo', 'Dawei Du', 'Fan Chen', 'Guang Chen', 'Jiamin Yuan', 'Lingxi Zhang', 'Lu Guo', 'Lusha Li', 'Longyin Wen', 'Qingyu Chen', 'Rachel Deng', 'Sijie Zhu', 'Stuart Siew', 'Tong Jin', 'Wei Lu', 'Wen Zhong', 'Xiaohui Shen', 'Xin Gu', 'Xing Mei', 'Xueqiong Qu'], 'affiliations': ['Intelligent Creation, ByteDance Inc. San Jose/Seattle, US'], 'pdf_title_img': 'assets/pdf/title_img/2504.15681.jpg', 'data': {'categories': ['#long_context', '#multimodal', '#games', '#video', '#benchmark'], 'emoji': '🎬', 'ru': {'title': 'Vidi: Революция в понимании и редактировании видео с помощью ИИ', 'desc': 'Vidi - это семейство крупных мультимодальных моделей (LMM) для широкого спектра задач по пониманию и редактированию видео. Модель способна обрабатывать часовые видео и выполнять темпоральный поиск, определяя временные диапазоны в видео, соответствующие текстовому запросу. Для комплексной оценки в реальных сценариях авторы представили бенчмарк VUE-TR с пятью ключевыми улучшениями, включая более длительные видео и поддержку аудиозапросов. Vidi значительно превосходит ведущие проприетарные модели, такие как GPT-4 и Gemini, в задаче темпорального поиска.'}, 'en': {'title': 'Vidi: Revolutionizing Video Editing with Multimodal Understanding', 'desc': "This paper presents Vidi, a family of Large Multimodal Models (LMMs) designed to enhance video editing by understanding various input types like vision, audio, and text. Vidi excels in temporal retrieval, which involves pinpointing specific time segments in long videos that match a given text query, making it crucial for intelligent video editing. The authors introduce the VUE-TR benchmark to evaluate Vidi's performance, featuring longer video durations, audio query support, diverse query formats, high-quality annotations, and a refined evaluation metric. Vidi demonstrates superior performance compared to existing models like GPT-4o and Gemini, showcasing its effectiveness in handling complex video editing tasks."}, 'zh': {'title': 'Vidi：视频编辑的新纪元', 'desc': '本论文介绍了一种名为Vidi的大型多模态模型（LMM），旨在解决视频编辑中的信息处理问题。Vidi能够处理多种输入模态，包括视觉、音频和文本，并具备强大的时间理解能力，能够从长达数小时的视频中提取相关时间段。该模型在时间检索任务上表现优异，超越了现有的领先模型，如GPT-4o和Gemini。为了支持真实场景中的全面评估，论文还提出了VUE-TR基准，包含了多个关键进展，如更长的视频时长和音频支持等。'}}}, {'id': 'https://huggingface.co/papers/2504.16080', 'title': 'From Reflection to Perfection: Scaling Inference-Time Optimization for\n  Text-to-Image Diffusion Models via Reflection Tuning', 'url': 'https://huggingface.co/papers/2504.16080', 'abstract': 'Recent text-to-image diffusion models achieve impressive visual quality through extensive scaling of training data and model parameters, yet they often struggle with complex scenes and fine-grained details. Inspired by the self-reflection capabilities emergent in large language models, we propose ReflectionFlow, an inference-time framework enabling diffusion models to iteratively reflect upon and refine their outputs. ReflectionFlow introduces three complementary inference-time scaling axes: (1) noise-level scaling to optimize latent initialization; (2) prompt-level scaling for precise semantic guidance; and most notably, (3) reflection-level scaling, which explicitly provides actionable reflections to iteratively assess and correct previous generations. To facilitate reflection-level scaling, we construct GenRef, a large-scale dataset comprising 1 million triplets, each containing a reflection, a flawed image, and an enhanced image. Leveraging this dataset, we efficiently perform reflection tuning on state-of-the-art diffusion transformer, FLUX.1-dev, by jointly modeling multimodal inputs within a unified framework. Experimental results show that ReflectionFlow significantly outperforms naive noise-level scaling methods, offering a scalable and compute-efficient solution toward higher-quality image synthesis on challenging tasks.', 'score': 2, 'issue_id': 3380, 'pub_date': '2025-04-22', 'pub_date_card': {'ru': '22 апреля', 'en': 'April 22', 'zh': '4月22日'}, 'hash': 'b7a7c66b6a20d5de', 'authors': ['Le Zhuo', 'Liangbing Zhao', 'Sayak Paul', 'Yue Liao', 'Renrui Zhang', 'Yi Xin', 'Peng Gao', 'Mohamed Elhoseiny', 'Hongsheng Li'], 'affiliations': ['CUHK MMLab', 'Hugging Face', 'KAUST', 'Shanghai AI Lab'], 'pdf_title_img': 'assets/pdf/title_img/2504.16080.jpg', 'data': {'categories': ['#dataset', '#diffusion', '#optimization', '#multimodal', '#cv', '#inference'], 'emoji': '🔍', 'ru': {'title': 'Самоанализ диффузионных моделей для улучшения качества генерации изображений', 'desc': 'ReflectionFlow - это новый подход к улучшению генерации изображений с помощью диффузионных моделей. Он вводит три оси масштабирования на этапе вывода: оптимизацию начального шума, точное семантическое управление и итеративную рефлексию для оценки и исправления предыдущих генераций. Для обучения рефлексии используется специально созданный датасет GenRef из 1 миллиона триплетов. Эксперименты показывают, что ReflectionFlow значительно превосходит наивные методы масштабирования шума при генерации сложных изображений.'}, 'en': {'title': 'Enhancing Image Synthesis with ReflectionFlow', 'desc': 'This paper introduces ReflectionFlow, a new framework designed to improve the performance of text-to-image diffusion models, especially in generating complex scenes and fine details. It leverages the concept of self-reflection, allowing models to iteratively refine their outputs through three scaling methods: noise-level, prompt-level, and reflection-level scaling. The authors created a dataset called GenRef, which contains 1 million triplets of reflections, flawed images, and enhanced images to support the reflection-level scaling process. Experimental results demonstrate that ReflectionFlow outperforms traditional methods, providing a more efficient approach to high-quality image synthesis.'}, 'zh': {'title': '反思流：提升图像合成质量的新方法', 'desc': '本文提出了一种名为ReflectionFlow的推理框架，旨在提高文本到图像扩散模型在复杂场景和细节处理上的表现。该框架通过引入三种推理时间的扩展方式，包括噪声级别扩展、提示级别扩展和反思级别扩展，来优化生成过程。特别是反思级别扩展，通过提供可操作的反思，帮助模型迭代评估和修正之前的生成结果。实验结果表明，ReflectionFlow在图像合成质量上显著优于传统的噪声级别扩展方法。'}}}, {'id': 'https://huggingface.co/papers/2504.11703', 'title': 'Progent: Programmable Privilege Control for LLM Agents', 'url': 'https://huggingface.co/papers/2504.11703', 'abstract': 'LLM agents are an emerging form of AI systems where large language models (LLMs) serve as the central component, utilizing a diverse set of tools to complete user-assigned tasks. Despite their great potential, LLM agents pose significant security risks. When interacting with the external world, they may encounter malicious commands from attackers, leading to the execution of dangerous actions. A promising way to address this is by enforcing the principle of least privilege: allowing only essential actions for task completion while blocking unnecessary ones. However, achieving this is challenging, as it requires covering diverse agent scenarios while preserving both security and utility.   We introduce Progent, the first privilege control mechanism for LLM agents. At its core is a domain-specific language for flexibly expressing privilege control policies applied during agent execution. These policies provide fine-grained constraints over tool calls, deciding when tool calls are permissible and specifying fallbacks if they are not. This enables agent developers and users to craft suitable policies for their specific use cases and enforce them deterministically to guarantee security. Thanks to its modular design, integrating Progent does not alter agent internals and requires only minimal changes to agent implementation, enhancing its practicality and potential for widespread adoption. To automate policy writing, we leverage LLMs to generate policies based on user queries, which are then updated dynamically for improved security and utility. Our extensive evaluation shows that it enables strong security while preserving high utility across three distinct scenarios or benchmarks: AgentDojo, ASB, and AgentPoison. Furthermore, we perform an in-depth analysis, showcasing the effectiveness of its core components and the resilience of its automated policy generation against adaptive attacks.', 'score': 1, 'issue_id': 3380, 'pub_date': '2025-04-16', 'pub_date_card': {'ru': '16 апреля', 'en': 'April 16', 'zh': '4月16日'}, 'hash': '01631fbca25ffa05', 'authors': ['Tianneng Shi', 'Jingxuan He', 'Zhun Wang', 'Linyu Wu', 'Hongwei Li', 'Wenbo Guo', 'Dawn Song'], 'affiliations': ['UC Berkeley', 'UC Santa Barbara'], 'pdf_title_img': 'assets/pdf/title_img/2504.11703.jpg', 'data': {'categories': ['#benchmark', '#security', '#agents'], 'emoji': '🛡️', 'ru': {'title': 'Progent: Безопасность агентов LLM без компромиссов', 'desc': 'Progent - это первый механизм контроля привилегий для агентов на основе больших языковых моделей (LLM). Он использует предметно-ориентированный язык для гибкого выражения политик контроля привилегий, применяемых во время выполнения агента. Progent позволяет разработчикам и пользователям агентов создавать подходящие политики для конкретных случаев использования и детерминированно применять их для обеспечения безопасности. Система демонстрирует высокую эффективность в обеспечении безопасности при сохранении высокой полезности в различных сценариях и бенчмарках.'}, 'en': {'title': 'Empowering LLM Agents with Secure Privilege Control', 'desc': 'This paper introduces Progent, a novel privilege control mechanism designed for large language model (LLM) agents, which are AI systems that utilize LLMs to perform tasks. Progent aims to enhance security by implementing the principle of least privilege, allowing only necessary actions while blocking harmful commands. It features a domain-specific language that enables developers to create fine-grained privilege policies, ensuring that tool calls are made safely and effectively. The system is designed to be easily integrated into existing LLM agents with minimal changes, and it automates policy generation using LLMs to adapt to user needs, demonstrating strong security and utility across various scenarios.'}, 'zh': {'title': 'LLM代理的安全守护者：Progent权限控制机制', 'desc': 'LLM代理是一种新兴的人工智能系统，利用大型语言模型（LLM）作为核心组件，结合多种工具完成用户任务。然而，这些代理在与外部世界互动时可能面临安全风险，可能会执行恶意命令。为了解决这个问题，我们提出了Progent，这是第一个针对LLM代理的权限控制机制，允许在执行过程中灵活地表达权限控制策略。通过这种方式，开发者可以为特定用例制定合适的策略，从而在保证安全的同时提高实用性。'}}}, {'id': 'https://huggingface.co/papers/2504.16082', 'title': 'MR. Video: "MapReduce" is the Principle for Long Video Understanding', 'url': 'https://huggingface.co/papers/2504.16082', 'abstract': 'We propose MR. Video, an agentic long video understanding framework that demonstrates the simple yet effective MapReduce principle for processing long videos: (1) Map: independently and densely perceiving short video clips, and (2) Reduce: jointly aggregating information from all clips. Compared with sequence-to-sequence vision-language models (VLMs), MR. Video performs detailed short video perception without being limited by context length. Compared with existing video agents that typically rely on sequential key segment selection, the Map operation enables simpler and more scalable sequence parallel perception of short video segments. Its Reduce step allows for more comprehensive context aggregation and reasoning, surpassing explicit key segment retrieval. This MapReduce principle is applicable to both VLMs and video agents, and we use LLM agents to validate its effectiveness.   In practice, MR. Video employs two MapReduce stages: (A) Captioning: generating captions for short video clips (map), then standardizing repeated characters and objects into shared names (reduce); (B) Analysis: for each user question, analyzing relevant information from individual short videos (map), and integrating them into a final answer (reduce). MR. Video achieves over 10% accuracy improvement on the challenging LVBench compared to state-of-the-art VLMs and video agents.   Code is available at: https://github.com/ziqipang/MR-Video', 'score': 0, 'issue_id': 3380, 'pub_date': '2025-04-22', 'pub_date_card': {'ru': '22 апреля', 'en': 'April 22', 'zh': '4月22日'}, 'hash': '52146a0dfc463f6d', 'authors': ['Ziqi Pang', 'Yu-Xiong Wang'], 'affiliations': ['University of Illinois Urbana-Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2504.16082.jpg', 'data': {'categories': ['#long_context', '#reasoning', '#multimodal', '#video', '#agents'], 'emoji': '🎬', 'ru': {'title': 'MapReduce для видео: новый уровень понимания длинного контента', 'desc': 'MR. Video - это новый подход к пониманию длинных видео, основанный на принципе MapReduce. Он включает в себя два этапа: независимое восприятие коротких видеоклипов (Map) и совместную агрегацию информации из всех клипов (Reduce). Этот метод превосходит существующие vision-language модели и видео-агенты, обеспечивая более детальное восприятие и масштабируемую обработку. MR. Video достигает более чем 10% улучшения точности на сложном бенчмарке LVBench по сравнению с современными моделями.'}, 'en': {'title': 'Revolutionizing Long Video Understanding with MapReduce', 'desc': "MR. Video is a framework designed for understanding long videos by applying the MapReduce principle. It processes short video clips independently in the 'Map' phase, allowing for detailed perception without the constraints of context length. In the 'Reduce' phase, it aggregates information from all clips for comprehensive reasoning, outperforming traditional methods that rely on key segment selection. This approach not only enhances accuracy but also demonstrates scalability in video analysis tasks, achieving significant improvements over existing models."}, 'zh': {'title': 'MR. Video：长视频理解的新方法', 'desc': '我们提出了MR. Video，这是一个用于长视频理解的框架，采用了简单而有效的MapReduce原则来处理长视频。首先，通过独立且密集地感知短视频片段（Map），然后将所有片段的信息进行聚合（Reduce）。与传统的序列到序列视觉语言模型相比，MR. Video能够在不受上下文长度限制的情况下，进行详细的短视频感知。通过使用大规模语言模型（LLM）代理验证其有效性，MR. Video在LVBench挑战中相比于最先进的视觉语言模型和视频代理实现了超过10%的准确率提升。'}}}, {'id': 'https://huggingface.co/papers/2504.14977', 'title': 'RealisDance-DiT: Simple yet Strong Baseline towards Controllable\n  Character Animation in the Wild', 'url': 'https://huggingface.co/papers/2504.14977', 'abstract': 'Controllable character animation remains a challenging problem, particularly in handling rare poses, stylized characters, character-object interactions, complex illumination, and dynamic scenes. To tackle these issues, prior work has largely focused on injecting pose and appearance guidance via elaborate bypass networks, but often struggles to generalize to open-world scenarios. In this paper, we propose a new perspective that, as long as the foundation model is powerful enough, straightforward model modifications with flexible fine-tuning strategies can largely address the above challenges, taking a step towards controllable character animation in the wild. Specifically, we introduce RealisDance-DiT, built upon the Wan-2.1 video foundation model. Our sufficient analysis reveals that the widely adopted Reference Net design is suboptimal for large-scale DiT models. Instead, we demonstrate that minimal modifications to the foundation model architecture yield a surprisingly strong baseline. We further propose the low-noise warmup and "large batches and small iterations" strategies to accelerate model convergence during fine-tuning while maximally preserving the priors of the foundation model. In addition, we introduce a new test dataset that captures diverse real-world challenges, complementing existing benchmarks such as TikTok dataset and UBC fashion video dataset, to comprehensively evaluate the proposed method. Extensive experiments show that RealisDance-DiT outperforms existing methods by a large margin.', 'score': 0, 'issue_id': 3380, 'pub_date': '2025-04-21', 'pub_date_card': {'ru': '21 апреля', 'en': 'April 21', 'zh': '4月21日'}, 'hash': '96e96789c52f6da1', 'authors': ['Jingkai Zhou', 'Yifan Wu', 'Shikai Li', 'Min Wei', 'Chao Fan', 'Weihua Chen', 'Wei Jiang', 'Fan Wang'], 'affiliations': ['DAMO Academy, Alibaba Group', 'Hupan Lab', 'Shenzhen University', 'Southern University of Science and Technology', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2504.14977.jpg', 'data': {'categories': ['#training', '#dataset', '#video', '#architecture'], 'emoji': '🕺', 'ru': {'title': 'Революция в анимации персонажей: от сложных сетей к простым модификациям', 'desc': "Статья представляет новый подход к управляемой анимации персонажей с использованием мощных фундаментальных моделей. Авторы предлагают RealisDance-DiT, основанную на видеомодели Wan-2.1, с минимальными модификациями архитектуры. Они вводят стратегии обучения, такие как разогрев с низким шумом и 'большие батчи и малые итерации', для ускорения сходимости модели. Эксперименты показывают, что RealisDance-DiT значительно превосходит существующие методы по различным сложным сценариям анимации."}, 'en': {'title': 'Revolutionizing Character Animation with RealisDance-DiT', 'desc': 'This paper addresses the challenges of controllable character animation, particularly in complex scenarios involving rare poses and dynamic environments. The authors introduce RealisDance-DiT, a model that leverages a powerful foundation model with minimal architectural modifications and flexible fine-tuning strategies. They argue that traditional methods, which rely on elaborate bypass networks, often fail to generalize well, while their approach shows significant improvements in performance. Additionally, they present a new test dataset to evaluate their method against existing benchmarks, demonstrating that RealisDance-DiT significantly outperforms prior techniques.'}, 'zh': {'title': '简单修改，强大动画！', 'desc': '可控角色动画仍然是一个具有挑战性的问题，尤其是在处理稀有姿势、风格化角色、角色与物体的交互、复杂照明和动态场景时。本文提出了一种新视角，认为只要基础模型足够强大，通过灵活的微调策略对模型进行简单修改，可以有效解决这些挑战。我们引入了RealisDance-DiT，基于Wan-2.1视频基础模型，并发现广泛采用的参考网络设计对于大规模DiT模型并不理想。通过最小的架构修改，我们展示了强大的基线性能，并提出了低噪声预热和“大批量小迭代”策略，以加速微调过程中的模型收敛，同时最大限度地保留基础模型的先验知识。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d', '#agents (2)', '#agi', '#alignment', '#architecture (2)', '#audio', '#benchmark (5)', '#cv (2)', '#data (1)', '#dataset (3)', '#diffusion (1)', '#ethics', '#games (1)', '#graphs', '#hallucinations', '#healthcare', '#inference (2)', '#interpretability', '#leakage', '#long_context (3)', '#low_resource (1)', '#machine_translation', '#math', '#multilingual (1)', '#multimodal (3)', '#open_source', '#optimization (3)', '#plp', '#rag', '#reasoning (2)', '#rl (1)', '#rlhf', '#robotics', '#science', '#security (1)', '#small_models', '#story_generation', '#survey', '#synthetic', '#training (2)', '#transfer_learning', '#video (3)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-04-23 02:24',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-04-23 02:24')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-04-23 02:24')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    