
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 10 papers. September 5.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">5 сентября</span> | <span id="title-articles-count">10 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-09-04.html">⬅️ <span id="prev-date">04.09</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-09-08.html">➡️ <span id="next-date">08.09</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-09.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '5 сентября', 'en': 'September 5', 'zh': '9月5日'};
        let feedDateNext = {'ru': '08.09', 'en': '09/08', 'zh': '9月8日'};
        let feedDatePrev = {'ru': '04.09', 'en': '09/04', 'zh': '9月4日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2509.04419', 'title': 'Towards a Unified View of Large Language Model Post-Training', 'url': 'https://huggingface.co/papers/2509.04419', 'abstract': 'A unified policy gradient estimator and Hybrid Post-Training algorithm effectively combine online and offline data for post-training language models, improving performance across various benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Two major sources of training data exist for post-training modern language models: online (model-generated rollouts) data, and offline (human or other-model demonstrations) data. These two types of data are typically used by approaches like Reinforcement Learning (RL) and Supervised Fine-Tuning (SFT), respectively. In this paper, we show that these approaches are not in contradiction, but are instances of a single optimization process. We derive a Unified Policy Gradient Estimator, and present the calculations of a wide spectrum of post-training approaches as the gradient of a common objective under different data distribution assumptions and various bias-variance tradeoffs. The gradient estimator is constructed with four interchangeable parts: stabilization mask, reference policy denominator, advantage estimate, and likelihood gradient. Motivated by our theoretical findings, we propose Hybrid Post-Training (HPT), an algorithm that dynamically selects different training signals. HPT is designed to yield both effective exploitation of demonstration and stable exploration without sacrificing learned reasoning patterns. We provide extensive experiments and ablation studies to verify the effectiveness of our unified theoretical framework and HPT. Across six mathematical reasoning benchmarks and two out-of-distribution suites, HPT consistently surpasses strong baselines across models of varying scales and families.', 'score': 27, 'issue_id': 5730, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '91f46a497fb0af28', 'authors': ['Xingtai Lv', 'Yuxin Zuo', 'Youbang Sun', 'Hongyi Liu', 'Yuntian Wei', 'Zhekai Chen', 'Lixuan He', 'Xuekai Zhu', 'Kaiyan Zhang', 'Bingning Wang', 'Ning Ding', 'Bowen Zhou'], 'affiliations': ['Shanghai AI Laboratory', 'Tsinghua University', 'WeChat AI'], 'pdf_title_img': 'assets/pdf/title_img/2509.04419.jpg', 'data': {'categories': ['#benchmark', '#reasoning', '#optimization', '#training', '#rl'], 'emoji': '🧠', 'ru': {'title': 'Объединение онлайн и офлайн данных для улучшения языковых моделей', 'desc': 'В статье представлен унифицированный оценщик градиента политики и алгоритм гибридного пост-обучения для языковых моделей. Авторы показывают, что подходы обучения с подкреплением и супервизорной донастройки являются частями единого процесса оптимизации. Предложенный метод Hybrid Post-Training эффективно комбинирует онлайн и офлайн данные для пост-обучения. Эксперименты на различных бенчмарках подтверждают преимущества нового подхода над существующими базовыми методами.'}, 'en': {'title': 'Unifying Online and Offline Learning for Superior Language Model Training', 'desc': 'This paper introduces a Unified Policy Gradient Estimator that integrates online and offline data for enhancing post-training in language models. It demonstrates that traditional methods like Reinforcement Learning and Supervised Fine-Tuning are part of a unified optimization framework. The proposed Hybrid Post-Training (HPT) algorithm adapts training signals to balance between utilizing demonstrations and exploring new strategies. Extensive experiments show that HPT outperforms existing methods across multiple benchmarks, confirming the effectiveness of the unified approach.'}, 'zh': {'title': '统一策略，提升语言模型性能', 'desc': '本文提出了一种统一的策略梯度估计器和混合后训练算法，能够有效结合在线和离线数据，以提升语言模型的性能。在线数据通常来自模型生成的回滚，而离线数据则是人类或其他模型的示范。我们证明了强化学习和监督微调这两种方法并不矛盾，而是同一优化过程的不同实例。通过广泛的实验和消融研究，我们验证了我们的理论框架和混合后训练算法的有效性。'}}}, {'id': 'https://huggingface.co/papers/2509.04292', 'title': 'Inverse IFEval: Can LLMs Unlearn Stubborn Training Conventions to Follow\n  Real Instructions?', 'url': 'https://huggingface.co/papers/2509.04292', 'abstract': "Inverse IFEval evaluates Large Language Models' ability to override training biases and follow unconventional instructions, highlighting the need for adaptability in diverse contexts.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) achieve strong performance on diverse tasks but often exhibit cognitive inertia, struggling to follow instructions that conflict with the standardized patterns learned during supervised fine-tuning (SFT). To evaluate this limitation, we propose Inverse IFEval, a benchmark that measures models Counter-intuitive Abilitytheir capacity to override training-induced biases and comply with adversarial instructions. Inverse IFEval introduces eight types of such challenges, including Question Correction, Intentional Textual Flaws, Code without Comments, and Counterfactual Answering. Using a human-in-the-loop pipeline, we construct a dataset of 1012 high-quality Chinese and English questions across 23 domains, evaluated under an optimized LLM-as-a-Judge framework. Experiments on existing leading LLMs demonstrate the necessity of our proposed Inverse IFEval benchmark. Our findings emphasize that future alignment efforts should not only pursue fluency and factual correctness but also account for adaptability under unconventional contexts. We hope that Inverse IFEval serves as both a diagnostic tool and a foundation for developing methods that mitigate cognitive inertia, reduce overfitting to narrow patterns, and ultimately enhance the instruction-following reliability of LLMs in diverse and unpredictable real-world scenarios.", 'score': 26, 'issue_id': 5732, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '65e94af989385211', 'authors': ['Qinyan Zhang', 'Xinping Lei', 'Ruijie Miao', 'Yu Fu', 'Haojie Fan', 'Le Chang', 'Jiafan Hou', 'Dingling Zhang', 'Zhongfei Hou', 'Ziqiang Yang', 'Changxin Pu', 'Fei Hu', 'Jingkai Liu', 'Mengyun Liu', 'Yang Liu', 'Xiang Gao', 'Jiaheng Liu', 'Tong Yang', 'Zaiyuan Wang', 'Ge Zhang', 'Wenhao Huang'], 'affiliations': ['ByteDance', 'Jiyun Hudong', 'Nanjing University'], 'pdf_title_img': 'assets/pdf/title_img/2509.04292.jpg', 'data': {'categories': ['#multilingual', '#hallucinations', '#dataset', '#benchmark', '#alignment'], 'emoji': '🧠', 'ru': {'title': 'Преодоление когнитивной инерции в больших языковых моделях', 'desc': 'Статья представляет новый бенчмарк Inverse IFEval для оценки способности больших языковых моделей (LLM) преодолевать предвзятости, полученные в ходе обучения, и следовать нестандартным инструкциям. Бенчмарк включает восемь типов задач, таких как исправление вопросов и контрфактический ответ, охватывая 1012 вопросов на китайском и английском языках. Эксперименты показали необходимость такой оценки для выявления ограничений существующих LLM. Авторы подчеркивают важность развития адаптивности моделей в разнообразных и непредсказуемых реальных сценариях.'}, 'en': {'title': 'Enhancing LLMs: Overcoming Biases for Better Adaptability', 'desc': "The paper introduces Inverse IFEval, a benchmark designed to assess the ability of Large Language Models (LLMs) to overcome biases from their training and follow unconventional instructions. It highlights that while LLMs perform well on many tasks, they often struggle with instructions that deviate from their learned patterns, a phenomenon known as cognitive inertia. The benchmark includes eight challenge types, such as Question Correction and Counterfactual Answering, to evaluate models' adaptability across various contexts. The findings suggest that improving LLMs requires not just fluency and accuracy, but also the ability to adapt to unexpected instructions in real-world applications."}, 'zh': {'title': '评估语言模型的适应能力', 'desc': '本文提出了Inverse IFEval基准，用于评估大型语言模型（LLMs）在面对与训练偏见相悖的指令时的适应能力。研究发现，尽管LLMs在多种任务上表现出色，但它们在遵循与标准化模式相冲突的指令时常常表现出认知惯性。Inverse IFEval引入了八种挑战类型，旨在测量模型克服训练偏见的能力。我们的实验结果表明，未来的对齐工作不仅要关注流畅性和事实正确性，还要考虑在非常规环境下的适应性。'}}}, {'id': 'https://huggingface.co/papers/2509.01396', 'title': "DeepResearch Arena: The First Exam of LLMs' Research Abilities via\n  Seminar-Grounded Tasks", 'url': 'https://huggingface.co/papers/2509.01396', 'abstract': "DeepResearch Arena, a benchmark using academic seminar transcripts, provides high-quality research tasks to evaluate deep research agents across multiple disciplines.  \t\t\t\t\tAI-generated summary \t\t\t\t Deep research agents have attracted growing attention for their potential to orchestrate multi-stage research workflows, spanning literature synthesis, methodological design, and empirical verification. Despite these strides, evaluating their research capability faithfully is rather challenging due to the difficulty of collecting frontier research questions that genuinely capture researchers' attention and intellectual curiosity. To address this gap, we introduce DeepResearch Arena, a benchmark grounded in academic seminars that capture rich expert discourse and interaction, better reflecting real-world research environments and reducing the risk of data leakage. To automatically construct DeepResearch Arena, we propose a Multi-Agent Hierarchical Task Generation (MAHTG) system that extracts research-worthy inspirations from seminar transcripts. The MAHTG system further translates research-worthy inspirations into high-quality research tasks, ensuring the traceability of research task formulation while filtering noise. With the MAHTG system, we curate DeepResearch Arena with over 10,000 high-quality research tasks from over 200 academic seminars, spanning 12 disciplines, such as literature, history, and science. Our extensive evaluation shows that DeepResearch Arena presents substantial challenges for current state-of-the-art agents, with clear performance gaps observed across different models.", 'score': 24, 'issue_id': 5729, 'pub_date': '2025-09-01', 'pub_date_card': {'ru': '1 сентября', 'en': 'September 1', 'zh': '9月1日'}, 'hash': '85ed0a774ea098f6', 'authors': ['Haiyuan Wan', 'Chen Yang', 'Junchi Yu', 'Meiqi Tu', 'Jiaxuan Lu', 'Di Yu', 'Jianbao Cao', 'Ben Gao', 'Jiaqing Xie', 'Aoran Wang', 'Wenlong Zhang', 'Philip Torr', 'Dongzhan Zhou'], 'affiliations': ['Shanghai Artificial Intelligence Laboratory', 'The Hong Kong University of Science and Technology, Guangzhou', 'The University of Hong Kong', 'Tsinghua University', 'University of Oxford', 'Wuhan University'], 'pdf_title_img': 'assets/pdf/title_img/2509.01396.jpg', 'data': {'categories': ['#leakage', '#science', '#agents', '#benchmark', '#survey', '#dataset'], 'emoji': '🧠', 'ru': {'title': 'Академические семинары как основа для оценки ИИ-исследователей', 'desc': 'DeepResearch Arena - это новый бенчмарк для оценки глубоких исследовательских агентов, основанный на транскриптах академических семинаров. Он использует систему Multi-Agent Hierarchical Task Generation (MAHTG) для автоматического создания исследовательских задач из семинарских обсуждений. Бенчмарк включает более 10 000 задач из 12 дисциплин, от литературы до естественных наук. Тестирование показало, что современные модели ИИ сталкиваются со значительными трудностями при решении этих задач.'}, 'en': {'title': 'Elevating Research Evaluation with DeepResearch Arena', 'desc': 'DeepResearch Arena is a new benchmark designed to evaluate deep research agents by using transcripts from academic seminars. It focuses on creating high-quality research tasks that reflect real-world research environments, addressing the challenge of finding relevant research questions. The benchmark is built using a Multi-Agent Hierarchical Task Generation (MAHTG) system, which extracts valuable insights from seminar discussions and converts them into structured research tasks. With over 10,000 tasks across various disciplines, this benchmark highlights the performance gaps of current research agents, pushing the boundaries of their capabilities.'}, 'zh': {'title': '深度研究代理的新挑战', 'desc': 'DeepResearch Arena 是一个基准测试，利用学术研讨会的记录来评估深度研究代理的能力。该平台提供高质量的研究任务，涵盖多个学科，帮助评估代理在文献综合、方法设计和实证验证等多阶段研究工作流中的表现。为了构建这个基准，我们提出了多智能体层次任务生成系统（MAHTG），从研讨会记录中提取研究灵感，并将其转化为高质量的研究任务。我们的评估表明，DeepResearch Arena 对当前最先进的研究代理提出了显著挑战，显示出不同模型之间的明显性能差距。'}}}, {'id': 'https://huggingface.co/papers/2509.04338', 'title': 'From Editor to Dense Geometry Estimator', 'url': 'https://huggingface.co/papers/2509.04338', 'abstract': 'FE2E, a framework using a Diffusion Transformer for dense geometry prediction, outperforms generative models in zero-shot monocular depth and normal estimation with improved performance and efficiency.  \t\t\t\t\tAI-generated summary \t\t\t\t Leveraging visual priors from pre-trained text-to-image (T2I) generative models has shown success in dense prediction. However, dense prediction is inherently an image-to-image task, suggesting that image editing models, rather than T2I generative models, may be a more suitable foundation for fine-tuning.   Motivated by this, we conduct a systematic analysis of the fine-tuning behaviors of both editors and generators for dense geometry estimation. Our findings show that editing models possess inherent structural priors, which enable them to converge more stably by ``refining" their innate features, and ultimately achieve higher performance than their generative counterparts.   Based on these findings, we introduce FE2E, a framework that pioneeringly adapts an advanced editing model based on Diffusion Transformer (DiT) architecture for dense geometry prediction. Specifically, to tailor the editor for this deterministic task, we reformulate the editor\'s original flow matching loss into the ``consistent velocity" training objective. And we use logarithmic quantization to resolve the precision conflict between the editor\'s native BFloat16 format and the high precision demand of our tasks. Additionally, we leverage the DiT\'s global attention for a cost-free joint estimation of depth and normals in a single forward pass, enabling their supervisory signals to mutually enhance each other.   Without scaling up the training data, FE2E achieves impressive performance improvements in zero-shot monocular depth and normal estimation across multiple datasets. Notably, it achieves over 35\\% performance gains on the ETH3D dataset and outperforms the DepthAnything series, which is trained on 100times data. The project page can be accessed https://amap-ml.github.io/FE2E/{here}.', 'score': 21, 'issue_id': 5732, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '3fbd2457f43c1688', 'authors': ['JiYuan Wang', 'Chunyu Lin', 'Lei Sun', 'Rongying Liu', 'Lang Nie', 'Mingxing Li', 'Kang Liao', 'Xiangxiang Chu', 'Yao Zhao'], 'affiliations': ['AMAP Alibaba Group', 'BJTU', 'CQUPT', 'NTU'], 'pdf_title_img': 'assets/pdf/title_img/2509.04338.jpg', 'data': {'categories': ['#inference', '#cv', '#diffusion', '#optimization', '#training'], 'emoji': '🔬', 'ru': {'title': 'FE2E: Революция в оценке глубины и нормалей с помощью Diffusion Transformer', 'desc': 'FE2E - это новый фреймворк, использующий Diffusion Transformer для предсказания плотной геометрии. Он превосходит генеративные модели в задачах оценки глубины и нормалей с нулевым обучением. FE2E адаптирует продвинутую модель редактирования на основе архитектуры DiT для этой задачи. Без увеличения объема обучающих данных, FE2E достигает значительных улучшений производительности в оценке монокулярной глубины и нормалей на нескольких наборах данных.'}, 'en': {'title': 'FE2E: Revolutionizing Dense Geometry Prediction with Diffusion Transformers', 'desc': "The paper introduces FE2E, a novel framework that utilizes a Diffusion Transformer for predicting dense geometry, specifically focusing on monocular depth and normal estimation. It demonstrates that editing models, which refine existing features, outperform generative models in this context due to their structural priors. The authors reformulate the training objective to enhance the model's performance and employ logarithmic quantization to address precision issues. FE2E achieves significant improvements in performance without requiring additional training data, showcasing its efficiency and effectiveness across various datasets."}, 'zh': {'title': 'FE2E：密集几何预测的新突破', 'desc': 'FE2E是一个使用扩散变换器的框架，专注于密集几何预测，表现优于生成模型，尤其在零样本单目深度和法线估计方面。该研究表明，图像编辑模型比文本到图像生成模型更适合进行密集预测，因为它们具有更稳定的收敛性和更高的性能。通过重新设计编辑模型的损失函数和使用对数量化，FE2E有效解决了精度问题，并利用全局注意力实现深度和法线的联合估计。最终，FE2E在多个数据集上取得了显著的性能提升，尤其是在ETH3D数据集上超过了35%的性能增益。'}}}, {'id': 'https://huggingface.co/papers/2509.04394', 'title': 'Transition Models: Rethinking the Generative Learning Objective', 'url': 'https://huggingface.co/papers/2509.04394', 'abstract': 'A novel generative paradigm, Transition Models (TiM), addresses the trade-off between computational cost and output quality in generative modeling by using a continuous-time dynamics equation.  \t\t\t\t\tAI-generated summary \t\t\t\t A fundamental dilemma in generative modeling persists: iterative diffusion models achieve outstanding fidelity, but at a significant computational cost, while efficient few-step alternatives are constrained by a hard quality ceiling. This conflict between generation steps and output quality arises from restrictive training objectives that focus exclusively on either infinitesimal dynamics (PF-ODEs) or direct endpoint prediction. We address this challenge by introducing an exact, continuous-time dynamics equation that analytically defines state transitions across any finite time interval. This leads to a novel generative paradigm, Transition Models (TiM), which adapt to arbitrary-step transitions, seamlessly traversing the generative trajectory from single leaps to fine-grained refinement with more steps. Despite having only 865M parameters, TiM achieves state-of-the-art performance, surpassing leading models such as SD3.5 (8B parameters) and FLUX.1 (12B parameters) across all evaluated step counts. Importantly, unlike previous few-step generators, TiM demonstrates monotonic quality improvement as the sampling budget increases. Additionally, when employing our native-resolution strategy, TiM delivers exceptional fidelity at resolutions up to 4096x4096.', 'score': 8, 'issue_id': 5730, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '872ae225cb79c916', 'authors': ['Zidong Wang', 'Yiyuan Zhang', 'Xiaoyu Yue', 'Xiangyu Yue', 'Yangguang Li', 'Wanli Ouyang', 'Lei Bai'], 'affiliations': ['MMLab, CUHK', 'Shanghai AI Lab', 'USYD'], 'pdf_title_img': 'assets/pdf/title_img/2509.04394.jpg', 'data': {'categories': ['#small_models', '#optimization', '#generative_modeling', '#diffusion', '#training'], 'emoji': '🔄', 'ru': {'title': 'TiM: гибкое генеративное моделирование с непрерывным временем', 'desc': 'Статья представляет новую парадигму генеративного моделирования - Transition Models (TiM). TiM использует уравнение динамики непрерывного времени для решения проблемы компромисса между вычислительными затратами и качеством выходных данных. Модель TiM адаптируется к переходам с произвольным количеством шагов, демонстрируя монотонное улучшение качества при увеличении бюджета сэмплирования. Несмотря на относительно небольшое количество параметров (865 млн), TiM превосходит ведущие модели с большим числом параметров по всем оцениваемым показателям.'}, 'en': {'title': 'Transition Models: Bridging Quality and Efficiency in Generative Modeling', 'desc': 'The paper introduces Transition Models (TiM), a new approach in generative modeling that balances computational efficiency and output quality. It tackles the existing dilemma where high-fidelity models require extensive computation, while faster models compromise on quality. TiM utilizes a continuous-time dynamics equation to define state transitions, allowing for flexible generation steps that can adapt from coarse to fine outputs. With only 865 million parameters, TiM outperforms larger models in quality and maintains consistent improvements as more computational resources are allocated.'}, 'zh': {'title': '过渡模型：高效生成与优质输出的完美平衡', 'desc': '本文提出了一种新的生成模型范式——过渡模型（TiM），旨在解决生成建模中计算成本与输出质量之间的权衡。传统的迭代扩散模型虽然生成质量高，但计算开销大，而高效的少步生成方法则受到质量上限的限制。TiM通过引入精确的连续时间动态方程，定义了任意有限时间间隔内的状态转移，从而实现了灵活的生成过程。尽管参数量仅为8.65亿，TiM在所有评估的步数中都超越了领先模型，展现出随着采样预算增加而持续提升的生成质量。'}}}, {'id': 'https://huggingface.co/papers/2509.04011', 'title': 'NER Retriever: Zero-Shot Named Entity Retrieval with Type-Aware\n  Embeddings', 'url': 'https://huggingface.co/papers/2509.04011', 'abstract': 'NER Retriever uses internal representations from large language models to perform zero-shot named entity retrieval by embedding entity mentions and type descriptions into a shared semantic space, outperforming lexical and dense sentence-level retrieval methods.  \t\t\t\t\tAI-generated summary \t\t\t\t We present NER Retriever, a zero-shot retrieval framework for ad-hoc Named Entity Retrieval, a variant of Named Entity Recognition (NER), where the types of interest are not provided in advance, and a user-defined type description is used to retrieve documents mentioning entities of that type. Instead of relying on fixed schemas or fine-tuned models, our method builds on internal representations of large language models (LLMs) to embed both entity mentions and user-provided open-ended type descriptions into a shared semantic space. We show that internal representations, specifically the value vectors from mid-layer transformer blocks, encode fine-grained type information more effectively than commonly used top-layer embeddings. To refine these representations, we train a lightweight contrastive projection network that aligns type-compatible entities while separating unrelated types. The resulting entity embeddings are compact, type-aware, and well-suited for nearest-neighbor search. Evaluated on three benchmarks, NER Retriever significantly outperforms both lexical and dense sentence-level retrieval baselines. Our findings provide empirical support for representation selection within LLMs and demonstrate a practical solution for scalable, schema-free entity retrieval. The NER Retriever Codebase is publicly available at https://github.com/ShacharOr100/ner_retriever', 'score': 7, 'issue_id': 5733, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': 'f55762e727076e6b', 'authors': ['Or Shachar', 'Uri Katz', 'Yoav Goldberg', 'Oren Glickman'], 'affiliations': ['Computer Science Department, Bar-Ilan University'], 'pdf_title_img': 'assets/pdf/title_img/2509.04011.jpg', 'data': {'categories': ['#dataset', '#benchmark', '#transfer_learning', '#multimodal', '#open_source'], 'emoji': '🔍', 'ru': {'title': 'Извлечение сущностей без схем с помощью внутренних представлений языковых моделей', 'desc': 'NER Retriever - это фреймворк для извлечения именованных сущностей без предварительного обучения. Он использует внутренние представления больших языковых моделей для встраивания упоминаний сущностей и описаний типов в общее семантическое пространство. Метод применяет векторы значений из средних слоев трансформера, которые лучше кодируют типовую информацию, чем верхние слои. NER Retriever превосходит лексические методы и методы плотного поиска на уровне предложений на трех эталонных наборах данных.'}, 'en': {'title': 'Zero-Shot Entity Retrieval with NER Retriever', 'desc': 'NER Retriever is a novel framework for zero-shot Named Entity Retrieval (NER) that allows users to retrieve documents based on entity types without prior definitions. It utilizes internal representations from large language models (LLMs) to create a shared semantic space for embedding both entity mentions and user-defined type descriptions. By leveraging mid-layer transformer block value vectors, the method captures fine-grained type information more effectively than traditional embeddings. A contrastive projection network further refines these embeddings, resulting in a compact and type-aware representation that excels in nearest-neighbor search, outperforming existing retrieval methods.'}, 'zh': {'title': '零-shot命名实体检索的创新解决方案', 'desc': 'NER Retriever 是一种零-shot命名实体检索框架，旨在根据用户定义的类型描述检索相关文档，而无需事先提供感兴趣的类型。该方法利用大型语言模型的内部表示，将实体提及和类型描述嵌入到共享的语义空间中，从而超越了传统的词汇和密集句子级检索方法。我们通过训练轻量级对比投影网络来优化这些表示，使得相似类型的实体能够对齐，而不相关的类型则被分开。实验结果表明，NER Retriever 在多个基准测试中显著优于现有的检索基线，展示了在无模式实体检索中的有效性。'}}}, {'id': 'https://huggingface.co/papers/2509.04406', 'title': 'Few-step Flow for 3D Generation via Marginal-Data Transport Distillation', 'url': 'https://huggingface.co/papers/2509.04406', 'abstract': 'A novel framework, MDT-dist, accelerates 3D flow generation by distilling pretrained models to learn Marginal-Data Transport through Velocity Matching and Velocity Distillation, reducing sampling steps and improving speed and fidelity.  \t\t\t\t\tAI-generated summary \t\t\t\t Flow-based 3D generation models typically require dozens of sampling steps during inference. Though few-step distillation methods, particularly Consistency Models (CMs), have achieved substantial advancements in accelerating 2D diffusion models, they remain under-explored for more complex 3D generation tasks. In this study, we propose a novel framework, MDT-dist, for few-step 3D flow distillation. Our approach is built upon a primary objective: distilling the pretrained model to learn the Marginal-Data Transport. Directly learning this objective needs to integrate the velocity fields, while this integral is intractable to be implemented. Therefore, we propose two optimizable objectives, Velocity Matching (VM) and Velocity Distillation (VD), to equivalently convert the optimization target from the transport level to the velocity and the distribution level respectively. Velocity Matching (VM) learns to stably match the velocity fields between the student and the teacher, but inevitably provides biased gradient estimates. Velocity Distillation (VD) further enhances the optimization process by leveraging the learned velocity fields to perform probability density distillation. When evaluated on the pioneer 3D generation framework TRELLIS, our method reduces sampling steps of each flow transformer from 25 to 1 or 2, achieving 0.68s (1 step x 2) and 0.94s (2 steps x 2) latency with 9.0x and 6.5x speedup on A800, while preserving high visual and geometric fidelity. Extensive experiments demonstrate that our method significantly outperforms existing CM distillation methods, and enables TRELLIS to achieve superior performance in few-step 3D generation.', 'score': 4, 'issue_id': 5732, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': 'e5f91b790b483c4a', 'authors': ['Zanwei Zhou', 'Taoran Yi', 'Jiemin Fang', 'Chen Yang', 'Lingxi Xie', 'Xinggang Wang', 'Wei Shen', 'Qi Tian'], 'affiliations': ['Huawei Inc.', 'Huazhong University of Science and Technology', 'Shanghai Jiao Tong University'], 'pdf_title_img': 'assets/pdf/title_img/2509.04406.jpg', 'data': {'categories': ['#3d', '#inference', '#diffusion', '#optimization', '#training'], 'emoji': '🚀', 'ru': {'title': 'Революционное ускорение 3D-генерации с помощью дистилляции потоков', 'desc': 'MDT-dist - это новая система для ускорения генерации 3D-моделей на основе потоков. Она использует дистилляцию предобученных моделей для изучения маргинального транспорта данных через сопоставление и дистилляцию скоростей. Это позволяет сократить количество шагов сэмплирования с 25 до 1-2, значительно ускоряя процесс. MDT-dist превосходит существующие методы дистилляции и обеспечивает высокое качество генерируемых 3D-моделей.'}, 'en': {'title': 'Accelerating 3D Flow Generation with MDT-dist', 'desc': 'The paper introduces MDT-dist, a new framework designed to speed up 3D flow generation by using a technique called distillation on pretrained models. It focuses on learning Marginal-Data Transport through two main strategies: Velocity Matching (VM) and Velocity Distillation (VD). VM helps align the velocity fields of the student and teacher models, while VD improves the process by distilling probability densities from the learned velocity fields. This approach significantly reduces the number of sampling steps needed, achieving faster generation times while maintaining high quality in the output.'}, 'zh': {'title': 'MDT-dist：加速3D流生成的新方法', 'desc': '本文提出了一种新颖的框架MDT-dist，用于加速3D流生成。该方法通过对预训练模型进行蒸馏，学习边际数据传输，结合速度匹配和速度蒸馏，显著减少了采样步骤，提高了生成速度和保真度。与传统的3D生成模型相比，MDT-dist能够将每个流变换器的采样步骤从25减少到1或2，同时保持高质量的视觉和几何保真度。实验结果表明，该方法在少步3D生成任务中显著优于现有的蒸馏方法。'}}}, {'id': 'https://huggingface.co/papers/2509.04434', 'title': 'Durian: Dual Reference-guided Portrait Animation with Attribute Transfer', 'url': 'https://huggingface.co/papers/2509.04434', 'abstract': 'Durian uses dual reference networks and a diffusion model to generate high-fidelity portrait animations with attribute transfer from a reference image to a target portrait in a zero-shot manner.  \t\t\t\t\tAI-generated summary \t\t\t\t We present Durian, the first method for generating portrait animation videos with facial attribute transfer from a given reference image to a target portrait in a zero-shot manner. To enable high-fidelity and spatially consistent attribute transfer across frames, we introduce dual reference networks that inject spatial features from both the portrait and attribute images into the denoising process of a diffusion model. We train the model using a self-reconstruction formulation, where two frames are sampled from the same portrait video: one is treated as the attribute reference and the other as the target portrait, and the remaining frames are reconstructed conditioned on these inputs and their corresponding masks. To support the transfer of attributes with varying spatial extent, we propose a mask expansion strategy using keypoint-conditioned image generation for training. In addition, we further augment the attribute and portrait images with spatial and appearance-level transformations to improve robustness to positional misalignment between them. These strategies allow the model to effectively generalize across diverse attributes and in-the-wild reference combinations, despite being trained without explicit triplet supervision. Durian achieves state-of-the-art performance on portrait animation with attribute transfer, and notably, its dual reference design enables multi-attribute composition in a single generation pass without additional training.', 'score': 2, 'issue_id': 5731, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '4b84700e944a41a7', 'authors': ['Hyunsoo Cha', 'Byungjun Kim', 'Hanbyul Joo'], 'affiliations': ['Seoul National University'], 'pdf_title_img': 'assets/pdf/title_img/2509.04434.jpg', 'data': {'categories': ['#cv', '#diffusion', '#multimodal', '#video'], 'emoji': '🍍', 'ru': {'title': 'Революция в анимации портретов: перенос атрибутов без предварительного обучения', 'desc': 'Статья представляет метод Durian для генерации анимированных портретов с переносом атрибутов с референсного изображения на целевой портрет. Используются двойные эталонные сети и диффузионная модель для достижения высокой точности и пространственной согласованности при переносе атрибутов. Модель обучается на основе самореконструкции кадров из одного видео, используя расширение масок и аугментацию для улучшения обобщения. Durian демонстрирует передовые результаты в анимации портретов с переносом атрибутов и позволяет комбинировать несколько атрибутов за один проход генерации.'}, 'en': {'title': 'Transforming Portraits: High-Fidelity Animation with Attribute Transfer', 'desc': 'Durian is a novel method for creating high-quality portrait animations that can transfer facial attributes from a reference image to a target portrait without needing prior examples. It employs dual reference networks to enhance the denoising process of a diffusion model, ensuring that the transferred attributes maintain spatial consistency across video frames. The model is trained using a self-reconstruction approach, where it learns to generate frames based on a reference and target portrait, while also incorporating a mask expansion strategy for better attribute transfer. This innovative design allows Durian to effectively handle various attributes and combinations, achieving top performance in the field of portrait animation.'}, 'zh': {'title': 'Durian：高保真肖像动画的创新方法', 'desc': 'Durian是一种新方法，可以在没有额外训练的情况下，从参考图像生成高保真度的肖像动画。它使用双重参考网络和扩散模型，将面部属性从参考图像转移到目标肖像。通过自重建的方式训练模型，使得不同帧之间的属性转移保持一致性。Durian在肖像动画和属性转移方面达到了最先进的性能，能够在一次生成中实现多属性组合。'}}}, {'id': 'https://huggingface.co/papers/2508.18733', 'title': 'Drawing2CAD: Sequence-to-Sequence Learning for CAD Generation from\n  Vector Drawings', 'url': 'https://huggingface.co/papers/2508.18733', 'abstract': 'Drawing2CAD is a framework that converts 2D vector drawings into parametric CAD models using a sequence-to-sequence learning approach with a dual-decoder transformer architecture and a soft target distribution loss function.  \t\t\t\t\tAI-generated summary \t\t\t\t Computer-Aided Design (CAD) generative modeling is driving significant innovations across industrial applications. Recent works have shown remarkable progress in creating solid models from various inputs such as point clouds, meshes, and text descriptions. However, these methods fundamentally diverge from traditional industrial workflows that begin with 2D engineering drawings. The automatic generation of parametric CAD models from these 2D vector drawings remains underexplored despite being a critical step in engineering design. To address this gap, our key insight is to reframe CAD generation as a sequence-to-sequence learning problem where vector drawing primitives directly inform the generation of parametric CAD operations, preserving geometric precision and design intent throughout the transformation process. We propose Drawing2CAD, a framework with three key technical components: a network-friendly vector primitive representation that preserves precise geometric information, a dual-decoder transformer architecture that decouples command type and parameter generation while maintaining precise correspondence, and a soft target distribution loss function accommodating inherent flexibility in CAD parameters. To train and evaluate Drawing2CAD, we create CAD-VGDrawing, a dataset of paired engineering drawings and parametric CAD models, and conduct thorough experiments to demonstrate the effectiveness of our method. Code and dataset are available at https://github.com/lllssc/Drawing2CAD.', 'score': 2, 'issue_id': 5729, 'pub_date': '2025-08-26', 'pub_date_card': {'ru': '26 августа', 'en': 'August 26', 'zh': '8月26日'}, 'hash': '4b2fa59592c89297', 'authors': ['Feiwei Qin', 'Shichao Lu', 'Junhao Hou', 'Changmiao Wang', 'Meie Fang', 'Ligang Liu'], 'affiliations': ['Guangzhou University, Guangzhou, China', 'Hangzhou Dianzi University, Hangzhou, China', 'Shenzhen Research Institute of Big Data, Shenzhen, China', 'University of Science and Technology of China, Hefei, China', 'Zhejiang University, Hangzhou, China'], 'pdf_title_img': 'assets/pdf/title_img/2508.18733.jpg', 'data': {'categories': ['#optimization', '#training', '#architecture', '#dataset', '#open_source'], 'emoji': '📐', 'ru': {'title': 'От чертежа к CAD: автоматическая генерация 3D-моделей из 2D-чертежей', 'desc': 'Drawing2CAD - это фреймворк, который преобразует 2D векторные чертежи в параметрические CAD-модели, используя подход sequence-to-sequence learning с архитектурой трансформера с двойным декодером. Он применяет функцию потерь с мягким целевым распределением для обучения модели. Ключевая идея заключается в переосмыслении генерации CAD как задачи последовательного обучения, где векторные примитивы чертежа напрямую информируют генерацию параметрических CAD-операций. Фреймворк включает три ключевых компонента: представление векторных примитивов, сохраняющее точную геометрическую информацию, архитектуру трансформера с двойным декодером и функцию потерь с мягким целевым распределением.'}, 'en': {'title': 'Transforming 2D Drawings into Precise CAD Models with AI', 'desc': 'Drawing2CAD is a novel framework that transforms 2D vector drawings into parametric CAD models using a sequence-to-sequence learning approach. It employs a dual-decoder transformer architecture to effectively separate the generation of command types and their corresponding parameters, ensuring geometric accuracy. The framework utilizes a soft target distribution loss function to handle the variability in CAD parameters, enhancing flexibility during model training. To validate its effectiveness, the authors introduce the CAD-VGDrawing dataset, which pairs engineering drawings with their corresponding CAD models, and conduct comprehensive experiments.'}, 'zh': {'title': '将二维图纸智能转化为CAD模型', 'desc': 'Drawing2CAD是一个将二维矢量图转换为参数化CAD模型的框架，采用序列到序列学习的方法。该框架使用双解码器变换器架构和软目标分布损失函数，确保在转换过程中保持几何精度和设计意图。通过将CAD生成重新定义为序列到序列学习问题，Drawing2CAD能够直接利用矢量图原语生成CAD操作。我们还创建了CAD-VGDrawing数据集，以训练和评估该框架的有效性。'}}}, {'id': 'https://huggingface.co/papers/2509.03888', 'title': 'False Sense of Security: Why Probing-based Malicious Input Detection\n  Fails to Generalize', 'url': 'https://huggingface.co/papers/2509.03888', 'abstract': "Probing-based approaches for detecting harmful instructions in LLMs are found to rely on superficial patterns rather than semantic understanding, indicating a need for redesigning models and evaluation methods.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) can comply with harmful instructions, raising serious safety concerns despite their impressive capabilities. Recent work has leveraged probing-based approaches to study the separability of malicious and benign inputs in LLMs' internal representations, and researchers have proposed using such probing methods for safety detection. We systematically re-examine this paradigm. Motivated by poor out-of-distribution performance, we hypothesize that probes learn superficial patterns rather than semantic harmfulness. Through controlled experiments, we confirm this hypothesis and identify the specific patterns learned: instructional patterns and trigger words. Our investigation follows a systematic approach, progressing from demonstrating comparable performance of simple n-gram methods, to controlled experiments with semantically cleaned datasets, to detailed analysis of pattern dependencies. These results reveal a false sense of security around current probing-based approaches and highlight the need to redesign both models and evaluation protocols, for which we provide further discussions in the hope of suggesting responsible further research in this direction. We have open-sourced the project at https://github.com/WangCheng0116/Why-Probe-Fails.", 'score': 0, 'issue_id': 5729, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': 'db5043bdc42c7fda', 'authors': ['Cheng Wang', 'Zeming Wei', 'Qin Liu', 'Muhao Chen'], 'affiliations': ['National University of Singapore', 'Peking University', 'University of California, Davis'], 'pdf_title_img': 'assets/pdf/title_img/2509.03888.jpg', 'data': {'categories': ['#security', '#training', '#alignment', '#benchmark', '#data', '#open_source'], 'emoji': '🕵️', 'ru': {'title': 'Зондирование LLM: за фасадом кажущейся безопасности', 'desc': 'Исследование показало, что методы зондирования для обнаружения вредоносных инструкций в больших языковых моделях (LLM) опираются на поверхностные паттерны, а не на семантическое понимание. Эксперименты выявили, что зонды учатся распознавать инструктивные паттерны и триггерные слова, а не истинную вредоносность содержания. Результаты указывают на ложное чувство безопасности вокруг существующих подходов на основе зондирования. Авторы призывают к пересмотру как самих моделей, так и методов их оценки для повышения безопасности LLM.'}, 'en': {'title': 'Rethinking Safety: Beyond Superficial Patterns in LLMs', 'desc': 'This paper investigates the effectiveness of probing-based methods used to detect harmful instructions in Large Language Models (LLMs). The authors find that these methods often rely on superficial patterns, such as specific words or phrases, rather than a true understanding of the semantic meaning behind harmful instructions. Through a series of experiments, they demonstrate that simpler n-gram models can perform similarly, indicating that current probing techniques may provide a false sense of security. The paper calls for a redesign of both the models and the evaluation methods to improve safety in AI systems.'}, 'zh': {'title': '重塑安全检测：超越表面模式', 'desc': '本研究探讨了基于探测的方法在大型语言模型（LLMs）中检测有害指令的有效性。我们发现，这些方法依赖于表面模式，而非真正的语义理解，导致安全性评估存在缺陷。通过系统的实验，我们确认探测器学习到的是指令模式和触发词，而非真正的有害性。研究结果表明，当前的探测方法存在误导性安全感，亟需重新设计模型和评估协议。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (1)', '#agents (1)', '#agi', '#alignment (2)', '#architecture (1)', '#audio', '#benchmark (5)', '#cv (2)', '#data (1)', '#dataset (4)', '#diffusion (4)', '#ethics', '#games', '#graphs', '#hallucinations (1)', '#healthcare', '#inference (2)', '#interpretability', '#leakage (1)', '#long_context', '#low_resource', '#machine_translation', '#math', '#multilingual (1)', '#multimodal (2)', '#open_source (3)', '#optimization (5)', '#plp', '#rag', '#reasoning (1)', '#rl (1)', '#rlhf', '#robotics', '#science (1)', '#security (1)', '#small_models (1)', '#story_generation', '#survey (1)', '#synthetic', '#training (6)', '#transfer_learning (1)', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-09-05 07:11',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-09-05 07:11')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-09-05 07:11')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    