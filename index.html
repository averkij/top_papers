
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 12 papers. September 8.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">8 сентября</span> | <span id="title-articles-count">12 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-09-05.html">⬅️ <span id="prev-date">05.09</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-09-09.html">➡️ <span id="next-date">09.09</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-09.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '8 сентября', 'en': 'September 8', 'zh': '9月8日'};
        let feedDateNext = {'ru': '09.09', 'en': '09/09', 'zh': '9月9日'};
        let feedDatePrev = {'ru': '05.09', 'en': '09/05', 'zh': '9月5日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2509.04664', 'title': 'Why Language Models Hallucinate', 'url': 'https://huggingface.co/papers/2509.04664', 'abstract': 'Language models produce incorrect statements due to training and evaluation procedures that reward guessing over acknowledging uncertainty, leading to a need for socio-technical changes in benchmark scoring.  \t\t\t\t\tAI-generated summary \t\t\t\t Like students facing hard exam questions, large language models sometimes guess when uncertain, producing plausible yet incorrect statements instead of admitting uncertainty. Such "hallucinations" persist even in state-of-the-art systems and undermine trust. We argue that language models hallucinate because the training and evaluation procedures reward guessing over acknowledging uncertainty, and we analyze the statistical causes of hallucinations in the modern training pipeline. Hallucinations need not be mysterious -- they originate simply as errors in binary classification. If incorrect statements cannot be distinguished from facts, then hallucinations in pretrained language models will arise through natural statistical pressures. We then argue that hallucinations persist due to the way most evaluations are graded -- language models are optimized to be good test-takers, and guessing when uncertain improves test performance. This "epidemic" of penalizing uncertain responses can only be addressed through a socio-technical mitigation: modifying the scoring of existing benchmarks that are misaligned but dominate leaderboards, rather than introducing additional hallucination evaluations. This change may steer the field toward more trustworthy AI systems.', 'score': 49, 'issue_id': 5763, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': 'a9af1f035c82b958', 'authors': ['Adam Tauman Kalai', 'Ofir Nachum', 'Santosh S. Vempala', 'Edwin Zhang'], 'affiliations': ['Georgia Tech', 'OpenAI'], 'pdf_title_img': 'assets/pdf/title_img/2509.04664.jpg', 'data': {'categories': ['#hallucinations', '#training', '#ethics', '#benchmark'], 'emoji': '🤖', 'ru': {'title': 'Переосмысление оценки языковых моделей для борьбы с галлюцинациями', 'desc': 'Статья рассматривает проблему галлюцинаций в языковых моделях, когда они генерируют правдоподобные, но неверные утверждения вместо признания неопределенности. Авторы утверждают, что это происходит из-за процедур обучения и оценки, которые поощряют угадывание. Они анализируют статистические причины галлюцинаций в современном процессе обучения моделей. Предлагается изменить систему оценки существующих бенчмарков, чтобы стимулировать разработку более надежных систем ИИ.'}, 'en': {'title': 'Transforming AI Trustworthiness by Addressing Hallucinations', 'desc': "This paper discusses how large language models often produce incorrect statements, known as 'hallucinations', due to their training and evaluation methods. These models are rewarded for guessing answers even when they are uncertain, which leads to plausible but false outputs. The authors analyze how these hallucinations stem from errors in binary classification and the statistical pressures in the training process. They propose that to reduce these hallucinations, the scoring systems of benchmarks should be modified to discourage guessing and promote acknowledgment of uncertainty, ultimately fostering more reliable AI systems."}, 'zh': {'title': '改进评分机制，提升语言模型可信度', 'desc': '这篇论文讨论了语言模型在训练和评估过程中产生错误陈述的原因。由于现有的评分机制奖励猜测而非承认不确定性，导致模型在面对不确定时倾向于猜测，从而产生虚假信息。作者分析了现代训练流程中导致这些“幻觉”的统计原因，并指出这些错误源于二元分类中的错误。为了提高语言模型的可信度，论文建议对现有基准的评分方式进行社会技术上的调整，而不是增加新的评估方法。'}}}, {'id': 'https://huggingface.co/papers/2509.05208', 'title': 'Symbolic Graphics Programming with Large Language Models', 'url': 'https://huggingface.co/papers/2509.05208', 'abstract': "LLMs generate SVGs from natural-language descriptions using a reinforcement learning approach with verifiable rewards, improving performance and scene coherence.  \t\t\t\t\tAI-generated summary \t\t\t\t Large language models (LLMs) excel at program synthesis, yet their ability to produce symbolic graphics programs (SGPs) that render into precise visual content remains underexplored. We study symbolic graphics programming, where the goal is to generate an SGP from a natural-language description. This task also serves as a lens into how LLMs understand the visual world by prompting them to generate images rendered from SGPs. Among various SGPs, our paper sticks to scalable vector graphics (SVGs). We begin by examining the extent to which LLMs can generate SGPs. To this end, we introduce SGP-GenBench, a comprehensive benchmark covering object fidelity, scene fidelity, and compositionality (attribute binding, spatial relations, numeracy). On SGP-GenBench, we discover that frontier proprietary models substantially outperform open-source models, and performance correlates well with general coding capabilities. Motivated by this gap, we aim to improve LLMs' ability to generate SGPs. We propose a reinforcement learning (RL) with verifiable rewards approach, where a format-validity gate ensures renderable SVG, and a cross-modal reward aligns text and the rendered image via strong vision encoders (e.g., SigLIP for text-image and DINO for image-image). Applied to Qwen-2.5-7B, our method substantially improves SVG generation quality and semantics, achieving performance on par with frontier systems. We further analyze training dynamics, showing that RL induces (i) finer decomposition of objects into controllable primitives and (ii) contextual details that improve scene coherence. Our results demonstrate that symbolic graphics programming offers a precise and interpretable lens on cross-modal grounding.", 'score': 21, 'issue_id': 5767, 'pub_date': '2025-09-05', 'pub_date_card': {'ru': '5 сентября', 'en': 'September 5', 'zh': '9月5日'}, 'hash': 'c1d059781774f265', 'authors': ['Yamei Chen', 'Haoquan Zhang', 'Yangyi Huang', 'Zeju Qiu', 'Kaipeng Zhang', 'Yandong Wen', 'Weiyang Liu'], 'affiliations': ['Max Planck Institute for Intelligent Systems', 'Shanghai Artificial Intelligence Laboratory', 'The Chinese University of Hong Kong', 'Westlake University'], 'pdf_title_img': 'assets/pdf/title_img/2509.05208.jpg', 'data': {'categories': ['#cv', '#training', '#games', '#interpretability', '#optimization', '#rl', '#multimodal', '#benchmark'], 'emoji': '🖼️', 'ru': {'title': 'ИИ рисует векторную графику по текстовым описаниям', 'desc': 'Статья исследует способность больших языковых моделей (LLM) генерировать программы символьной графики (SGP) из текстовых описаний, фокусируясь на масштабируемой векторной графике (SVG). Авторы представляют бенчмарк SGP-GenBench для оценки качества генерации SGP и обнаруживают значительное превосходство проприетарных моделей над открытыми. Предлагается подход обучения с подкреплением (RL) с проверяемыми наградами для улучшения генерации SVG, используя кросс-модальные награды на основе сильных энкодеров изображений. Результаты показывают, что RL улучшает декомпозицию объектов и контекстуальные детали, повышая качество и семантическую согласованность сгенерированных SVG.'}, 'en': {'title': 'Enhancing SVG Generation with Reinforcement Learning', 'desc': 'This paper explores how large language models (LLMs) can generate scalable vector graphics (SVGs) from natural-language descriptions using a reinforcement learning (RL) approach. The authors introduce SGP-GenBench, a benchmark that evaluates the quality of symbolic graphics programs (SGPs) based on object fidelity, scene fidelity, and compositionality. They find that proprietary models outperform open-source ones, and they propose a method that uses verifiable rewards to enhance the generation of SVGs. The results show that their approach significantly improves the quality and coherence of the generated graphics, providing insights into how LLMs understand visual content.'}, 'zh': {'title': '用强化学习提升SVG生成质量', 'desc': '本文研究了大型语言模型（LLMs）在从自然语言描述生成符号图形程序（SGPs）方面的能力，特别是可缩放矢量图形（SVGs）。我们提出了SGP-GenBench基准，评估对象保真度、场景保真度和组合性等指标，发现前沿的专有模型在生成SGPs方面显著优于开源模型。为了解决这一差距，我们采用了带有可验证奖励的强化学习方法，确保生成的SVG格式有效，并通过强大的视觉编码器对文本和渲染图像进行对齐。实验结果表明，我们的方法显著提高了SVG生成的质量和语义，达到了与前沿系统相当的性能。'}}}, {'id': 'https://huggingface.co/papers/2509.04185', 'title': 'Set Block Decoding is a Language Model Inference Accelerator', 'url': 'https://huggingface.co/papers/2509.04185', 'abstract': 'Set Block Decoding accelerates language model generation by integrating next token prediction and masked token prediction, enabling parallel sampling of future tokens and reducing computational cost without sacrificing accuracy.  \t\t\t\t\tAI-generated summary \t\t\t\t Autoregressive next token prediction language models offer powerful capabilities but face significant challenges in practical deployment due to the high computational and memory costs of inference, particularly during the decoding stage. We introduce Set Block Decoding (SBD), a simple and flexible paradigm that accelerates generation by integrating standard next token prediction (NTP) and masked token prediction (MATP) within a single architecture. SBD allows the model to sample multiple, not necessarily consecutive, future tokens in parallel, a key distinction from previous acceleration methods. This flexibility allows the use of advanced solvers from the discrete diffusion literature, offering significant speedups without sacrificing accuracy. SBD requires no architectural changes or extra training hyperparameters, maintains compatibility with exact KV-caching, and can be implemented by fine-tuning existing next token prediction models. By fine-tuning Llama-3.1 8B and Qwen-3 8B, we demonstrate that SBD enables a 3-5x reduction in the number of forward passes required for generation while achieving same performance as equivalent NTP training.', 'score': 16, 'issue_id': 5770, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '43590e8d94e403ca', 'authors': ['Itai Gat', 'Heli Ben-Hamu', 'Marton Havasi', 'Daniel Haziza', 'Jeremy Reizenstein', 'Gabriel Synnaeve', 'David Lopez-Paz', 'Brian Karrer', 'Yaron Lipman'], 'affiliations': ['FAIR at Meta'], 'pdf_title_img': 'assets/pdf/title_img/2509.04185.jpg', 'data': {'categories': ['#architecture', '#optimization', '#training', '#inference'], 'emoji': '🚀', 'ru': {'title': 'Set Block Decoding: параллельная генерация для ускорения языковых моделей', 'desc': 'Статья представляет новый метод ускорения генерации текста языковыми моделями под названием Set Block Decoding (SBD). SBD объединяет предсказание следующего токена и предсказание маскированных токенов, позволяя параллельно сэмплировать несколько будущих токенов. Это снижает вычислительные затраты без потери точности. Метод не требует изменений в архитектуре модели и совместим с точным KV-кэшированием.'}, 'en': {'title': 'Accelerate Language Generation with Set Block Decoding!', 'desc': "Set Block Decoding (SBD) is a novel approach that enhances the efficiency of language model generation by combining next token prediction (NTP) and masked token prediction (MATP) in one framework. This method allows for the parallel sampling of multiple future tokens, which significantly reduces the computational and memory costs associated with inference. By leveraging advanced solvers from discrete diffusion techniques, SBD achieves faster generation speeds without compromising the model's accuracy. Importantly, SBD can be implemented without altering the model architecture or requiring additional training parameters, making it a practical solution for existing models like Llama-3.1 and Qwen-3."}, 'zh': {'title': '集合块解码：加速语言模型生成的创新方法', 'desc': '本文介绍了一种名为集合块解码（Set Block Decoding, SBD）的方法，旨在加速语言模型的生成过程。SBD通过将下一标记预测（Next Token Prediction, NTP）和掩码标记预测（Masked Token Prediction, MATP）结合在一个架构中，实现了并行采样多个未来标记。与以往的加速方法不同，SBD允许模型同时生成多个不一定连续的标记，从而显著降低计算成本。通过对现有模型进行微调，SBD在保持准确性的同时，减少了生成所需的前向传递次数，提升了生成效率。'}}}, {'id': 'https://huggingface.co/papers/2509.04744', 'title': 'WildScore: Benchmarking MLLMs in-the-Wild Symbolic Music Reasoning', 'url': 'https://huggingface.co/papers/2509.04744', 'abstract': "WildScore evaluates MLLMs' symbolic music reasoning through a benchmark of real-world music scores and user-generated queries, revealing both strengths and challenges.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in Multimodal Large Language Models (MLLMs) have demonstrated impressive capabilities across various vision-language tasks. However, their reasoning abilities in the multimodal symbolic music domain remain largely unexplored. We introduce WildScore, the first in-the-wild multimodal symbolic music reasoning and analysis benchmark, designed to evaluate MLLMs' capacity to interpret real-world music scores and answer complex musicological queries. Each instance in WildScore is sourced from genuine musical compositions and accompanied by authentic user-generated questions and discussions, capturing the intricacies of practical music analysis. To facilitate systematic evaluation, we propose a systematic taxonomy, comprising both high-level and fine-grained musicological ontologies. Furthermore, we frame complex music reasoning as multiple-choice question answering, enabling controlled and scalable assessment of MLLMs' symbolic music understanding. Empirical benchmarking of state-of-the-art MLLMs on WildScore reveals intriguing patterns in their visual-symbolic reasoning, uncovering both promising directions and persistent challenges for MLLMs in symbolic music reasoning and analysis. We release the dataset and code.", 'score': 8, 'issue_id': 5761, 'pub_date': '2025-09-05', 'pub_date_card': {'ru': '5 сентября', 'en': 'September 5', 'zh': '9月5日'}, 'hash': '44d75a7c2c61a026', 'authors': ['Gagan Mundada', 'Yash Vishe', 'Amit Namburi', 'Xin Xu', 'Zachary Novack', 'Julian McAuley', 'Junda Wu'], 'affiliations': ['University of California, San Diego'], 'pdf_title_img': 'assets/pdf/title_img/2509.04744.jpg', 'data': {'categories': ['#multimodal', '#dataset', '#benchmark', '#reasoning', '#survey'], 'emoji': '🎼', 'ru': {'title': 'WildScore: новый рубеж в понимании музыки искусственным интеллектом', 'desc': 'Статья представляет WildScore - первый бенчмарк для оценки способностей мультимодальных языковых моделей (MLLM) в области анализа и рассуждений о символической музыке. Бенчмарк состоит из реальных музыкальных партитур и вопросов пользователей, охватывая сложности практического музыкального анализа. Авторы предлагают систематическую таксономию и формулируют задачу как ответы на вопросы с множественным выбором. Эмпирическое тестирование современных MLLM на WildScore выявляет как перспективные направления, так и сохраняющиеся проблемы в области рассуждений о символической музыке.'}, 'en': {'title': "WildScore: Unlocking MLLMs' Music Reasoning Potential", 'desc': "WildScore is a benchmark designed to assess the reasoning abilities of Multimodal Large Language Models (MLLMs) in the context of symbolic music. It evaluates how well these models can interpret real-world music scores and respond to complex questions about music. The benchmark includes genuine musical compositions and user-generated queries, providing a realistic setting for analysis. By framing music reasoning as multiple-choice questions, WildScore allows for systematic evaluation of MLLMs' understanding of music, revealing both their strengths and areas needing improvement."}, 'zh': {'title': 'WildScore：音乐推理的新基准', 'desc': 'WildScore是一个评估多模态大型语言模型（MLLMs）在符号音乐推理能力的基准测试。它通过真实的音乐乐谱和用户生成的查询，揭示了这些模型在音乐分析中的优势和挑战。该基准测试采用了系统的分类法，涵盖了高层次和细粒度的音乐学本体。通过将复杂的音乐推理框架化为多项选择题回答，WildScore为MLLMs的符号音乐理解提供了可控和可扩展的评估方式。'}}}, {'id': 'https://huggingface.co/papers/2509.05263', 'title': 'LatticeWorld: A Multimodal Large Language Model-Empowered Framework for\n  Interactive Complex World Generation', 'url': 'https://huggingface.co/papers/2509.05263', 'abstract': 'LatticeWorld, a 3D world generation framework using lightweight LLMs and Unreal Engine 5, creates dynamic, interactive environments from textual and visual inputs, achieving high accuracy and efficiency.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent research has been increasingly focusing on developing 3D world models that simulate complex real-world scenarios. World models have found broad applications across various domains, including embodied AI, autonomous driving, entertainment, etc. A more realistic simulation with accurate physics will effectively narrow the sim-to-real gap and allow us to gather rich information about the real world conveniently. While traditional manual modeling has enabled the creation of virtual 3D scenes, modern approaches have leveraged advanced machine learning algorithms for 3D world generation, with most recent advances focusing on generative methods that can create virtual worlds based on user instructions. This work explores such a research direction by proposing LatticeWorld, a simple yet effective 3D world generation framework that streamlines the industrial production pipeline of 3D environments. LatticeWorld leverages lightweight LLMs (LLaMA-2-7B) alongside the industry-grade rendering engine (e.g., Unreal Engine 5) to generate a dynamic environment. Our proposed framework accepts textual descriptions and visual instructions as multimodal inputs and creates large-scale 3D interactive worlds with dynamic agents, featuring competitive multi-agent interaction, high-fidelity physics simulation, and real-time rendering. We conduct comprehensive experiments to evaluate LatticeWorld, showing that it achieves superior accuracy in scene layout generation and visual fidelity. Moreover, LatticeWorld achieves over a 90times increase in industrial production efficiency while maintaining high creative quality compared with traditional manual production methods. Our demo video is available at https://youtu.be/8VWZXpERR18', 'score': 3, 'issue_id': 5761, 'pub_date': '2025-09-05', 'pub_date_card': {'ru': '5 сентября', 'en': 'September 5', 'zh': '9月5日'}, 'hash': '027e61af3a0f5c1a', 'authors': ['Yinglin Duan', 'Zhengxia Zou', 'Tongwei Gu', 'Wei Jia', 'Zhan Zhao', 'Luyi Xu', 'Xinzhu Liu', 'Hao Jiang', 'Kang Chen', 'Shuang Qiu'], 'affiliations': ['Beihang University, China', 'City University of Hong Kong, China', 'NetEase, Inc., China', 'Tsinghua University, China'], 'pdf_title_img': 'assets/pdf/title_img/2509.05263.jpg', 'data': {'categories': ['#multimodal', '#games', '#optimization', '#agents', '#3d'], 'emoji': '🌐', 'ru': {'title': 'Генерация 3D-миров на основе ИИ: быстро, точно, реалистично', 'desc': 'LatticeWorld - это фреймворк для создания трёхмерных миров, использующий облегчённые языковые модели и Unreal Engine 5. Система принимает текстовые и визуальные инструкции для генерации динамических интерактивных сред. LatticeWorld достигает высокой точности в создании планировки сцен и визуальной достоверности. Фреймворк значительно повышает эффективность промышленного производства по сравнению с традиционными ручными методами.'}, 'en': {'title': 'Revolutionizing 3D World Generation with LatticeWorld', 'desc': 'LatticeWorld is a 3D world generation framework that utilizes lightweight large language models (LLMs) and Unreal Engine 5 to create interactive environments from both textual and visual inputs. This framework aims to enhance the realism of simulations, bridging the gap between simulated and real-world scenarios, which is crucial for applications like autonomous driving and embodied AI. By employing generative methods, LatticeWorld can produce large-scale 3D worlds with dynamic agents, showcasing high-fidelity physics and real-time rendering capabilities. The results demonstrate a significant increase in production efficiency, achieving over 90 times faster output compared to traditional modeling techniques while maintaining high visual quality.'}, 'zh': {'title': 'LatticeWorld：高效生成动态3D世界的创新框架', 'desc': 'LatticeWorld是一个使用轻量级大语言模型和虚幻引擎5的3D世界生成框架。它能够根据文本和视觉输入创建动态、互动的环境，具有高准确性和效率。该框架通过多模态输入生成大规模的3D互动世界，支持动态代理和高保真物理模拟。与传统手动建模方法相比，LatticeWorld在工业生产效率上提高了90倍，同时保持了高创意质量。'}}}, {'id': 'https://huggingface.co/papers/2509.03680', 'title': 'LuxDiT: Lighting Estimation with Video Diffusion Transformer', 'url': 'https://huggingface.co/papers/2509.03680', 'abstract': 'LuxDiT, a video diffusion transformer fine-tuned with low-rank adaptation, generates accurate HDR environment maps from visual input, outperforming existing methods.  \t\t\t\t\tAI-generated summary \t\t\t\t Estimating scene lighting from a single image or video remains a longstanding challenge in computer vision and graphics. Learning-based approaches are constrained by the scarcity of ground-truth HDR environment maps, which are expensive to capture and limited in diversity. While recent generative models offer strong priors for image synthesis, lighting estimation remains difficult due to its reliance on indirect visual cues, the need to infer global (non-local) context, and the recovery of high-dynamic-range outputs. We propose LuxDiT, a novel data-driven approach that fine-tunes a video diffusion transformer to generate HDR environment maps conditioned on visual input. Trained on a large synthetic dataset with diverse lighting conditions, our model learns to infer illumination from indirect visual cues and generalizes effectively to real-world scenes. To improve semantic alignment between the input and the predicted environment map, we introduce a low-rank adaptation finetuning strategy using a collected dataset of HDR panoramas. Our method produces accurate lighting predictions with realistic angular high-frequency details, outperforming existing state-of-the-art techniques in both quantitative and qualitative evaluations.', 'score': 3, 'issue_id': 5766, 'pub_date': '2025-09-03', 'pub_date_card': {'ru': '3 сентября', 'en': 'September 3', 'zh': '9月3日'}, 'hash': 'aa0dec923ff8c683', 'authors': ['Ruofan Liang', 'Kai He', 'Zan Gojcic', 'Igor Gilitschenski', 'Sanja Fidler', 'Nandita Vijaykumar', 'Zian Wang'], 'affiliations': ['NVIDIA', 'University of Toronto', 'Vector Institute'], 'pdf_title_img': 'assets/pdf/title_img/2509.03680.jpg', 'data': {'categories': ['#diffusion', '#synthetic', '#cv', '#dataset', '#training', '#video'], 'emoji': '💡', 'ru': {'title': 'LuxDiT: Трансформер для реалистичного HDR-освещения из одного изображения', 'desc': 'LuxDiT - это новый подход к оценке освещения сцены из одного изображения или видео. Метод основан на видео-диффузионном трансформере, дообученном с помощью низкоранговой адаптации. LuxDiT генерирует точные HDR-карты окружения на основе визуального ввода, превосходя существующие методы. Модель обучена на большом синтетическом наборе данных с разнообразными условиями освещения и эффективно обобщается на реальные сцены.'}, 'en': {'title': 'LuxDiT: Revolutionizing HDR Lighting Estimation with Video Diffusion Transformers', 'desc': 'LuxDiT is a novel machine learning model that generates high dynamic range (HDR) environment maps from images or videos. It uses a video diffusion transformer that has been fine-tuned with low-rank adaptation to improve the accuracy of lighting predictions. The model is trained on a large synthetic dataset, allowing it to learn diverse lighting conditions and effectively generalize to real-world scenarios. By enhancing the semantic alignment between input visuals and the generated maps, LuxDiT surpasses existing methods in both quality and performance.'}, 'zh': {'title': 'LuxDiT：高效生成HDR环境图的创新方法', 'desc': 'LuxDiT是一种新型的数据驱动方法，利用视频扩散变换器生成高动态范围（HDR）环境图。该模型通过低秩适应微调，能够从视觉输入中推断照明信息，克服了传统方法在真实场景中的局限性。它在一个包含多样化光照条件的大型合成数据集上进行训练，能够有效地从间接视觉线索中学习。与现有技术相比，LuxDiT在定量和定性评估中均表现出色，生成的照明预测具有真实的高频细节。'}}}, {'id': 'https://huggingface.co/papers/2509.05296', 'title': 'WinT3R: Window-Based Streaming Reconstruction with Camera Token Pool', 'url': 'https://huggingface.co/papers/2509.05296', 'abstract': 'WinT3R, a feed-forward reconstruction model, achieves high-quality camera pose estimation and real-time performance using a sliding window mechanism and a global camera token pool.  \t\t\t\t\tAI-generated summary \t\t\t\t We present WinT3R, a feed-forward reconstruction model capable of online prediction of precise camera poses and high-quality point maps. Previous methods suffer from a trade-off between reconstruction quality and real-time performance. To address this, we first introduce a sliding window mechanism that ensures sufficient information exchange among frames within the window, thereby improving the quality of geometric predictions without large computation. In addition, we leverage a compact representation of cameras and maintain a global camera token pool, which enhances the reliability of camera pose estimation without sacrificing efficiency. These designs enable WinT3R to achieve state-of-the-art performance in terms of online reconstruction quality, camera pose estimation, and reconstruction speed, as validated by extensive experiments on diverse datasets. Code and model are publicly available at https://github.com/LiZizun/WinT3R.', 'score': 2, 'issue_id': 5764, 'pub_date': '2025-09-05', 'pub_date_card': {'ru': '5 сентября', 'en': 'September 5', 'zh': '9月5日'}, 'hash': 'b6ac447839602a03', 'authors': ['Zizun Li', 'Jianjun Zhou', 'Yifan Wang', 'Haoyu Guo', 'Wenzheng Chang', 'Yang Zhou', 'Haoyi Zhu', 'Junyi Chen', 'Chunhua Shen', 'Tong He'], 'affiliations': ['SII', 'Shanghai AI Lab', 'University of Science and Technology of China', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2509.05296.jpg', 'data': {'categories': ['#benchmark', '#dataset', '#cv'], 'emoji': '🎥', 'ru': {'title': 'WinT3R: Революция в реконструкции камер в реальном времени', 'desc': 'WinT3R - это модель прямого распространения для реконструкции, которая обеспечивает высококачественную оценку положения камеры и работу в режиме реального времени. Модель использует механизм скользящего окна для обмена информацией между кадрами, что улучшает качество геометрических предсказаний. WinT3R также применяет компактное представление камер и глобальный пул токенов камеры для повышения надежности оценки положения. Эти инновации позволяют модели достичь передовых результатов в онлайн-реконструкции, оценке положения камеры и скорости реконструкции.'}, 'en': {'title': 'WinT3R: Real-Time Camera Pose Estimation with High Precision', 'desc': 'WinT3R is a feed-forward reconstruction model designed for accurate camera pose estimation and efficient real-time performance. It utilizes a sliding window mechanism to facilitate effective information sharing among frames, enhancing the quality of geometric predictions while minimizing computational load. Additionally, the model incorporates a global camera token pool, which improves the reliability of pose estimation without compromising speed. As a result, WinT3R achieves state-of-the-art performance in online reconstruction tasks, as demonstrated through extensive testing on various datasets.'}, 'zh': {'title': 'WinT3R：高效精准的相机姿态估计', 'desc': 'WinT3R是一种前馈重建模型，能够实时预测精确的相机姿态和高质量的点云地图。以往的方法在重建质量和实时性能之间存在权衡。为了解决这个问题，我们引入了滑动窗口机制，确保窗口内帧之间的信息充分交流，从而提高几何预测的质量。通过维护一个全局相机令牌池，WinT3R在不牺牲效率的情况下增强了相机姿态估计的可靠性。'}}}, {'id': 'https://huggingface.co/papers/2509.04013', 'title': 'On Robustness and Reliability of Benchmark-Based Evaluation of LLMs', 'url': 'https://huggingface.co/papers/2509.04013', 'abstract': "LLMs show reduced effectiveness on paraphrased benchmark questions, indicating limitations in handling linguistic variability and suggesting the need for more robust evaluation methods.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) effectiveness is usually evaluated by means of benchmarks such as MMLU, ARC-C, or HellaSwag, where questions are presented in their original wording, thus in a fixed, standardized format. However, real-world applications involve linguistic variability, requiring models to maintain their effectiveness across diverse rewordings of the same question or query. In this study, we systematically assess the robustness of LLMs to paraphrased benchmark questions and investigate whether benchmark-based evaluations provide a reliable measure of model capabilities. We systematically generate various paraphrases of all the questions across six different common benchmarks, and measure the resulting variations in effectiveness of 34 state-of-the-art LLMs, of different size and effectiveness. Our findings reveal that while LLM rankings remain relatively stable across paraphrased inputs, absolute effectiveness scores change, and decline significantly. This suggests that LLMs struggle with linguistic variability, raising concerns about their generalization abilities and evaluation methodologies. Furthermore, the observed performance drop challenges the reliability of benchmark-based evaluations, indicating that high benchmark scores may not fully capture a model's robustness to real-world input variations. We discuss the implications of these findings for LLM evaluation methodologies, emphasizing the need for robustness-aware benchmarks that better reflect practical deployment scenarios.", 'score': 2, 'issue_id': 5764, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '32f0ad5327f657e2', 'authors': ['Riccardo Lunardi', 'Vincenzo Della Mea', 'Stefano Mizzaro', 'Kevin Roitero'], 'affiliations': ['University of Udine, Italy'], 'pdf_title_img': 'assets/pdf/title_img/2509.04013.jpg', 'data': {'categories': ['#evaluation', '#interpretability', '#benchmark', '#reasoning', '#data'], 'emoji': '🔍', 'ru': {'title': 'Языковые модели спотыкаются о перефразированные вопросы', 'desc': 'Исследование показало, что большие языковые модели (LLM) менее эффективны при работе с перефразированными вопросами из стандартных тестов. Это указывает на ограничения LLM в обработке лингвистических вариаций. Результаты ставят под сомнение надежность оценки моделей на основе существующих бенчмарков. Исследователи подчеркивают необходимость разработки более устойчивых методов оценки, которые лучше отражают реальные сценарии использования LLM.'}, 'en': {'title': 'Evaluating LLMs: Beyond Fixed Benchmarks to Real-World Language Variability', 'desc': "This paper investigates how well Large Language Models (LLMs) perform when faced with paraphrased questions, highlighting their limitations in dealing with linguistic variability. The authors found that while the rankings of LLMs remained stable, their effectiveness scores dropped significantly when questions were reworded. This indicates that current benchmark evaluations may not accurately reflect a model's ability to generalize to real-world language use. The study calls for the development of more robust evaluation methods that account for diverse question phrasing to better assess LLM capabilities."}, 'zh': {'title': '提升LLMs鲁棒性，重塑评估标准', 'desc': '大型语言模型（LLMs）在处理同一问题的不同表述时效果较差，显示出其在语言变异性方面的局限性。这项研究系统地评估了LLMs对改写基准问题的鲁棒性，并探讨了基于基准的评估是否可靠。研究发现，尽管LLMs在不同表述下的排名相对稳定，但其绝对有效性得分显著下降。这表明LLMs在应对真实世界的语言变异时存在困难，呼吁开发更能反映实际应用场景的评估方法。'}}}, {'id': 'https://huggingface.co/papers/2509.03800', 'title': 'MedVista3D: Vision-Language Modeling for Reducing Diagnostic Errors in\n  3D CT Disease Detection, Understanding and Reporting', 'url': 'https://huggingface.co/papers/2509.03800', 'abstract': 'MedVista3D is a multi-scale semantic-enriched vision-language pretraining framework for 3D CT analysis that addresses local-global understanding, report variability, and achieves state-of-the-art performance in disease classification, report retrieval, and medical visual question answering.  \t\t\t\t\tAI-generated summary \t\t\t\t Radiologic diagnostic errors-under-reading errors, inattentional blindness, and communication failures-remain prevalent in clinical practice. These issues often stem from missed localized abnormalities, limited global context, and variability in report language. These challenges are amplified in 3D imaging, where clinicians must examine hundreds of slices per scan. Addressing them requires systems with precise localized detection, global volume-level reasoning, and semantically consistent natural language reporting. However, existing 3D vision-language models are unable to meet all three needs jointly, lacking local-global understanding for spatial reasoning and struggling with the variability and noise of uncurated radiology reports. We present MedVista3D, a multi-scale semantic-enriched vision-language pretraining framework for 3D CT analysis. To enable joint disease detection and holistic interpretation, MedVista3D performs local and global image-text alignment for fine-grained representation learning within full-volume context. To address report variability, we apply language model rewrites and introduce a Radiology Semantic Matching Bank for semantics-aware alignment. MedVista3D achieves state-of-the-art performance on zero-shot disease classification, report retrieval, and medical visual question answering, while transferring well to organ segmentation and prognosis prediction. Code and datasets will be released.', 'score': 2, 'issue_id': 5762, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': 'ad0922456cbd778e', 'authors': ['Yuheng Li', 'Yenho Chen', 'Yuxiang Lai', 'Jike Zhong', 'Vanessa Wildman', 'Xiaofeng Yang'], 'affiliations': ['Department of Biomedical Engineering, Georgia Institute of Technology, Atlanta, GA', 'Department of Computer Science, University of Southern California, Los Angeles, CA', 'Department of Machine Learning, Georgia Institute of Technology, Atlanta, GA', 'Department of Radiation Oncology, Emory University School of Medicine, Atlanta, USA'], 'pdf_title_img': 'assets/pdf/title_img/2509.03800.jpg', 'data': {'categories': ['#multimodal', '#science', '#healthcare', '#transfer_learning', '#3d'], 'emoji': '🏥', 'ru': {'title': 'Улучшение анализа КТ с помощью многомасштабного обучения компьютерного зрения и обработки естественного языка', 'desc': 'MedVista3D - это фреймворк для предварительного обучения многомасштабных семантически обогащенных моделей компьютерного зрения и обработки естественного языка для анализа 3D КТ-изображений. Он решает проблемы локально-глобального понимания и вариативности медицинских отчетов. MedVista3D использует выравнивание изображения и текста на локальном и глобальном уровнях для детального представления в контексте полного объема. Фреймворк достигает передовых результатов в классификации заболеваний, поиске отчетов и медицинских вопросно-ответных системах.'}, 'en': {'title': 'Revolutionizing 3D CT Analysis with MedVista3D', 'desc': 'MedVista3D is a new framework designed to improve the analysis of 3D CT scans by combining vision and language understanding. It tackles common problems in radiology, such as missing details and inconsistent report language, by enhancing local and global context in image analysis. The framework uses advanced techniques for aligning images with text, allowing for better disease detection and interpretation of medical reports. MedVista3D has shown to outperform existing models in tasks like disease classification and report retrieval, making it a significant advancement in medical imaging technology.'}, 'zh': {'title': 'MedVista3D：提升3D CT分析的智能框架', 'desc': 'MedVista3D是一个多尺度语义增强的视觉-语言预训练框架，专门用于3D CT分析。它解决了局部与全局理解、报告变异性等问题，并在疾病分类、报告检索和医学视觉问答中达到了最先进的性能。该框架通过局部和全局图像-文本对齐，实现了细粒度的表示学习，并引入了语义匹配库来处理报告的变异性。MedVista3D在零样本疾病分类和器官分割等任务中表现优异，展示了其在医学影像分析中的潜力。'}}}, {'id': 'https://huggingface.co/papers/2509.02437', 'title': 'U-ARM : Ultra low-cost general teleoperation interface for robot\n  manipulation', 'url': 'https://huggingface.co/papers/2509.02437', 'abstract': 'U-Arm is a low-cost, adaptable teleoperation framework for robotic arms that optimizes mechanical design and control logic to enhance data collection efficiency and task success rates.  \t\t\t\t\tAI-generated summary \t\t\t\t We propose U-Arm, a low-cost and rapidly adaptable leader-follower teleoperation framework designed to interface with most of commercially available robotic arms. Our system supports teleoperation through three structurally distinct 3D-printed leader arms that share consistent control logic, enabling seamless compatibility with diverse commercial robot configurations. Compared with previous open-source leader-follower interfaces, we further optimized both the mechanical design and servo selection, achieving a bill of materials (BOM) cost of only \\50.5 for the 6-DoF leader arm and 56.8 for the 7-DoF version. To enhance usability, we mitigate the common challenge in controlling redundant degrees of freedom by %engineering methods mechanical and control optimizations. Experimental results demonstrate that U-Arm achieves 39\\% higher data collection efficiency and comparable task success rates across multiple manipulation scenarios compared with Joycon, another low-cost teleoperation interface. We have open-sourced all CAD models of three configs and also provided simulation support for validating teleoperation workflows. We also open-sourced real-world manipulation data collected with U-Arm. The project website is https://github.com/MINT-SJTU/LeRobot-Anything-U-Arm.', 'score': 1, 'issue_id': 5767, 'pub_date': '2025-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': '328b26798c2ef081', 'authors': ['Yanwen Zou', 'Zhaoye Zhou', 'Chenyang Shi', 'Zewei Ye', 'Junda Huang', 'Yan Ding', 'Bo Zhao'], 'affiliations': ['EvoMind Tech', 'IAAR-Shanghai', 'Independent Researcher', 'School of AI, SJTU'], 'pdf_title_img': 'assets/pdf/title_img/2509.02437.jpg', 'data': {'categories': ['#open_source', '#robotics', '#dataset'], 'emoji': '🦾', 'ru': {'title': 'Доступное и универсальное телеуправление роботами', 'desc': 'U-Arm - это недорогая и адаптируемая система телеуправления для роботизированных манипуляторов. Она оптимизирует механическую конструкцию и логику управления для повышения эффективности сбора данных и успешности выполнения задач. Система совместима с большинством коммерчески доступных роботов и поддерживает телеуправление через три различных 3D-печатных ведущих манипулятора. По сравнению с предыдущими открытыми интерфейсами, U-Arm достигает более низкой стоимости комплектующих и решает проблему управления избыточными степенями свободы.'}, 'en': {'title': 'U-Arm: Affordable and Efficient Teleoperation for Robotic Arms', 'desc': 'U-Arm is a cost-effective teleoperation framework designed for robotic arms, enhancing both mechanical design and control logic. It features three distinct 3D-printed leader arms that maintain consistent control, allowing compatibility with various commercial robots. The system has been optimized to reduce costs significantly while improving data collection efficiency by 39% compared to existing interfaces. Additionally, U-Arm addresses the challenges of controlling redundant degrees of freedom through engineering optimizations, making it a versatile tool for robotic manipulation tasks.'}, 'zh': {'title': 'U-Arm：低成本高效的遥操作解决方案', 'desc': 'U-Arm是一个低成本、可快速适应的遥操作框架，专为机器人手臂设计。它通过三种不同结构的3D打印领导臂，提供一致的控制逻辑，支持与多种商业机器人兼容。与之前的开源遥操作接口相比，U-Arm在机械设计和伺服选择上进行了优化，使得6自由度和7自由度的领导臂成本分别仅为50.5美元和56.8美元。实验结果表明，U-Arm在数据收集效率上提高了39%，并在多种操作场景中达到了与Joycon相当的任务成功率。'}}}, {'id': 'https://huggingface.co/papers/2509.04504', 'title': 'Behavioral Fingerprinting of Large Language Models', 'url': 'https://huggingface.co/papers/2509.04504', 'abstract': "A Behavioral Fingerprinting framework evaluates Large Language Models using a Diagnostic Prompt Suite and automated pipeline, revealing divergent alignment behaviors and clustering patterns.  \t\t\t\t\tAI-generated summary \t\t\t\t Current benchmarks for Large Language Models (LLMs) primarily focus on performance metrics, often failing to capture the nuanced behavioral characteristics that differentiate them. This paper introduces a novel ``Behavioral Fingerprinting'' framework designed to move beyond traditional evaluation by creating a multi-faceted profile of a model's intrinsic cognitive and interactive styles. Using a curated Diagnostic Prompt Suite and an innovative, automated evaluation pipeline where a powerful LLM acts as an impartial judge, we analyze eighteen models across capability tiers. Our results reveal a critical divergence in the LLM landscape: while core capabilities like abstract and causal reasoning are converging among top models, alignment-related behaviors such as sycophancy and semantic robustness vary dramatically. We further document a cross-model default persona clustering (ISTJ/ESTJ) that likely reflects common alignment incentives. Taken together, this suggests that a model's interactive nature is not an emergent property of its scale or reasoning power, but a direct consequence of specific, and highly variable, developer alignment strategies. Our framework provides a reproducible and scalable methodology for uncovering these deep behavioral differences. Project: https://github.com/JarvisPei/Behavioral-Fingerprinting", 'score': 1, 'issue_id': 5763, 'pub_date': '2025-09-02', 'pub_date_card': {'ru': '2 сентября', 'en': 'September 2', 'zh': '9月2日'}, 'hash': 'c8bc7caa6cf21161', 'authors': ['Zehua Pei', 'Hui-Ling Zhen', 'Ying Zhang', 'Zhiyuan Yang', 'Xing Li', 'Xianzhi Yu', 'Mingxuan Yuan', 'Bei Yu'], 'affiliations': ['Noahs Ark Lab, Huawei', 'The Chinese University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2509.04504.jpg', 'data': {'categories': ['#dataset', '#alignment', '#benchmark', '#interpretability'], 'emoji': '🧠', 'ru': {'title': 'Поведенческий отпечаток: новый взгляд на оценку языковых моделей', 'desc': "Статья представляет новую методологию оценки больших языковых моделей (LLM), названную 'Поведенческим отпечатком'. Этот подход использует набор диагностических промптов и автоматизированный конвейер оценки, где мощная LLM выступает в роли беспристрастного судьи. Исследование выявило значительные различия в поведении моделей, связанном с выравниванием (alignment), несмотря на сходство в базовых когнитивных способностях. Результаты показывают, что интерактивная природа модели является прямым следствием конкретных стратегий выравнивания, а не просто побочным эффектом масштаба или мощности рассуждений."}, 'en': {'title': 'Unveiling the Hidden Behaviors of Language Models', 'desc': "This paper presents a new framework called 'Behavioral Fingerprinting' to evaluate Large Language Models (LLMs) beyond just their performance metrics. It uses a Diagnostic Prompt Suite and an automated evaluation pipeline to analyze the cognitive and interactive styles of various models. The study finds that while core reasoning abilities are becoming similar among top models, their alignment behaviors, such as sycophancy and semantic robustness, show significant differences. This indicates that a model's behavior is influenced more by the developers' alignment strategies than by its size or reasoning capabilities."}, 'zh': {'title': '揭示大型语言模型的行为特征', 'desc': '本文提出了一种新的“行为指纹”框架，用于评估大型语言模型（LLMs），超越传统的性能指标，关注模型的行为特征。通过使用精心设计的诊断提示套件和自动化评估流程，分析了十八种不同能力层次的模型。研究发现，尽管顶级模型在抽象和因果推理等核心能力上趋于一致，但在对齐相关的行为（如谄媚和语义稳健性）上却存在显著差异。该框架为揭示模型之间深层次的行为差异提供了一种可重复和可扩展的方法。'}}}, {'id': 'https://huggingface.co/papers/2509.04575', 'title': 'Bootstrapping Task Spaces for Self-Improvement', 'url': 'https://huggingface.co/papers/2509.04575', 'abstract': 'Exploratory Iteration (ExIt) is an autocurriculum RL method that trains LLMs to perform multi-step self-improvement at inference-time by selectively sampling informative intermediate histories, enabling strong self-improvement on unseen tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t Progress in many task domains emerges from repeated revisions to previous solution attempts. Training agents that can reliably self-improve over such sequences at inference-time is a natural target for reinforcement learning (RL), yet the naive approach assumes a fixed maximum iteration depth, which can be both costly and arbitrary. We present Exploratory Iteration (ExIt), a family of autocurriculum RL methods that directly exploits the recurrent structure of self-improvement tasks to train LLMs to perform multi-step self-improvement at inference-time while only training on the most informative single-step iterations. ExIt grows a task space by selectively sampling the most informative intermediate, partial histories encountered during an episode for continued iteration, treating these starting points as new self-iteration task instances to train a self-improvement policy. ExIt can further pair with explicit exploration mechanisms to sustain greater task diversity. Across several domains, encompassing competition math, multi-turn tool-use, and machine learning engineering, we demonstrate that ExIt strategies, starting from either a single or many task instances, can produce policies exhibiting strong inference-time self-improvement on held-out task instances, and the ability to iterate towards higher performance over a step budget extending beyond the average iteration depth encountered during training.', 'score': 0, 'issue_id': 5768, 'pub_date': '2025-09-04', 'pub_date_card': {'ru': '4 сентября', 'en': 'September 4', 'zh': '9月4日'}, 'hash': '86e95856d92a57a9', 'authors': ['Minqi Jiang', 'Andrei Lupu', 'Yoram Bachrach'], 'affiliations': ['Meta Superintelligence Labs', 'University of Oxford'], 'pdf_title_img': 'assets/pdf/title_img/2509.04575.jpg', 'data': {'categories': ['#reasoning', '#rlhf', '#rl', '#optimization'], 'emoji': '🔄', 'ru': {'title': 'ExIt: Самосовершенствование языковых моделей через исследовательские итерации', 'desc': 'Exploratory Iteration (ExIt) - это метод обучения с подкреплением, который тренирует языковые модели для многошагового самосовершенствования во время вывода. ExIt выборочно отбирает наиболее информативные промежуточные истории для продолжения итерации, рассматривая их как новые экземпляры задач самоулучшения. Этот подход позволяет моделям эффективно улучшаться на невиданных ранее задачах, не ограничиваясь фиксированной глубиной итераций. ExIt продемонстрировал сильные результаты в различных областях, включая математические соревнования, многоэтапное использование инструментов и инженерию машинного обучения.'}, 'en': {'title': 'Empowering Self-Improvement in LLMs with Exploratory Iteration', 'desc': 'Exploratory Iteration (ExIt) is a novel reinforcement learning method designed to enhance the self-improvement capabilities of large language models (LLMs) during inference. It focuses on training agents to iteratively refine their solutions by selectively sampling the most informative intermediate steps from previous attempts. This approach allows LLMs to tackle unseen tasks more effectively by treating these sampled histories as new tasks for further improvement. The results show that ExIt can significantly boost performance across various domains by enabling agents to explore and iterate beyond their initial training experiences.'}, 'zh': {'title': '探索性迭代：强化学习中的自我改进新方法', 'desc': '探索性迭代（ExIt）是一种自适应课程强化学习方法，旨在训练大型语言模型（LLM）在推理时进行多步自我改进。该方法通过选择性地采样信息丰富的中间历史，帮助模型在未见过的任务上实现强大的自我提升。ExIt利用自我改进任务的递归结构，专注于最具信息量的单步迭代，从而扩展任务空间。通过与明确的探索机制结合，ExIt能够维持更大的任务多样性，展示出在多个领域的强大自我改进能力。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (2)', '#agents (1)', '#agi', '#alignment (1)', '#architecture (1)', '#audio', '#benchmark (6)', '#cv (3)', '#data (1)', '#dataset (5)', '#diffusion (1)', '#ethics (1)', '#games (2)', '#graphs', '#hallucinations (1)', '#healthcare (1)', '#inference (1)', '#interpretability (3)', '#leakage', '#long_context', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal (4)', '#open_source (1)', '#optimization (4)', '#plp', '#rag', '#reasoning (3)', '#rl (2)', '#rlhf (1)', '#robotics (1)', '#science (1)', '#security', '#small_models', '#story_generation', '#survey (1)', '#synthetic (1)', '#training (4)', '#transfer_learning (1)', '#video (1)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-09-08 13:24',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-09-08 13:24')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-09-08 13:24')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    