
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 28 papers. July 9.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">9 июля</span> | <span id="title-articles-count">28 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-07-08.html">⬅️ <span id="prev-date">08.07</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-07-10.html">➡️ <span id="next-date">10.07</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-07.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '9 июля', 'en': 'July 9', 'zh': '7月9日'};
        let feedDateNext = {'ru': '10.07', 'en': '07/10', 'zh': '7月10日'};
        let feedDatePrev = {'ru': '08.07', 'en': '07/08', 'zh': '7月8日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2507.05566', 'title': 'SingLoRA: Low Rank Adaptation Using a Single Matrix', 'url': 'https://huggingface.co/papers/2507.05566', 'abstract': 'SingLoRA, a reformulated low-rank adaptation method, enhances parameter-efficient fine-tuning by learning a single low-rank matrix update, ensuring stable optimization and reduced parameter count.  \t\t\t\t\tAI-generated summary \t\t\t\t Low-Rank Adaptation (LoRA) has significantly advanced parameter-efficient fine-tuning of large pretrained models. LoRA augments the pre-trained weights of a model by adding the product of two smaller matrices that together form a low-rank matrix update. Recent research has shown that scale disparities between these two matrices often cause unstable training dynamics, leading to suboptimal performance. In this paper, we propose SingLoRA, which reformulates low-rank adaptation by learning the weights update as a decomposition of a single low-rank matrix multiplied by its transpose. This simple design inherently removes inter-matrix scale conflicts, ensuring stable optimization, and roughly halves the parameter count. We analyze SingLoRA within the infinite-width neural network framework, showing that it guarantees stable feature learning by construction. Extensive experiments on multiple tasks validate these benefits. In common sense reasoning, fine-tuning LLama 7B on MNLI with SingLoRA achieves 91.3% accuracy - surpassing LoRA (89.1%) and LoRA+ (90.2%) - while using only 60% of their parameter budget. In image generation, fine-tuning Stable Diffusion with SingLoRA significantly improves image fidelity on DreamBooth, achieving a DINO similarity score of 0.151, compared to scores of 0.148 and 0.143 for DoRA and LoRA, respectively.', 'score': 58, 'issue_id': 4720, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': 'b4bac7e0cf74ddfa', 'authors': ['David Bensaïd', 'Noam Rotstein', 'Roy Velich', 'Daniel Bensaïd', 'Ron Kimmel'], 'affiliations': ['Technion - IIT Haifa, Israel', 'University Paris Dauphine Paris, France'], 'pdf_title_img': 'assets/pdf/title_img/2507.05566.jpg', 'data': {'categories': ['#optimization', '#transfer_learning', '#training', '#architecture'], 'emoji': '🔢', 'ru': {'title': 'SingLoRA: стабильная и эффективная адаптация моделей', 'desc': 'SingLoRA - это новый метод адаптации с низким рангом для эффективной донастройки больших предобученных моделей. Он решает проблему нестабильности обучения, характерную для стандартного LoRA, путем использования разложения одной низкоранговой матрицы. SingLoRA обеспечивает более стабильную оптимизацию и уменьшает количество параметров примерно вдвое. Эксперименты показывают, что SingLoRA превосходит LoRA и другие методы в задачах обработки естественного языка и генерации изображений.'}, 'en': {'title': 'SingLoRA: Simplifying Fine-Tuning with Stable Low-Rank Updates', 'desc': 'SingLoRA is a new method for fine-tuning large machine learning models efficiently by using a single low-rank matrix update. This approach simplifies the training process by avoiding issues related to scale differences between multiple matrices, which can lead to unstable learning. By reformulating the adaptation process, SingLoRA reduces the number of parameters needed, making it more efficient while maintaining performance. Experiments show that SingLoRA outperforms previous methods in tasks like common sense reasoning and image generation, achieving higher accuracy and better image quality with fewer parameters.'}, 'zh': {'title': 'SingLoRA：稳定高效的低秩适应方法', 'desc': 'SingLoRA是一种重新构建的低秩适应方法，旨在通过学习单个低秩矩阵的更新来增强参数高效的微调。它通过将两个较小矩阵的乘积形成低秩矩阵更新，解决了传统LoRA方法中矩阵间尺度差异导致的不稳定训练问题。SingLoRA的设计消除了这些冲突，确保了优化过程的稳定性，并大幅减少了参数数量。实验结果表明，SingLoRA在多个任务上表现优异，尤其是在常识推理和图像生成方面，超越了传统的LoRA方法。'}}}, {'id': 'https://huggingface.co/papers/2507.06229', 'title': 'Agent KB: Leveraging Cross-Domain Experience for Agentic Problem Solving', 'url': 'https://huggingface.co/papers/2507.06229', 'abstract': "As language agents tackle increasingly complex tasks, they struggle with effective error correction and experience reuse across domains. We introduce Agent KB, a hierarchical experience framework that enables complex agentic problem solving via a novel Reason-Retrieve-Refine pipeline. Agent KB addresses a core limitation: agents traditionally cannot learn from each other's experiences. By capturing both high-level strategies and detailed execution logs, Agent KB creates a shared knowledge base that enables cross-agent knowledge transfer. Evaluated on the GAIA benchmark, Agent KB improves success rates by up to 16.28 percentage points. On the most challenging tasks, Claude-3 improves from 38.46% to 57.69%, while GPT-4 improves from 53.49% to 73.26% on intermediate tasks. On SWE-bench code repair, Agent KB enables Claude-3 to improve from 41.33% to 53.33%. Our results suggest that Agent KB provides a modular, framework-agnostic infrastructure for enabling agents to learn from past experiences and generalize successful strategies to new tasks.", 'score': 54, 'issue_id': 4733, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': 'fe7edacae46166de', 'authors': ['Xiangru Tang', 'Tianrui Qin', 'Tianhao Peng', 'Ziyang Zhou', 'Daniel Shao', 'Tingting Du', 'Xinming Wei', 'Peng Xia', 'Fang Wu', 'He Zhu', 'Ge Zhang', 'Jiaheng Liu', 'Xingyao Wang', 'Sirui Hong', 'Chenglin Wu', 'Hao Cheng', 'Chi Wang', 'Wangchunshu Zhou'], 'affiliations': ['All Hands AI', 'Bytedance', 'Google DeepMind', 'MetaGPT X', 'Microsoft Research', 'Nanjing University', 'OPPO', 'Stanford University', 'UNC Chapel Hill', 'UW-Madison', 'Yale University'], 'pdf_title_img': 'assets/pdf/title_img/2507.06229.jpg', 'data': {'categories': ['#benchmark', '#reasoning', '#agents', '#transfer_learning'], 'emoji': '🧠', 'ru': {'title': 'Коллективный разум: Agent KB объединяет опыт языковых моделей', 'desc': 'Статья представляет Agent KB - иерархическую систему для обмена опытом между языковыми агентами. Используя процесс Reason-Retrieve-Refine, Agent KB создает общую базу знаний, позволяющую агентам учиться на опыте друг друга. Система улучшает показатели успешности на бенчмарке GAIA до 16.28 процентных пунктов. Agent KB также повышает эффективность исправления кода на SWE-bench для Claude-3 с 41.33% до 53.33%.'}, 'en': {'title': 'Empowering Agents with Shared Knowledge for Better Learning', 'desc': 'This paper presents Agent KB, a new framework designed to enhance the learning capabilities of language agents by allowing them to share and reuse experiences. It introduces a Reason-Retrieve-Refine pipeline that helps agents learn from both high-level strategies and detailed execution logs. By creating a shared knowledge base, Agent KB facilitates knowledge transfer between agents, overcoming the traditional limitation of isolated learning. The framework shows significant improvements in task success rates across various benchmarks, demonstrating its effectiveness in enabling agents to generalize successful strategies to new challenges.'}, 'zh': {'title': 'Agent KB：提升代理学习与经验共享的框架', 'desc': '本文介绍了一种名为Agent KB的层次化经验框架，旨在提升语言代理在复杂任务中的错误修正和经验重用能力。Agent KB通过一种新颖的推理-检索-精炼管道，解决了代理之间无法相互学习经验的核心限制。该框架捕捉高层策略和详细执行日志，创建了一个共享知识库，促进了跨代理的知识转移。在GAIA基准测试中，Agent KB显著提高了成功率，Claude-3和GPT-4在不同任务上的表现都有显著提升。'}}}, {'id': 'https://huggingface.co/papers/2507.06203', 'title': 'A Survey on Latent Reasoning', 'url': 'https://huggingface.co/papers/2507.06203', 'abstract': "Latent reasoning enhances large language models by performing multi-step inference in continuous hidden states, improving efficiency and expressiveness beyond token-level supervision.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have demonstrated impressive reasoning capabilities, especially when guided by explicit chain-of-thought (CoT) reasoning that verbalizes intermediate steps. While CoT improves both interpretability and accuracy, its dependence on natural language reasoning limits the model's expressive bandwidth. Latent reasoning tackles this bottleneck by performing multi-step inference entirely in the model's continuous hidden state, eliminating token-level supervision. To advance latent reasoning research, this survey provides a comprehensive overview of the emerging field of latent reasoning. We begin by examining the foundational role of neural network layers as the computational substrate for reasoning, highlighting how hierarchical representations support complex transformations. Next, we explore diverse latent reasoning methodologies, including activation-based recurrence, hidden state propagation, and fine-tuning strategies that compress or internalize explicit reasoning traces. Finally, we discuss advanced paradigms such as infinite-depth latent reasoning via masked diffusion models, which enable globally consistent and reversible reasoning processes. By unifying these perspectives, we aim to clarify the conceptual landscape of latent reasoning and chart future directions for research at the frontier of LLM cognition. An associated GitHub repository collecting the latest papers and repos is available at: https://github.com/multimodal-art-projection/LatentCoT-Horizon/.", 'score': 52, 'issue_id': 4716, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '9b37c1970657d866', 'authors': ['Rui-Jie Zhu', 'Tianhao Peng', 'Tianhao Cheng', 'Xingwei Qu', 'Jinfa Huang', 'Dawei Zhu', 'Hao Wang', 'Kaiwen Xue', 'Xuanliang Zhang', 'Yong Shan', 'Tianle Cai', 'Taylor Kergan', 'Assel Kembay', 'Andrew Smith', 'Chenghua Lin', 'Binh Nguyen', 'Yuqi Pan', 'Yuhong Chou', 'Zefan Cai', 'Zhenhe Wu', 'Yongchi Zhao', 'Tianyu Liu', 'Jian Yang', 'Wangchunshu Zhou', 'Chujie Zheng', 'Chongxuan Li', 'Yuyin Zhou', 'Zhoujun Li', 'Zhaoxiang Zhang', 'Jiaheng Liu', 'Ge Zhang', 'Wenhao Huang', 'Jason Eshraghian'], 'affiliations': ['FDU', 'M-A-P', 'NJU', 'PKU', 'PolyU', 'RUC', 'UCSC', 'UW-Madison', 'UoM'], 'pdf_title_img': 'assets/pdf/title_img/2507.06203.jpg', 'data': {'categories': ['#reasoning', '#rl', '#survey', '#training', '#architecture'], 'emoji': '🧠', 'ru': {'title': 'Латентное рассуждение: новый горизонт для больших языковых моделей', 'desc': 'Это исследование посвящено латентному рассуждению в больших языковых моделях (LLM). Латентное рассуждение позволяет выполнять многошаговые логические выводы в непрерывном скрытом состоянии модели, что повышает эффективность и выразительность по сравнению с токеновым уровнем. В статье рассматриваются различные методологии латентного рассуждения, включая рекуррентность на основе активаций и распространение скрытого состояния. Также обсуждаются продвинутые парадигмы, такие как латентное рассуждение бесконечной глубины с использованием маскированных диффузионных моделей.'}, 'en': {'title': 'Unlocking LLM Potential with Latent Reasoning', 'desc': "This paper discusses how latent reasoning can improve large language models (LLMs) by allowing them to perform multi-step inference in their hidden states, rather than relying on token-level supervision. It highlights the limitations of traditional chain-of-thought reasoning, which, while effective, restricts the model's ability to express complex ideas. The authors review various methodologies for latent reasoning, such as activation-based recurrence and hidden state propagation, which enhance the model's reasoning capabilities. They also introduce advanced techniques like masked diffusion models that facilitate more sophisticated and reversible reasoning processes."}, 'zh': {'title': '潜在推理：超越标记的推理新境界', 'desc': '潜在推理通过在连续的隐藏状态中进行多步推理，增强了大型语言模型的能力，超越了基于标记的监督，提高了效率和表达能力。虽然链式推理（CoT）可以提高模型的可解释性和准确性，但其对自然语言推理的依赖限制了模型的表达带宽。潜在推理通过完全在模型的隐藏状态中进行推理，消除了对标记级监督的需求。本文综述了潜在推理的基础、方法和未来研究方向，旨在阐明这一新兴领域的概念框架。'}}}, {'id': 'https://huggingface.co/papers/2507.06165', 'title': 'OmniPart: Part-Aware 3D Generation with Semantic Decoupling and\n  Structural Cohesion', 'url': 'https://huggingface.co/papers/2507.06165', 'abstract': 'OmniPart generates part-aware 3D objects with high semantic decoupling and robust structural cohesion using an autoregressive structure planning module and a spatially-conditioned rectified flow model.  \t\t\t\t\tAI-generated summary \t\t\t\t The creation of 3D assets with explicit, editable part structures is crucial for advancing interactive applications, yet most generative methods produce only monolithic shapes, limiting their utility. We introduce OmniPart, a novel framework for part-aware 3D object generation designed to achieve high semantic decoupling among components while maintaining robust structural cohesion. OmniPart uniquely decouples this complex task into two synergistic stages: (1) an autoregressive structure planning module generates a controllable, variable-length sequence of 3D part bounding boxes, critically guided by flexible 2D part masks that allow for intuitive control over part decomposition without requiring direct correspondences or semantic labels; and (2) a spatially-conditioned rectified flow model, efficiently adapted from a pre-trained holistic 3D generator, synthesizes all 3D parts simultaneously and consistently within the planned layout. Our approach supports user-defined part granularity, precise localization, and enables diverse downstream applications. Extensive experiments demonstrate that OmniPart achieves state-of-the-art performance, paving the way for more interpretable, editable, and versatile 3D content.', 'score': 41, 'issue_id': 4716, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '3acb1f1fb28acbf6', 'authors': ['Yunhan Yang', 'Yufan Zhou', 'Yuan-Chen Guo', 'Zi-Xin Zou', 'Yukun Huang', 'Ying-Tian Liu', 'Hao Xu', 'Ding Liang', 'Yan-Pei Cao', 'Xihui Liu'], 'affiliations': ['Harbin Institute of Technology, China', 'The University of Hong Kong, China', 'VAST, China', 'Zhejiang University, China'], 'pdf_title_img': 'assets/pdf/title_img/2507.06165.jpg', 'data': {'categories': ['#optimization', '#3d', '#games'], 'emoji': '🧩', 'ru': {'title': 'OmniPart: Интеллектуальная генерация редактируемых 3D-объектов', 'desc': 'OmniPart - это новая система для генерации 3D-объектов с явной структурой частей. Она использует авторегрессивный модуль планирования структуры и пространственно-обусловленную модель выпрямленного потока. OmniPart обеспечивает высокую семантическую независимость компонентов при сохранении структурной целостности. Система поддерживает контроль гранулярности частей и позволяет создавать редактируемый 3D-контент для различных приложений.'}, 'en': {'title': 'Revolutionizing 3D Object Generation with Part Awareness', 'desc': 'OmniPart is a framework designed to generate 3D objects that are aware of their individual parts, allowing for better control and editing. It uses an autoregressive structure planning module to create a sequence of bounding boxes for each part, guided by 2D masks for intuitive control. Additionally, it employs a spatially-conditioned rectified flow model to synthesize all parts together in a coherent manner. This method enhances the usability of 3D assets for interactive applications by providing high semantic decoupling and structural integrity.'}, 'zh': {'title': 'OmniPart：可编辑的三维对象生成新方法', 'desc': 'OmniPart 是一个新颖的框架，用于生成具有明确可编辑部件结构的三维对象。它通过自回归结构规划模块和空间条件修正流模型，实现了部件之间的高语义解耦和稳健的结构凝聚力。该方法将复杂任务分为两个协同阶段，首先生成可控的三维部件边界框序列，然后同时合成所有三维部件。实验表明，OmniPart 在性能上达到了最先进水平，为更可解释、可编辑和多功能的三维内容铺平了道路。'}}}, {'id': 'https://huggingface.co/papers/2507.04103', 'title': 'How to Train Your LLM Web Agent: A Statistical Diagnosis', 'url': 'https://huggingface.co/papers/2507.04103', 'abstract': 'A study on compute allocation for post-training LLM-based web agents finds that combining supervised fine-tuning with on-policy reinforcement learning improves performance and reduces computational costs compared to either method alone.  \t\t\t\t\tAI-generated summary \t\t\t\t LLM-based web agents have recently made significant progress, but much of it has occurred in closed-source systems, widening the gap with open-source alternatives. Progress has been held back by two key challenges: first, a narrow focus on single-step tasks that overlooks the complexity of multi-step web interactions; and second, the high compute costs required to post-train LLM-based web agents. To address this, we present the first statistically grounded study on compute allocation for LLM web-agent post-training. Our approach uses a two-stage pipeline, training a Llama 3.1 8B student to imitate a Llama 3.3 70B teacher via supervised fine-tuning (SFT), followed by on-policy reinforcement learning. We find this process highly sensitive to hyperparameter choices, making exhaustive sweeps impractical. To spare others from expensive trial-and-error, we sample 1,370 configurations and use bootstrapping to estimate effective hyperparameters. Our results show that combining SFT with on-policy RL consistently outperforms either approach alone on both WorkArena and MiniWob++. Further, this strategy requires only 55% of the compute to match the peak performance of pure SFT on MiniWob++, effectively pushing the compute-performance Pareto frontier, and is the only strategy that can close the gap with closed-source models.', 'score': 35, 'issue_id': 4716, 'pub_date': '2025-07-05', 'pub_date_card': {'ru': '5 июля', 'en': 'July 5', 'zh': '7月5日'}, 'hash': '64d72d8a50ee925a', 'authors': ['Dheeraj Vattikonda', 'Santhoshi Ravichandran', 'Emiliano Penaloza', 'Hadi Nekoei', 'Megh Thakkar', 'Thibault Le Sellier de Chezelles', 'Nicolas Gontier', 'Miguel Muñoz-Mármol', 'Sahar Omidi Shayegan', 'Stefania Raimondo', 'Xue Liu', 'Alexandre Drouin', 'Laurent Charlin', 'Alexandre Piché', 'Alexandre Lacoste', 'Massimo Caccia'], 'affiliations': ['HEC Montréal', 'McGill University', 'MilaQuebec AI Institute', 'Polytechnique Montréal', 'ServiceNow Research', 'Univeristé de Montréal'], 'pdf_title_img': 'assets/pdf/title_img/2507.04103.jpg', 'data': {'categories': ['#agents', '#optimization', '#rl', '#training', '#open_source'], 'emoji': '🤖', 'ru': {'title': 'Эффективное пост-обучение LLM-агентов: синергия SFT и RL', 'desc': 'Исследование посвящено оптимизации вычислительных ресурсов для пост-обучения веб-агентов на основе больших языковых моделей (LLM). Авторы применяют двухэтапный подход, сочетающий обучение с учителем (SFT) и обучение с подкреплением (RL). Результаты показывают, что такая комбинация превосходит каждый метод по отдельности на бенчмарках WorkArena и MiniWob++. Этот подход также позволяет сократить вычислительные затраты на 45% по сравнению с чистым SFT при сохранении пиковой производительности.'}, 'en': {'title': 'Optimizing LLM Training: Combining SFT and RL for Efficiency', 'desc': 'This paper investigates how to allocate computing resources effectively for post-training large language model (LLM)-based web agents. It demonstrates that integrating supervised fine-tuning (SFT) with on-policy reinforcement learning (RL) leads to better performance and lower computational costs than using either method separately. The study employs a two-stage training process, where a smaller model learns from a larger one, and it carefully samples hyperparameters to optimize the training process. The findings indicate that this combined approach not only enhances performance but also significantly reduces the computational resources needed, making it a viable alternative to closed-source systems.'}, 'zh': {'title': '结合微调与强化学习，提升LLM代理性能', 'desc': '本研究探讨了基于大语言模型（LLM）的网络代理的计算分配问题。我们提出了一种结合监督微调（SFT）和在线强化学习（RL）的方法，发现这种组合在性能和计算成本上均优于单独使用任一方法。通过对1,370种配置进行采样并使用自助法估计有效超参数，我们的结果表明，这种策略在MiniWob++上仅需55%的计算资源即可达到纯SFT的最佳性能。此方法有效缩小了与闭源模型的差距，推动了计算与性能的帕累托前沿。'}}}, {'id': 'https://huggingface.co/papers/2507.06181', 'title': 'CriticLean: Critic-Guided Reinforcement Learning for Mathematical\n  Formalization', 'url': 'https://huggingface.co/papers/2507.06181', 'abstract': "CriticLean, a reinforcement learning framework with CriticLeanGPT and CriticLeanBench, enhances semantic evaluation in automated theorem proving by actively learning to distinguish correct from incorrect formalizations.  \t\t\t\t\tAI-generated summary \t\t\t\t Translating natural language mathematical statements into formal, executable code is a fundamental challenge in automated theorem proving. While prior work has focused on generation and compilation success, little attention has been paid to the critic phase-the evaluation of whether generated formalizations truly capture the semantic intent of the original problem. In this paper, we introduce CriticLean, a novel critic-guided reinforcement learning framework that elevates the role of the critic from a passive validator to an active learning component. Specifically, first, we propose the CriticLeanGPT, trained via supervised fine-tuning and reinforcement learning, to rigorously assess the semantic fidelity of Lean 4 formalizations. Then, we introduce CriticLeanBench, a benchmark designed to measure models' ability to distinguish semantically correct from incorrect formalizations, and demonstrate that our trained CriticLeanGPT models can significantly outperform strong open- and closed-source baselines. Building on the CriticLean framework, we construct FineLeanCorpus, a dataset comprising over 285K problems that exhibits rich domain diversity, broad difficulty coverage, and high correctness based on human evaluation. Overall, our findings highlight that optimizing the critic phase is essential for producing reliable formalizations, and we hope our CriticLean will provide valuable insights for future advances in formal mathematical reasoning.", 'score': 34, 'issue_id': 4715, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': 'ad86fa3f7ff162ee', 'authors': ['Zhongyuan Peng', 'Yifan Yao', 'Kaijing Ma', 'Shuyue Guo', 'Yizhe Li', 'Yichi Zhang', 'Chenchen Zhang', 'Yifan Zhang', 'Zhouliang Yu', 'Luming Li', 'Minghao Liu', 'Yihang Xia', 'Jiawei Shen', 'Yuchen Wu', 'Yixin Cao', 'Zhaoxiang Zhang', 'Wenhao Huang', 'Jiaheng Liu', 'Ge Zhang'], 'affiliations': [], 'pdf_title_img': 'assets/pdf/title_img/2507.06181.jpg', 'data': {'categories': ['#benchmark', '#optimization', '#reasoning', '#rl', '#dataset'], 'emoji': '🧠', 'ru': {'title': 'Критик учится различать правильные и неправильные формализации теорем', 'desc': 'CriticLean - это фреймворк обучения с подкреплением для улучшения семантической оценки в автоматическом доказательстве теорем. Он включает в себя CriticLeanGPT - модель, обученную различать правильные и неправильные формализации, и CriticLeanBench - набор данных для оценки таких моделей. Фреймворк позволяет активно обучать критика, переводя его роль из пассивного валидатора в активный обучающийся компонент. Результаты показывают, что оптимизация фазы критики крайне важна для получения надежных формализаций в математических рассуждениях.'}, 'en': {'title': 'Empowering Theorem Proving with Active Semantic Evaluation', 'desc': 'CriticLean is a reinforcement learning framework designed to improve the evaluation of formalizations in automated theorem proving. It introduces CriticLeanGPT, a model that actively learns to assess the semantic accuracy of mathematical statements translated into formal code. The framework also includes CriticLeanBench, a benchmark for measuring the effectiveness of models in distinguishing correct from incorrect formalizations. By optimizing the critic phase, CriticLean aims to enhance the reliability of formalizations and contribute to advancements in formal mathematical reasoning.'}, 'zh': {'title': '优化评判阶段，提升自动定理证明的可靠性', 'desc': 'CriticLean是一个强化学习框架，旨在提高自动定理证明中的语义评估。它通过CriticLeanGPT和CriticLeanBench，主动学习区分正确和错误的形式化表达。CriticLeanGPT经过监督微调和强化学习训练，能够严格评估Lean 4形式化的语义准确性。我们的研究表明，优化评判阶段对于生成可靠的形式化表达至关重要。'}}}, {'id': 'https://huggingface.co/papers/2507.05240', 'title': 'StreamVLN: Streaming Vision-and-Language Navigation via SlowFast Context\n  Modeling', 'url': 'https://huggingface.co/papers/2507.05240', 'abstract': 'StreamVLN, a streaming VLN framework, uses a hybrid slow-fast context modeling strategy to balance fine-grained visual understanding, long-term context modeling, and computational efficiency in real-world settings.  \t\t\t\t\tAI-generated summary \t\t\t\t Vision-and-Language Navigation (VLN) in real-world settings requires agents to process continuous visual streams and generate actions with low latency grounded in language instructions. While Video-based Large Language Models (Video-LLMs) have driven recent progress, current VLN methods based on Video-LLM often face trade-offs among fine-grained visual understanding, long-term context modeling and computational efficiency. We introduce StreamVLN, a streaming VLN framework that employs a hybrid slow-fast context modeling strategy to support multi-modal reasoning over interleaved vision, language and action inputs. The fast-streaming dialogue context facilitates responsive action generation through a sliding-window of active dialogues, while the slow-updating memory context compresses historical visual states using a 3D-aware token pruning strategy. With this slow-fast design, StreamVLN achieves coherent multi-turn dialogue through efficient KV cache reuse, supporting long video streams with bounded context size and inference cost. Experiments on VLN-CE benchmarks demonstrate state-of-the-art performance with stable low latency, ensuring robustness and efficiency in real-world deployment. The project page is: https://streamvln.github.io/{https://streamvln.github.io/}.', 'score': 34, 'issue_id': 4718, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': '89c364a9ab7df29e', 'authors': ['Meng Wei', 'Chenyang Wan', 'Xiqian Yu', 'Tai Wang', 'Yuqiang Yang', 'Xiaohan Mao', 'Chenming Zhu', 'Wenzhe Cai', 'Hanqing Wang', 'Yilun Chen', 'Xihui Liu', 'Jiangmiao Pang'], 'affiliations': ['Shanghai AI Laboratory', 'Shanghai Jiao Tong University', 'The University of Hong Kong', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2507.05240.jpg', 'data': {'categories': ['#video', '#agents', '#multimodal', '#games', '#benchmark', '#long_context'], 'emoji': '🧭', 'ru': {'title': 'StreamVLN: Эффективная навигация ИИ в реальном мире', 'desc': 'StreamVLN - это новая система для навигации с использованием зрения и языка (VLN) в реальном мире. Она применяет гибридную стратегию медленно-быстрого моделирования контекста для баланса между детальным пониманием визуальной информации, долгосрочным моделированием контекста и вычислительной эффективностью. StreamVLN использует быстрый диалоговый контекст для оперативной генерации действий и медленно обновляемый контекст памяти для сжатия исторических визуальных состояний. Эксперименты показывают, что StreamVLN достигает современного уровня производительности с стабильно низкой задержкой.'}, 'en': {'title': 'StreamVLN: Efficient Navigation with Hybrid Context Modeling', 'desc': 'StreamVLN is a new framework designed for Vision-and-Language Navigation (VLN) that effectively processes continuous visual data while following language instructions. It uses a hybrid slow-fast context modeling approach to balance detailed visual understanding with long-term context and computational efficiency. The fast-streaming dialogue context allows for quick action responses, while the slow-updating memory context efficiently manages historical visual information. This innovative design leads to improved performance in real-world applications, achieving state-of-the-art results with low latency and robust operation.'}, 'zh': {'title': 'StreamVLN：高效的流式视觉与语言导航', 'desc': 'StreamVLN是一个流式视觉与语言导航框架，采用混合的慢速-快速上下文建模策略，以平衡细粒度视觉理解、长期上下文建模和计算效率。该框架支持多模态推理，能够处理交错的视觉、语言和动作输入。快速流式对话上下文通过滑动窗口实现响应式动作生成，而慢速更新的记忆上下文则利用3D感知的标记修剪策略压缩历史视觉状态。实验结果表明，StreamVLN在VLN-CE基准测试中表现出色，具备稳定的低延迟，确保在实际应用中的鲁棒性和效率。'}}}, {'id': 'https://huggingface.co/papers/2507.03112', 'title': 'RLVER: Reinforcement Learning with Verifiable Emotion Rewards for\n  Empathetic Agents', 'url': 'https://huggingface.co/papers/2507.03112', 'abstract': "An end-to-end reinforcement learning framework using simulated user emotion rewards enhances emotional intelligence in large language models while maintaining cognitive skills.  \t\t\t\t\tAI-generated summary \t\t\t\t Large language models (LLMs) excel at logical and algorithmic reasoning, yet their emotional intelligence (EQ) still lags far behind their cognitive prowess. While reinforcement learning from verifiable rewards (RLVR) has advanced in other domains, its application to dialogue-especially for emotional intelligence-remains underexplored. In this work, we introduce RLVER, the first end-to-end reinforcement learning framework that leverages verifiable emotion rewards from simulated users to cultivate higher-order empathetic abilities in LLMs. Within this framework, self-consistent affective simulated users engage in dialogue rollouts and produce deterministic emotion scores during conversations, serving as reward signals to guide the LLM's learning. Fine-tuning publicly available Qwen2.5-7B-Instruct model with PPO boosts its Sentient-Benchmark score from 13.3 to 79.2 while largely preserving mathematical and coding competence. Extensive experiments reveal that: (i) RLVER consistently improves multiple dialogue capabilities; (ii) Thinking and non-thinking models show distinct trends--thinking models excel in empathy and insight, while non-thinking models favor action; (iii) GRPO often yields stable gains, while PPO can push certain capabilities to a higher ceiling; (iv) More challenging environments are not always better-moderate ones can yield stronger outcomes. Our results show that RLVER is a practical route toward emotionally intelligent and broadly capable language agents.", 'score': 27, 'issue_id': 4715, 'pub_date': '2025-07-03', 'pub_date_card': {'ru': '3 июля', 'en': 'July 3', 'zh': '7月3日'}, 'hash': 'c1368a26272d7e57', 'authors': ['Peisong Wang', 'Ruotian Ma', 'Bang Zhang', 'Xingyu Chen', 'Zhiwei He', 'Kang Luo', 'Qingsong Lv', 'Qingxuan Jiang', 'Zheng Xie', 'Shanyi Wang', 'Yuan Li', 'Fanghua Ye', 'Jian Li', 'Yifan Yang', 'Zhaopeng Tu', 'Xiaolong Li'], 'affiliations': ['Hunyuan AI Digital Human, Tencent'], 'pdf_title_img': 'assets/pdf/title_img/2507.03112.jpg', 'data': {'categories': ['#reasoning', '#rl', '#alignment', '#agents', '#rlhf', '#training'], 'emoji': '🤖💕', 'ru': {'title': 'Эмоциональный интеллект ИИ: обучение с подкреплением открывает новые горизонты', 'desc': 'Статья представляет RLVER - первую систему обучения с подкреплением для развития эмоционального интеллекта у больших языковых моделей (LLM). Система использует симулированных пользователей для генерации эмоциональных наград в процессе диалога. Применение RLVER к модели Qwen2.5-7B-Instruct значительно повысило её показатели эмоционального интеллекта при сохранении когнитивных навыков. Эксперименты показали, что RLVER последовательно улучшает различные диалоговые способности модели.'}, 'en': {'title': 'Enhancing Emotional Intelligence in Language Models with RLVER', 'desc': 'This paper presents RLVER, a novel reinforcement learning framework designed to enhance emotional intelligence in large language models (LLMs) by using simulated user emotion rewards. The framework employs reinforcement learning from verifiable rewards (RLVR) to train LLMs in dialogue settings, focusing on developing empathetic abilities. By fine-tuning the Qwen2.5-7B-Instruct model with Proximal Policy Optimization (PPO), the authors demonstrate significant improvements in emotional understanding while maintaining cognitive skills. The findings indicate that RLVER effectively boosts dialogue capabilities and suggests that moderate training environments can lead to better outcomes than more challenging ones.'}, 'zh': {'title': '情感智能与认知能力的完美结合', 'desc': '本文提出了一种端到端的强化学习框架RLVER，旨在通过模拟用户的情感奖励来提升大型语言模型的情感智能。尽管大型语言模型在逻辑推理方面表现出色，但它们的情感智能仍然不足。RLVER利用可验证的情感奖励，指导模型学习更高层次的同理心能力。实验结果表明，RLVER显著提高了对话能力，并在保持数学和编码能力的同时，提升了模型的情感理解能力。'}}}, {'id': 'https://huggingface.co/papers/2507.05675', 'title': 'MedGen: Unlocking Medical Video Generation by Scaling\n  Granularly-annotated Medical Videos', 'url': 'https://huggingface.co/papers/2507.05675', 'abstract': 'MedGen, a model trained on the large-scale MedVideoCap-55K dataset, achieves top performance in medical video generation by balancing visual quality and medical accuracy.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in video generation have shown remarkable progress in open-domain settings, yet medical video generation remains largely underexplored. Medical videos are critical for applications such as clinical training, education, and simulation, requiring not only high visual fidelity but also strict medical accuracy. However, current models often produce unrealistic or erroneous content when applied to medical prompts, largely due to the lack of large-scale, high-quality datasets tailored to the medical domain. To address this gap, we introduce MedVideoCap-55K, the first large-scale, diverse, and caption-rich dataset for medical video generation. It comprises over 55,000 curated clips spanning real-world medical scenarios, providing a strong foundation for training generalist medical video generation models. Built upon this dataset, we develop MedGen, which achieves leading performance among open-source models and rivals commercial systems across multiple benchmarks in both visual quality and medical accuracy. We hope our dataset and model can serve as a valuable resource and help catalyze further research in medical video generation. Our code and data is available at https://github.com/FreedomIntelligence/MedGen', 'score': 22, 'issue_id': 4716, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '06c0aadc1cba572e', 'authors': ['Rongsheng Wang', 'Junying Chen', 'Ke Ji', 'Zhenyang Cai', 'Shunian Chen', 'Yunjin Yang', 'Benyou Wang'], 'affiliations': ['The Chinese University of Hong Kong, Shenzhen'], 'pdf_title_img': 'assets/pdf/title_img/2507.05675.jpg', 'data': {'categories': ['#science', '#video', '#healthcare', '#open_source', '#dataset'], 'emoji': '🏥', 'ru': {'title': 'MedGen: Новый стандарт в генерации медицинских видео с помощью ИИ', 'desc': 'Модель MedGen, обученная на крупномасштабном наборе данных MedVideoCap-55K, достигает высоких результатов в генерации медицинских видео, балансируя между визуальным качеством и медицинской точностью. MedVideoCap-55K - это первый масштабный, разнообразный набор данных с подписями для генерации медицинских видео, содержащий более 55 000 отобранных клипов из реальных медицинских сценариев. MedGen превосходит открытые модели и соперничает с коммерческими системами по визуальному качеству и медицинской точности на различных бенчмарках. Авторы надеются, что их датасет и модель послужат ценным ресурсом и катализатором дальнейших исследований в области генерации медицинских видео.'}, 'en': {'title': 'Revolutionizing Medical Video Generation with MedGen', 'desc': 'MedGen is a cutting-edge model designed for generating medical videos, trained on the extensive MedVideoCap-55K dataset. This dataset is the first of its kind, featuring over 55,000 high-quality video clips that accurately depict real-world medical scenarios. MedGen excels in producing videos that not only look visually appealing but also maintain strict adherence to medical accuracy, addressing a significant challenge in the field. By providing this innovative model and dataset, the authors aim to advance research in medical video generation and improve applications in clinical training and education.'}, 'zh': {'title': '医学视频生成的新突破', 'desc': 'MedGen是一个基于大规模MedVideoCap-55K数据集训练的模型，专注于医学视频生成。该模型在视觉质量和医学准确性之间取得了良好的平衡，表现出色。医学视频在临床培训、教育和模拟中至关重要，因此需要高视觉保真度和严格的医学准确性。MedVideoCap-55K数据集是首个大规模、多样化且富含字幕的医学视频生成数据集，为训练医学视频生成模型提供了坚实基础。'}}}, {'id': 'https://huggingface.co/papers/2507.06219', 'title': 'Is Diversity All You Need for Scalable Robotic Manipulation?', 'url': 'https://huggingface.co/papers/2507.06219', 'abstract': 'Investigation into data diversity in robotic manipulation reveals that task diversity is crucial, multi-embodiment data is optional, and expert diversity can be confounding, leading to a distribution debiasing method for improved performance.  \t\t\t\t\tAI-generated summary \t\t\t\t Data scaling has driven remarkable success in foundation models for Natural Language Processing (NLP) and Computer Vision (CV), yet the principles of effective data scaling in robotic manipulation remain insufficiently understood. In this work, we investigate the nuanced role of data diversity in robot learning by examining three critical dimensions-task (what to do), embodiment (which robot to use), and expert (who demonstrates)-challenging the conventional intuition of "more diverse is better". Throughout extensive experiments on various robot platforms, we reveal that (1) task diversity proves more critical than per-task demonstration quantity, benefiting transfer from diverse pre-training tasks to novel downstream scenarios; (2) multi-embodiment pre-training data is optional for cross-embodiment transfer-models trained on high-quality single-embodiment data can efficiently transfer to different platforms, showing more desirable scaling property during fine-tuning than multi-embodiment pre-trained models; and (3) expert diversity, arising from individual operational preferences and stochastic variations in human demonstrations, can be confounding to policy learning, with velocity multimodality emerging as a key contributing factor. Based on this insight, we propose a distribution debiasing method to mitigate velocity ambiguity, the yielding GO-1-Pro achieves substantial performance gains of 15%, equivalent to using 2.5 times pre-training data. Collectively, these findings provide new perspectives and offer practical guidance on how to scale robotic manipulation datasets effectively.', 'score': 17, 'issue_id': 4715, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': 'd4781dc7e2730cb8', 'authors': ['Modi Shi', 'Li Chen', 'Jin Chen', 'Yuxiang Lu', 'Chiming Liu', 'Guanghui Ren', 'Ping Luo', 'Di Huang', 'Maoqing Yao', 'Hongyang Li'], 'affiliations': ['AgiBot', 'Beihang University', 'Shanghai AI Lab', 'Shanghai Innovation Institute', 'The University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2507.06219.jpg', 'data': {'categories': ['#optimization', '#transfer_learning', '#robotics', '#data', '#dataset', '#training'], 'emoji': '🤖', 'ru': {'title': 'Ключ к эффективному обучению роботов: разнообразие задач важнее разнообразия платформ', 'desc': 'Исследование разнообразия данных в робототехнической манипуляции показало, что разнообразие задач имеет решающее значение, в то время как использование данных от нескольких роботов необязательно. Разнообразие экспертов может вносить путаницу, что привело к разработке метода дебиасинга распределения для улучшения производительности. Модели, обученные на высококачественных данных от одного робота, могут эффективно переноситься на другие платформы. Предложенный метод GO-1-Pro, снижающий неоднозначность скорости, позволяет достичь значительного прироста производительности в 15%.'}, 'en': {'title': 'Diversity in Data: Key to Better Robot Learning', 'desc': 'This paper explores the importance of data diversity in robotic manipulation, focusing on three key aspects: task diversity, embodiment diversity, and expert diversity. It finds that having a variety of tasks is more beneficial than simply increasing the number of demonstrations for each task. The study also shows that using data from a single robot can be just as effective as using data from multiple robots for training. Additionally, it highlights that differences in how experts demonstrate tasks can complicate learning, leading to the development of a new method to reduce confusion caused by these variations, resulting in significant performance improvements.'}, 'zh': {'title': '任务多样性是机器人操作的关键', 'desc': '本研究探讨了数据多样性在机器人操作中的重要性，发现任务多样性是关键，而多种机器人形态的数据是可选的。通过对不同机器人平台的广泛实验，我们发现任务多样性比每个任务的演示数量更为重要，有助于从多样的预训练任务转移到新的下游场景。我们还提出了一种分布去偏方法，以减少速度模糊，从而显著提高性能。整体而言，这些发现为有效扩展机器人操作数据集提供了新的视角和实用指导。'}}}, {'id': 'https://huggingface.co/papers/2507.04569', 'title': 'Nile-Chat: Egyptian Language Models for Arabic and Latin Scripts', 'url': 'https://huggingface.co/papers/2507.04569', 'abstract': 'Nile-Chat models, using Branch-Train-MiX strategy, outperform existing multilingual and Arabic LLMs on Egyptian dialect benchmarks in both Arabic and Latin scripts.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce Nile-Chat-4B, 3x4B-A6B, and 12B, a collection of LLMs for Egyptian dialect, uniquely designed to understand and generate texts written in both Arabic and Latin scripts. Specifically, with Nile-Chat-3x4B-A6B, we introduce a novel language adaptation approach by leveraging the Branch-Train-MiX strategy to merge script-specialized experts, into a single MoE model. Our Nile-Chat models significantly outperform leading multilingual and Arabic LLMs, such as LLaMa, Jais, and ALLaM, on our newly introduced Egyptian evaluation benchmarks, which span both understanding and generative tasks. Notably, our 12B model yields a 14.4% performance gain over Qwen2.5-14B-Instruct on Latin-script benchmarks. All our resources are publicly available. We believe this work presents a comprehensive methodology for adapting LLMs to dual-script languages, addressing an often overlooked aspect in modern LLM development.', 'score': 15, 'issue_id': 4722, 'pub_date': '2025-07-06', 'pub_date_card': {'ru': '6 июля', 'en': 'July 6', 'zh': '7月6日'}, 'hash': '40595bd58ae7eb1b', 'authors': ['Guokan Shang', 'Hadi Abdine', 'Ahmad Chamma', 'Amr Mohamed', 'Mohamed Anwar', 'Abdelaziz Bounhar', 'Omar El Herraoui', 'Preslav Nakov', 'Michalis Vazirgiannis', 'Eric Xing'], 'affiliations': ['Ecole Polytechnique', 'MBZUAI'], 'pdf_title_img': 'assets/pdf/title_img/2507.04569.jpg', 'data': {'categories': ['#dataset', '#open_source', '#multilingual', '#training', '#low_resource'], 'emoji': '🇪🇬', 'ru': {'title': 'Nile-Chat: прорыв в обработке египетского диалекта с двойной системой письма', 'desc': 'Исследователи представили серию моделей Nile-Chat для египетского диалекта, способных работать как с арабской, так и с латинской письменностью. Они разработали новый подход к адаптации языковых моделей, названный Branch-Train-MiX, который объединяет специализированные по письменности экспертные модели в единую модель смеси экспертов (MoE). Модели Nile-Chat значительно превосходят существующие многоязычные и арабские языковые модели на новых бенчмарках для египетского диалекта. Авторы считают, что их работа предлагает комплексную методологию адаптации больших языковых моделей к языкам с двойной системой письма.'}, 'en': {'title': 'Nile-Chat: Bridging Scripts for Egyptian Dialect Mastery', 'desc': 'The paper presents Nile-Chat, a series of large language models (LLMs) specifically designed for the Egyptian dialect, capable of processing both Arabic and Latin scripts. It introduces the Branch-Train-MiX strategy, which combines specialized models into a single mixture of experts (MoE) framework, enhancing language adaptation. The Nile-Chat models demonstrate superior performance on newly established benchmarks compared to existing multilingual and Arabic LLMs, achieving significant improvements in both understanding and generation tasks. This work highlights a novel approach to adapting LLMs for dual-script languages, filling a gap in current LLM research.'}, 'zh': {'title': 'Nile-Chat：双脚本语言的突破性适应', 'desc': 'Nile-Chat模型采用了Branch-Train-MiX策略，在埃及方言基准测试中，超越了现有的多语言和阿拉伯大型语言模型（LLMs）。我们推出了Nile-Chat-4B、3x4B-A6B和12B，这些模型专门设计用于理解和生成阿拉伯和拉丁文书写的文本。特别是Nile-Chat-3x4B-A6B，通过合并脚本专门化的专家，提出了一种新颖的语言适应方法，形成了一个单一的混合专家（MoE）模型。我们的模型在理解和生成任务上显著优于领先的多语言和阿拉伯LLMs，展示了如何将LLMs适应双脚本语言的全面方法。'}}}, {'id': 'https://huggingface.co/papers/2507.06138', 'title': 'Coding Triangle: How Does Large Language Model Understand Code?', 'url': 'https://huggingface.co/papers/2507.06138', 'abstract': 'The Code Triangle framework evaluates large language models across editorial analysis, code implementation, and test case generation, revealing limitations in diversity and robustness compared to human programmers and suggesting enhancements through human-generated content and model mixtures.  \t\t\t\t\tAI-generated summary \t\t\t\t Large language models (LLMs) have achieved remarkable progress in code generation, yet their true programming competence remains underexplored. We introduce the Code Triangle framework, which systematically evaluates LLMs across three fundamental dimensions: editorial analysis, code implementation, and test case generation. Through extensive experiments on competitive programming benchmarks, we reveal that while LLMs can form a self-consistent system across these dimensions, their solutions often lack the diversity and robustness of human programmers. We identify a significant distribution shift between model cognition and human expertise, with model errors tending to cluster due to training data biases and limited reasoning transfer. Our study demonstrates that incorporating human-generated editorials, solutions, and diverse test cases, as well as leveraging model mixtures, can substantially enhance both the performance and robustness of LLMs. Furthermore, we reveal both the consistency and inconsistency in the cognition of LLMs that may facilitate self-reflection and self-improvement, providing a potential direction for developing more powerful coding models.', 'score': 14, 'issue_id': 4716, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '1eb6710e161b9c74', 'authors': ['Taolin Zhang', 'Zihan Ma', 'Maosong Cao', 'Junnan Liu', 'Songyang Zhang', 'Kai Chen'], 'affiliations': ['Shanghai AI Laboratory', 'Tsinghua University', 'Xian Jiaotong University'], 'pdf_title_img': 'assets/pdf/title_img/2507.06138.jpg', 'data': {'categories': ['#plp', '#reasoning', '#optimization', '#training', '#benchmark'], 'emoji': '🔺', 'ru': {'title': 'Треугольник кода: новый взгляд на оценку языковых моделей в программировании', 'desc': 'Исследователи представили фреймворк Code Triangle для оценки больших языковых моделей в программировании. Фреймворк анализирует три аспекта: редакционный анализ, реализацию кода и генерацию тестовых случаев. Эксперименты показали, что решения языковых моделей часто уступают решениям человека-программиста в разнообразии и надежности. Авторы предлагают улучшить модели, используя контент, созданный людьми, и комбинируя различные модели.'}, 'en': {'title': 'Enhancing LLMs: Bridging the Gap with Human Insight', 'desc': 'The Code Triangle framework assesses large language models (LLMs) by examining their performance in three key areas: editorial analysis, code implementation, and test case generation. The study finds that while LLMs can create coherent outputs, they often lack the diversity and robustness seen in human programming. It highlights a gap between how models understand coding tasks and the expertise of human programmers, primarily due to biases in training data. The paper suggests that integrating human-generated content and using a mix of models can significantly improve the capabilities and reliability of LLMs in coding tasks.'}, 'zh': {'title': '提升大型语言模型的编码能力', 'desc': '本文介绍了Code Triangle框架，用于评估大型语言模型（LLMs）在编辑分析、代码实现和测试用例生成三个方面的表现。研究发现，尽管LLMs在这些维度上能够形成自洽的系统，但其解决方案的多样性和鲁棒性往往不及人类程序员。我们指出模型认知与人类专业知识之间存在显著的分布差异，模型错误往往因训练数据偏差和有限的推理转移而聚集。通过引入人类生成的内容和模型混合，能够显著提升LLMs的性能和鲁棒性，为开发更强大的编码模型提供了潜在方向。'}}}, {'id': 'https://huggingface.co/papers/2507.05791', 'title': 'GTA1: GUI Test-time Scaling Agent', 'url': 'https://huggingface.co/papers/2507.05791', 'abstract': 'GTA1 addresses task planning ambiguity and visual grounding in GUI interactions using test-time scaling and reinforcement learning, achieving state-of-the-art performance across benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Graphical user interface (GUI) agents autonomously operate across platforms (e.g., Linux) to complete tasks by interacting with visual elements. Specifically, a user instruction is decomposed into a sequence of action proposals, each corresponding to an interaction with the GUI. After each action, the agent observes the updated GUI environment to plan the next step. However, two main challenges arise: i) resolving ambiguity in task planning (i.e., the action proposal sequence), where selecting an appropriate plan is non-trivial, as many valid ones may exist; ii) accurately grounding actions in complex and high-resolution interfaces, i.e., precisely interacting with visual targets.   This paper investigates the two aforementioned challenges with our GUI Test-time Scaling Agent, namely GTA1. First, to select the most appropriate action proposal, we introduce a test-time scaling method. At each step, we sample multiple candidate action proposals and leverage a judge model to evaluate and select the most suitable one. It trades off computation for better decision quality by concurrent sampling, shortening task execution steps, and improving overall performance. Second, we propose a model that achieves improved accuracy when grounding the selected action proposal to its corresponding visual elements. Our key insight is that reinforcement learning (RL) facilitates visual grounding through inherent objective alignments, rewarding successful clicks on interface elements.   Experimentally, our method establishes state-of-the-art performance across diverse benchmarks. For example, GTA1-7B achieves 50.1%, 92.4%, and 67.7% accuracies on Screenspot-Pro, Screenspot-V2, and OSWorld-G, respectively. When paired with a planner applying our test-time scaling strategy, it exhibits state-of-the-art agentic performance (e.g., 45.2% task success rate on OSWorld). We open-source our code and models here.', 'score': 14, 'issue_id': 4715, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': 'e20f930b7b567221', 'authors': ['Yan Yang', 'Dongxu Li', 'Yutong Dai', 'Yuhao Yang', 'Ziyang Luo', 'Zirui Zhao', 'Zhiyuan Hu', 'Junzhe Huang', 'Amrita Saha', 'Zeyuan Chen', 'Ran Xu', 'Liyuan Pan', 'Caiming Xiong', 'Junnan Li'], 'affiliations': ['Salesforce AI Research', 'The Australian National University', 'University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2507.05791.jpg', 'data': {'categories': ['#benchmark', '#optimization', '#games', '#rl', '#agents', '#open_source'], 'emoji': '🖥️', 'ru': {'title': 'GTA1: Умный агент для автономного управления графическими интерфейсами', 'desc': 'Статья представляет GTA1 - агента для взаимодействия с графическим интерфейсом, решающего проблемы планирования задач и визуальной привязки действий. Метод использует масштабирование во время тестирования для выбора оптимальных действий и обучение с подкреплением для точного взаимодействия с визуальными элементами. GTA1 достигает наилучших результатов на нескольких бенчмарках, значительно улучшая точность и успешность выполнения задач. Авторы открыли исходный код и модели для дальнейших исследований.'}, 'en': {'title': 'GTA1: Mastering GUI Interactions with Smart Planning and Learning', 'desc': 'The paper presents GTA1, a novel approach to enhance task planning and visual grounding in graphical user interface (GUI) interactions using reinforcement learning. It addresses the challenges of ambiguity in action proposals by employing a test-time scaling method that samples multiple candidates and selects the best one through a judge model. Additionally, it improves the accuracy of grounding actions to visual elements by leveraging reinforcement learning, which aligns objectives with successful interactions. The results demonstrate that GTA1 achieves state-of-the-art performance on various benchmarks, showcasing its effectiveness in autonomous GUI task execution.'}, 'zh': {'title': 'GTA1：提升GUI交互的智能决策与视觉定位', 'desc': 'GTA1是一种图形用户界面（GUI）代理，旨在解决任务规划中的模糊性和视觉定位问题。它通过测试时缩放和强化学习的方法，优化了在复杂界面中与视觉元素的交互。该方法通过采样多个候选动作提案，并利用评判模型选择最合适的提案，从而提高决策质量。实验结果表明，GTA1在多个基准测试中达到了最先进的性能，展示了其在任务成功率和准确性方面的优势。'}}}, {'id': 'https://huggingface.co/papers/2507.05169', 'title': 'Critiques of World Models', 'url': 'https://huggingface.co/papers/2507.05169', 'abstract': 'World Model, the supposed algorithmic surrogate of the real-world environment which biological agents experience with and act upon, has been an emerging topic in recent years because of the rising needs to develop virtual agents with artificial (general) intelligence. There has been much debate on what a world model really is, how to build it, how to use it, and how to evaluate it. In this essay, starting from the imagination in the famed Sci-Fi classic Dune, and drawing inspiration from the concept of "hypothetical thinking" in psychology literature, we offer critiques of several schools of thoughts on world modeling, and argue the primary goal of a world model to be simulating all actionable possibilities of the real world for purposeful reasoning and acting. Building on the critiques, we propose a new architecture for a general-purpose world model, based on hierarchical, multi-level, and mixed continuous/discrete representations, and a generative and self-supervision learning framework, with an outlook of a Physical, Agentic, and Nested (PAN) AGI system enabled by such a model.', 'score': 12, 'issue_id': 4729, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': 'a6ec55259ef20f8f', 'authors': ['Eric Xing', 'Mingkai Deng', 'Jinyu Hou', 'Zhiting Hu'], 'affiliations': ['Halıcıoglu Data Science Institute, UC San Diego', 'Institute of Foundation Models, Mohamed bin Zayed University of Artificial Intelligence', 'School of Computer Science, Carnegie Mellon University'], 'pdf_title_img': 'assets/pdf/title_img/2507.05169.jpg', 'data': {'categories': ['#reasoning', '#architecture', '#agents', '#agi'], 'emoji': '🌍', 'ru': {'title': 'Новый взгляд на мировые модели для ИИ общего назначения', 'desc': 'Статья посвящена концепции Мировой Модели в контексте искусственного интеллекта. Авторы предлагают новую архитектуру для универсальной мировой модели, основанную на иерархических, многоуровневых и смешанных непрерывно-дискретных представлениях. Они утверждают, что основная цель мировой модели - моделирование всех возможных действий в реальном мире для целенаправленных рассуждений и действий. Статья также представляет генеративную систему обучения с самоконтролем и перспективу создания физической, агентной и вложенной (PAN) системы ИИ общего назначения.'}, 'en': {'title': 'Building Smarter Agents with Advanced World Models', 'desc': "This paper discusses the concept of a 'world model', which is a representation of the environment that artificial agents use to understand and interact with the world. It critiques existing approaches to building and evaluating these models, emphasizing the need for a system that can simulate all possible actions in a realistic manner. The authors propose a new architecture that combines hierarchical structures and mixed representations to enhance the model's capabilities. Ultimately, they envision a Physical, Agentic, and Nested (PAN) AGI system that leverages this advanced world model for better reasoning and decision-making."}, 'zh': {'title': '构建智能代理的世界模型', 'desc': '世界模型是生物体在真实环境中体验和行动的算法替代品，近年来因开发具有人工智能的虚拟代理的需求而受到关注。本文探讨了世界模型的定义、构建、使用和评估等问题，并批评了几种关于世界建模的理论。我们认为，世界模型的主要目标是模拟现实世界中所有可操作的可能性，以便进行有目的的推理和行动。基于这些批评，我们提出了一种新的通用世界模型架构，采用分层、多级和混合连续/离散表示，并结合生成和自我监督学习框架，展望基于此模型的物理、代理和嵌套的人工通用智能系统。'}}}, {'id': 'https://huggingface.co/papers/2507.06223', 'title': 'Efficiency-Effectiveness Reranking FLOPs for LLM-based Rerankers', 'url': 'https://huggingface.co/papers/2507.06223', 'abstract': 'E\\textsuperscript{2}R-FLOPs evaluates LLM-based rerankers by measuring relevance and throughput per PetaFLOP, providing a hardware-agnostic metric for efficiency and effectiveness.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have recently been applied to reranking tasks in information retrieval, achieving strong performance. However, their high computational demands often hinder practical deployment. Existing studies evaluate the efficiency of LLM-based rerankers using proxy metrics such as latency, the number of forward passes, input tokens, and output tokens. However, these metrics depend on hardware and running-time choices (\\eg parallel or not, batch size, etc), and often fail to account for model size, making it difficult to interpret and obscuring the evaluation of the efficiency-effectiveness tradeoff. To address this issue, we propose E2R-FLOPs, for LLM-based rerankers: ranking metrics per PetaFLOP (RPP) for relevance per compute and queries per PetaFLOP (QPP) for hardware-agnostic throughput. Companied with the new metrics, an interpretable FLOPs estimator is built to estimate the FLOPs of an LLM-based reranker even without running any experiments. Based on the proposed metrics, we conduct comprehensive experiments to evaluate a wide range of LLM-based rerankers with different architecture, studying the efficiency-effectiveness trade-off and bringing this issue to the attention of the research community.', 'score': 11, 'issue_id': 4715, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '6073d3ee8c07d225', 'authors': ['Zhiyuan Peng', 'Ting-ruen Wei', 'Tingyu Song', 'Yilun Zhao', 'Yi Fang'], 'affiliations': ['Independent Researcher, Beijing, China', 'Santa Clara University, Santa Clara, CA', 'Yale University, New Haven, CT'], 'pdf_title_img': 'assets/pdf/title_img/2507.06223.jpg', 'data': {'categories': ['#benchmark', '#optimization', '#interpretability', '#architecture', '#inference'], 'emoji': '🔬', 'ru': {'title': 'E2R-FLOPs: Новый взгляд на эффективность LLM-ранжировщиков', 'desc': 'Статья представляет новую метрику E2R-FLOPs для оценки эффективности ранжировщиков на основе больших языковых моделей (LLM). Метрика измеряет релевантность и пропускную способность на ПетаФЛОП, предоставляя аппаратно-независимый способ оценки эффективности и результативности. Авторы разработали интерпретируемый оценщик ФЛОП для расчета вычислительной сложности LLM-ранжировщиков без необходимости проведения экспериментов. На основе предложенной метрики были проведены комплексные эксперименты для оценки различных LLM-ранжировщиков, изучая компромисс между эффективностью и результативностью.'}, 'en': {'title': 'E2R-FLOPs: A New Standard for Evaluating LLM Efficiency', 'desc': 'The paper introduces E2R-FLOPs, a new metric for evaluating the efficiency of Large Language Model (LLM)-based rerankers in information retrieval. It measures relevance and throughput per PetaFLOP, providing a hardware-agnostic way to assess performance. Traditional metrics like latency and token counts are limited by hardware dependencies and do not adequately reflect model size, making comparisons challenging. By using E2R-FLOPs, researchers can better understand the trade-offs between efficiency and effectiveness in LLM-based reranking tasks.'}, 'zh': {'title': 'E2R-FLOPs：高效评估LLM重排序器的工具', 'desc': 'E2R-FLOPs 是一种评估基于大型语言模型（LLM）的重排序器的新方法，通过每 PetaFLOP 的相关性和吞吐量来衡量其效率和有效性。这种方法解决了现有评估指标依赖于硬件和运行时间选择的问题，使得评估更加通用和易于理解。我们还构建了一个可解释的 FLOPs 估算器，可以在不进行实验的情况下估算 LLM 重排序器的 FLOPs。通过这些新指标，我们对多种不同架构的 LLM 重排序器进行了全面实验，研究了效率与有效性之间的权衡。'}}}, {'id': 'https://huggingface.co/papers/2507.05101', 'title': 'PRING: Rethinking Protein-Protein Interaction Prediction from Pairs to\n  Graphs', 'url': 'https://huggingface.co/papers/2507.05101', 'abstract': "Deep learning-based computational methods have achieved promising results in predicting protein-protein interactions (PPIs). However, existing benchmarks predominantly focus on isolated pairwise evaluations, overlooking a model's capability to reconstruct biologically meaningful PPI networks, which is crucial for biology research. To address this gap, we introduce PRING, the first comprehensive benchmark that evaluates protein-protein interaction prediction from a graph-level perspective. PRING curates a high-quality, multi-species PPI network dataset comprising 21,484 proteins and 186,818 interactions, with well-designed strategies to address both data redundancy and leakage. Building on this golden-standard dataset, we establish two complementary evaluation paradigms: (1) topology-oriented tasks, which assess intra and cross-species PPI network construction, and (2) function-oriented tasks, including protein complex pathway prediction, GO module analysis, and essential protein justification. These evaluations not only reflect the model's capability to understand the network topology but also facilitate protein function annotation, biological module detection, and even disease mechanism analysis. Extensive experiments on four representative model categories, consisting of sequence similarity-based, naive sequence-based, protein language model-based, and structure-based approaches, demonstrate that current PPI models have potential limitations in recovering both structural and functional properties of PPI networks, highlighting the gap in supporting real-world biological applications. We believe PRING provides a reliable platform to guide the development of more effective PPI prediction models for the community. The dataset and source code of PRING are available at https://github.com/SophieSarceau/PRING.", 'score': 10, 'issue_id': 4715, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': 'c987593bed9476c8', 'authors': ['Xinzhe Zheng', 'Hao Du', 'Fanding Xu', 'Jinzhe Li', 'Zhiyuan Liu', 'Wenkang Wang', 'Tao Chen', 'Wanli Ouyang', 'Stan Z. Li', 'Yan Lu', 'Nanqing Dong', 'Yang Zhang'], 'affiliations': ['Fudan University', 'National University of Singapore', 'Shanghai Artificial Intelligence Laboratory', 'Shanghai Innovation Institute', 'The Chinese University of Hong Kong', 'Westlake University', 'Xian Jiaotong University'], 'pdf_title_img': 'assets/pdf/title_img/2507.05101.jpg', 'data': {'categories': ['#benchmark', '#data', '#open_source', '#dataset', '#graphs', '#leakage'], 'emoji': '🧬', 'ru': {'title': 'PRING: новый стандарт оценки предсказания белковых взаимодействий на уровне графов', 'desc': 'Статья представляет PRING - новый комплексный бенчмарк для оценки предсказания взаимодействий белок-белок (PPI) с точки зрения графов. PRING включает высококачественный набор данных PPI-сетей для нескольких видов, содержащий 21,484 белка и 186,818 взаимодействий. Бенчмарк предлагает две парадигмы оценки: задачи, ориентированные на топологию сети, и задачи, ориентированные на функции белков. Эксперименты показали, что современные модели PPI имеют ограничения в восстановлении структурных и функциональных свойств PPI-сетей.'}, 'en': {'title': 'Revolutionizing PPI Prediction with PRING: A Graph-Level Benchmark', 'desc': 'This paper introduces PRING, a new benchmark for evaluating protein-protein interaction (PPI) prediction models from a graph-level perspective. Unlike previous benchmarks that focused on pairwise evaluations, PRING assesses the ability of models to reconstruct meaningful PPI networks, which is essential for biological research. The benchmark includes a comprehensive dataset of 21,484 proteins and 186,818 interactions, addressing issues like data redundancy and leakage. The evaluation framework consists of topology-oriented and function-oriented tasks, revealing limitations in current PPI models and guiding future improvements in PPI prediction.'}, 'zh': {'title': 'PRING：蛋白质相互作用预测的新基准', 'desc': '本论文介绍了一种新的基准测试工具PRING，用于评估蛋白质-蛋白质相互作用（PPI）预测模型的能力。与以往的评估方法不同，PRING从图级别的角度出发，关注模型重建生物学意义的PPI网络。该基准数据集包含21,484个蛋白质和186,818个相互作用，旨在解决数据冗余和泄漏问题。通过拓扑导向和功能导向的评估任务，PRING帮助研究人员更好地理解PPI网络的结构和功能。'}}}, {'id': 'https://huggingface.co/papers/2507.03698', 'title': 'SAMed-2: Selective Memory Enhanced Medical Segment Anything Model', 'url': 'https://huggingface.co/papers/2507.03698', 'abstract': 'SAMed-2, an adaptation of SAM-2 for medical image segmentation, incorporates a temporal adapter and confidence-driven memory to improve performance across diverse medical datasets and tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent "segment anything" efforts show promise by learning from large-scale data, but adapting such models directly to medical images remains challenging due to the complexity of medical data, noisy annotations, and continual learning requirements across diverse modalities and anatomical structures. In this work, we propose SAMed-2, a new foundation model for medical image segmentation built upon the SAM-2 architecture. Specifically, we introduce a temporal adapter into the image encoder to capture image correlations and a confidence-driven memory mechanism to store high-certainty features for later retrieval. This memory-based strategy counters the pervasive noise in large-scale medical datasets and mitigates catastrophic forgetting when encountering new tasks or modalities. To train and evaluate SAMed-2, we curate MedBank-100k, a comprehensive dataset spanning seven imaging modalities and 21 medical segmentation tasks. Our experiments on both internal benchmarks and 10 external datasets demonstrate superior performance over state-of-the-art baselines in multi-task scenarios. The code is available at: https://github.com/ZhilingYan/Medical-SAM-Bench.', 'score': 10, 'issue_id': 4715, 'pub_date': '2025-07-04', 'pub_date_card': {'ru': '4 июля', 'en': 'July 4', 'zh': '7月4日'}, 'hash': '6eb9d67bc0e6c585', 'authors': ['Zhiling Yan', 'Sifan Song', 'Dingjie Song', 'Yiwei Li', 'Rong Zhou', 'Weixiang Sun', 'Zhennong Chen', 'Sekeun Kim', 'Hui Ren', 'Tianming Liu', 'Quanzheng Li', 'Xiang Li', 'Lifang He', 'Lichao Sun'], 'affiliations': ['Lehigh University, Bethlehem, PA, USA', 'Massachusetts General Hospital and Harvard Medical School, Boston, MA, USA', 'University of Georgia, Athens, GA, USA', 'University of Notre Dame, Notre Dame, IN, USA'], 'pdf_title_img': 'assets/pdf/title_img/2507.03698.jpg', 'data': {'categories': ['#cv', '#benchmark', '#healthcare', '#data', '#dataset', '#training'], 'emoji': '🏥', 'ru': {'title': 'SAMed-2: Универсальный сегментатор для медицинских изображений', 'desc': 'SAMed-2 - это новая модель для сегментации медицинских изображений, основанная на архитектуре SAM-2. Она включает в себя временной адаптер для захвата корреляций между изображениями и механизм памяти, управляемый уверенностью, для хранения высокодостоверных признаков. Модель обучена на наборе данных MedBank-100k, охватывающем 7 модальностей визуализации и 21 задачу медицинской сегментации. Эксперименты показали превосходную производительность SAMed-2 по сравнению с современными базовыми моделями в многозадачных сценариях.'}, 'en': {'title': 'Enhancing Medical Image Segmentation with SAMed-2', 'desc': 'SAMed-2 is a new model designed for medical image segmentation, enhancing the original SAM-2 framework. It introduces a temporal adapter to the image encoder, which helps in understanding relationships between images over time. Additionally, a confidence-driven memory mechanism is implemented to retain important features, addressing issues like noisy data and preventing loss of knowledge when learning new tasks. The model is trained on a large dataset called MedBank-100k, showing improved performance in various medical imaging tasks compared to existing methods.'}, 'zh': {'title': '医学图像分割的新突破：SAMed-2', 'desc': 'SAMed-2是针对医学图像分割的SAM-2模型的改进版本。它引入了时间适配器和基于信心的记忆机制，以提高在不同医学数据集和任务中的表现。时间适配器帮助捕捉图像之间的相关性，而记忆机制则存储高置信度特征，以应对医学数据中的噪声和避免灾难性遗忘。通过构建MedBank-100k数据集并进行实验，SAMed-2在多任务场景中表现优于现有的最先进模型。'}}}, {'id': 'https://huggingface.co/papers/2507.05963', 'title': 'Tora2: Motion and Appearance Customized Diffusion Transformer for\n  Multi-Entity Video Generation', 'url': 'https://huggingface.co/papers/2507.05963', 'abstract': 'Tora2 enhances motion-guided video generation by introducing a decoupled personalization extractor, gated self-attention mechanism, and contrastive loss, enabling simultaneous multi-entity customization and advanced motion control.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in diffusion transformer models for motion-guided video generation, such as Tora, have shown significant progress. In this paper, we present Tora2, an enhanced version of Tora, which introduces several design improvements to expand its capabilities in both appearance and motion customization. Specifically, we introduce a decoupled personalization extractor that generates comprehensive personalization embeddings for multiple open-set entities, better preserving fine-grained visual details compared to previous methods. Building on this, we design a gated self-attention mechanism to integrate trajectory, textual description, and visual information for each entity. This innovation significantly reduces misalignment in multimodal conditioning during training. Moreover, we introduce a contrastive loss that jointly optimizes trajectory dynamics and entity consistency through explicit mapping between motion and personalization embeddings. Tora2 is, to our best knowledge, the first method to achieve simultaneous multi-entity customization of appearance and motion for video generation. Experimental results demonstrate that Tora2 achieves competitive performance with state-of-the-art customization methods while providing advanced motion control capabilities, which marks a critical advancement in multi-condition video generation. Project page: https://github.com/alibaba/Tora .', 'score': 8, 'issue_id': 4716, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '0230e47a99a4f7d8', 'authors': ['Zhenghao Zhang', 'Junchao Liao', 'Xiangyu Meng', 'Long Qin', 'Weizhi Wang'], 'affiliations': ['Alibaba Group China'], 'pdf_title_img': 'assets/pdf/title_img/2507.05963.jpg', 'data': {'categories': ['#video', '#diffusion', '#multimodal'], 'emoji': '🎬', 'ru': {'title': 'Tora2: Революция в персонализированной генерации видео с управлением движением', 'desc': 'Tora2 - это усовершенствованная версия модели Tora для генерации видео на основе движения. Она вводит несколько улучшений, включая отдельный экстрактор персонализации для нескольких сущностей, механизм гейтированного самовнимания и контрастную функцию потерь. Эти инновации позволяют одновременно настраивать внешний вид и движение нескольких объектов в генерируемом видео. Tora2 демонстрирует конкурентоспособные результаты по сравнению с современными методами кастомизации, обеспечивая при этом расширенные возможности контроля движения.'}, 'en': {'title': 'Tora2: Revolutionizing Multi-Entity Video Customization', 'desc': 'Tora2 is an advanced model for generating videos that can be customized for multiple entities at the same time. It uses a decoupled personalization extractor to create detailed embeddings that capture the unique features of each entity. The model also incorporates a gated self-attention mechanism to effectively combine different types of information, such as motion and text descriptions, which helps improve the alignment during training. Additionally, Tora2 employs a contrastive loss to ensure that the generated motion is consistent with the personalized features, making it a significant step forward in motion-guided video generation.'}, 'zh': {'title': 'Tora2：多实体个性化与运动控制的突破', 'desc': 'Tora2 是一种增强的运动引导视频生成模型，采用了分离的个性化提取器和门控自注意力机制。它能够同时对多个实体进行个性化定制，并实现更高级的运动控制。通过引入对比损失，Tora2 优化了运动动态和实体一致性，提升了多模态条件下的对齐效果。实验结果表明，Tora2 在个性化定制方面的表现与最先进的方法相当，同时提供了更强的运动控制能力。'}}}, {'id': 'https://huggingface.co/papers/2507.04723', 'title': 'LOOM-Scope: a comprehensive and efficient LOng-cOntext Model evaluation\n  framework', 'url': 'https://huggingface.co/papers/2507.04723', 'abstract': "Long-context processing has become a fundamental capability for large language models~(LLMs). To assess model's long-context performance, numerous long-context evaluation benchmarks have been proposed. However, variations in evaluation settings across these benchmarks lead to inconsistent results, making it difficult to draw reliable comparisons. Besides, the high computational cost of long-context evaluation poses a significant barrier for the community to conduct comprehensive assessments of long-context models. In this paper, we propose LOOM-Scope, a comprehensive and efficient framework for long-context evaluation. LOOM-Scope standardizes evaluation settings across diverse benchmarks, supports deployment of efficient long-context inference acceleration methods, and introduces a holistic yet lightweight benchmark suite to evaluate models comprehensively. Homepage: https://loomscope.github.io", 'score': 8, 'issue_id': 4718, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': '14c1c5cb4e9b0c49', 'authors': ['Zecheng Tang', 'Haitian Wang', 'Quantong Qiu', 'Baibei Ji', 'Ruoxi Sun', 'Keyan Zhou', 'Juntao Li', 'Min Zhang'], 'affiliations': ['Key Laboratory of Data Intelligence and Advanced Computing, Soochow University', 'Soochow University, China'], 'pdf_title_img': 'assets/pdf/title_img/2507.04723.jpg', 'data': {'categories': ['#benchmark', '#long_context', '#inference'], 'emoji': '🔬', 'ru': {'title': 'LOOM-Scope: стандартизация и оптимизация оценки языковых моделей для длинных контекстов', 'desc': 'LOOM-Scope - это комплексная и эффективная система для оценки способностей языковых моделей обрабатывать длинные контексты. Она стандартизирует настройки оценки для различных бенчмарков, что позволяет проводить более надежные сравнения моделей. LOOM-Scope поддерживает внедрение методов ускорения вывода для длинных контекстов, снижая вычислительные затраты. Кроме того, система предлагает целостный, но легковесный набор бенчмарков для всесторонней оценки языковых моделей.'}, 'en': {'title': 'Standardizing Long-Context Evaluation for Better Comparisons', 'desc': 'This paper introduces LOOM-Scope, a new framework designed to improve the evaluation of long-context performance in large language models (LLMs). It addresses the inconsistencies in results caused by varying evaluation settings across existing benchmarks. LOOM-Scope not only standardizes these settings but also incorporates efficient inference acceleration methods to reduce computational costs. Additionally, it provides a lightweight benchmark suite that allows for comprehensive assessments of long-context models, facilitating better comparisons within the research community.'}, 'zh': {'title': 'LOOM-Scope：高效的长文本评估框架', 'desc': '长文本处理已成为大型语言模型（LLMs）的基本能力。为了评估模型在长文本上的表现，提出了许多长文本评估基准。然而，这些基准的评估设置差异导致结果不一致，使得可靠比较变得困难。此外，长文本评估的高计算成本也成为社区进行全面评估的重大障碍。本文提出了LOOM-Scope，一个全面且高效的长文本评估框架，标准化了不同基准的评估设置，并支持高效的长文本推理加速方法。'}}}, {'id': 'https://huggingface.co/papers/2507.06204', 'title': 'Differential Mamba', 'url': 'https://huggingface.co/papers/2507.06204', 'abstract': 'A novel differential mechanism for Mamba, a selective state-space layer architecture, improves retrieval capabilities and performance by addressing overallocation issues.  \t\t\t\t\tAI-generated summary \t\t\t\t Sequence models like Transformers and RNNs often overallocate attention to irrelevant context, leading to noisy intermediate representations. This degrades LLM capabilities by promoting hallucinations, weakening long-range and retrieval abilities, and reducing robustness. Recent work has shown that differential design can mitigate this issue in Transformers, improving their effectiveness across various applications. In this paper, we explore whether these techniques, originally developed for Transformers, can be applied to Mamba, a recent architecture based on selective state-space layers that achieves Transformer-level performance with greater efficiency. We show that a naive adaptation of differential design to Mamba is insufficient and requires careful architectural modifications. To address this, we introduce a novel differential mechanism for Mamba, empirically validated on language modeling benchmarks, demonstrating improved retrieval capabilities and superior performance over vanilla Mamba. Finally, we conduct extensive ablation studies and empirical analyses to justify our design choices and provide evidence that our approach effectively mitigates the overallocation problem in Mamba-based models. Our code is publicly available.', 'score': 7, 'issue_id': 4720, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '69109b333dac5628', 'authors': ['Nadav Schneider', 'Itamar Zimerman', 'Eliya Nachmani'], 'affiliations': ['Ben-Gurion University', 'IBM Research', 'School of Electrical and Computer Engineering, Ben Gurion University of the Negev', 'Tel-Aviv University'], 'pdf_title_img': 'assets/pdf/title_img/2507.06204.jpg', 'data': {'categories': ['#open_source', '#benchmark', '#optimization', '#long_context', '#hallucinations', '#architecture'], 'emoji': '🐍', 'ru': {'title': 'Дифференциальная Mamba: точнее, эффективнее, умнее', 'desc': 'Статья представляет новый дифференциальный механизм для архитектуры Mamba, основанной на селективных слоях пространства состояний. Этот механизм решает проблему избыточного выделения внимания нерелевантному контексту, характерную для моделей последовательностей. Авторы демонстрируют улучшение способностей извлечения информации и общей производительности модели по сравнению с ванильной версией Mamba. Проведены обширные эксперименты и абляционные исследования для обоснования предложенного подхода.'}, 'en': {'title': 'Enhancing Mamba: A New Approach to Mitigate Overallocation in Language Models', 'desc': 'This paper presents a new differential mechanism for the Mamba architecture, which uses selective state-space layers to enhance performance in language modeling. The authors identify that traditional sequence models, like Transformers, often focus too much on irrelevant information, leading to poor results. By adapting differential design techniques to Mamba, they show that careful modifications can significantly improve retrieval capabilities and overall performance. The results from their experiments indicate that this new approach effectively reduces the overallocation problem, making Mamba models more robust and efficient.'}, 'zh': {'title': '提升Mamba架构性能的新机制', 'desc': '本文提出了一种新颖的差分机制，用于Mamba架构，这是一种选择性状态空间层的设计，旨在改善检索能力和性能。传统的序列模型如Transformer和RNN常常对无关上下文过度关注，导致中间表示噪声增多，从而影响大语言模型的能力。我们发现，简单地将差分设计应用于Mamba并不足够，需要进行仔细的架构修改。通过实验证明，我们的新机制有效缓解了Mamba模型中的过度分配问题，提升了其检索能力和整体性能。'}}}, {'id': 'https://huggingface.co/papers/2507.05920', 'title': 'High-Resolution Visual Reasoning via Multi-Turn Grounding-Based\n  Reinforcement Learning', 'url': 'https://huggingface.co/papers/2507.05920', 'abstract': "MGPO, an end-to-end reinforcement learning framework, enhances large multi-modal models' ability to focus on key visual regions without requiring additional grounding annotations, improving performance on both in-distribution and out-of-distribution benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t State-of-the-art large multi-modal models (LMMs) face challenges when processing high-resolution images, as these inputs are converted into enormous visual tokens, many of which are irrelevant to the downstream task. In this paper, we propose Multi-turn Grounding-based Policy Optimization (MGPO), an end-to-end reinforcement learning (RL) framework that enables LMMs to iteratively focus on key visual regions by automatically cropping sub-images, based on model-predicted grounding coordinates within a multi-turn conversation framework. Compared to supervised fine-tuning (SFT), which requires costly additional grounding annotations, our approach highlights that LMMs can emerge robust grounding abilities during the RL training process, leveraging only a binary reward function derived from the correctness of the final answer. Additionally, we observe that LMMs struggle to autonomously trigger visual grounding during the rollout process. To address this cold start problem, we design a multi-turn conversational template and restrict policy loss computation to model outputs generated across multiple dialogue rounds, thereby promoting stable optimization. Extensive experiments demonstrate that, when trained on standard visual-question-short answering data without grounding annotations, MGPO effectively elicits stronger grounding capabilities compared to GRPO, leading to 5.4\\% improvement on in-distribution MME-Realworld and 5.2\\% improvement on the challenging out-of-distribution (OOD) V* Bench. Notably, MGPO post-training on Qwen2.5-VL-7B with 21K samples surpasses OpenAI's o1 and GPT-4o models on the OOD V* Bench. Codes are available at https://github.com/EvolvingLMMs-Lab/MGPO.", 'score': 7, 'issue_id': 4717, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': 'be1d59008c501b7d', 'authors': ['Xinyu Huang', 'Yuhao Dong', 'Weiwei Tian', 'Bo Li', 'Rui Feng', 'Ziwei Liu'], 'affiliations': ['Fudan University', 'S-Lab, Nanyang Technological University'], 'pdf_title_img': 'assets/pdf/title_img/2507.05920.jpg', 'data': {'categories': ['#optimization', '#multimodal', '#benchmark', '#rl', '#games'], 'emoji': '🔍', 'ru': {'title': 'Фокусировка внимания мультимодальных моделей без дополнительной разметки', 'desc': 'MGPO - это фреймворк обучения с подкреплением для улучшения способности мультимодальных моделей фокусироваться на ключевых визуальных областях. Он использует итеративное обрезание подизображений на основе предсказанных моделью координат в рамках многоэтапного диалога. MGPO не требует дополнительных аннотаций для привязки к изображению, что отличает его от обучения с учителем. Эксперименты показывают, что MGPO превосходит базовые модели на стандартных и out-of-distribution бенчмарках.'}, 'en': {'title': 'Empowering LMMs with Reinforcement Learning for Visual Grounding', 'desc': "The paper introduces MGPO, a novel reinforcement learning framework designed to enhance the performance of large multi-modal models (LMMs) by enabling them to focus on important visual areas without needing extra grounding annotations. MGPO uses a multi-turn conversational approach to iteratively crop sub-images based on predicted grounding coordinates, improving the model's ability to ground visual information effectively. Unlike traditional supervised fine-tuning methods, MGPO relies on a simple binary reward system derived from the accuracy of the final output, allowing LMMs to develop grounding skills during training. The results show significant improvements in both in-distribution and out-of-distribution benchmarks, demonstrating MGPO's effectiveness in enhancing visual grounding capabilities in LMMs."}, 'zh': {'title': 'MGPO：无需标注的强化学习聚焦关键视觉区域', 'desc': 'MGPO是一种端到端的强化学习框架，旨在提高大型多模态模型在处理高分辨率图像时的关键视觉区域聚焦能力，而无需额外的标注。该方法通过在多轮对话框架中自动裁剪子图像，利用模型预测的定位坐标，帮助模型逐步聚焦于重要区域。与传统的监督微调方法相比，MGPO仅依赖于最终答案的正确性来提供二元奖励，从而在训练过程中培养出更强的定位能力。实验结果表明，MGPO在没有标注的情况下，能够显著提升模型在标准视觉问答任务上的表现。'}}}, {'id': 'https://huggingface.co/papers/2507.05578', 'title': 'The Landscape of Memorization in LLMs: Mechanisms, Measurement, and\n  Mitigation', 'url': 'https://huggingface.co/papers/2507.05578', 'abstract': 'The paper reviews recent studies on memorization in Large Language Models, exploring factors that influence memorization, detection methodologies, and mitigation strategies, while addressing privacy and ethical implications.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have demonstrated remarkable capabilities across a wide range of tasks, yet they also exhibit memorization of their training data. This phenomenon raises critical questions about model behavior, privacy risks, and the boundary between learning and memorization. Addressing these concerns, this paper synthesizes recent studies and investigates the landscape of memorization, the factors influencing it, and methods for its detection and mitigation. We explore key drivers, including training data duplication, training dynamics, and fine-tuning procedures that influence data memorization. In addition, we examine methodologies such as prefix-based extraction, membership inference, and adversarial prompting, assessing their effectiveness in detecting and measuring memorized content. Beyond technical analysis, we also explore the broader implications of memorization, including the legal and ethical implications. Finally, we discuss mitigation strategies, including data cleaning, differential privacy, and post-training unlearning, while highlighting open challenges in balancing the minimization of harmful memorization with utility. This paper provides a comprehensive overview of the current state of research on LLM memorization across technical, privacy, and performance dimensions, identifying critical directions for future work.', 'score': 4, 'issue_id': 4715, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '9fd6f105854c8570', 'authors': ['Alexander Xiong', 'Xuandong Zhao', 'Aneesh Pappu', 'Dawn Song'], 'affiliations': ['Google DeepMind', 'University of California, Berkeley'], 'pdf_title_img': 'assets/pdf/title_img/2507.05578.jpg', 'data': {'categories': ['#healthcare', '#hallucinations', '#survey', '#data', '#training', '#ethics'], 'emoji': '🧠', 'ru': {'title': 'Запоминание в LLM: от технических аспектов до этических проблем', 'desc': 'Статья рассматривает недавние исследования запоминания в больших языковых моделях (LLM). Авторы изучают факторы, влияющие на запоминание, методологии его обнаружения и стратегии смягчения последствий. Рассматриваются такие аспекты, как дублирование обучающих данных, динамика обучения и процедуры тонкой настройки. Также обсуждаются правовые и этические последствия запоминания в LLM.'}, 'en': {'title': 'Understanding and Mitigating Memorization in Large Language Models', 'desc': 'This paper reviews how Large Language Models (LLMs) memorize information from their training data, which can lead to privacy concerns. It discusses factors that contribute to this memorization, such as data duplication and training methods. The paper also evaluates various techniques for detecting memorized data, like membership inference and adversarial prompting. Finally, it suggests strategies to reduce harmful memorization while maintaining model performance, highlighting the need for further research in this area.'}, 'zh': {'title': '大型语言模型的记忆现象与挑战', 'desc': '这篇论文回顾了关于大型语言模型（LLM）记忆现象的最新研究，探讨了影响记忆的因素、检测方法和缓解策略，同时关注隐私和伦理问题。研究表明，LLM在执行任务时会记住训练数据，这引发了关于模型行为和隐私风险的关键问题。论文分析了训练数据重复、训练动态和微调过程等关键驱动因素，并评估了前缀提取、成员推断和对抗性提示等检测方法的有效性。最后，论文讨论了数据清理、差分隐私和后训练遗忘等缓解策略，强调在减少有害记忆与保持模型效用之间的挑战。'}}}, {'id': 'https://huggingface.co/papers/2507.04610', 'title': 'any4: Learned 4-bit Numeric Representation for LLMs', 'url': 'https://huggingface.co/papers/2507.04610', 'abstract': 'any4 is a learned 4-bit weight quantization method for LLMs that achieves high accuracy without preprocessing and uses a GPU-efficient lookup table strategy.  \t\t\t\t\tAI-generated summary \t\t\t\t We present any4, a learned 4-bit weight quantization solution for large language models (LLMs) providing arbitrary numeric representations without requiring pre-processing of weights or activations. any4 yields higher accuracy compared to other related 4-bit numeric representation types: int4, fp4 and nf4, as evaluated on a range of model sizes, generations and families (Llama 2, Llama 3, Mistral and Mixtral). While any4 does not require preprocessing of weights or activations, it is also competitive with orthogonal techniques that require such preprocessing (e.g., AWQ and GPTQ). We also experiment with any3 and any2 and show competitiveness at lower bits. Additionally, we show that we can calibrate using a single curated diverse sample rather than hundreds of samples from a dataset as done in most quantization approaches. We also open source tinygemm, a latency optimized GPU matrix multiplication library for LLMs, that implements any4 using a GPU-efficient lookup table strategy along with other common quantization methods. We open source our code at https://github.com/facebookresearch/any4 .', 'score': 4, 'issue_id': 4715, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': '677d34e801c63489', 'authors': ['Mostafa Elhoushi', 'Jeff Johnson'], 'affiliations': ['FAIR at Meta'], 'pdf_title_img': 'assets/pdf/title_img/2507.04610.jpg', 'data': {'categories': ['#open_source', '#optimization', '#inference', '#training'], 'emoji': '🧠', 'ru': {'title': 'any4: Эффективная квантизация LLM без компромиссов', 'desc': 'Статья представляет any4 - метод обучаемой 4-битной квантизации весов для больших языковых моделей (LLM). Этот метод обеспечивает высокую точность без предварительной обработки весов или активаций, превосходя другие 4-битные представления. any4 использует эффективную для GPU стратегию поиска по таблице и конкурентоспособен с методами, требующими предобработки. Исследователи также экспериментировали с any3 и any2, показав их эффективность при меньшем количестве битов.'}, 'en': {'title': 'any4: Efficient 4-Bit Weight Quantization for High-Accuracy LLMs', 'desc': 'The paper introduces any4, a novel method for quantizing weights in large language models (LLMs) to 4 bits, which maintains high accuracy without the need for preprocessing. This method outperforms existing 4-bit representations like int4, fp4, and nf4 across various model sizes and families. Additionally, any4 allows for calibration using just one diverse sample, contrasting with traditional methods that require many samples. The authors also provide an open-source GPU-optimized library, tinygemm, to implement this quantization technique efficiently.'}, 'zh': {'title': 'any4：高效的4位权重量化方法', 'desc': 'any4是一种针对大型语言模型（LLMs）的学习型4位权重量化方法，能够在不需要预处理的情况下实现高精度的数值表示。与其他4位数值表示方法（如int4、fp4和nf4）相比，any4在多种模型规模和类型上表现出更高的准确性。该方法还可以使用单个多样化样本进行校准，而不是像大多数量化方法那样需要数百个样本。此外，我们开源了tinygemm，这是一个针对LLMs优化的GPU矩阵乘法库，采用了高效的查找表策略来实现any4。'}}}, {'id': 'https://huggingface.co/papers/2507.06230', 'title': 'Feed-Forward SceneDINO for Unsupervised Semantic Scene Completion', 'url': 'https://huggingface.co/papers/2507.06230', 'abstract': 'SceneDINO achieves state-of-the-art segmentation accuracy in unsupervised semantic scene completion by leveraging self-supervised representation learning and 2D unsupervised scene understanding techniques.  \t\t\t\t\tAI-generated summary \t\t\t\t Semantic scene completion (SSC) aims to infer both the 3D geometry and semantics of a scene from single images. In contrast to prior work on SSC that heavily relies on expensive ground-truth annotations, we approach SSC in an unsupervised setting. Our novel method, SceneDINO, adapts techniques from self-supervised representation learning and 2D unsupervised scene understanding to SSC. Our training exclusively utilizes multi-view consistency self-supervision without any form of semantic or geometric ground truth. Given a single input image, SceneDINO infers the 3D geometry and expressive 3D DINO features in a feed-forward manner. Through a novel 3D feature distillation approach, we obtain unsupervised 3D semantics. In both 3D and 2D unsupervised scene understanding, SceneDINO reaches state-of-the-art segmentation accuracy. Linear probing our 3D features matches the segmentation accuracy of a current supervised SSC approach. Additionally, we showcase the domain generalization and multi-view consistency of SceneDINO, taking the first steps towards a strong foundation for single image 3D scene understanding.', 'score': 3, 'issue_id': 4725, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '12d51a9f4c4400e9', 'authors': ['Aleksandar Jevtić', 'Christoph Reich', 'Felix Wimbauer', 'Oliver Hahn', 'Christian Rupprecht', 'Stefan Roth', 'Daniel Cremers'], 'affiliations': ['ELIZA', 'MCML', 'TU Darmstadt', 'TU Munich', 'University of Oxford', 'hessian.AI'], 'pdf_title_img': 'assets/pdf/title_img/2507.06230.jpg', 'data': {'categories': ['#optimization', '#cv', '#transfer_learning', '#3d'], 'emoji': '🏙️', 'ru': {'title': 'Несупервизорное 3D понимание сцены по одному изображению', 'desc': 'SceneDINO - это новый метод для несупервизорного семантического завершения сцены (SSC). Он использует самоконтролируемое обучение представлений и техники несупервизорного понимания 2D сцен для SSC. SceneDINO обучается исключительно на самоконтроле согласованности нескольких ракурсов, без использования семантической или геометрической разметки. Метод достигает современного уровня точности сегментации в несупервизорном понимании 3D и 2D сцен.'}, 'en': {'title': 'Unsupervised 3D Scene Understanding with SceneDINO', 'desc': 'SceneDINO is a novel method for unsupervised semantic scene completion (SSC) that excels in accurately inferring 3D geometry and semantics from single images. It utilizes self-supervised representation learning and 2D scene understanding techniques, avoiding the need for expensive ground-truth annotations. The model leverages multi-view consistency self-supervision to train, allowing it to generate 3D features and semantics without any labeled data. SceneDINO achieves state-of-the-art segmentation accuracy, demonstrating its effectiveness in both 3D and 2D scene understanding tasks.'}, 'zh': {'title': '无监督语义场景补全的新突破', 'desc': 'SceneDINO是一种无监督的语义场景补全方法，能够从单张图像中推断出场景的3D几何形状和语义信息。该方法利用自监督表示学习和2D无监督场景理解技术，避免了对昂贵的真实标注的依赖。通过多视图一致性的自我监督训练，SceneDINO在无监督的情况下实现了最先进的分割精度。该方法的3D特征蒸馏技术使得我们能够获得无监督的3D语义，为单图像3D场景理解奠定了坚实的基础。'}}}, {'id': 'https://huggingface.co/papers/2507.05201', 'title': 'MedGemma Technical Report', 'url': 'https://huggingface.co/papers/2507.05201', 'abstract': "MedGemma, a collection of medical vision-language foundation models, demonstrates advanced understanding and reasoning in healthcare applications, improving performance across various tasks and maintaining general capabilities.  \t\t\t\t\tAI-generated summary \t\t\t\t Artificial intelligence (AI) has significant potential in healthcare applications, but its training and deployment faces challenges due to healthcare's diverse data, complex tasks, and the need to preserve privacy. Foundation models that perform well on medical tasks and require less task-specific tuning data are critical to accelerate the development of healthcare AI applications. We introduce MedGemma, a collection of medical vision-language foundation models based on Gemma 3 4B and 27B. MedGemma demonstrates advanced medical understanding and reasoning on images and text, significantly exceeding the performance of similar-sized generative models and approaching the performance of task-specific models, while maintaining the general capabilities of the Gemma 3 base models. For out-of-distribution tasks, MedGemma achieves 2.6-10% improvement on medical multimodal question answering, 15.5-18.1% improvement on chest X-ray finding classification, and 10.8% improvement on agentic evaluations compared to the base models. Fine-tuning MedGemma further improves performance in subdomains, reducing errors in electronic health record information retrieval by 50% and reaching comparable performance to existing specialized state-of-the-art methods for pneumothorax classification and histopathology patch classification. We additionally introduce MedSigLIP, a medically-tuned vision encoder derived from SigLIP. MedSigLIP powers the visual understanding capabilities of MedGemma and as an encoder achieves comparable or better performance than specialized medical image encoders. Taken together, the MedGemma collection provides a strong foundation of medical image and text capabilities, with potential to significantly accelerate medical research and development of downstream applications. The MedGemma collection, including tutorials and model weights, can be found at https://goo.gle/medgemma.", 'score': 2, 'issue_id': 4728, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': '7f5f922ddf886fbb', 'authors': ['Andrew Sellergren', 'Sahar Kazemzadeh', 'Tiam Jaroensri', 'Atilla Kiraly', 'Madeleine Traverse', 'Timo Kohlberger', 'Shawn Xu', 'Fayaz Jamil', 'Cían Hughes', 'Charles Lau', 'Justin Chen', 'Fereshteh Mahvar', 'Liron Yatziv', 'Tiffany Chen', 'Bram Sterling', 'Stefanie Anna Baby', 'Susanna Maria Baby', 'Jeremy Lai', 'Samuel Schmidgall', 'Lu Yang', 'Kejia Chen', 'Per Bjornsson', 'Shashir Reddy', 'Ryan Brush', 'Kenneth Philbrick', 'Howard Hu', 'Howard Yang', 'Richa Tiwari', 'Sunny Jansen', 'Preeti Singh', 'Yun Liu', 'Shekoofeh Azizi', 'Aishwarya Kamath', 'Johan Ferret', 'Shreya Pathak', 'Nino Vieillard', 'Ramona Merhej', 'Sarah Perrin', 'Tatiana Matejovicova', 'Alexandre Ramé', 'Morgane Riviere', 'Louis Rouillard', 'Thomas Mesnard', 'Geoffrey Cideron', 'Jean-bastien Grill', 'Sabela Ramos', 'Edouard Yvinec', 'Michelle Casbon', 'Elena Buchatskaya', 'Jean-Baptiste Alayrac', 'Dmitry Lepikhin', 'Vlad Feinberg', 'Sebastian Borgeaud', 'Alek Andreev', 'Cassidy Hardin', 'Robert Dadashi', 'Léonard Hussenot', 'Armand Joulin', 'Olivier Bachem', 'Yossi Matias', 'Katherine Chou', 'Avinatan Hassidim', 'Kavi Goel', 'Clement Farabet', 'Joelle Barral', 'Tris Warkentin', 'Jonathon Shlens', 'David Fleet', 'Victor Cotruta', 'Omar Sanseviero', 'Gus Martins', 'Phoebe Kirk', 'Anand Rao', 'Shravya Shetty', 'David F. Steiner', 'Can Kirmizibayrak', 'Rory Pilgrim', 'Daniel Golden', 'Lin Yang'], 'affiliations': ['Google DeepMind', 'Google Research'], 'pdf_title_img': 'assets/pdf/title_img/2507.05201.jpg', 'data': {'categories': ['#architecture', '#reasoning', '#multimodal', '#science', '#dataset', '#training', '#healthcare'], 'emoji': '🩺', 'ru': {'title': 'MedGemma: Революция в медицинском ИИ', 'desc': 'MedGemma - это набор медицинских моделей компьютерного зрения и обработки естественного языка, основанных на Gemma 3. Модели демонстрируют продвинутое понимание и рассуждение в медицинских приложениях, значительно превосходя производительность аналогичных генеративных моделей. MedGemma улучшает результаты в задачах мультимодального вопросно-ответного анализа, классификации рентгеновских снимков грудной клетки и агентных оценках. Модели сохраняют общие возможности базовых моделей Gemma 3, предоставляя сильную основу для медицинских исследований и разработки приложений.'}, 'en': {'title': 'MedGemma: Revolutionizing Healthcare AI with Vision-Language Models', 'desc': "MedGemma is a set of advanced medical vision-language foundation models designed to enhance AI applications in healthcare. It excels in understanding and reasoning with medical images and text, outperforming similar models and nearing the effectiveness of specialized systems. The models show significant improvements in various tasks, such as medical question answering and chest X-ray classification, while also reducing errors in electronic health record retrieval. Additionally, MedSigLIP, a vision encoder, boosts MedGemma's capabilities, making it a valuable resource for accelerating medical research and application development."}, 'zh': {'title': 'MedGemma：加速医疗AI应用的基础模型', 'desc': 'MedGemma是一个医疗视觉-语言基础模型的集合，展示了在医疗应用中的高级理解和推理能力。它在多个任务上表现出色，并保持了Gemma 3基础模型的通用能力。MedGemma在医学多模态问答、胸部X光发现分类等任务上显著提高了性能，尤其是在处理分布外任务时。通过微调，MedGemma在特定领域的表现进一步提升，错误率降低了50%，并与现有的专业方法相媲美。'}}}, {'id': 'https://huggingface.co/papers/2507.03728', 'title': 'FAROS: Fair Graph Generation via Attribute Switching Mechanisms', 'url': 'https://huggingface.co/papers/2507.03728', 'abstract': "FAROS is a framework that enhances fairness in graph diffusion models by strategically switching node attributes during generation to balance accuracy and fairness.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advancements in graph diffusion models (GDMs) have enabled the synthesis of realistic network structures, yet ensuring fairness in the generated data remains a critical challenge. Existing solutions attempt to mitigate bias by re-training the GDMs with ad-hoc fairness constraints. Conversely, with this work, we propose FAROS, a novel FAir graph geneRatiOn framework leveraging attribute Switching mechanisms and directly running in the generation process of the pre-trained GDM. Technically, our approach works by altering nodes' sensitive attributes during the generation. To this end, FAROS calculates the optimal fraction of switching nodes, and selects the diffusion step to perform the switch by setting tailored multi-criteria constraints to preserve the node-topology profile from the original distribution (a proxy for accuracy) while ensuring the edge independence on the sensitive attributes for the generated graph (a proxy for fairness). Our experiments on benchmark datasets for link prediction demonstrate that the proposed approach effectively reduces fairness discrepancies while maintaining comparable (or even higher) accuracy performance to other similar baselines. Noteworthy, FAROS is also able to strike a better accuracy-fairness trade-off than other competitors in some of the tested settings under the Pareto optimality concept, demonstrating the effectiveness of the imposed multi-criteria constraints.", 'score': 1, 'issue_id': 4723, 'pub_date': '2025-07-04', 'pub_date_card': {'ru': '4 июля', 'en': 'July 4', 'zh': '7月4日'}, 'hash': 'a0d6f2a3eb887939', 'pdf_title_img': 'img/title_stub.png', 'data': {'categories': ['#graphs', '#ethics', '#benchmark', '#multimodal', '#dataset'], 'emoji': '⚖️', 'ru': {'title': 'Справедливая генерация графов без ущерба для точности', 'desc': 'FAROS - это фреймворк, который улучшает справедливость в графовых диффузионных моделях путем стратегического переключения атрибутов узлов во время генерации. Он рассчитывает оптимальную долю переключаемых узлов и выбирает шаг диффузии для переключения, устанавливая специальные многокритериальные ограничения. Это позволяет сохранить профиль топологии узлов из исходного распределения, обеспечивая при этом независимость ребер от чувствительных атрибутов в сгенерированном графе. Эксперименты показывают, что FAROS эффективно снижает неравенство, сохраняя при этом сопоставимую или даже более высокую точность по сравнению с другими базовыми методами.'}, 'en': {'title': 'Balancing Fairness and Accuracy in Graph Generation with FAROS', 'desc': 'FAROS is a framework designed to improve fairness in graph diffusion models (GDMs) by modifying node attributes during the generation process. It addresses the challenge of bias in generated data by strategically switching sensitive attributes of nodes while preserving the overall network structure. The framework calculates the optimal number of nodes to switch and selects the appropriate diffusion steps to maintain accuracy and fairness. Experimental results show that FAROS not only reduces fairness discrepancies but also achieves competitive accuracy compared to existing methods, highlighting its effectiveness in balancing these two important aspects.'}, 'zh': {'title': 'FAROS：平衡准确性与公平性的图生成框架', 'desc': 'FAROS是一个框架，旨在通过在生成过程中战略性地切换节点属性来增强图扩散模型的公平性。该方法在生成预训练图扩散模型时，动态调整节点的敏感属性，以平衡生成数据的准确性和公平性。FAROS通过计算最佳切换节点的比例，并设置多标准约束，确保生成图的边缘独立性和节点拓扑特征的保留。实验结果表明，FAROS在减少公平性差异的同时，能够保持与其他基线相当或更高的准确性。'}}}, {'id': 'https://huggingface.co/papers/2507.06137', 'title': 'NeoBabel: A Multilingual Open Tower for Visual Generation', 'url': 'https://huggingface.co/papers/2507.06137', 'abstract': 'NeoBabel, a multilingual image generation framework, achieves state-of-the-art performance across six languages while maintaining efficiency and cultural alignment, outperforming existing multilingual models.  \t\t\t\t\tAI-generated summary \t\t\t\t Text-to-image generation advancements have been predominantly English-centric, creating barriers for non-English speakers and perpetuating digital inequities. While existing systems rely on translation pipelines, these introduce semantic drift, computational overhead, and cultural misalignment. We introduce NeoBabel, a novel multilingual image generation framework that sets a new Pareto frontier in performance, efficiency and inclusivity, supporting six languages: English, Chinese, Dutch, French, Hindi, and Persian. The model is trained using a combination of large-scale multilingual pretraining and high-resolution instruction tuning. To evaluate its capabilities, we expand two English-only benchmarks to multilingual equivalents: m-GenEval and m-DPG. NeoBabel achieves state-of-the-art multilingual performance while retaining strong English capability, scoring 0.75 on m-GenEval and 0.68 on m-DPG. Notably, it performs on par with leading models on English tasks while outperforming them by +0.11 and +0.09 on multilingual benchmarks, even though these models are built on multilingual base LLMs. This demonstrates the effectiveness of our targeted alignment training for preserving and extending crosslingual generalization. We further introduce two new metrics to rigorously assess multilingual alignment and robustness to code-mixed prompts. Notably, NeoBabel matches or exceeds English-only models while being 2-4x smaller. We release an open toolkit, including all code, model checkpoints, a curated dataset of 124M multilingual text-image pairs, and standardized multilingual evaluation protocols, to advance inclusive AI research. Our work demonstrates that multilingual capability is not a trade-off but a catalyst for improved robustness, efficiency, and cultural fidelity in generative AI.', 'score': 0, 'issue_id': 4733, 'pub_date': '2025-07-08', 'pub_date_card': {'ru': '8 июля', 'en': 'July 8', 'zh': '7月8日'}, 'hash': '15b4ba4c927c0d0b', 'authors': ['Mohammad Mahdi Derakhshani', 'Dheeraj Varghese', 'Marzieh Fadaee', 'Cees G. M. Snoek'], 'affiliations': ['Cohere Labs', 'University of Amsterdam'], 'pdf_title_img': 'assets/pdf/title_img/2507.06137.jpg', 'data': {'categories': ['#multilingual', '#dataset', '#low_resource', '#alignment', '#benchmark', '#open_source'], 'emoji': '🌍', 'ru': {'title': 'NeoBabel: прорыв в мультиязычной генерации изображений', 'desc': 'NeoBabel - это новая мультиязычная система генерации изображений, поддерживающая шесть языков. Она достигает наилучших результатов в многоязычных тестах, сохраняя при этом высокую производительность на английском языке. Модель обучена с использованием комбинации крупномасштабного мультиязычного предобучения и высокоточной настройки инструкций. NeoBabel демонстрирует, что многоязычность не является компромиссом, а катализатором повышения надежности, эффективности и культурной точности в генеративном ИИ.'}, 'en': {'title': 'Empowering Multilingual Image Generation with NeoBabel', 'desc': 'NeoBabel is a multilingual image generation framework that excels in creating images from text in six different languages, achieving top performance while being efficient and culturally relevant. Unlike previous models that relied on translation, which often led to inaccuracies and inefficiencies, NeoBabel uses a unique training approach that combines multilingual pretraining with high-resolution instruction tuning. It has been evaluated using new multilingual benchmarks and shows superior performance compared to existing models, particularly in multilingual tasks. The framework is designed to be smaller and more efficient, proving that supporting multiple languages can enhance the overall quality and robustness of AI-generated content.'}, 'zh': {'title': 'NeoBabel：多语言生成的未来', 'desc': 'NeoBabel是一个多语言图像生成框架，能够在六种语言中实现最先进的性能，同时保持高效性和文化一致性，超越了现有的多语言模型。该模型通过大规模的多语言预训练和高分辨率的指令调优进行训练，支持英语、中文、荷兰语、法语、印地语和波斯语。NeoBabel在多语言基准测试中表现优异，尤其在英语任务上与领先模型相当，同时在多语言基准上超出它们。我们的研究表明，多语言能力不仅不是一种权衡，而是生成AI中提高鲁棒性、高效性和文化忠实度的催化剂。'}}}, {'id': 'https://huggingface.co/papers/2507.05411', 'title': 'AXLearn: Modular Large Model Training on Heterogeneous Infrastructure', 'url': 'https://huggingface.co/papers/2507.05411', 'abstract': "AXLearn is a modular deep learning system designed for scalable training on heterogeneous hardware, maintaining performance and modularity through efficient code integration methods.  \t\t\t\t\tAI-generated summary \t\t\t\t We design and implement AXLearn, a production deep learning system that facilitates scalable and high-performance training of large deep learning models. Compared to other state-of-the-art deep learning systems, AXLearn has a unique focus on modularity and support for heterogeneous hardware infrastructure. AXLearn's internal interfaces between software components follow strict encapsulation, allowing different components to be assembled to facilitate rapid model development and experimentation on heterogeneous compute infrastructure. We introduce a novel method of quantifying modularity via Lines-of-Code (LoC)-complexity, which demonstrates how our system maintains constant complexity as we scale the components in the system, compared to linear or quadratic complexity in other systems. This allows integrating features such as Rotary Position Embeddings (RoPE) into AXLearn across hundred of modules with just 10 lines of code, compared to hundreds as required in other systems. At the same time, AXLearn maintains equivalent performance compared to state-of-the-art training systems. Finally, we share our experience in the development and operation of AXLearn.", 'score': 0, 'issue_id': 4722, 'pub_date': '2025-07-07', 'pub_date_card': {'ru': '7 июля', 'en': 'July 7', 'zh': '7月7日'}, 'hash': 'b9bc54d8cca9de71', 'authors': ['Mark Lee', 'Tom Gunter', 'Chang Lan', 'John Peebles', 'Hanzhi Zhou', 'Kelvin Zou', 'Sneha Bangalore', 'Chung-Cheng Chiu', 'Nan Du', 'Xianzhi Du', 'Philipp Dufter', 'Ruixuan Hou', 'Haoshuo Huang', 'Dongseong Hwang', 'Xiang Kong', 'Jinhao Lei', 'Tao Lei', 'Meng Li', 'Li Li', 'Jiarui Lu', 'Zhiyun Lu', 'Yiping Ma', 'David Qiu', 'Vivek Rathod', 'Senyu Tong', 'Zhucheng Tu', 'Jianyu Wang', 'Yongqiang Wang', 'Zirui Wang', 'Floris Weers', 'Sam Wiseman', 'Guoli Yin', 'Bowen Zhang', 'Xiyou Zhou', 'Danyang Zhuo', 'Cheng Leong', 'Ruoming Pang'], 'affiliations': ['Apple', 'Duke University'], 'pdf_title_img': 'assets/pdf/title_img/2507.05411.jpg', 'data': {'categories': ['#architecture', '#inference', '#training', '#optimization'], 'emoji': '🧩', 'ru': {'title': 'Модульность и эффективность в глубоком обучении', 'desc': 'AXLearn - это модульная система глубокого обучения, разработанная для масштабируемого обучения на гетерогенном оборудовании. Система фокусируется на модульности и поддержке разнородной аппаратной инфраструктуры, сохраняя при этом высокую производительность. AXLearn использует строгую инкапсуляцию между программными компонентами, что позволяет быстро разрабатывать и экспериментировать с моделями. Авторы вводят метод количественной оценки модульности через сложность в строках кода, демонстрируя постоянную сложность при масштабировании компонентов системы.'}, 'en': {'title': 'Modular Deep Learning for Scalable Performance', 'desc': 'AXLearn is a deep learning system that allows for efficient training of large models on various types of hardware. It emphasizes modularity, meaning different parts of the system can be easily combined and reused, which speeds up the development process. The system uses a unique way to measure modularity, showing that it keeps complexity low even as more components are added. This design enables quick integration of new features while maintaining high performance, making AXLearn a competitive choice among existing deep learning frameworks.'}, 'zh': {'title': 'AXLearn：高效模块化的深度学习系统', 'desc': 'AXLearn是一个模块化的深度学习系统，旨在支持在异构硬件上进行可扩展的训练。它通过高效的代码集成方法，保持了性能和模块化的特点。AXLearn的内部接口遵循严格的封装原则，使得不同组件可以快速组装，便于在异构计算基础设施上进行模型开发和实验。我们还提出了一种新的量化模块化的方法，通过代码行复杂度（LoC复杂度）来展示系统在扩展组件时保持恒定复杂度的能力。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (2)', '#agents (6)', '#agi (1)', '#alignment (2)', '#architecture (7)', '#audio', '#benchmark (13)', '#cv (2)', '#data (4)', '#dataset (9)', '#diffusion (1)', '#ethics (2)', '#games (4)', '#graphs (2)', '#hallucinations (2)', '#healthcare (4)', '#inference (4)', '#interpretability (1)', '#leakage (1)', '#long_context (3)', '#low_resource (2)', '#machine_translation', '#math', '#multilingual (2)', '#multimodal (5)', '#open_source (8)', '#optimization (13)', '#plp (1)', '#rag', '#reasoning (7)', '#rl (6)', '#rlhf (1)', '#robotics (1)', '#science (2)', '#security', '#small_models', '#story_generation', '#survey (2)', '#synthetic', '#training (12)', '#transfer_learning (4)', '#video (3)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-07-09 20:12',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-07-09 20:12')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-07-09 20:12')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    