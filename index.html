
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 18 papers. August 25.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">25 августа</span> | <span id="title-articles-count">18 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-08-22.html">⬅️ <span id="prev-date">22.08</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-08-26.html">➡️ <span id="next-date">26.08</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-08.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '25 августа', 'en': 'August 25', 'zh': '8月25日'};
        let feedDateNext = {'ru': '26.08', 'en': '08/26', 'zh': '8月26日'};
        let feedDatePrev = {'ru': '22.08', 'en': '08/22', 'zh': '8月22日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2508.16153', 'title': 'AgentFly: Fine-tuning LLM Agents without Fine-tuning LLMs', 'url': 'https://huggingface.co/papers/2508.16153', 'abstract': 'A novel memory-augmented reinforcement learning paradigm enables adaptive LLM agents to continually learn without fine-tuning, using episodic memory and a neural case-selection policy.  \t\t\t\t\tAI-generated summary \t\t\t\t In this paper, we introduce a novel learning paradigm for adaptive Large Language Model (LLM) agents that eliminates the need for fine-tuning the underlying LLMs. Existing approaches are often either rigid, relying on static, handcrafted reflection workflows, or computationally intensive, requiring gradient updates of LLM model parameters. In contrast, our method enables low-cost continual adaptation via memory-based online reinforcement learning. We formalise this as a Memory-augmented Markov Decision Process (M-MDP), equipped with a neural case-selection policy to guide action decisions. Past experiences are stored in an episodic memory, either differentiable or non-parametric. The policy is continually updated based on environmental feedback through a memory rewriting mechanism, whereas policy improvement is achieved through efficient memory reading (retrieval). We instantiate our agent model in the deep research setting, namely AgentFly, which attains top-1 on GAIA validation (87.88% Pass@3) and 79.40% on the test set. It reaches 66.6% F1 and 80.4% PM on the DeepResearcher dataset, outperforming the state-of-the-art training-based method, while case-based memory adds 4.7% to 9.6% absolute points on out-of-distribution tasks. Our approach offers a scalable and efficient pathway for developing generalist LLM agents capable of continuous, real-time learning without gradient updates, advancing machine learning towards open-ended skill acquisition and deep research scenarios. The code is available at https://github.com/Agent-on-the-Fly/AgentFly.', 'score': 51, 'issue_id': 5518, 'pub_date': '2025-08-22', 'pub_date_card': {'ru': '22 августа', 'en': 'August 22', 'zh': '8月22日'}, 'hash': '6286f08d6e4a4187', 'authors': ['Huichi Zhou', 'Yihang Chen', 'Siyuan Guo', 'Xue Yan', 'Kin Hei Lee', 'Zihan Wang', 'Ka Yiu Lee', 'Guchun Zhang', 'Kun Shao', 'Linyi Yang', 'Jun Wang'], 'affiliations': ['AI Centre, UCL', 'Huawei Noahs Ark Lab, UK', 'Institute of Automation, CAS', 'Jilin University'], 'pdf_title_img': 'assets/pdf/title_img/2508.16153.jpg', 'data': {'categories': ['#agi', '#optimization', '#rl', '#agents'], 'emoji': '🧠', 'ru': {'title': 'Непрерывное обучение LLM-агентов без дообучения', 'desc': 'В этой статье представлена новая парадигма обучения для адаптивных агентов на основе больших языковых моделей (LLM), которая устраняет необходимость в их дообучении. Метод использует эпизодическую память и нейронную политику выбора примеров для непрерывной адаптации через обучение с подкреплением на основе памяти. Авторы формализуют подход как марковский процесс принятия решений с дополненной памятью (M-MDP). Реализация модели агента под названием AgentFly достигает высоких результатов на нескольких наборах данных, превосходя современные методы, основанные на обучении.'}, 'en': {'title': 'Empowering LLMs with Memory for Continuous Learning', 'desc': 'This paper presents a new approach for adaptive Large Language Model (LLM) agents that allows them to learn continuously without the need for fine-tuning. The method utilizes a Memory-augmented Markov Decision Process (M-MDP) that incorporates episodic memory and a neural case-selection policy to make decisions based on past experiences. By leveraging memory-based online reinforcement learning, the agents can adapt to new information efficiently, improving their performance on various tasks. The results show that this approach outperforms traditional training methods, making it a promising direction for developing versatile LLM agents capable of ongoing learning.'}, 'zh': {'title': '记忆增强的自适应学习，持续进步无微调', 'desc': '本文提出了一种新颖的记忆增强强化学习范式，使自适应的大型语言模型（LLM）代理能够在不进行微调的情况下持续学习。与传统方法相比，我们的方法通过基于记忆的在线强化学习实现了低成本的持续适应，避免了静态的手工反思流程和计算密集型的梯度更新。我们将其形式化为记忆增强马尔可夫决策过程（M-MDP），并使用神经案例选择策略来指导行动决策。我们的代理模型在深度研究环境中表现优异，超越了现有的基于训练的方法，展示了在开放式技能获取和深度研究场景中的潜力。'}}}, {'id': 'https://huggingface.co/papers/2508.08240', 'title': 'ODYSSEY: Open-World Quadrupeds Exploration and Manipulation for\n  Long-Horizon Tasks', 'url': 'https://huggingface.co/papers/2508.08240', 'abstract': "ODYSSEY is a unified mobile manipulation framework for quadruped robots that integrates high-level task planning with low-level whole-body control, addressing challenges in egocentric perception, generalization, and coordination in unstructured environments.  \t\t\t\t\tAI-generated summary \t\t\t\t Language-guided long-horizon mobile manipulation has long been a grand challenge in embodied semantic reasoning, generalizable manipulation, and adaptive locomotion. Three fundamental limitations hinder progress: First, although large language models have improved spatial reasoning and task planning through semantic priors, existing implementations remain confined to tabletop scenarios, failing to address the constrained perception and limited actuation ranges of mobile platforms. Second, current manipulation strategies exhibit insufficient generalization when confronted with the diverse object configurations encountered in open-world environments. Third, while crucial for practical deployment, the dual requirement of maintaining high platform maneuverability alongside precise end-effector control in unstructured settings remains understudied.   In this work, we present ODYSSEY, a unified mobile manipulation framework for agile quadruped robots equipped with manipulators, which seamlessly integrates high-level task planning with low-level whole-body control. To address the challenge of egocentric perception in language-conditioned tasks, we introduce a hierarchical planner powered by a vision-language model, enabling long-horizon instruction decomposition and precise action execution. At the control level, our novel whole-body policy achieves robust coordination across challenging terrains. We further present the first benchmark for long-horizon mobile manipulation, evaluating diverse indoor and outdoor scenarios. Through successful sim-to-real transfer, we demonstrate the system's generalization and robustness in real-world deployments, underscoring the practicality of legged manipulators in unstructured environments. Our work advances the feasibility of generalized robotic assistants capable of complex, dynamic tasks. Our project page: https://kaijwang.github.io/odyssey.github.io/", 'score': 34, 'issue_id': 5522, 'pub_date': '2025-08-11', 'pub_date_card': {'ru': '11 августа', 'en': 'August 11', 'zh': '8月11日'}, 'hash': '313edb98990f0684', 'authors': ['Kaijun Wang', 'Liqin Lu', 'Mingyu Liu', 'Jianuo Jiang', 'Zeju Li', 'Bolin Zhang', 'Wancai Zheng', 'Xinyi Yu', 'Hao Chen', 'Chunhua Shen'], 'affiliations': ['The Chinese University of Hong Kong, Shenzhen', 'Zhejiang University', 'Zhejiang University of Technology'], 'pdf_title_img': 'assets/pdf/title_img/2508.08240.jpg', 'data': {'categories': ['#robotics', '#transfer_learning', '#optimization', '#reasoning', '#agents', '#benchmark'], 'emoji': '🤖', 'ru': {'title': 'Мобильная манипуляция роботов: от планирования к действию', 'desc': 'ODYSSEY - это унифицированная система мобильной манипуляции для четвероногих роботов, объединяющая высокоуровневое планирование задач с низкоуровневым управлением всем телом. Система решает проблемы эгоцентрического восприятия, обобщения и координации в неструктурированной среде с помощью иерархического планировщика на основе визуально-языковой модели. На уровне управления используется оригинальная политика для всего тела робота, обеспечивающая надежную координацию на сложных поверхностях. ODYSSEY демонстрирует обобщение и надежность при развертывании в реальном мире, подчеркивая практичность использования четвероногих манипуляторов в неструктурированных средах.'}, 'en': {'title': 'Empowering Quadruped Robots for Complex Mobile Manipulation', 'desc': 'ODYSSEY is a new framework designed for quadruped robots that combines high-level planning with low-level control to improve mobile manipulation. It addresses key challenges such as understanding tasks through language, adapting to various object configurations, and coordinating movements in complex environments. The framework uses a vision-language model for better perception and task execution, allowing robots to follow long-term instructions effectively. Additionally, it includes a benchmark for testing these capabilities in real-world scenarios, showcasing the potential of robots to perform complex tasks in dynamic settings.'}, 'zh': {'title': '四足机器人移动操控的新突破', 'desc': 'ODYSSEY是一个统一的移动操控框架，专为四足机器人设计，结合了高层次的任务规划和低层次的全身控制。该框架解决了在非结构化环境中自我中心感知、泛化和协调等挑战。我们引入了一种基于视觉-语言模型的分层规划器，能够实现长时间指令的分解和精确执行。通过成功的模拟到现实转移，展示了该系统在真实环境中的泛化能力和鲁棒性，推动了复杂动态任务的机器人助手的可行性。'}}}, {'id': 'https://huggingface.co/papers/2508.14029', 'title': 'Beyond Pass@1: Self-Play with Variational Problem Synthesis Sustains\n  RLVR', 'url': 'https://huggingface.co/papers/2508.14029', 'abstract': "An online self-play strategy with variational problem synthesis for RLVR training maintains policy entropy and improves Pass@k performance on reasoning benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Reinforcement Learning with Verifiable Rewards (RLVR) has recently emerged as a key paradigm for post-training Large Language Models (LLMs), particularly for complex reasoning tasks. However, vanilla RLVR training has been shown to improve Pass@1 performance at the expense of policy entropy, leading to reduced generation diversity and limiting the Pass@k performance, which typically represents the upper bound of LLM reasoning capability. In this paper, we systematically analyze the policy's generation diversity from the perspective of training problems and find that augmenting and updating training problems helps mitigate entropy collapse during training. Based on these observations, we propose an online Self-play with Variational problem Synthesis (SvS) strategy for RLVR training, which uses the policy's correct solutions to synthesize variational problems while ensuring their reference answers remain identical to the originals. This self-improving strategy effectively maintains policy entropy during training and substantially improves Pass@k compared with standard RLVR, sustaining prolonged improvements and achieving absolute gains of 18.3% and 22.8% in Pass@32 performance on the competition-level AIME24 and AIME25 benchmarks. Experiments on 12 reasoning benchmarks across varying model sizes from 3B to 32B consistently demonstrate the generalizability and robustness of SvS.", 'score': 27, 'issue_id': 5520, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '615692d5b0adab3d', 'authors': ['Xiao Liang', 'Zhongzhi Li', 'Yeyun Gong', 'Yelong Shen', 'Ying Nian Wu', 'Zhijiang Guo', 'Weizhu Chen'], 'affiliations': ['Hong Kong University of Science and Technology', 'Hong Kong University of Science and Technology (Guangzhou)', 'Microsoft', 'School of Artificial Intelligence, Chinese Academy of Sciences', 'University of California, Los Angeles'], 'pdf_title_img': 'assets/pdf/title_img/2508.14029.jpg', 'data': {'categories': ['#rl', '#benchmark', '#optimization', '#rlhf', '#reasoning', '#training'], 'emoji': '🧠', 'ru': {'title': 'Самоулучшение языковых моделей через синтез вариативных задач', 'desc': 'Статья представляет новую стратегию обучения с подкреплением с проверяемыми наградами (RLVR) для улучшения языковых моделей в задачах рассуждения. Предложенный метод Self-play with Variational problem Synthesis (SvS) использует правильные решения модели для синтеза вариативных задач, сохраняя при этом энтропию политики. Это позволяет значительно улучшить показатель Pass@k по сравнению со стандартным RLVR. Эксперименты на 12 наборах данных для оценки рассуждений показали эффективность и обобщаемость предложенного подхода для моделей различного размера.'}, 'en': {'title': 'Enhancing Reasoning Performance with Self-Play and Variational Synthesis', 'desc': "This paper introduces a novel online self-play strategy called Self-play with Variational problem Synthesis (SvS) for training Reinforcement Learning with Verifiable Rewards (RLVR) in large language models. The authors identify that traditional RLVR training can lead to reduced policy entropy, which negatively impacts the diversity of generated outputs and overall performance on reasoning tasks. By augmenting and updating training problems, SvS maintains policy entropy and enhances the model's ability to generate diverse and accurate responses. The results show significant improvements in Pass@k performance on various reasoning benchmarks, demonstrating the effectiveness and robustness of the proposed method."}, 'zh': {'title': '自我对弈策略提升推理能力', 'desc': '本文提出了一种在线自我对弈策略，结合变分问题合成，用于强化学习可验证奖励（RLVR）训练。该方法通过增强和更新训练问题，解决了传统RLVR训练中策略熵降低的问题，从而提高了生成多样性。我们的方法在训练过程中有效维持了策略熵，并显著提升了在推理基准测试中的Pass@k表现。实验结果表明，该策略在不同规模的模型上均表现出良好的泛化能力和鲁棒性。'}}}, {'id': 'https://huggingface.co/papers/2508.13013', 'title': 'EgoTwin: Dreaming Body and View in First Person', 'url': 'https://huggingface.co/papers/2508.13013', 'abstract': "EgoTwin, a diffusion transformer framework, addresses viewpoint alignment and causal interplay in joint egocentric video and human motion generation using a head-centric motion representation and cybernetics-inspired interaction mechanism.  \t\t\t\t\tAI-generated summary \t\t\t\t While exocentric video synthesis has achieved great progress, egocentric video generation remains largely underexplored, which requires modeling first-person view content along with camera motion patterns induced by the wearer's body movements. To bridge this gap, we introduce a novel task of joint egocentric video and human motion generation, characterized by two key challenges: 1) Viewpoint Alignment: the camera trajectory in the generated video must accurately align with the head trajectory derived from human motion; 2) Causal Interplay: the synthesized human motion must causally align with the observed visual dynamics across adjacent video frames. To address these challenges, we propose EgoTwin, a joint video-motion generation framework built on the diffusion transformer architecture. Specifically, EgoTwin introduces a head-centric motion representation that anchors the human motion to the head joint and incorporates a cybernetics-inspired interaction mechanism that explicitly captures the causal interplay between video and motion within attention operations. For comprehensive evaluation, we curate a large-scale real-world dataset of synchronized text-video-motion triplets and design novel metrics to assess video-motion consistency. Extensive experiments demonstrate the effectiveness of the EgoTwin framework.", 'score': 14, 'issue_id': 5521, 'pub_date': '2025-08-18', 'pub_date_card': {'ru': '18 августа', 'en': 'August 18', 'zh': '8月18日'}, 'hash': '3573d981a35e3de1', 'authors': ['Jingqiao Xiu', 'Fangzhou Hong', 'Yicong Li', 'Mengze Li', 'Wentao Wang', 'Sirui Han', 'Liang Pan', 'Ziwei Liu'], 'affiliations': ['Hong Kong University of Science and Technology', 'Nanyang Technological University', 'National University of Singapore', 'Shanghai AI Laboratory'], 'pdf_title_img': 'assets/pdf/title_img/2508.13013.jpg', 'data': {'categories': ['#diffusion', '#video', '#multimodal', '#dataset', '#architecture'], 'emoji': '👀', 'ru': {'title': 'EgoTwin: Синхронная генерация эгоцентрического видео и движений человека', 'desc': 'EgoTwin - это новая система генерации эгоцентрического видео и движений человека на основе архитектуры диффузионного трансформера. Она решает проблемы выравнивания точки обзора и причинно-следственной взаимосвязи между видео и движениями с помощью представления движений относительно головы и механизма взаимодействия, вдохновленного кибернетикой. Авторы создали большой набор данных из синхронизированных триплетов текст-видео-движение для обучения и оценки. Эксперименты показывают эффективность предложенного подхода EgoTwin.'}, 'en': {'title': 'EgoTwin: Bridging Video and Motion in First-Person View', 'desc': "EgoTwin is a new framework that combines video generation and human motion modeling in a first-person perspective. It tackles two main challenges: ensuring that the camera movement matches the head movement of the person and making sure that the generated human actions correspond to the visual changes in the video. The framework uses a special representation that focuses on the head's motion and a mechanism inspired by cybernetics to understand how video and motion influence each other. By creating a large dataset and new evaluation methods, EgoTwin shows significant improvements in generating realistic egocentric videos and human movements."}, 'zh': {'title': 'EgoTwin：自我中心视频与人类运动生成的创新框架', 'desc': 'EgoTwin是一个扩散变换器框架，旨在解决联合自我中心视频和人类运动生成中的视角对齐和因果关系问题。该框架采用以头部为中心的运动表示，结合受网络控制启发的交互机制，能够有效捕捉视频与运动之间的因果关系。通过建立一个新的任务，EgoTwin需要处理相机轨迹与人类运动的头部轨迹之间的对齐，以及合成的人类运动与相邻视频帧的视觉动态之间的因果关系。实验结果表明，EgoTwin在视频与运动的一致性生成方面表现出色。'}}}, {'id': 'https://huggingface.co/papers/2508.13650', 'title': 'CRISP: Persistent Concept Unlearning via Sparse Autoencoders', 'url': 'https://huggingface.co/papers/2508.13650', 'abstract': "CRISP is a parameter-efficient method using sparse autoencoders to permanently remove unwanted knowledge from large language models while preserving their utility.  \t\t\t\t\tAI-generated summary \t\t\t\t As large language models (LLMs) are increasingly deployed in real-world applications, the need to selectively remove unwanted knowledge while preserving model utility has become paramount. Recent work has explored sparse autoencoders (SAEs) to perform precise interventions on monosemantic features. However, most SAE-based methods operate at inference time, which does not create persistent changes in the model's parameters. Such interventions can be bypassed or reversed by malicious actors with parameter access. We introduce CRISP, a parameter-efficient method for persistent concept unlearning using SAEs. CRISP automatically identifies salient SAE features across multiple layers and suppresses their activations. We experiment with two LLMs and show that our method outperforms prior approaches on safety-critical unlearning tasks from the WMDP benchmark, successfully removing harmful knowledge while preserving general and in-domain capabilities. Feature-level analysis reveals that CRISP achieves semantically coherent separation between target and benign concepts, allowing precise suppression of the target features.", 'score': 11, 'issue_id': 5520, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': 'bfe846ca6ab823e6', 'authors': ['Tomer Ashuach', 'Dana Arad', 'Aaron Mueller', 'Martin Tutek', 'Yonatan Belinkov'], 'affiliations': ['Boston University', 'TakeLab, University of Zagreb', 'Technion Israel Institute of Technology'], 'pdf_title_img': 'assets/pdf/title_img/2508.13650.jpg', 'data': {'categories': ['#inference', '#ethics', '#training', '#security'], 'emoji': '🧠', 'ru': {'title': 'Точное удаление знаний из нейросетей без потери функциональности', 'desc': 'CRISP - это эффективный метод для удаления нежелательных знаний из больших языковых моделей (LLM) с использованием разреженных автоэнкодеров. Метод позволяет сохранить полезность модели, при этом внося постоянные изменения в её параметры. CRISP автоматически идентифицирует важные признаки в нескольких слоях модели и подавляет их активации. Эксперименты показали, что CRISP превосходит предыдущие подходы в задачах забывания критически важной информации, сохраняя при этом общие возможности модели.'}, 'en': {'title': 'CRISP: Permanently Unlearning Harmful Knowledge in LLMs', 'desc': "CRISP is a novel method designed to efficiently remove unwanted knowledge from large language models (LLMs) using sparse autoencoders (SAEs). Unlike previous approaches that only intervene at inference time, CRISP makes permanent changes to the model's parameters, ensuring that harmful knowledge cannot be easily restored. The method identifies important features across different layers of the model and suppresses their activations, effectively achieving concept unlearning. Our experiments demonstrate that CRISP outperforms existing techniques in safety-critical tasks, maintaining the model's overall performance while ensuring a clear distinction between harmful and benign knowledge."}, 'zh': {'title': 'CRISP：高效的知识去除方法', 'desc': 'CRISP是一种高效的参数方法，利用稀疏自编码器（SAE）从大型语言模型中永久性地去除不必要的知识，同时保持模型的实用性。随着大型语言模型在实际应用中的广泛使用，选择性去除不必要知识的需求变得尤为重要。CRISP能够自动识别多个层次中的显著SAE特征，并抑制其激活，从而实现持久的概念遗忘。实验结果表明，CRISP在安全关键的遗忘任务中优于之前的方法，成功去除了有害知识，同时保留了模型的通用能力和领域内能力。'}}}, {'id': 'https://huggingface.co/papers/2508.07877', 'title': 'Selective Contrastive Learning for Weakly Supervised Affordance\n  Grounding', 'url': 'https://huggingface.co/papers/2508.07877', 'abstract': "The method uses selective prototypical and pixel contrastive objectives to learn affordance-relevant cues from third-person demonstrations, improving upon traditional weakly supervised affordance grounding by focusing on both part and object levels.  \t\t\t\t\tAI-generated summary \t\t\t\t Facilitating an entity's interaction with objects requires accurately identifying parts that afford specific actions. Weakly supervised affordance grounding (WSAG) seeks to imitate human learning from third-person demonstrations, where humans intuitively grasp functional parts without needing pixel-level annotations. To achieve this, grounding is typically learned using a shared classifier across images from different perspectives, along with distillation strategies incorporating part discovery process. However, since affordance-relevant parts are not always easily distinguishable, models primarily rely on classification, often focusing on common class-specific patterns that are unrelated to affordance. To address this limitation, we move beyond isolated part-level learning by introducing selective prototypical and pixel contrastive objectives that adaptively learn affordance-relevant cues at both the part and object levels, depending on the granularity of the available information. Initially, we find the action-associated objects in both egocentric (object-focused) and exocentric (third-person example) images by leveraging CLIP. Then, by cross-referencing the discovered objects of complementary views, we excavate the precise part-level affordance clues in each perspective. By consistently learning to distinguish affordance-relevant regions from affordance-irrelevant background context, our approach effectively shifts activation from irrelevant areas toward meaningful affordance cues. Experimental results demonstrate the effectiveness of our method. Codes are available at github.com/hynnsk/SelectiveCL.", 'score': 10, 'issue_id': 5520, 'pub_date': '2025-08-11', 'pub_date_card': {'ru': '11 августа', 'en': 'August 11', 'zh': '8月11日'}, 'hash': '1be5d42feb9fc4d7', 'authors': ['WonJun Moon', 'Hyun Seok Seong', 'Jae-Pil Heo'], 'affiliations': ['Sungkyunkwan University'], 'pdf_title_img': 'assets/pdf/title_img/2508.07877.jpg', 'data': {'categories': ['#optimization', '#multimodal', '#cv'], 'emoji': '🤖', 'ru': {'title': 'Улучшенное распознавание возможностей взаимодействия с помощью селективного контрастивного обучения', 'desc': 'Эта статья представляет новый метод слабо контролируемого обучения распознаванию возможностей взаимодействия с объектами. Авторы предлагают использовать селективные прототипические и пиксельные контрастивные цели для извлечения релевантных признаков как на уровне частей объектов, так и целых объектов. Метод применяет CLIP для нахождения связанных с действиями объектов в эгоцентрических и экзоцентрических изображениях. Экспериментальные результаты демонстрируют эффективность предложенного подхода в сравнении с традиционными методами.'}, 'en': {'title': 'Enhancing Affordance Grounding with Selective Learning Techniques', 'desc': 'This paper presents a novel approach to weakly supervised affordance grounding (WSAG) by utilizing selective prototypical and pixel contrastive objectives. The method enhances the learning of affordance-relevant cues from third-person demonstrations, focusing on both object and part levels. By leveraging CLIP to identify action-associated objects from different perspectives, the model effectively distinguishes meaningful affordance regions from irrelevant background. Experimental results show that this approach significantly improves the accuracy of identifying parts that facilitate specific actions, addressing limitations of traditional classification methods.'}, 'zh': {'title': '通过选择性学习提升功能基础定位的准确性', 'desc': '本文提出了一种新的方法，通过选择性原型和像素对比目标，从第三人称示范中学习与功能相关的线索，从而改进传统的弱监督功能基础定位。该方法关注于物体和部件的层面，能够更准确地识别与特定动作相关的部件。我们利用CLIP技术在不同视角的图像中找到与动作相关的物体，并通过交叉参考发现的物体来挖掘每个视角中的精确部件功能线索。实验结果表明，该方法在功能基础定位任务中表现出色。'}}}, {'id': 'https://huggingface.co/papers/2508.16402', 'title': "AetherCode: Evaluating LLMs' Ability to Win In Premier Programming\n  Competitions", 'url': 'https://huggingface.co/papers/2508.16402', 'abstract': 'AetherCode is a new benchmark for evaluating Large Language Models in competitive programming, offering more challenging and expert-validated test cases than existing benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Competitive programming has emerged as a critical benchmark for evaluating the reasoning and coding capabilities of Large Language Models (LLMs). Despite impressive progress on existing benchmarks, we argue that current evaluations overstate model proficiency, masking a substantial gap between LLMs and elite human programmers. This gap arises from two key limitations: insufficient difficulty and scope of benchmark problems, and evaluation bias from low-quality test cases. To address these shortcomings, we present AetherCode, a new benchmark that draws problems from premier programming competitions such as IOI and ICPC, offering broader coverage and higher difficulty. AetherCode further incorporates comprehensive, expert-validated test suites built through a hybrid of automated generation and human curation, ensuring rigorous and reliable assessment. By combining challenging problem design with robust evaluation, AetherCode provides a more faithful measure of LLM capabilities and sets a new standard for future research in code reasoning.', 'score': 9, 'issue_id': 5517, 'pub_date': '2025-08-22', 'pub_date_card': {'ru': '22 августа', 'en': 'August 22', 'zh': '8月22日'}, 'hash': 'e6c79bec20f431d6', 'authors': ['Zihan Wang', 'Jiaze Chen', 'Zhicheng Liu', 'Markus Mak', 'Yidi Du', 'Geonsik Moon', 'Luoqi Xu', 'Aaron Tua', 'Kunshuo Peng', 'Jiayi Lu', 'Mingfei Xia', 'Boqian Zou', 'Chenyang Ran', 'Guang Tian', 'Shoutai Zhu', 'Yeheng Duan', 'Zhenghui Kang', 'Zhenxing Lin', 'Shangshu Li', 'Qiang Luo', 'Qingshen Long', 'Zhiyong Chen', 'Yihan Xiao', 'Yurong Wu', 'Daoguang Zan', 'Yuyi Fu', 'Mingxuan Wang', 'Ming Ding'], 'affiliations': ['ByteDance'], 'pdf_title_img': 'assets/pdf/title_img/2508.16402.jpg', 'data': {'categories': ['#benchmark', '#optimization', '#reasoning'], 'emoji': '🏆', 'ru': {'title': 'AetherCode: Новая планка в оценке ИИ-программистов', 'desc': 'AetherCode - новый эталон для оценки больших языковых моделей в соревновательном программировании. Он предлагает более сложные и экспертно проверенные тестовые случаи, чем существующие бенчмарки. AetherCode использует задачи из престижных соревнований по программированию, таких как IOI и ICPC, обеспечивая более широкий охват и повышенную сложность. Бенчмарк включает в себя комплексные наборы тестов, созданные с помощью гибридного подхода автоматической генерации и ручной курации.'}, 'en': {'title': 'AetherCode: Raising the Bar for LLM Evaluation in Competitive Programming', 'desc': 'AetherCode is a benchmark designed to evaluate Large Language Models (LLMs) specifically in the context of competitive programming. It addresses the limitations of existing benchmarks by providing more difficult and expertly validated test cases, which better reflect the skills of elite human programmers. The benchmark includes problems sourced from prestigious competitions like IOI and ICPC, ensuring a wider range of challenges. By combining automated generation with human curation, AetherCode aims to deliver a more accurate assessment of LLM capabilities in coding and reasoning tasks.'}, 'zh': {'title': 'AetherCode：提升大型语言模型评估标准的基准', 'desc': 'AetherCode是一个新的基准，用于评估大型语言模型在竞争编程中的表现。与现有基准相比，它提供了更具挑战性和经过专家验证的测试案例。当前的评估往往夸大了模型的能力，掩盖了大型语言模型与顶尖人类程序员之间的差距。AetherCode通过从顶级编程竞赛中提取问题，结合自动生成和人工策划的测试套件，确保了评估的严格性和可靠性。'}}}, {'id': 'https://huggingface.co/papers/2508.16292', 'title': 'Do What? Teaching Vision-Language-Action Models to Reject the Impossible', 'url': 'https://huggingface.co/papers/2508.16292', 'abstract': 'A unified framework, Instruct-Verify-and-Act (IVA), enhances Vision-Language-Action (VLA) models to detect and respond to false-premise instructions by leveraging contextually augmented datasets.  \t\t\t\t\tAI-generated summary \t\t\t\t Recently, Vision-Language-Action (VLA) models have demonstrated strong performance on a range of robotic tasks. These models rely on multimodal inputs, with language instructions playing a crucial role -- not only in predicting actions, but also in robustly interpreting user intent, even when the requests are impossible to fulfill. In this work, we investigate how VLAs can recognize, interpret, and respond to false-premise instructions: natural language commands that reference objects or conditions absent from the environment. We propose Instruct-Verify-and-Act (IVA), a unified framework that (i) detects when an instruction cannot be executed due to a false premise, (ii) engages in language-based clarification or correction, and (iii) grounds plausible alternatives in perception and action. Towards this end, we construct a large-scale instruction tuning setup with structured language prompts and train a VLA model capable of handling both accurate and erroneous requests. Our approach leverages a contextually augmented, semi-synthetic dataset containing paired positive and false-premise instructions, enabling robust detection and natural language correction. Our experiments show that IVA improves false premise detection accuracy by 97.56% over baselines, while increasing successful responses in false-premise scenarios by 50.78%.', 'score': 5, 'issue_id': 5518, 'pub_date': '2025-08-22', 'pub_date_card': {'ru': '22 августа', 'en': 'August 22', 'zh': '8月22日'}, 'hash': 'fad295352d591bab', 'authors': ['Wen-Han Hsieh', 'Elvis Hsieh', 'Dantong Niu', 'Trevor Darrell', 'Roei Herzig', 'David M. Chan'], 'affiliations': ['University of California, Berkeley'], 'pdf_title_img': 'assets/pdf/title_img/2508.16292.jpg', 'data': {'categories': ['#multimodal', '#interpretability', '#robotics', '#alignment', '#dataset'], 'emoji': '🤖', 'ru': {'title': 'Умные роботы учатся распознавать невыполнимые команды', 'desc': 'Исследователи предложили единую систему Instruct-Verify-and-Act (IVA) для улучшения моделей Vision-Language-Action (VLA) в робототехнике. IVA позволяет обнаруживать и реагировать на инструкции с ложными предпосылками, используя контекстно дополненные наборы данных. Система способна распознавать невыполнимые команды, уточнять их через диалог и находить альтернативные решения. Эксперименты показали значительное улучшение точности обнаружения ложных предпосылок и успешности ответов в таких сценариях.'}, 'en': {'title': 'Enhancing VLA Models to Handle False-Premise Instructions with IVA', 'desc': 'The paper introduces a new framework called Instruct-Verify-and-Act (IVA) that improves Vision-Language-Action (VLA) models in handling incorrect instructions. It focuses on detecting false-premise commands, which are instructions that refer to non-existent objects or conditions. The IVA framework not only identifies these erroneous instructions but also engages in clarifying or correcting them through natural language. By using a specially designed dataset for training, the model significantly enhances its ability to respond accurately to both valid and invalid requests, achieving remarkable improvements in detection and response rates.'}, 'zh': {'title': '指令验证与行动：提升VLA模型的智能响应能力', 'desc': '本文提出了一种统一框架，称为指令验证与行动（IVA），旨在增强视觉-语言-行动（VLA）模型的能力，以检测和响应错误前提的指令。该框架通过利用上下文增强的数据集，帮助模型识别无法执行的指令，并进行语言上的澄清或修正。我们构建了一个大规模的指令调优设置，训练出能够处理准确和错误请求的VLA模型。实验结果表明，IVA在错误前提检测准确率上提高了97.56%，并在错误前提场景中成功响应的比例增加了50.78%。'}}}, {'id': 'https://huggingface.co/papers/2508.15746', 'title': 'End-to-End Agentic RAG System Training for Traceable Diagnostic\n  Reasoning', 'url': 'https://huggingface.co/papers/2508.15746', 'abstract': "Deep-DxSearch, an agentic RAG system trained with reinforcement learning, enhances medical diagnosis accuracy by integrating a large-scale retrieval corpus and tailored rewards.  \t\t\t\t\tAI-generated summary \t\t\t\t Accurate diagnosis with medical large language models is hindered by knowledge gaps and hallucinations. Retrieval and tool-augmented methods help, but their impact is limited by weak use of external knowledge and poor feedback-reasoning traceability. To address these challenges, We introduce Deep-DxSearch, an agentic RAG system trained end-to-end with reinforcement learning (RL) that enables steer tracebale retrieval-augmented reasoning for medical diagnosis. In Deep-DxSearch, we first construct a large-scale medical retrieval corpus comprising patient records and reliable medical knowledge sources to support retrieval-aware reasoning across diagnostic scenarios. More crutially, we frame the LLM as the core agent and the retrieval corpus as its environment, using tailored rewards on format, retrieval, reasoning structure, and diagnostic accuracy, thereby evolving the agentic RAG policy from large-scale data through RL.   Experiments demonstrate that our end-to-end agentic RL training framework consistently outperforms prompt-engineering and training-free RAG approaches across multiple data centers. After training, Deep-DxSearch achieves substantial gains in diagnostic accuracy, surpassing strong diagnostic baselines such as GPT-4o, DeepSeek-R1, and other medical-specific frameworks for both common and rare disease diagnosis under in-distribution and out-of-distribution settings. Moreover, ablation studies on reward design and retrieval corpus components confirm their critical roles, underscoring the uniqueness and effectiveness of our approach compared with traditional implementations. Finally, case studies and interpretability analyses highlight improvements in Deep-DxSearch's diagnostic policy, providing deeper insight into its performance gains and supporting clinicians in delivering more reliable and precise preliminary diagnoses. See https://github.com/MAGIC-AI4Med/Deep-DxSearch.", 'score': 5, 'issue_id': 5519, 'pub_date': '2025-08-21', 'pub_date_card': {'ru': '21 августа', 'en': 'August 21', 'zh': '8月21日'}, 'hash': '7a7f46f22403e421', 'authors': ['Qiaoyu Zheng', 'Yuze Sun', 'Chaoyi Wu', 'Weike Zhao', 'Pengcheng Qiu', 'Yongguo Yu', 'Kun Sun', 'Yanfeng Wang', 'Ya Zhang', 'Weidi Xie'], 'affiliations': ['Shanghai AI Laboratory, Shanghai, China', 'Shanghai Jiao Tong University, Shanghai, China', 'Xinhua Hospital affiliated to Shanghai Jiao Tong University School of Medicine, Shanghai, China'], 'pdf_title_img': 'assets/pdf/title_img/2508.15746.jpg', 'data': {'categories': ['#optimization', '#interpretability', '#healthcare', '#rl', '#reasoning', '#rag', '#hallucinations'], 'emoji': '🩺', 'ru': {'title': 'Искусственный интеллект на страже здоровья: революция в медицинской диагностике', 'desc': 'Deep-DxSearch - это система диагностики на основе агентного RAG, обученная с помощью обучения с подкреплением. Она использует большой корпус медицинских данных для поиска и специальные награды для улучшения точности диагностики. Система превосходит существующие подходы, включая GPT-4 и DeepSeek-R1, как для распространенных, так и для редких заболеваний. Deep-DxSearch демонстрирует значительное улучшение в диагностической политике и может помочь врачам в предварительной диагностике.'}, 'en': {'title': 'Revolutionizing Medical Diagnosis with Deep-DxSearch', 'desc': 'Deep-DxSearch is a novel retrieval-augmented generation (RAG) system that uses reinforcement learning (RL) to improve the accuracy of medical diagnoses. It integrates a large-scale retrieval corpus of patient records and medical knowledge, allowing the model to perform better reasoning in diagnostic scenarios. By framing the large language model (LLM) as an agent and the retrieval corpus as its environment, the system utilizes tailored rewards to enhance its performance in terms of format, reasoning structure, and diagnostic accuracy. Experimental results show that Deep-DxSearch significantly outperforms existing models, providing clinicians with more reliable and precise preliminary diagnoses.'}, 'zh': {'title': '提升医疗诊断准确性的智能检索系统', 'desc': 'Deep-DxSearch 是一个通过强化学习训练的代理 RAG 系统，旨在提高医疗诊断的准确性。它结合了大规模的检索语料库和定制的奖励机制，以支持基于检索的推理。该系统通过构建包含患者记录和可靠医学知识来源的检索语料库，增强了诊断场景中的推理能力。实验结果表明，Deep-DxSearch 在多种数据中心的诊断准确性上显著超越了传统的提示工程和无训练的 RAG 方法。'}}}, {'id': 'https://huggingface.co/papers/2508.15881', 'title': 'TPLA: Tensor Parallel Latent Attention for Efficient Disaggregated\n  Prefill \\& Decode Inference', 'url': 'https://huggingface.co/papers/2508.15881', 'abstract': "Tensor-Parallel Latent Attention (TPLA) enhances tensor parallelism efficiency by partitioning latent representations and input dimensions, preserving the benefits of compressed key-value caches while maintaining strong representational capacity.  \t\t\t\t\tAI-generated summary \t\t\t\t Multi-Head Latent Attention (MLA), introduced in DeepSeek-V2, compresses key-value states into a low-rank latent vector, caching only this vector to reduce memory. In tensor parallelism (TP), however, attention heads are computed across multiple devices, and each device must load the full cache, eroding the advantage of MLA over Grouped Query Attention (GQA). We propose Tensor-Parallel Latent Attention (TPLA): a scheme that partitions both the latent representation and each head's input dimension across devices, performs attention independently per shard, and then combines results with an all-reduce. TPLA preserves the benefits of a compressed KV cache while unlocking TP efficiency. Unlike Grouped Latent Attention (GLA), every head in TPLA still leverages the full latent representation, maintaining stronger representational capacity. TPLA is drop-in compatible with models pre-trained using MLA: it supports MLA-style prefilling and enables efficient tensor-parallel decoding without retraining. Applying simple orthogonal transforms -- e.g., the Hadamard transform or PCA -- before TP slicing further mitigates cross-shard interference, yielding minimal accuracy degradation. By reducing the per-device KV cache for DeepSeek-V3 and Kimi-K2, we achieve 1.79x and 1.93x speedups, respectively, at a 32K-token context length while maintaining performance on commonsense and LongBench benchmarks. TPLA can be implemented with FlashAttention-3, enabling practical end-to-end acceleration.", 'score': 5, 'issue_id': 5516, 'pub_date': '2025-08-21', 'pub_date_card': {'ru': '21 августа', 'en': 'August 21', 'zh': '8月21日'}, 'hash': '603c38aea1aa4a8f', 'authors': ['Xiaojuan Tang', 'Fanxu Meng', 'Pingzhi Tang', 'Yuxuan Wang', 'Di Yin', 'Xing Sun', 'Muhan Zhang'], 'affiliations': ['Institute for Artificial Intelligence, Peking University', 'State Key Laboratory of General Artificial Intelligence, BIGAI', 'Tencent Youtu Lab, Shanghai, China'], 'pdf_title_img': 'assets/pdf/title_img/2508.15881.jpg', 'data': {'categories': ['#architecture', '#optimization', '#training', '#benchmark', '#long_context'], 'emoji': '⚡', 'ru': {'title': 'TPLA: Эффективный тензорный параллелизм для ускорения обработки длинных последовательностей', 'desc': 'Статья представляет новый метод тензорного параллелизма для моделей машинного обучения - Tensor-Parallel Latent Attention (TPLA). TPLA разделяет латентные представления и входные размерности между устройствами, сохраняя преимущества сжатого кэша ключей и значений. Этот подход позволяет эффективно распараллеливать вычисления, сохраняя при этом сильную репрезентативную способность модели. TPLA совместим с предобученными моделями и показывает значительное ускорение обработки длинных последовательностей.'}, 'en': {'title': 'Boosting Tensor Parallelism with TPLA', 'desc': 'Tensor-Parallel Latent Attention (TPLA) improves the efficiency of tensor parallelism by dividing latent representations and input dimensions across multiple devices. This method retains the advantages of compressed key-value caches while ensuring that each attention head can still utilize the full latent representation, thus enhancing its representational capacity. TPLA is compatible with models that have been pre-trained using Multi-Head Latent Attention (MLA), allowing for efficient tensor-parallel decoding without the need for retraining. By applying orthogonal transforms before partitioning, TPLA minimizes cross-shard interference, leading to significant speedups in processing time while maintaining accuracy on various benchmarks.'}, 'zh': {'title': '张量并行潜在注意力：提升效率与表现的完美结合', 'desc': 'Tensor-Parallel Latent Attention (TPLA) 是一种提高张量并行效率的方法，通过在设备之间划分潜在表示和输入维度，保持压缩的键值缓存的优势，同时保持强大的表示能力。与多头潜在注意力（MLA）相比，TPLA 允许每个头在不同设备上独立计算注意力，并通过全归约组合结果，从而提高了效率。TPLA 兼容使用 MLA 预训练的模型，支持 MLA 风格的预填充，并实现高效的张量并行解码，而无需重新训练。通过在 TP 切片之前应用简单的正交变换，可以进一步减少跨分片干扰，确保在保持性能的同时实现显著的加速。'}}}, {'id': 'https://huggingface.co/papers/2508.16279', 'title': 'AgentScope 1.0: A Developer-Centric Framework for Building Agentic\n  Applications', 'url': 'https://huggingface.co/papers/2508.16279', 'abstract': 'AgentScope enhances agentic applications by providing flexible tool-based interactions, unified interfaces, and advanced infrastructure based on the ReAct paradigm, supporting efficient and safe development and deployment.  \t\t\t\t\tAI-generated summary \t\t\t\t Driven by rapid advancements of Large Language Models (LLMs), agents are empowered to combine intrinsic knowledge with dynamic tool use, greatly enhancing their capacity to address real-world tasks. In line with such an evolution, AgentScope introduces major improvements in a new version (1.0), towards comprehensively supporting flexible and efficient tool-based agent-environment interactions for building agentic applications. Specifically, we abstract foundational components essential for agentic applications and provide unified interfaces and extensible modules, enabling developers to easily leverage the latest progress, such as new models and MCPs. Furthermore, we ground agent behaviors in the ReAct paradigm and offer advanced agent-level infrastructure based on a systematic asynchronous design, which enriches both human-agent and agent-agent interaction patterns while improving execution efficiency. Building on this foundation, we integrate several built-in agents tailored to specific practical scenarios. AgentScope also includes robust engineering support for developer-friendly experiences. We provide a scalable evaluation module with a visual studio interface, making the development of long-trajectory agentic applications more manageable and easier to trace. In addition, AgentScope offers a runtime sandbox to ensure safe agent execution and facilitates rapid deployment in production environments. With these enhancements, AgentScope provides a practical foundation for building scalable, adaptive, and effective agentic applications.', 'score': 4, 'issue_id': 5518, 'pub_date': '2025-08-22', 'pub_date_card': {'ru': '22 августа', 'en': 'August 22', 'zh': '8月22日'}, 'hash': '5a3094b08e023d2b', 'authors': ['Dawei Gao', 'Zitao Li', 'Yuexiang Xie', 'Weirui Kuang', 'Liuyi Yao', 'Bingchen Qian', 'Zhijian Ma', 'Yue Cui', 'Haohao Luo', 'Shen Li', 'Lu Yi', 'Yi Yu', 'Shiqi He', 'Zhiling Luo', 'Wenmeng Zhou', 'Zhicheng Zhang', 'Xuguang He', 'Ziqian Chen', 'Weikai Liao', 'Farruh Isakulovich Kushnazarov', 'Yaliang Li', 'Bolin Ding', 'Jingren Zhou'], 'affiliations': ['Alibaba Group'], 'pdf_title_img': 'assets/pdf/title_img/2508.16279.jpg', 'data': {'categories': ['#agents', '#architecture'], 'emoji': '🤖', 'ru': {'title': 'AgentScope: гибкая платформа для создания ИИ-агентов нового поколения', 'desc': 'AgentScope 1.0 - это новая версия фреймворка для разработки агентных приложений на основе больших языковых моделей. Он предоставляет унифицированные интерфейсы и расширяемые модули для гибкого взаимодействия агентов с инструментами. AgentScope основан на парадигме ReAct и включает асинхронную инфраструктуру для эффективного выполнения задач. Фреймворк также обеспечивает масштабируемую оценку, визуальный интерфейс разработки и безопасное выполнение агентов в production-среде.'}, 'en': {'title': 'Empowering Agentic Applications with AgentScope', 'desc': 'AgentScope is a framework designed to improve the development of agentic applications by offering flexible interactions and a unified interface. It leverages the ReAct paradigm to enhance agent capabilities, allowing them to effectively use tools and interact with their environments. The latest version introduces foundational components and extensible modules that simplify the integration of new models and methodologies. Additionally, it includes features like a visual evaluation module and a runtime sandbox to ensure safe and efficient deployment of agents in real-world scenarios.'}, 'zh': {'title': 'AgentScope：构建灵活高效的智能代理应用', 'desc': 'AgentScope 是一个增强智能代理应用程序的工具，提供灵活的工具交互和统一的接口。它基于 ReAct 理论，支持高效和安全的开发与部署。新版本 1.0 引入了重要改进，帮助开发者轻松利用最新的模型和模块。AgentScope 还提供了可扩展的评估模块和安全的运行时沙箱，确保代理的安全执行。'}}}, {'id': 'https://huggingface.co/papers/2508.14037', 'title': 'Distilled-3DGS:Distilled 3D Gaussian Splatting', 'url': 'https://huggingface.co/papers/2508.14037', 'abstract': 'A knowledge distillation framework for 3D Gaussian Splatting improves rendering quality and storage efficiency by aggregating outputs from multiple teacher models to optimize a lightweight student model.  \t\t\t\t\tAI-generated summary \t\t\t\t 3D Gaussian Splatting (3DGS) has exhibited remarkable efficacy in novel view synthesis (NVS). However, it suffers from a significant drawback: achieving high-fidelity rendering typically necessitates a large number of 3D Gaussians, resulting in substantial memory consumption and storage requirements. To address this challenge, we propose the first knowledge distillation framework for 3DGS, featuring various teacher models, including vanilla 3DGS, noise-augmented variants, and dropout-regularized versions. The outputs of these teachers are aggregated to guide the optimization of a lightweight student model. To distill the hidden geometric structure, we propose a structural similarity loss to boost the consistency of spatial geometric distributions between the student and teacher model. Through comprehensive quantitative and qualitative evaluations across diverse datasets, the proposed Distilled-3DGS, a simple yet effective framework without bells and whistles, achieves promising rendering results in both rendering quality and storage efficiency compared to state-of-the-art methods. Project page: https://distilled3dgs.github.io . Code: https://github.com/lt-xiang/Distilled-3DGS .', 'score': 3, 'issue_id': 5531, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '44772dad89d5ac79', 'authors': ['Lintao Xiang', 'Xinkai Chen', 'Jianhuang Lai', 'Guangcong Wang'], 'affiliations': ['Sun Yat-Sen University', 'The University of Manchester', 'Vision, Graphics, and Group, Great Bay University'], 'pdf_title_img': 'assets/pdf/title_img/2508.14037.jpg', 'data': {'categories': ['#optimization', '#3d', '#training'], 'emoji': '🎨', 'ru': {'title': 'Эффективный рендеринг через дистилляцию знаний в 3D Gaussian Splatting', 'desc': 'Представлена система дистилляции знаний для 3D Gaussian Splatting, которая улучшает качество рендеринга и эффективность хранения. Метод агрегирует выходные данные нескольких учительских моделей для оптимизации легковесной ученической модели. Предложена функция потерь структурного сходства для повышения согласованности пространственных геометрических распределений между моделями. Эксперименты показали, что предложенный фреймворк Distilled-3DGS достигает многообещающих результатов по качеству рендеринга и эффективности хранения.'}, 'en': {'title': 'Optimizing 3D Gaussian Splatting with Knowledge Distillation', 'desc': 'This paper introduces a knowledge distillation framework specifically designed for 3D Gaussian Splatting (3DGS), which enhances rendering quality while reducing storage needs. By utilizing multiple teacher models, including standard and noise-augmented versions, the framework optimizes a more compact student model. A novel structural similarity loss is implemented to ensure that the spatial geometric distributions of the student closely match those of the teachers. The results demonstrate that the proposed Distilled-3DGS framework achieves superior rendering performance and efficiency compared to existing methods.'}, 'zh': {'title': '知识蒸馏提升3D高斯渲染效率', 'desc': '本文提出了一种知识蒸馏框架，用于3D高斯点云渲染，以提高渲染质量和存储效率。该框架通过聚合多个教师模型的输出，优化一个轻量级的学生模型。为了解决高保真渲染所需的大量3D高斯体积带来的内存消耗问题，本文引入了结构相似性损失，以增强学生模型与教师模型之间的空间几何分布一致性。经过多种数据集的评估，提出的Distilled-3DGS在渲染质量和存储效率上均表现出色。'}}}, {'id': 'https://huggingface.co/papers/2508.16359', 'title': 'RotaTouille: Rotation Equivariant Deep Learning for Contours', 'url': 'https://huggingface.co/papers/2508.16359', 'abstract': 'RotaTouille is a deep learning framework that achieves rotation and cyclic shift equivariance for contour data using complex-valued circular convolution, enabling effective performance in shape classification, reconstruction, and contour regression.  \t\t\t\t\tAI-generated summary \t\t\t\t Contours or closed planar curves are common in many domains. For example, they appear as object boundaries in computer vision, isolines in meteorology, and the orbits of rotating machinery. In many cases when learning from contour data, planar rotations of the input will result in correspondingly rotated outputs. It is therefore desirable that deep learning models be rotationally equivariant. In addition, contours are typically represented as an ordered sequence of edge points, where the choice of starting point is arbitrary. It is therefore also desirable for deep learning methods to be equivariant under cyclic shifts. We present RotaTouille, a deep learning framework for learning from contour data that achieves both rotation and cyclic shift equivariance through complex-valued circular convolution. We further introduce and characterize equivariant non-linearities, coarsening layers, and global pooling layers to obtain invariant representations for downstream tasks. Finally, we demonstrate the effectiveness of RotaTouille through experiments in shape classification, reconstruction, and contour regression.', 'score': 1, 'issue_id': 5528, 'pub_date': '2025-08-22', 'pub_date_card': {'ru': '22 августа', 'en': 'August 22', 'zh': '8月22日'}, 'hash': '6bd890386e0d4116', 'authors': ['Odin Hoff Gardaa', 'Nello Blaser'], 'affiliations': ['University of Bergen'], 'pdf_title_img': 'assets/pdf/title_img/2508.16359.jpg', 'data': {'categories': ['#optimization', '#games', '#architecture', '#cv'], 'emoji': '🔄', 'ru': {'title': 'Вращение и сдвиг не помеха: RotaTouille для анализа контуров', 'desc': 'RotaTouille - это фреймворк глубокого обучения для работы с контурными данными. Он достигает эквивариантности к вращению и циклическим сдвигам с помощью комплекснозначной круговой свертки. Фреймворк включает эквивариантные нелинейности, слои понижения размерности и глобального пулинга для получения инвариантных представлений. RotaTouille показывает эффективность в задачах классификации форм, реконструкции и регрессии контуров.'}, 'en': {'title': 'RotaTouille: Mastering Contours with Equivariance', 'desc': 'RotaTouille is a deep learning framework designed to handle contour data by ensuring that the model is equivariant to both rotations and cyclic shifts. This is achieved through the use of complex-valued circular convolution, which allows the model to maintain performance across various transformations of the input data. The framework also introduces new components like equivariant non-linearities and coarsening layers to create invariant representations for tasks such as shape classification and reconstruction. Experiments show that RotaTouille effectively improves the learning process for contour-related applications.'}, 'zh': {'title': 'RotaTouille：轮廓数据的旋转与循环移位不变性', 'desc': 'RotaTouille是一个深度学习框架，专门用于处理轮廓数据，能够实现旋转和循环移位的不变性。它通过复值圆卷积来达到这一目标，从而在形状分类、重建和轮廓回归等任务中表现出色。轮廓数据在计算机视觉和气象等多个领域中非常常见，因此模型的旋转不变性和循环移位不变性是非常重要的。RotaTouille还引入了不变的非线性层、粗化层和全局池化层，以便为后续任务提供不变的表示。'}}}, {'id': 'https://huggingface.co/papers/2508.16072', 'title': 'InMind: Evaluating LLMs in Capturing and Applying Individual Human\n  Reasoning Styles', 'url': 'https://huggingface.co/papers/2508.16072', 'abstract': "InMind evaluates LLMs' ability to capture and apply personalized reasoning styles in social deduction games, highlighting limitations in current models' adaptive reasoning.  \t\t\t\t\tAI-generated summary \t\t\t\t LLMs have shown strong performance on human-centric reasoning tasks. While previous evaluations have explored whether LLMs can infer intentions or detect deception, they often overlook the individualized reasoning styles that influence how people interpret and act in social contexts. Social deduction games (SDGs) provide a natural testbed for evaluating individualized reasoning styles, where different players may adopt diverse but contextually valid reasoning strategies under identical conditions. To address this, we introduce InMind, a cognitively grounded evaluation framework designed to assess whether LLMs can capture and apply personalized reasoning styles in SDGs. InMind enhances structured gameplay data with round-level strategy traces and post-game reflections, collected under both Observer and Participant modes. It supports four cognitively motivated tasks that jointly evaluate both static alignment and dynamic adaptation. As a case study, we apply InMind to the game Avalon, evaluating 11 state-of-the-art LLMs. General-purpose LLMs, even GPT-4o frequently rely on lexical cues, struggling to anchor reflections in temporal gameplay or adapt to evolving strategies. In contrast, reasoning-enhanced LLMs like DeepSeek-R1 exhibit early signs of style-sensitive reasoning. These findings reveal key limitations in current LLMs' capacity for individualized, adaptive reasoning, and position InMind as a step toward cognitively aligned human-AI interaction.", 'score': 0, 'issue_id': 5518, 'pub_date': '2025-08-22', 'pub_date_card': {'ru': '22 августа', 'en': 'August 22', 'zh': '8月22日'}, 'hash': '1987a0ba86bfb9ad', 'authors': ['Zizhen Li', 'Chuanhao Li', 'Yibin Wang', 'Qi Chen', 'Diping Song', 'Yukang Feng', 'Jianwen Sun', 'Jiaxin Ai', 'Fanrui Zhang', 'Mingzhu Sun', 'Kaipeng Zhang'], 'affiliations': ['Fudan University', 'Johns Hopkins University', 'Nankai University', 'Shanghai AI Laboratory', 'Shanghai Innovation Institute', 'University of Science and Technology of China', 'Wuhan University'], 'pdf_title_img': 'assets/pdf/title_img/2508.16072.jpg', 'data': {'categories': ['#benchmark', '#multimodal', '#games', '#reasoning'], 'emoji': '🧠', 'ru': {'title': 'Оценка индивидуальных стилей рассуждения в ИИ: ограничения и перспективы', 'desc': 'Статья представляет InMind - систему оценки способности языковых моделей (LLM) улавливать и применять индивидуальные стили рассуждений в играх с социальной дедукцией. Исследование выявило, что большинство современных LLM, включая GPT-4, часто опираются на лексические подсказки и испытывают трудности с адаптацией к меняющимся стратегиям. Модели, усиленные возможностями рассуждения, такие как DeepSeek-R1, показывают первые признаки рассуждений, чувствительных к индивидуальному стилю. Результаты указывают на ограничения текущих LLM в индивидуализированном адаптивном рассуждении.'}, 'en': {'title': 'InMind: Evaluating Personalized Reasoning in AI for Social Deduction Games', 'desc': 'The paper introduces InMind, a framework for evaluating large language models (LLMs) on their ability to understand and apply personalized reasoning styles in social deduction games (SDGs). It highlights that while LLMs perform well in human-centric reasoning tasks, they often fail to adapt to the unique reasoning strategies that different players use in similar situations. By analyzing gameplay data and player reflections, InMind assesses both static alignment and dynamic adaptation of reasoning styles. The study finds that many general-purpose LLMs struggle with individualized reasoning, while some enhanced models show potential for better adaptation to diverse reasoning styles.'}, 'zh': {'title': '评估个性化推理风格的InMind框架', 'desc': 'InMind是一个评估大型语言模型（LLMs）在社交推理游戏中捕捉和应用个性化推理风格能力的框架。当前的模型在适应性推理方面存在局限，尤其是在处理个体化推理风格时。通过在社交推理游戏中引入结构化的游戏数据和策略追踪，InMind能够更好地评估LLMs的推理能力。研究表明，尽管一些先进的LLMs表现出一定的推理能力，但仍然在个性化和动态适应性推理方面存在不足。'}}}, {'id': 'https://huggingface.co/papers/2508.15868', 'title': 'CARFT: Boosting LLM Reasoning via Contrastive Learning with Annotated\n  Chain-of-Thought-based Reinforced Fine-Tuning', 'url': 'https://huggingface.co/papers/2508.15868', 'abstract': 'A contrastive learning approach with annotated Chain-of-Thought enhances the reasoning performance of Large Language Models through stable fine-tuning and robust contrastive signals.  \t\t\t\t\tAI-generated summary \t\t\t\t Reasoning capability plays a significantly critical role in the the broad applications of Large Language Models (LLMs). To enhance the reasoning performance of LLMs, diverse Reinforcement Learning (RL)-based fine-tuning approaches have been proposed to address the limited generalization capability of LLMs trained solely via Supervised Fine-Tuning (SFT). Despite their effectiveness, two major limitations hinder the advancement of LLMs. First, vanilla RL-based approaches ignore annotated Chain-of-Thought (CoT) and incorporate unstable reasoning path sampling, which typically results in model collapse, unstable training process, and suboptimal performance. Second, existing SFT approaches generally overemphasize the annotated CoT, potentially leading to performance degradation due to insufficient exploitation of potential CoT. In this paper, we propose a Contrastive learning with annotated CoT-based Reinforced Fine-Tuning approach, i.e., , to enhance the reasoning performance of LLMs while addressing the aforementioned limitations. Specifically, we propose learning a representation for each CoT. Based on this representation, we design novel contrastive signals to guide the fine-tuning process. Our approach not only fully exploits the available annotated CoT but also stabilizes the fine-tuning procedure by incorporating an additional unsupervised learning signal. We conduct comprehensive experiments and in-depth analysis with three baseline approaches, two foundation models, and two datasets to demonstrate significant advantages of  in terms of robustness, performance (up to 10.15\\%), and efficiency (up to 30.62\\%). Code is available at https://github.com/WNQzhu/CARFT.', 'score': 0, 'issue_id': 5525, 'pub_date': '2025-08-21', 'pub_date_card': {'ru': '21 августа', 'en': 'August 21', 'zh': '8月21日'}, 'hash': '47b82f30fedd191b', 'authors': ['Wenqiao Zhu', 'Ji Liu', 'Rongjuncheng Zhang', 'Haipang Wu', 'Yulun Zhang'], 'affiliations': ['HiThink Research', 'Shanghai Jiao Tong University'], 'pdf_title_img': 'assets/pdf/title_img/2508.15868.jpg', 'data': {'categories': ['#training', '#rl', '#reasoning', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'Контрастное обучение с CoT: новый шаг в улучшении рассуждений LLM', 'desc': 'Статья представляет новый подход к улучшению способностей рассуждения больших языковых моделей (LLM) с использованием контрастного обучения и аннотированной цепочки рассуждений (CoT). Метод, названный CARFT, сочетает в себе преимущества обучения с подкреплением и обучения с учителем, избегая при этом их недостатков. CARFT использует представления для каждой CoT и новые контрастные сигналы для стабилизации процесса дообучения. Эксперименты показывают значительное улучшение производительности и эффективности по сравнению с базовыми подходами.'}, 'en': {'title': 'Enhancing LLM Reasoning with Contrastive Learning and Chain-of-Thought', 'desc': 'This paper introduces a new method called Contrastive learning with annotated Chain-of-Thought (CoT) for improving the reasoning abilities of Large Language Models (LLMs). The authors highlight the limitations of existing Reinforcement Learning (RL) methods, which often overlook the importance of annotated CoT and can lead to unstable training. Their approach stabilizes the fine-tuning process by using contrastive signals that leverage both annotated and unsupervised learning. Experimental results show that this method significantly enhances the robustness and performance of LLMs compared to traditional techniques.'}, 'zh': {'title': '对比学习提升推理能力的创新方法', 'desc': '本文提出了一种基于对比学习的增强型强化微调方法，旨在提升大型语言模型（LLMs）的推理能力。该方法利用注释的思维链（CoT）来稳定微调过程，并通过新颖的对比信号来指导训练。与传统的强化学习方法相比，我们的方法能够充分利用可用的注释CoT，同时避免模型崩溃和训练不稳定的问题。实验结果表明，该方法在鲁棒性、性能和效率方面均有显著提升。'}}}, {'id': 'https://huggingface.co/papers/2508.13797', 'title': 'Sketch3DVE: Sketch-based 3D-Aware Scene Video Editing', 'url': 'https://huggingface.co/papers/2508.13797', 'abstract': 'Sketch3DVE is a sketch-based 3D-aware video editing method that uses dense stereo estimation, point cloud editing, and a video diffusion model to handle sparse inputs and viewpoint changes in video editing.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent video editing methods achieve attractive results in style transfer or appearance modification. However, editing the structural content of 3D scenes in videos remains challenging, particularly when dealing with significant viewpoint changes, such as large camera rotations or zooms. Key challenges include generating novel view content that remains consistent with the original video, preserving unedited regions, and translating sparse 2D inputs into realistic 3D video outputs. To address these issues, we propose Sketch3DVE, a sketch-based 3D-aware video editing method to enable detailed local manipulation of videos with significant viewpoint changes. To solve the challenge posed by sparse inputs, we employ image editing methods to generate edited results for the first frame, which are then propagated to the remaining frames of the video. We utilize sketching as an interaction tool for precise geometry control, while other mask-based image editing methods are also supported. To handle viewpoint changes, we perform a detailed analysis and manipulation of the 3D information in the video. Specifically, we utilize a dense stereo method to estimate a point cloud and the camera parameters of the input video. We then propose a point cloud editing approach that uses depth maps to represent the 3D geometry of newly edited components, aligning them effectively with the original 3D scene. To seamlessly merge the newly edited content with the original video while preserving the features of unedited regions, we introduce a 3D-aware mask propagation strategy and employ a video diffusion model to produce realistic edited videos. Extensive experiments demonstrate the superiority of Sketch3DVE in video editing. Homepage and code: http://http://geometrylearning.com/Sketch3DVE/', 'score': 0, 'issue_id': 5528, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': '214d175c6e1f5020', 'authors': ['Feng-Lin Liu', 'Shi-Yang Li', 'Yan-Pei Cao', 'Hongbo Fu', 'Lin Gao'], 'affiliations': ['Hong Kong University of Science and Technology, China', 'Institute of Computing Technology, Chinese Academy of Sciences, China', 'University of Chinese Academy of Sciences, China', 'VAST, China'], 'pdf_title_img': 'assets/pdf/title_img/2508.13797.jpg', 'data': {'categories': ['#video', '#games', '#diffusion', '#3d'], 'emoji': '✏️', 'ru': {'title': 'Редактирование видео с учетом 3D-структуры с помощью эскизов', 'desc': 'Sketch3DVE - это метод редактирования видео на основе эскизов, учитывающий 3D-структуру сцены. Он использует плотную стереооценку, редактирование облака точек и диффузионную модель видео для работы с разреженными входными данными и изменениями ракурса. Метод позволяет выполнять детальные локальные манипуляции с видео при значительных изменениях точки обзора, таких как большие повороты камеры или зумирование. Sketch3DVE применяет анализ и манипуляцию 3D-информацией в видео для обеспечения согласованности редактирования при изменении ракурса.'}, 'en': {'title': 'Revolutionizing Video Editing with 3D Sketch Manipulation', 'desc': 'Sketch3DVE is a novel method for editing videos that allows users to manipulate 3D structures using sketches. It addresses the challenges of viewpoint changes and sparse inputs by employing dense stereo estimation to create a point cloud representation of the video. The method enables precise editing by propagating changes from the first frame to subsequent frames while maintaining the integrity of unedited areas. By integrating a video diffusion model, Sketch3DVE produces realistic outputs that align new edits with the original 3D scene.'}, 'zh': {'title': 'Sketch3DVE：创新的3D视频编辑方法', 'desc': 'Sketch3DVE是一种基于草图的3D视频编辑方法，能够处理视频编辑中的稀疏输入和视角变化。该方法通过密集立体估计和点云编辑，生成与原始视频一致的新视角内容。用户可以通过草图进行精确的几何控制，同时支持其他基于掩膜的图像编辑方法。最终，Sketch3DVE结合视频扩散模型，生成真实感强的编辑视频，展示了其在视频编辑中的优越性。'}}}, {'id': 'https://huggingface.co/papers/2508.13562', 'title': 'Learnable SMPLify: A Neural Solution for Optimization-Free Human Pose\n  Inverse Kinematics', 'url': 'https://huggingface.co/papers/2508.13562', 'abstract': 'Learnable SMPLify replaces iterative optimization in SMPLify with a neural network for faster and more generalized 3D human pose and shape estimation.  \t\t\t\t\tAI-generated summary \t\t\t\t In 3D human pose and shape estimation, SMPLify remains a robust baseline that solves inverse kinematics (IK) through iterative optimization. However, its high computational cost limits its practicality. Recent advances across domains have shown that replacing iterative optimization with data-driven neural networks can achieve significant runtime improvements without sacrificing accuracy. Motivated by this trend, we propose Learnable SMPLify, a neural framework that replaces the iterative fitting process in SMPLify with a single-pass regression model. The design of our framework targets two core challenges in neural IK: data construction and generalization. To enable effective training, we propose a temporal sampling strategy that constructs initialization-target pairs from sequential frames. To improve generalization across diverse motions and unseen poses, we propose a human-centric normalization scheme and residual learning to narrow the solution space. Learnable SMPLify supports both sequential inference and plug-in post-processing to refine existing image-based estimators. Extensive experiments demonstrate that our method establishes itself as a practical and simple baseline: it achieves nearly 200x faster runtime compared to SMPLify, generalizes well to unseen 3DPW and RICH, and operates in a model-agnostic manner when used as a plug-in tool on LucidAction. The code is available at https://github.com/Charrrrrlie/Learnable-SMPLify.', 'score': 0, 'issue_id': 5523, 'pub_date': '2025-08-19', 'pub_date_card': {'ru': '19 августа', 'en': 'August 19', 'zh': '8月19日'}, 'hash': 'b08c5280107ed4d1', 'authors': ['Yuchen Yang', 'Linfeng Dong', 'Wei Wang', 'Zhihang Zhong', 'Xiao Sun'], 'affiliations': ['Fudan University', 'Shanghai Artificial Intelligence Laboratory', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2508.13562.jpg', 'data': {'categories': ['#3d', '#data', '#training', '#optimization'], 'emoji': '🏃', 'ru': {'title': 'Быстрая и обобщаемая оценка 3D позы человека с помощью нейросетей', 'desc': 'Статья представляет Learnable SMPLify - нейросетевой подход к оценке 3D позы и формы человека. Он заменяет итеративную оптимизацию в SMPLify на однопроходную регрессионную модель, что значительно ускоряет процесс. Для эффективного обучения предложена стратегия временной выборки и нормализация, ориентированная на человека. Метод показывает 200-кратное ускорение по сравнению с SMPLify и хорошо обобщается на новые данные.'}, 'en': {'title': 'Speeding Up 3D Pose Estimation with Neural Networks', 'desc': 'Learnable SMPLify introduces a neural network approach to 3D human pose and shape estimation, replacing the traditional iterative optimization used in SMPLify. This method significantly reduces computational time while maintaining accuracy, making it more practical for real-world applications. The framework addresses key challenges in neural inverse kinematics, such as data construction and generalization, by utilizing a temporal sampling strategy and a human-centric normalization scheme. Extensive testing shows that Learnable SMPLify is nearly 200 times faster than its predecessor and effectively generalizes to new poses and motions.'}, 'zh': {'title': 'Learnable SMPLify：加速3D人体姿态估计的神经网络', 'desc': 'Learnable SMPLify 是一种新的神经网络框架，用于更快和更通用的 3D 人体姿态和形状估计。它用单次回归模型替代了 SMPLify 中的迭代优化过程，从而显著提高了运行速度。该框架通过时间采样策略构建初始化-目标对，并采用人本归一化和残差学习来改善对不同动作和未见姿态的泛化能力。实验表明，Learnable SMPLify 的运行速度比 SMPLify 快近 200 倍，并且在多种情况下表现良好。'}}}, {'id': 'https://huggingface.co/papers/2508.10390', 'title': 'Jailbreaking Commercial Black-Box LLMs with Explicitly Harmful Prompts', 'url': 'https://huggingface.co/papers/2508.10390', 'abstract': 'A hybrid framework combining LLMs and human oversight is proposed to clean datasets and detect jailbreak attacks, with new strategies to enhance jailbreak success.  \t\t\t\t\tAI-generated summary \t\t\t\t Evaluating jailbreak attacks is challenging when prompts are not overtly harmful or fail to induce harmful outputs. Unfortunately, many existing red-teaming datasets contain such unsuitable prompts. To evaluate attacks accurately, these datasets need to be assessed and cleaned for maliciousness. However, existing malicious content detection methods rely on either manual annotation, which is labor-intensive, or large language models (LLMs), which have inconsistent accuracy in harmful types. To balance accuracy and efficiency, we propose a hybrid evaluation framework named MDH (Malicious content Detection based on LLMs with Human assistance) that combines LLM-based annotation with minimal human oversight, and apply it to dataset cleaning and detection of jailbroken responses. Furthermore, we find that well-crafted developer messages can significantly boost jailbreak success, leading us to propose two new strategies: D-Attack, which leverages context simulation, and DH-CoT, which incorporates hijacked chains of thought. The Codes, datasets, judgements, and detection results will be released in github repository: https://github.com/AlienZhang1996/DH-CoT.', 'score': 0, 'issue_id': 5518, 'pub_date': '2025-08-14', 'pub_date_card': {'ru': '14 августа', 'en': 'August 14', 'zh': '8月14日'}, 'hash': 'df08ead155e89f8d', 'authors': ['Chiyu Zhang', 'Lu Zhou', 'Xiaogang Xu', 'Jiafei Wu', 'Liming Fang', 'Zhe Liu'], 'affiliations': ['Collaborative Innovation Center of Novel Software Technology and Industrialization', 'Nanjing University of Aeronautics and Astronautics', 'The Chinese University of Hong Kong', 'Zhejiang Lab'], 'pdf_title_img': 'assets/pdf/title_img/2508.10390.jpg', 'data': {'categories': ['#open_source', '#benchmark', '#data', '#security', '#dataset'], 'emoji': '🛡️', 'ru': {'title': 'Гибридный подход к обнаружению вредоносного контента и усилению jailbreak-атак', 'desc': 'Предложена гибридная система, сочетающая большие языковые модели (LLM) и человеческий контроль для очистки датасетов и обнаружения атак по обходу ограничений (jailbreak). Система MDH использует LLM для аннотации с минимальным участием человека, что позволяет эффективно оценивать и очищать наборы данных от вредоносного контента. Разработаны новые стратегии D-Attack и DH-CoT для повышения успешности jailbreak-атак с использованием контекстной симуляции и измененных цепочек рассуждений. Предложенный подход позволяет более точно оценивать jailbreak-атаки, особенно в случаях неявно вредоносных промптов.'}, 'en': {'title': 'Enhancing Dataset Integrity and Jailbreak Detection with Hybrid LLMs', 'desc': 'This paper introduces a hybrid framework called MDH that combines large language models (LLMs) with minimal human oversight to improve the detection of malicious content in datasets and evaluate jailbreak attacks. The framework addresses the limitations of existing methods, which either require extensive manual work or suffer from inconsistent accuracy. By integrating LLMs with human assistance, the proposed approach enhances the cleaning of datasets and the identification of harmful prompts. Additionally, the authors present two innovative strategies, D-Attack and DH-CoT, to increase the success rate of jailbreak attempts by utilizing context simulation and hijacked reasoning processes.'}, 'zh': {'title': '混合框架提升数据集清理与越狱检测', 'desc': '本文提出了一种混合框架，结合了大型语言模型（LLMs）和人工监督，用于清理数据集和检测越狱攻击。现有的恶意内容检测方法要么依赖人工标注，耗时耗力，要么依赖LLMs，但在识别有害类型时准确性不一致。我们提出的MDH框架通过最小化人工干预，结合LLM标注，提高了检测的准确性和效率。此外，我们发现精心设计的开发者消息可以显著提高越狱成功率，并提出了两种新策略：D-Attack和DH-CoT。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (3)', '#agents (3)', '#agi (1)', '#alignment (1)', '#architecture (4)', '#audio', '#benchmark (6)', '#cv (2)', '#data (2)', '#dataset (3)', '#diffusion (2)', '#ethics (1)', '#games (3)', '#graphs', '#hallucinations (1)', '#healthcare (1)', '#inference (1)', '#interpretability (2)', '#leakage', '#long_context (1)', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal (4)', '#open_source (1)', '#optimization (11)', '#plp', '#rag (1)', '#reasoning (6)', '#rl (4)', '#rlhf (1)', '#robotics (2)', '#science', '#security (2)', '#small_models', '#story_generation', '#survey', '#synthetic', '#training (6)', '#transfer_learning (1)', '#video (2)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-08-25 20:13',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-08-25 20:13')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-08-25 20:13')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    