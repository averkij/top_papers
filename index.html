
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 18 papers. November 8.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #0989eacf;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #f5f5f5;
            --text-color: #333333;
            --header-color: #0989eacf;
            --body-color: #f5f5f5;
            --menu-color: #002370;
        }        
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 0;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2em;
            padding: 10px 0 20px 0;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.tags {
            color: #555;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            transition: background-color 0.2s ease;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .article-content {
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
        }
        body.dark-theme>div>main>article {
            background-color: #444;
        }
        body.light-theme>div>main>article {
            background-color: #fff;
        }
        body.dark-theme>div>main>article:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
        }
        .pub-date {
            font-size: 0.9em;
            margin-bottom: 0.8em;
            font-weight: 300;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 1em;
            position: absolute;
            bottom: 10px;
            font-weight: 300;
            font-family: 'Roboto Slab';
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 80px;
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            padding: 1em 0;
            margin-top: 2em;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 0px;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }
        
        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">8 ноября</span> | <span id="title-articles-count">18 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item" id="nav-prev"><a href="/d/2024-11-07.html">⬅️ <span id="prev-date">07.11</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2024-11-11.html">➡️ <span id="next-date">11.11</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2024-11.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '8 ноября', 'en': 'November 8', 'zh': '11月8日'};
        let feedDateNext = {'ru': '11.11', 'en': '11/11', 'zh': '11月11日'};
        let feedDatePrev = {'ru': '07.11', 'en': '11/07', 'zh': '11月7日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'Статья от ', 'en': 'Published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2411.04905', 'title': 'OpenCoder: The Open Cookbook for Top-Tier Code Large Language Models', 'url': 'https://huggingface.co/papers/2411.04905', 'abstract': "Large language models (LLMs) for code have become indispensable in various domains, including code generation, reasoning tasks and agent systems.While open-access code LLMs are increasingly approaching the performance levels of proprietary models, high-quality code LLMs suitable for rigorous scientific investigation, particularly those with reproducible data processing pipelines and transparent training protocols, remain limited. The scarcity is due to various challenges, including resource constraints, ethical considerations, and the competitive advantages of keeping models advanced. To address the gap, we introduce OpenCoder, a top-tier code LLM that not only achieves performance comparable to leading models but also serves as an ``open cookbook'' for the research community. Unlike most prior efforts, we release not only model weights and inference code, but also the reproducible training data, complete data processing pipeline, rigorous experimental ablation results, and detailed training protocols for open scientific research. Through this comprehensive release, we identify the key ingredients for building a top-tier code LLM: (1) code optimized heuristic rules for data cleaning and methods for data deduplication, (2) recall of text corpus related to code and (3) high-quality synthetic data in both annealing and supervised fine-tuning stages. By offering this level of openness, we aim to broaden access to all aspects of a top-tier code LLM, with OpenCoder serving as both a powerful model and an open foundation to accelerate research, and enable reproducible advancements in code AI.", 'score': 74, 'issue_id': 465, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '799dedd6597ce7ab', 'data': {'categories': ['#dataset', '#data', '#training', '#synthetic', '#agents', '#plp'], 'emoji': '🧑\u200d💻', 'ru': {'title': 'OpenCoder: открытая книга рецептов для создания топовых языковых моделей кода', 'desc': 'OpenCoder - это высококачественная языковая модель для работы с кодом, сопоставимая по производительности с ведущими моделями. Авторы не только предоставляют веса модели и код для инференса, но и полный набор воспроизводимых данных для обучения, конвейер обработки данных и подробные протоколы обучения. Ключевыми ингредиентами для создания модели такого уровня являются оптимизированные эвристические правила очистки данных, методы дедупликации, использование текстового корпуса, связанного с кодом, и высококачественные синтетические данные. Эта открытость призвана ускорить исследования и обеспечить воспроизводимый прогресс в области ИИ для работы с кодом.'}, 'en': {'title': 'OpenCoder: Unlocking Code AI with Transparency and Reproducibility', 'desc': 'This paper introduces OpenCoder, a high-performance large language model (LLM) specifically designed for code generation and reasoning tasks. It addresses the lack of open-access models that provide reproducible data processing and transparent training protocols, which are essential for scientific research. OpenCoder not only matches the performance of proprietary models but also shares its model weights, inference code, and detailed training methodologies. By emphasizing data cleaning, corpus recall, and synthetic data generation, OpenCoder aims to enhance accessibility and foster reproducible advancements in the field of code AI.'}, 'zh': {'title': 'OpenCoder：开放的顶级代码大语言模型', 'desc': '本文介绍了OpenCoder，一个高质量的代码大语言模型（LLM），旨在为科学研究提供开放的资源。与其他模型不同，OpenCoder不仅提供模型权重和推理代码，还包括可重复的训练数据和完整的数据处理流程。我们识别出构建顶级代码LLM的关键要素，包括数据清洗的启发式规则、与代码相关的文本语料库的回忆以及高质量的合成数据。通过这种开放性，我们希望加速代码人工智能的研究和可重复的进展。'}}}, {'id': 'https://huggingface.co/papers/2411.05003', 'title': 'ReCapture: Generative Video Camera Controls for User-Provided Videos using Masked Video Fine-Tuning', 'url': 'https://huggingface.co/papers/2411.05003', 'abstract': 'Recently, breakthroughs in video modeling have allowed for controllable camera trajectories in generated videos. However, these methods cannot be directly applied to user-provided videos that are not generated by a video model. In this paper, we present ReCapture, a method for generating new videos with novel camera trajectories from a single user-provided video. Our method allows us to re-generate the reference video, with all its existing scene motion, from vastly different angles and with cinematic camera motion. Notably, using our method we can also plausibly hallucinate parts of the scene that were not observable in the reference video. Our method works by (1) generating a noisy anchor video with a new camera trajectory using multiview diffusion models or depth-based point cloud rendering and then (2) regenerating the anchor video into a clean and temporally consistent reangled video using our proposed masked video fine-tuning technique.', 'score': 55, 'issue_id': 464, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'f71f2e0f1addbe57', 'data': {'categories': ['#video', '#diffusion', '#hallucinations'], 'emoji': '🎥', 'ru': {'title': 'Переснимаем реальность: новые ракурсы для любого видео', 'desc': 'ReCapture - это метод генерации новых видео с измененными траекториями камеры на основе одного пользовательского видео. Он позволяет перегенерировать исходное видео с другими углами обзора и кинематографическим движением камеры, включая правдоподобное восстановление невидимых частей сцены. Метод работает в два этапа: сначала создается шумное опорное видео с новой траекторией камеры, а затем оно очищается и делается временно согласованным. ReCapture использует мультивидовые диффузионные модели и рендеринг облака точек на основе глубины.'}, 'en': {'title': 'ReCapture: Transforming User Videos with New Camera Perspectives', 'desc': 'This paper introduces ReCapture, a novel method for generating new videos with different camera angles from a single user-provided video. It leverages multiview diffusion models and depth-based point cloud rendering to create an initial noisy video with a new camera trajectory. The method then refines this video using a masked video fine-tuning technique to ensure temporal consistency and clarity. Additionally, ReCapture can convincingly generate parts of the scene that were not visible in the original video, enhancing the overall viewing experience.'}, 'zh': {'title': 'ReCapture：从用户视频生成新视角的魔法', 'desc': '最近在视频建模方面取得了突破，使得生成视频中的相机轨迹可控。然而，这些方法无法直接应用于用户提供的非生成视频。本文提出了一种名为ReCapture的方法，可以从单个用户提供的视频生成具有新相机轨迹的新视频。该方法不仅能够从不同角度重新生成参考视频，还能合理地幻觉出参考视频中不可见的场景部分。'}}}, {'id': 'https://huggingface.co/papers/2411.04965', 'title': 'BitNet a4.8: 4-bit Activations for 1-bit LLMs', 'url': 'https://huggingface.co/papers/2411.04965', 'abstract': 'Recent research on the 1-bit Large Language Models (LLMs), such as BitNet b1.58, presents a promising direction for reducing the inference cost of LLMs while maintaining their performance. In this work, we introduce BitNet a4.8, enabling 4-bit activations for 1-bit LLMs. BitNet a4.8 employs a hybrid quantization and sparsification strategy to mitigate the quantization errors introduced by the outlier channels. Specifically, we utilize 4-bit activations for inputs to the attention and feed-forward network layers, while sparsifying intermediate states followed with 8-bit quantization. Extensive experiments demonstrate that BitNet a4.8 achieves performance comparable to BitNet b1.58 with equivalent training costs, while being faster in inference with enabling 4-bit (INT4/FP4) kernels. Additionally, BitNet a4.8 activates only 55% of parameters and supports 3-bit KV cache, further enhancing the efficiency of large-scale LLM deployment and inference.', 'score': 48, 'issue_id': 466, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'dcfd440f9caf6714', 'data': {'categories': ['#inference', '#optimization', '#architecture'], 'emoji': '🧠', 'ru': {'title': 'BitNet a4.8: Эффективность и производительность в мире языковых моделей', 'desc': 'Статья представляет BitNet a4.8 - усовершенствованную версию 1-битной языковой модели. Эта модель использует 4-битные активации для входных данных в слоях внимания и прямой связи, а также применяет разреживание и 8-битное квантование для промежуточных состояний. Эксперименты показывают, что BitNet a4.8 достигает производительности, сравнимой с BitNet b1.58, при эквивалентных затратах на обучение, но с более быстрым выводом. Модель активирует только 55% параметров и поддерживает 3-битный KV-кэш, повышая эффективность развертывания и вывода крупномасштабных языковых моделей.'}, 'en': {'title': 'Efficient Inference with 4-bit Activations in LLMs', 'desc': 'This paper introduces BitNet a4.8, a new model that enhances the efficiency of 1-bit Large Language Models (LLMs) by using 4-bit activations. It combines hybrid quantization and sparsification techniques to reduce errors from outlier channels, allowing for better performance. The model uses 4-bit activations in key layers while applying 8-bit quantization to intermediate states, resulting in faster inference times. Experiments show that BitNet a4.8 matches the performance of its predecessor, BitNet b1.58, while being more efficient in terms of parameter activation and supporting a 3-bit key-value cache.'}, 'zh': {'title': '提升大型语言模型推理效率的新方法', 'desc': '最近关于1位大型语言模型（LLMs）的研究，如BitNet b1.58，展示了在保持性能的同时降低推理成本的前景。本文介绍了BitNet a4.8，支持1位LLMs的4位激活。BitNet a4.8采用混合量化和稀疏化策略，以减轻由异常通道引入的量化误差。实验表明，BitNet a4.8在训练成本相当的情况下，推理速度更快，且仅激活55%的参数，支持3位KV缓存，进一步提高了大规模LLM的部署和推理效率。'}}}, {'id': 'https://huggingface.co/papers/2411.04928', 'title': 'DimensionX: Create Any 3D and 4D Scenes from a Single Image with Controllable Video Diffusion', 'url': 'https://huggingface.co/papers/2411.04928', 'abstract': 'In this paper, we introduce DimensionX, a framework designed to generate photorealistic 3D and 4D scenes from just a single image with video diffusion. Our approach begins with the insight that both the spatial structure of a 3D scene and the temporal evolution of a 4D scene can be effectively represented through sequences of video frames. While recent video diffusion models have shown remarkable success in producing vivid visuals, they face limitations in directly recovering 3D/4D scenes due to limited spatial and temporal controllability during generation. To overcome this, we propose ST-Director, which decouples spatial and temporal factors in video diffusion by learning dimension-aware LoRAs from dimension-variant data. This controllable video diffusion approach enables precise manipulation of spatial structure and temporal dynamics, allowing us to reconstruct both 3D and 4D representations from sequential frames with the combination of spatial and temporal dimensions. Additionally, to bridge the gap between generated videos and real-world scenes, we introduce a trajectory-aware mechanism for 3D generation and an identity-preserving denoising strategy for 4D generation. Extensive experiments on various real-world and synthetic datasets demonstrate that DimensionX achieves superior results in controllable video generation, as well as in 3D and 4D scene generation, compared with previous methods.', 'score': 30, 'issue_id': 466, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'b0958f934bc56a95', 'data': {'categories': ['#3d', '#video', '#synthetic'], 'emoji': '🎭', 'ru': {'title': 'От 2D к 4D: DimensionX раздвигает границы генеративных моделей', 'desc': 'DimensionX - это фреймворк для генерации фотореалистичных 3D и 4D сцен из одного изображения с помощью видео-диффузии. Ключевым компонентом является ST-Director, который разделяет пространственные и временные факторы в видео-диффузии, обучая размерно-зависимые LoRA на данных с различными измерениями. Для 3D генерации используется механизм, учитывающий траекторию, а для 4D - стратегия шумоподавления, сохраняющая идентичность. Эксперименты показывают превосходство DimensionX в контролируемой генерации видео и создании 3D/4D сцен по сравнению с существующими методами.'}, 'en': {'title': 'Transforming Single Images into Stunning 3D and 4D Worlds!', 'desc': 'DimensionX is a novel framework that generates photorealistic 3D and 4D scenes from a single image using video diffusion techniques. It addresses the limitations of existing video diffusion models by introducing ST-Director, which separates spatial and temporal factors, allowing for better control over the generated scenes. By learning dimension-aware Low-Rank Adaptations (LoRAs) from diverse data, DimensionX enhances the manipulation of both spatial structures and temporal dynamics. The framework also incorporates a trajectory-aware mechanism and an identity-preserving denoising strategy to improve the realism of generated scenes, outperforming previous methods in extensive experiments.'}, 'zh': {'title': 'DimensionX：从单图像生成真实3D和4D场景的创新框架', 'desc': '本文介绍了DimensionX，一个框架，旨在通过单张图像和视频扩散生成逼真的3D和4D场景。我们的方法利用视频帧序列有效表示3D场景的空间结构和4D场景的时间演变。为了解决现有视频扩散模型在生成过程中空间和时间可控性不足的问题，我们提出了ST-Director，通过从维度变化的数据中学习维度感知的LoRA，解耦空间和时间因素。实验结果表明，DimensionX在可控视频生成以及3D和4D场景生成方面优于以往的方法。'}}}, {'id': 'https://huggingface.co/papers/2411.04996', 'title': 'Mixture-of-Transformers: A Sparse and Scalable Architecture for Multi-Modal Foundation Models', 'url': 'https://huggingface.co/papers/2411.04996', 'abstract': "The development of large language models (LLMs) has expanded to multi-modal systems capable of processing text, images, and speech within a unified framework. Training these models demands significantly larger datasets and computational resources compared to text-only LLMs. To address the scaling challenges, we introduce Mixture-of-Transformers (MoT), a sparse multi-modal transformer architecture that significantly reduces pretraining computational costs. MoT decouples non-embedding parameters of the model by modality -- including feed-forward networks, attention matrices, and layer normalization -- enabling modality-specific processing with global self-attention over the full input sequence. We evaluate MoT across multiple settings and model scales. In the Chameleon 7B setting (autoregressive text-and-image generation), MoT matches the dense baseline's performance using only 55.8\\% of the FLOPs. When extended to include speech, MoT reaches speech performance comparable to the dense baseline with only 37.2\\% of the FLOPs. In the Transfusion setting, where text and image are trained with different objectives, a 7B MoT model matches the image modality performance of the dense baseline with one third of the FLOPs, and a 760M MoT model outperforms a 1.4B dense baseline across key image generation metrics. System profiling further highlights MoT's practical benefits, achieving dense baseline image quality in 47.2\\% of the wall-clock time and text quality in 75.6\\% of the wall-clock time (measured on AWS p4de.24xlarge instances with NVIDIA A100 GPUs).", 'score': 28, 'issue_id': 465, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '53d29fd65eda072e', 'data': {'categories': ['#architecture', '#multimodal', '#training', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'Эффективные мультимодальные трансформеры: меньше вычислений, та же мощность', 'desc': 'Эта статья представляет Mixture-of-Transformers (MoT) - новую архитектуру для мультимодальных языковых моделей, которая значительно снижает вычислительные затраты при предобучении. MoT разделяет параметры модели по модальностям, позволяя эффективно обрабатывать текст, изображения и речь в единой системе. Эксперименты показывают, что MoT достигает производительности плотных базовых моделей, используя значительно меньше вычислительных ресурсов. Это позволяет создавать более эффективные мультимодальные системы искусственного интеллекта.'}, 'en': {'title': 'Efficient Multi-Modal Processing with Mixture-of-Transformers', 'desc': 'This paper presents Mixture-of-Transformers (MoT), a novel sparse multi-modal transformer architecture designed to efficiently handle text, images, and speech. By decoupling non-embedding parameters by modality, MoT allows for specialized processing while maintaining global self-attention across the entire input. The architecture significantly reduces computational costs, achieving comparable performance to dense models with fewer floating point operations (FLOPs). Evaluations show that MoT not only matches but often outperforms dense baselines in various settings, demonstrating its effectiveness in multi-modal tasks.'}, 'zh': {'title': '混合变换器：高效的多模态学习新方案', 'desc': '本论文介绍了一种新的稀疏多模态变换器架构，称为混合变换器（MoT），旨在降低大语言模型的预训练计算成本。MoT通过模态解耦模型的非嵌入参数，使得不同模态（如文本、图像和语音）可以进行特定处理，同时保持全局自注意力机制。实验结果表明，MoT在多个设置下表现出色，能够以更少的计算资源达到与密集基线相当的性能。该模型在图像生成和语音处理任务中均展现了显著的效率优势，证明了其在多模态学习中的潜力。'}}}, {'id': 'https://huggingface.co/papers/2411.04709', 'title': 'TIP-I2V: A Million-Scale Real Text and Image Prompt Dataset for Image-to-Video Generation', 'url': 'https://huggingface.co/papers/2411.04709', 'abstract': 'Video generation models are revolutionizing content creation, with image-to-video models drawing increasing attention due to their enhanced controllability, visual consistency, and practical applications. However, despite their popularity, these models rely on user-provided text and image prompts, and there is currently no dedicated dataset for studying these prompts. In this paper, we introduce TIP-I2V, the first large-scale dataset of over 1.70 million unique user-provided Text and Image Prompts specifically for Image-to-Video generation. Additionally, we provide the corresponding generated videos from five state-of-the-art image-to-video models. We begin by outlining the time-consuming and costly process of curating this large-scale dataset. Next, we compare TIP-I2V to two popular prompt datasets, VidProM (text-to-video) and DiffusionDB (text-to-image), highlighting differences in both basic and semantic information. This dataset enables advancements in image-to-video research. For instance, to develop better models, researchers can use the prompts in TIP-I2V to analyze user preferences and evaluate the multi-dimensional performance of their trained models; and to enhance model safety, they may focus on addressing the misinformation issue caused by image-to-video models. The new research inspired by TIP-I2V and the differences with existing datasets emphasize the importance of a specialized image-to-video prompt dataset. The project is publicly available at https://tip-i2v.github.io.', 'score': 20, 'issue_id': 464, 'pub_date': '2024-11-05', 'pub_date_card': {'ru': '5 ноября', 'en': 'November 5', 'zh': '11月5日'}, 'hash': 'fcc8e4daf79a82b9', 'data': {'categories': ['#dataset', '#video'], 'emoji': '🎬', 'ru': {'title': 'TIP-I2V: Революция в изучении промптов для генерации видео из изображений', 'desc': 'Исследователи представили TIP-I2V - первый крупномасштабный набор данных, содержащий более 1,70 миллиона уникальных пользовательских текстовых и изображений-промптов для генерации видео из изображений. Датасет также включает соответствующие сгенерированные видео от пяти современных моделей преобразования изображений в видео. TIP-I2V позволяет анализировать предпочтения пользователей, оценивать многомерную производительность обученных моделей и решать проблемы безопасности, связанные с дезинформацией. Этот набор данных подчеркивает важность специализированного датасета промптов для генерации видео из изображений и открывает новые возможности для исследований в этой области.'}, 'en': {'title': 'Empowering Image-to-Video Generation with TIP-I2V Dataset', 'desc': 'This paper presents TIP-I2V, the first large-scale dataset containing over 1.70 million unique user-provided text and image prompts for image-to-video generation. The dataset aims to enhance the controllability and visual consistency of video generation models by providing a rich source of prompts. It also includes generated videos from five advanced image-to-video models, facilitating comparative analysis and model evaluation. By addressing the lack of dedicated datasets, TIP-I2V supports research in user preferences and model safety, particularly in mitigating misinformation issues.'}, 'zh': {'title': 'TIP-I2V：图像到视频生成的新数据集', 'desc': '视频生成模型正在改变内容创作，图像到视频模型因其更好的可控性和视觉一致性而受到关注。尽管这些模型很受欢迎，但目前缺乏专门用于研究用户提供的文本和图像提示的数据集。本文介绍了TIP-I2V，这是第一个大规模的数据集，包含超过170万个独特的用户提供的文本和图像提示，专门用于图像到视频生成。该数据集的推出将推动图像到视频研究的进展，帮助研究人员分析用户偏好并评估模型性能。'}}}, {'id': 'https://huggingface.co/papers/2411.05000', 'title': 'Needle Threading: Can LLMs Follow Threads through Near-Million-Scale Haystacks?', 'url': 'https://huggingface.co/papers/2411.05000', 'abstract': 'As the context limits of Large Language Models (LLMs) increase, the range of possible applications and downstream functions broadens. In many real-world tasks, decisions depend on details scattered across collections of often disparate documents containing mostly irrelevant information. Long-context LLMs appear well-suited to this form of complex information retrieval and reasoning, which has traditionally proven costly and time-consuming. However, although the development of longer context models has seen rapid gains in recent years, our understanding of how effectively LLMs use their context has not kept pace. To address this, we conduct a set of retrieval experiments designed to evaluate the capabilities of 17 leading LLMs, such as their ability to follow threads of information through the context window. Strikingly, we find that many models are remarkably threadsafe: capable of simultaneously following multiple threads without significant loss in performance. Still, for many models, we find the effective context limit is significantly shorter than the supported context length, with accuracy decreasing as the context window grows. Our study also highlights the important point that token counts from different tokenizers should not be directly compared -- they often correspond to substantially different numbers of written characters. We release our code and long-context experimental data.', 'score': 15, 'issue_id': 474, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '72ef4dc00d41e203', 'data': {'categories': ['#benchmark', '#multimodal', '#dataset', '#long_context'], 'emoji': '🧵', 'ru': {'title': 'Языковые модели в лабиринте длинного контекста: нити информации и границы понимания', 'desc': 'Исследование посвящено анализу способностей современных языковых моделей (LLM) эффективно использовать увеличенный контекст. Авторы провели серию экспериментов по извлечению информации, оценивая 17 ведущих LLM на способность следовать нескольким информационным потокам в контексте. Результаты показали, что многие модели способны эффективно обрабатывать несколько потоков одновременно, но для некоторых моделей эффективная длина контекста оказалась значительно меньше заявленной. Исследование также подчеркивает важность учета различий в токенизации при сравнении моделей.'}, 'en': {'title': 'Unlocking the Potential of Long-Context LLMs', 'desc': 'This paper investigates how well large language models (LLMs) can utilize their extended context capabilities for complex information retrieval and reasoning tasks. The authors conduct experiments with 17 leading LLMs to assess their ability to track multiple threads of information within their context windows. They discover that while many models can maintain performance across various threads, the effective context limit is often shorter than the maximum supported length, leading to decreased accuracy with larger contexts. Additionally, the study emphasizes the need for caution when comparing token counts from different tokenizers, as they can represent different amounts of text.'}, 'zh': {'title': '长上下文模型的潜力与挑战', 'desc': '随着大型语言模型（LLMs）上下文限制的增加，应用范围和下游功能也在扩大。许多现实任务的决策依赖于分散在不同文档中的细节，这些文档通常包含大量无关信息。长上下文LLMs在复杂信息检索和推理方面表现出色，但我们对它们如何有效利用上下文的理解仍然滞后。我们的实验表明，尽管许多模型在跟踪信息线程方面表现良好，但有效的上下文限制往往比支持的上下文长度要短，且随着上下文窗口的增大，准确性会下降。'}}}, {'id': 'https://huggingface.co/papers/2411.04496', 'title': 'Thanos: Enhancing Conversational Agents with Skill-of-Mind-Infused Large Language Model', 'url': 'https://huggingface.co/papers/2411.04496', 'abstract': 'To increase social bonding with interlocutors, humans naturally acquire the ability to respond appropriately in a given situation by considering which conversational skill is most suitable for the response - a process we call skill-of-mind. For large language model (LLM)-based conversational agents, planning appropriate conversational skills, as humans do, is challenging due to the complexity of social dialogue, especially in interactive scenarios. To address this, we propose a skill-of-mind-annotated conversation dataset, named Multifaceted Skill-of-Mind, which includes multi-turn and multifaceted conversational skills across various interactive scenarios (e.g., long-term, counseling, task-oriented), grounded in diverse social contexts (e.g., demographics, persona, rules of thumb). This dataset consists of roughly 100K conversations. Using this dataset, we introduce a new family of skill-of-mind-infused LLMs, named Thanos, with model sizes of 1B, 3B, and 8B parameters. With extensive experiments, these models successfully demonstrate the skill-of-mind process and exhibit strong generalizability in inferring multifaceted skills across a variety of domains. Moreover, we show that Thanos significantly enhances the quality of responses generated by LLM-based conversational agents and promotes prosocial behavior in human evaluations.', 'score': 15, 'issue_id': 466, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'bf7486353434568f', 'data': {'categories': ['#dataset', '#agents', '#multimodal'], 'emoji': '🗣️', 'ru': {'title': 'Языковые модели учатся искусству общения', 'desc': 'Исследователи представили новый набор данных под названием Multifaceted Skill-of-Mind, содержащий аннотации навыков ведения диалога в различных интерактивных сценариях. На основе этого набора данных была разработана серия языковых моделей Thanos, способных выбирать подходящие навыки общения в зависимости от контекста. Эксперименты показали, что модели Thanos успешно демонстрируют процесс выбора навыков и обладают хорошей обобщающей способностью в различных областях. Кроме того, использование Thanos значительно улучшило качество ответов диалоговых агентов на основе больших языковых моделей и способствовало более просоциальному поведению по оценкам людей.'}, 'en': {'title': 'Enhancing Conversational Skills in AI with Thanos', 'desc': 'This paper introduces a new dataset called Multifaceted Skill-of-Mind, which helps large language models (LLMs) learn how to respond appropriately in social conversations. The dataset contains around 100,000 conversations that cover various interactive scenarios and social contexts, allowing LLMs to understand different conversational skills. The authors also present a new family of LLMs named Thanos, which are designed to incorporate these skills into their responses. Through experiments, Thanos models show improved response quality and promote positive social interactions in conversations.'}, 'zh': {'title': '提升对话质量的技能思维模型', 'desc': '本文提出了一种名为多面技能思维的对话数据集，旨在帮助大型语言模型（LLM）更好地理解和应用社交对话中的适当回应技能。该数据集包含约10万条对话，涵盖了多轮和多方面的对话技能，适用于不同的互动场景，如长期对话、咨询和任务导向。我们还介绍了一种新的LLM家族，名为Thanos，具有1B、3B和8B参数规模，能够有效地展示技能思维过程，并在多种领域中推断多面技能。实验结果表明，Thanos显著提高了LLM对话代理生成的回应质量，并在人工评估中促进了亲社会行为。'}}}, {'id': 'https://huggingface.co/papers/2411.04952', 'title': 'M3DocRAG: Multi-modal Retrieval is What You Need for Multi-page Multi-document Understanding', 'url': 'https://huggingface.co/papers/2411.04952', 'abstract': 'Document visual question answering (DocVQA) pipelines that answer questions from documents have broad applications. Existing methods focus on handling single-page documents with multi-modal language models (MLMs), or rely on text-based retrieval-augmented generation (RAG) that uses text extraction tools such as optical character recognition (OCR). However, there are difficulties in applying these methods in real-world scenarios: (a) questions often require information across different pages or documents, where MLMs cannot handle many long documents; (b) documents often have important information in visual elements such as figures, but text extraction tools ignore them. We introduce M3DocRAG, a novel multi-modal RAG framework that flexibly accommodates various document contexts (closed-domain and open-domain), question hops (single-hop and multi-hop), and evidence modalities (text, chart, figure, etc.). M3DocRAG finds relevant documents and answers questions using a multi-modal retriever and an MLM, so that it can efficiently handle single or many documents while preserving visual information. Since previous DocVQA datasets ask questions in the context of a specific document, we also present M3DocVQA, a new benchmark for evaluating open-domain DocVQA over 3,000+ PDF documents with 40,000+ pages. In three benchmarks (M3DocVQA/MMLongBench-Doc/MP-DocVQA), empirical results show that M3DocRAG with ColPali and Qwen2-VL 7B achieves superior performance than many strong baselines, including state-of-the-art performance in MP-DocVQA. We provide comprehensive analyses of different indexing, MLMs, and retrieval models. Lastly, we qualitatively show that M3DocRAG can successfully handle various scenarios, such as when relevant information exists across multiple pages and when answer evidence only exists in images.', 'score': 14, 'issue_id': 477, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '56e0d2f2775dbda9', 'data': {'categories': ['#benchmark', '#rag', '#dataset', '#multimodal', '#games', '#long_context'], 'emoji': '📄', 'ru': {'title': 'M3DocRAG: Мультимодальные ответы на вопросы по документам нового поколения', 'desc': 'Статья представляет M3DocRAG - новую мультимодальную систему для ответов на вопросы по документам. Она использует мультимодальный ретривер и мультимодальную языковую модель для эффективной обработки одного или нескольких документов с сохранением визуальной информации. M3DocRAG способна работать с различными контекстами документов, типами вопросов и модальностями доказательств. Авторы также представляют новый бенчмарк M3DocVQA для оценки систем открытого домена на более чем 3000 PDF-документах.'}, 'en': {'title': 'M3DocRAG: Revolutionizing Document Visual Question Answering', 'desc': 'The paper presents M3DocRAG, a new framework for Document Visual Question Answering (DocVQA) that addresses limitations of existing methods. Unlike traditional approaches that focus on single-page documents and often overlook visual elements, M3DocRAG can process multiple pages and various document types while retaining important visual information. It utilizes a multi-modal retriever and a multi-modal language model (MLM) to efficiently find relevant documents and answer questions, accommodating both text and visual evidence. The authors also introduce M3DocVQA, a benchmark for evaluating open-domain DocVQA, demonstrating that their framework outperforms existing models in several benchmarks.'}, 'zh': {'title': 'M3DocRAG：跨页文档问答的新突破', 'desc': '本文介绍了一种新的多模态检索增强生成框架M3DocRAG，旨在解决文档视觉问答（DocVQA）中的挑战。现有方法主要处理单页文档，无法有效应对跨页或多文档的信息检索。M3DocRAG能够灵活处理不同的文档上下文和问题跳跃，同时保留重要的视觉信息，如图表和图像。通过在超过3000个PDF文档上进行评估，M3DocRAG在多个基准测试中表现优异，超越了许多强基线。'}}}, {'id': 'https://huggingface.co/papers/2411.05001', 'title': 'Analyzing The Language of Visual Tokens', 'url': 'https://huggingface.co/papers/2411.05001', 'abstract': 'With the introduction of transformer-based models for vision and language tasks, such as LLaVA and Chameleon, there has been renewed interest in the discrete tokenized representation of images. These models often treat image patches as discrete tokens, analogous to words in natural language, learning joint alignments between visual and human languages. However, little is known about the statistical behavior of these visual languages - whether they follow similar frequency distributions, grammatical structures, or topologies as natural languages. In this paper, we take a natural-language-centric approach to analyzing discrete visual languages and uncover striking similarities and fundamental differences. We demonstrate that, although visual languages adhere to Zipfian distributions, higher token innovation drives greater entropy and lower compression, with tokens predominantly representing object parts, indicating intermediate granularity. We also show that visual languages lack cohesive grammatical structures, leading to higher perplexity and weaker hierarchical organization compared to natural languages. Finally, we demonstrate that, while vision models align more closely with natural languages than other models, this alignment remains significantly weaker than the cohesion found within natural languages. Through these experiments, we demonstrate how understanding the statistical properties of discrete visual languages can inform the design of more effective computer vision models.', 'score': 13, 'issue_id': 482, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '75768d92bd8ce17a', 'data': {'categories': ['#multimodal', '#cv', '#interpretability', '#alignment'], 'emoji': '🖼️', 'ru': {'title': 'Визуальные языки: между Ципфом и хаосом', 'desc': 'Статья исследует статистические свойства дискретных визуальных языков, используемых в современных моделях компьютерного зрения. Авторы обнаружили, что визуальные языки следуют распределению Ципфа, но имеют более высокую энтропию и меньшую сжимаемость по сравнению с естественными языками. Визуальные токены в основном представляют части объектов, а не целые объекты или сцены. Исследование также показало, что визуальным языкам не хватает связной грамматической структуры и иерархической организации, характерной для естественных языков.'}, 'en': {'title': 'Unlocking the Secrets of Visual Languages in AI', 'desc': 'This paper explores the statistical properties of discrete visual languages used in transformer-based models for vision and language tasks. It reveals that these visual languages exhibit Zipfian distributions, but their token innovation leads to higher entropy and lower compression, primarily representing object parts. The study finds that visual languages lack cohesive grammatical structures, resulting in higher perplexity and less hierarchical organization compared to natural languages. Ultimately, the research highlights the importance of understanding these properties to improve the design of computer vision models.'}, 'zh': {'title': '揭示视觉语言的统计特性', 'desc': '本文探讨了基于变换器的视觉和语言任务模型（如LLaVA和Chameleon）中图像的离散标记表示。研究发现，视觉语言虽然遵循Zipf分布，但更高的标记创新会导致更大的熵和更低的压缩率，标记主要代表物体部分，显示出中间粒度。与自然语言相比，视觉语言缺乏连贯的语法结构，导致更高的困惑度和较弱的层次组织。通过这些实验，我们揭示了离散视觉语言的统计特性如何影响计算机视觉模型的设计。'}}}, {'id': 'https://huggingface.co/papers/2411.04923', 'title': 'VideoGLaMM: A Large Multimodal Model for Pixel-Level Visual Grounding in Videos', 'url': 'https://huggingface.co/papers/2411.04923', 'abstract': 'Fine-grained alignment between videos and text is challenging due to complex spatial and temporal dynamics in videos. Existing video-based Large Multimodal Models (LMMs) handle basic conversations but struggle with precise pixel-level grounding in videos. To address this, we introduce VideoGLaMM, a LMM designed for fine-grained pixel-level grounding in videos based on user-provided textual inputs. Our design seamlessly connects three key components: a Large Language Model, a dual vision encoder that emphasizes both spatial and temporal details, and a spatio-temporal decoder for accurate mask generation. This connection is facilitated via tunable V-L and L-V adapters that enable close Vision-Language (VL) alignment. The architecture is trained to synchronize both spatial and temporal elements of video content with textual instructions. To enable fine-grained grounding, we curate a multimodal dataset featuring detailed visually-grounded conversations using a semiautomatic annotation pipeline, resulting in a diverse set of 38k video-QA triplets along with 83k objects and 671k masks. We evaluate VideoGLaMM on three challenging tasks: Grounded Conversation Generation, Visual Grounding, and Referring Video Segmentation. Experimental results show that our model consistently outperforms existing approaches across all three tasks.', 'score': 13, 'issue_id': 474, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '3db2b6994e9c5047', 'data': {'categories': ['#dataset', '#multimodal', '#architecture', '#games', '#alignment', '#cv'], 'emoji': '🎥', 'ru': {'title': 'Точная локализация в видео с помощью мультимодального ИИ', 'desc': 'VideoGLaMM - это новая модель крупномасштабного мультимодального обучения, разработанная для точной пиксельной локализации в видео на основе текстовых запросов пользователя. Модель объединяет языковую модель, двойной энкодер зрения и пространственно-временной декодер для генерации масок. Для обучения модели был создан специальный набор данных с детальными визуально-обоснованными диалогами. Эксперименты показали превосходство VideoGLaMM над существующими подходами в задачах генерации обоснованных диалогов, визуальной локализации и сегментации видео по запросу.'}, 'en': {'title': 'Achieving Pixel-Level Precision in Video-Text Alignment', 'desc': 'This paper presents VideoGLaMM, a Large Multimodal Model (LMM) that enhances the alignment between videos and text at a fine-grained level. It addresses the challenges of pixel-level grounding by integrating a Large Language Model with a dual vision encoder that captures both spatial and temporal dynamics of video content. The model employs tunable adapters for effective Vision-Language alignment and is trained on a comprehensive multimodal dataset with 38k video-QA triplets. Experimental results demonstrate that VideoGLaMM outperforms existing models in tasks such as Grounded Conversation Generation, Visual Grounding, and Referring Video Segmentation.'}, 'zh': {'title': '视频与文本的精细对齐新突破', 'desc': '本论文介绍了一种名为VideoGLaMM的多模态模型，旨在实现视频与文本之间的精细像素级对齐。该模型结合了大型语言模型、双重视觉编码器和时空解码器，能够处理视频中的复杂空间和时间动态。通过可调的视觉-语言适配器，VideoGLaMM实现了视觉与语言的紧密对齐。实验结果表明，该模型在生成对话、视觉对齐和视频分割等任务上均优于现有方法。'}}}, {'id': 'https://huggingface.co/papers/2411.05007', 'title': 'SVDQunat: Absorbing Outliers by Low-Rank Components for 4-Bit Diffusion Models', 'url': 'https://huggingface.co/papers/2411.05007', 'abstract': 'Diffusion models have been proven highly effective at generating high-quality images. However, as these models grow larger, they require significantly more memory and suffer from higher latency, posing substantial challenges for deployment. In this work, we aim to accelerate diffusion models by quantizing their weights and activations to 4 bits. At such an aggressive level, both weights and activations are highly sensitive, where conventional post-training quantization methods for large language models like smoothing become insufficient. To overcome this limitation, we propose SVDQuant, a new 4-bit quantization paradigm. Different from smoothing which redistributes outliers between weights and activations, our approach absorbs these outliers using a low-rank branch. We first consolidate the outliers by shifting them from activations to weights, then employ a high-precision low-rank branch to take in the weight outliers with Singular Value Decomposition (SVD). This process eases the quantization on both sides. However, na\\"{\\i}vely running the low-rank branch independently incurs significant overhead due to extra data movement of activations, negating the quantization speedup. To address this, we co-design an inference engine Nunchaku that fuses the kernels of the low-rank branch into those of the low-bit branch to cut off redundant memory access. It can also seamlessly support off-the-shelf low-rank adapters (LoRAs) without the need for re-quantization. Extensive experiments on SDXL, PixArt-Sigma, and FLUX.1 validate the effectiveness of SVDQuant in preserving image quality. We reduce the memory usage for the 12B FLUX.1 models by 3.5times, achieving 3.0times speedup over the 4-bit weight-only quantized baseline on the 16GB laptop 4090 GPU, paving the way for more interactive applications on PCs. Our quantization library and inference engine are open-sourced.', 'score': 13, 'issue_id': 466, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '636ee9cbe15eefb6', 'data': {'categories': ['#inference', '#optimization', '#diffusion'], 'emoji': '🚀', 'ru': {'title': 'Ускорение диффузионных моделей с помощью 4-битного квантования', 'desc': 'Статья представляет новый метод квантования под названием SVDQuant для ускорения диффузионных моделей. Метод использует низкоранговую ветвь для поглощения выбросов в весах и активациях, позволяя эффективно квантовать их до 4 бит. Авторы также разработали движок вывода Nunchaku, который оптимизирует выполнение квантованных моделей. Эксперименты показали значительное снижение использования памяти и ускорение работы крупных моделей генерации изображений.'}, 'en': {'title': 'Accelerating Diffusion Models with SVDQuant: Efficient 4-Bit Quantization', 'desc': 'This paper presents SVDQuant, a novel 4-bit quantization method designed to enhance the efficiency of diffusion models for image generation. As these models increase in size, they face challenges related to memory usage and latency, which SVDQuant aims to address by effectively managing outliers in weights and activations. The method utilizes Singular Value Decomposition (SVD) to absorb outliers into a low-rank branch, improving the quantization process without compromising image quality. Additionally, the co-designed inference engine, Nunchaku, optimizes memory access, resulting in significant reductions in memory usage and increased processing speed for large models.'}, 'zh': {'title': '加速扩散模型的4位量化新方法', 'desc': '扩散模型在生成高质量图像方面非常有效，但随着模型规模的增大，它们需要更多的内存并且延迟更高，这给部署带来了挑战。本文提出了一种新的4位量化方法SVDQuant，通过量化权重和激活值来加速扩散模型。与传统的平滑方法不同，SVDQuant通过低秩分支吸收异常值，从而减轻量化过程中的困难。实验结果表明，SVDQuant在保持图像质量的同时，显著减少了内存使用和提高了速度，适用于更多互动应用。'}}}, {'id': 'https://huggingface.co/papers/2411.04999', 'title': 'DynaMem: Online Dynamic Spatio-Semantic Memory for Open World Mobile Manipulation', 'url': 'https://huggingface.co/papers/2411.04999', 'abstract': "Significant progress has been made in open-vocabulary mobile manipulation, where the goal is for a robot to perform tasks in any environment given a natural language description. However, most current systems assume a static environment, which limits the system's applicability in real-world scenarios where environments frequently change due to human intervention or the robot's own actions. In this work, we present DynaMem, a new approach to open-world mobile manipulation that uses a dynamic spatio-semantic memory to represent a robot's environment. DynaMem constructs a 3D data structure to maintain a dynamic memory of point clouds, and answers open-vocabulary object localization queries using multimodal LLMs or open-vocabulary features generated by state-of-the-art vision-language models. Powered by DynaMem, our robots can explore novel environments, search for objects not found in memory, and continuously update the memory as objects move, appear, or disappear in the scene. We run extensive experiments on the Stretch SE3 robots in three real and nine offline scenes, and achieve an average pick-and-drop success rate of 70% on non-stationary objects, which is more than a 2x improvement over state-of-the-art static systems. Our code as well as our experiment and deployment videos are open sourced and can be found on our project website: https://dynamem.github.io/", 'score': 13, 'issue_id': 465, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '47171ef52d95552a', 'data': {'categories': ['#robotics', '#3d', '#multimodal', '#agents'], 'emoji': '🤖', 'ru': {'title': 'Динамическая память для роботов в изменяющемся мире', 'desc': 'DynaMem - новый подход к мобильной манипуляции с открытым словарем в динамических средах. Система использует динамическую пространственно-семантическую память для представления окружения робота, построенную на основе 3D структуры данных облаков точек. DynaMem применяет мультимодальные языковые модели и модели компьютерного зрения для локализации объектов по запросам на естественном языке. Эксперименты показали двукратное улучшение успешности захвата и перемещения нестационарных объектов по сравнению с современными статическими системами.'}, 'en': {'title': 'Empowering Robots with Dynamic Memory for Open-World Manipulation', 'desc': "This paper introduces DynaMem, a novel approach for open-vocabulary mobile manipulation that allows robots to adapt to dynamic environments. Unlike traditional systems that rely on static environments, DynaMem utilizes a dynamic spatio-semantic memory to keep track of changes in the robot's surroundings. It employs a 3D data structure to manage point clouds and leverages multimodal large language models (LLMs) for object localization. The results show that DynaMem significantly improves the robot's ability to interact with non-stationary objects, achieving a 70% success rate in pick-and-drop tasks, which is more than double the performance of existing static systems."}, 'zh': {'title': '动态记忆，智能操作！', 'desc': '本研究提出了一种新的动态空间语义记忆方法DynaMem，用于开放词汇的移动操作。与传统静态环境系统不同，DynaMem能够在不断变化的环境中进行物体定位和操作。该方法利用三维数据结构维护动态记忆，并通过多模态大语言模型进行查询。实验结果表明，DynaMem在非静态物体的抓取和放置任务中成功率达70%，显著优于现有静态系统。'}}}, {'id': 'https://huggingface.co/papers/2411.05005', 'title': 'Diff-2-in-1: Bridging Generation and Dense Perception with Diffusion Models', 'url': 'https://huggingface.co/papers/2411.05005', 'abstract': 'Beyond high-fidelity image synthesis, diffusion models have recently exhibited promising results in dense visual perception tasks. However, most existing work treats diffusion models as a standalone component for perception tasks, employing them either solely for off-the-shelf data augmentation or as mere feature extractors. In contrast to these isolated and thus sub-optimal efforts, we introduce a unified, versatile, diffusion-based framework, Diff-2-in-1, that can simultaneously handle both multi-modal data generation and dense visual perception, through a unique exploitation of the diffusion-denoising process. Within this framework, we further enhance discriminative visual perception via multi-modal generation, by utilizing the denoising network to create multi-modal data that mirror the distribution of the original training set. Importantly, Diff-2-in-1 optimizes the utilization of the created diverse and faithful data by leveraging a novel self-improving learning mechanism. Comprehensive experimental evaluations validate the effectiveness of our framework, showcasing consistent performance improvements across various discriminative backbones and high-quality multi-modal data generation characterized by both realism and usefulness.', 'score': 12, 'issue_id': 477, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': '249deab8440380fc', 'data': {'categories': ['#training', '#diffusion', '#data', '#multimodal', '#optimization', '#cv'], 'emoji': '🔄', 'ru': {'title': 'Diff-2-in-1: Объединение генерации и восприятия в диффузионных моделях', 'desc': 'Статья представляет новый универсальный фреймворк на основе диффузионных моделей под названием Diff-2-in-1. Этот фреймворк способен одновременно выполнять мультимодальную генерацию данных и плотное визуальное восприятие, используя процесс диффузионного шумоподавления. Diff-2-in-1 улучшает дискриминативное визуальное восприятие путем генерации мультимодальных данных, отражающих распределение исходного обучающего набора. Фреймворк также использует новый механизм самосовершенствующегося обучения для оптимизации использования созданных разнообразных и достоверных данных.'}, 'en': {'title': 'Unifying Data Generation and Visual Perception with Diff-2-in-1', 'desc': 'This paper presents a new framework called Diff-2-in-1 that integrates diffusion models for both data generation and visual perception tasks. Unlike previous approaches that used diffusion models in isolation, this framework leverages the diffusion-denoising process to enhance the performance of visual perception. It generates multi-modal data that closely resembles the original training data, improving the discriminative capabilities of the model. The framework also includes a self-improving learning mechanism to optimize the use of the generated data, leading to better performance across various tasks.'}, 'zh': {'title': 'Diff-2-in-1：多模态生成与视觉感知的统一框架', 'desc': '本文提出了一种新的框架，称为Diff-2-in-1，旨在同时处理多模态数据生成和密集视觉感知。与以往将扩散模型视为独立组件的做法不同，该框架利用扩散去噪过程的独特特性，增强了视觉感知的判别能力。通过生成与原始训练集分布相似的多模态数据，Diff-2-in-1优化了生成数据的使用，采用了一种新颖的自我改进学习机制。实验结果表明，该框架在多种判别模型上均表现出一致的性能提升，并生成了高质量的多模态数据，具有真实感和实用性。'}}}, {'id': 'https://huggingface.co/papers/2411.04335', 'title': 'GazeGen: Gaze-Driven User Interaction for Visual Content Generation', 'url': 'https://huggingface.co/papers/2411.04335', 'abstract': "We present GazeGen, a user interaction system that generates visual content (images and videos) for locations indicated by the user's eye gaze. GazeGen allows intuitive manipulation of visual content by targeting regions of interest with gaze. Using advanced techniques in object detection and generative AI, GazeGen performs gaze-controlled image adding/deleting, repositioning, and surface material changes of image objects, and converts static images into videos. Central to GazeGen is the DFT Gaze (Distilled and Fine-Tuned Gaze) agent, an ultra-lightweight model with only 281K parameters, performing accurate real-time gaze predictions tailored to individual users' eyes on small edge devices. GazeGen is the first system to combine visual content generation with real-time gaze estimation, made possible exclusively by DFT Gaze. This real-time gaze estimation enables various visual content generation tasks, all controlled by the user's gaze. The input for DFT Gaze is the user's eye images, while the inputs for visual content generation are the user's view and the predicted gaze point from DFT Gaze. To achieve efficient gaze predictions, we derive the small model from a large model (10x larger) via novel knowledge distillation and personal adaptation techniques. We integrate knowledge distillation with a masked autoencoder, developing a compact yet powerful gaze estimation model. This model is further fine-tuned with Adapters, enabling highly accurate and personalized gaze predictions with minimal user input. DFT Gaze ensures low-latency and precise gaze tracking, supporting a wide range of gaze-driven tasks. We validate the performance of DFT Gaze on AEA and OpenEDS2020 benchmarks, demonstrating low angular gaze error and low latency on the edge device (Raspberry Pi 4). Furthermore, we describe applications of GazeGen, illustrating its versatility and effectiveness in various usage scenarios.", 'score': 12, 'issue_id': 466, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'caa85d9f2385fc2a', 'data': {'categories': ['#agents', '#cv', '#video', '#edge_computing', '#training'], 'emoji': '👁️', 'ru': {'title': 'Взглядом управляй: революция в генерации визуального контента', 'desc': 'Исследователи представляют систему GazeGen, которая генерирует визуальный контент на основе направления взгляда пользователя. В основе системы лежит сверхлегкая модель DFT Gaze, выполняющая точное предсказание направления взгляда в реальном времени на небольших устройствах. GazeGen позволяет интуитивно манипулировать визуальным контентом, используя передовые методы обнаружения объектов и генеративного ИИ. Система была протестирована на эталонных наборах данных, продемонстрировав низкую угловую ошибку определения взгляда и низкую задержку на периферийных устройствах.'}, 'en': {'title': 'GazeGen: Transforming Eye Gaze into Visual Content Control', 'desc': 'GazeGen is an innovative user interaction system that generates visual content based on where a user is looking. It utilizes advanced object detection and generative AI techniques to allow users to manipulate images and videos by simply gazing at specific areas. The core of GazeGen is the DFT Gaze agent, a lightweight model that accurately predicts gaze in real-time, making it suitable for use on small devices like the Raspberry Pi 4. By combining gaze estimation with visual content generation, GazeGen enables intuitive and personalized interactions with digital media.'}, 'zh': {'title': '眼动控制的视觉内容生成系统', 'desc': 'GazeGen是一个用户交互系统，可以根据用户的眼动生成视觉内容（图像和视频）。它利用先进的物体检测和生成AI技术，实现了基于视线的图像添加、删除、重新定位和表面材质变化。系统的核心是DFT Gaze代理，这是一个轻量级模型，能够在小型边缘设备上进行实时的眼动预测。GazeGen是首个将视觉内容生成与实时眼动估计相结合的系统，展示了其在多种应用场景中的灵活性和有效性。'}}}, {'id': 'https://huggingface.co/papers/2411.04752', 'title': 'RetrieveGPT: Merging Prompts and Mathematical Models for Enhanced Code-Mixed Information Retrieval', 'url': 'https://huggingface.co/papers/2411.04752', 'abstract': 'Code-mixing, the integration of lexical and grammatical elements from multiple languages within a single sentence, is a widespread linguistic phenomenon, particularly prevalent in multilingual societies. In India, social media users frequently engage in code-mixed conversations using the Roman script, especially among migrant communities who form online groups to share relevant local information. This paper focuses on the challenges of extracting relevant information from code-mixed conversations, specifically within Roman transliterated Bengali mixed with English. This study presents a novel approach to address these challenges by developing a mechanism to automatically identify the most relevant answers from code-mixed conversations. We have experimented with a dataset comprising of queries and documents from Facebook, and Query Relevance files (QRels) to aid in this task. Our results demonstrate the effectiveness of our approach in extracting pertinent information from complex, code-mixed digital conversations, contributing to the broader field of natural language processing in multilingual and informal text environments. We use GPT-3.5 Turbo via prompting alongwith using the sequential nature of relevant documents to frame a mathematical model which helps to detect relevant documents corresponding to a query.', 'score': 12, 'issue_id': 466, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'e2dbb14c8f2ca6ef', 'data': {'categories': ['#multilingual', '#dataset', '#data'], 'emoji': '🗣️', 'ru': {'title': 'Извлечение информации из многоязычных разговоров: новый подход к обработке смешанных текстов', 'desc': 'Статья посвящена проблеме извлечения релевантной информации из смешанных языковых разговоров в социальных сетях Индии. Авторы разработали новый подход для автоматического определения наиболее релевантных ответов в разговорах на смеси бенгальского и английского языков, записанных латиницей. В исследовании использовались данные из Facebook и файлы Query Relevance, а также применялась языковая модель GPT-3.5 Turbo. Результаты демонстрируют эффективность предложенного метода в обработке сложных многоязычных текстов в неформальной цифровой среде.'}, 'en': {'title': 'Enhancing Information Retrieval in Code-Mixed Conversations', 'desc': 'This paper addresses the challenge of extracting relevant information from code-mixed conversations, particularly in Roman transliterated Bengali and English. It presents a novel mechanism that utilizes GPT-3.5 Turbo and a mathematical model to identify pertinent answers from social media interactions. The study experiments with a dataset from Facebook, focusing on queries and documents to enhance information retrieval. The results indicate that the proposed approach effectively navigates the complexities of multilingual and informal text, contributing to advancements in natural language processing.'}, 'zh': {'title': '从代码混合对话中提取信息的新方法', 'desc': '本文研究了在多语言环境中，如何从代码混合的对话中提取相关信息。特别是在印度，社交媒体用户常用罗马字母书写的孟加拉语与英语混合交流。我们提出了一种新方法，通过自动识别代码混合对话中的相关答案来解决这一挑战。实验结果表明，该方法在提取复杂数字对话中的相关信息方面是有效的，推动了自然语言处理领域的发展。'}}}, {'id': 'https://huggingface.co/papers/2411.04989', 'title': 'SG-I2V: Self-Guided Trajectory Control in Image-to-Video Generation', 'url': 'https://huggingface.co/papers/2411.04989', 'abstract': 'Methods for image-to-video generation have achieved impressive, photo-realistic quality. However, adjusting specific elements in generated videos, such as object motion or camera movement, is often a tedious process of trial and error, e.g., involving re-generating videos with different random seeds. Recent techniques address this issue by fine-tuning a pre-trained model to follow conditioning signals, such as bounding boxes or point trajectories. Yet, this fine-tuning procedure can be computationally expensive, and it requires datasets with annotated object motion, which can be difficult to procure. In this work, we introduce SG-I2V, a framework for controllable image-to-video generation that is self-guidedx2013offering zero-shot control by relying solely on the knowledge present in a pre-trained image-to-video diffusion model without the need for fine-tuning or external knowledge. Our zero-shot method outperforms unsupervised baselines while being competitive with supervised models in terms of visual quality and motion fidelity.', 'score': 12, 'issue_id': 465, 'pub_date': '2024-11-07', 'pub_date_card': {'ru': '7 ноября', 'en': 'November 7', 'zh': '11月7日'}, 'hash': 'a707043470b8dffd', 'data': {'categories': ['#video', '#diffusion', '#dataset'], 'emoji': '🎬', 'ru': {'title': 'Управляемая генерация видео без дополнительного обучения', 'desc': 'SG-I2V - это новый фреймворк для управляемой генерации видео из изображений. Он использует предобученную диффузионную модель без необходимости дополнительного обучения или внешних данных. Метод превосходит неконтролируемые базовые модели и конкурирует с контролируемыми по качеству изображения и точности движения. SG-I2V позволяет легко настраивать конкретные элементы генерируемых видео, такие как движение объектов или камеры.'}, 'en': {'title': 'Zero-Shot Control in Image-to-Video Generation', 'desc': 'This paper presents SG-I2V, a novel framework for generating videos from images with controllable features. Unlike traditional methods that require fine-tuning on annotated datasets, SG-I2V operates in a zero-shot manner, leveraging a pre-trained image-to-video diffusion model. This approach allows for easier manipulation of elements like object motion and camera movement without the computational costs associated with fine-tuning. The results show that SG-I2V achieves high visual quality and motion fidelity, outperforming unsupervised methods and competing with supervised ones.'}, 'zh': {'title': 'SG-I2V：高效的图像到视频生成方法', 'desc': '本文介绍了一种名为SG-I2V的框架，用于可控的图像到视频生成。该方法利用预训练的图像到视频扩散模型，提供零-shot控制，避免了繁琐的微调过程。与无监督基线相比，我们的方法在视觉质量和运动保真度上表现优越，并且与监督模型相竞争。此研究为视频生成提供了一种更高效的解决方案，减少了对标注数据集的依赖。'}}}, {'id': 'https://huggingface.co/papers/2411.04075', 'title': 'M3SciQA: A Multi-Modal Multi-Document Scientific QA Benchmark for Evaluating Foundation Models', 'url': 'https://huggingface.co/papers/2411.04075', 'abstract': 'Existing benchmarks for evaluating foundation models mainly focus on single-document, text-only tasks. However, they often fail to fully capture the complexity of research workflows, which typically involve interpreting non-textual data and gathering information across multiple documents. To address this gap, we introduce M3SciQA, a multi-modal, multi-document scientific question answering benchmark designed for a more comprehensive evaluation of foundation models. M3SciQA consists of 1,452 expert-annotated questions spanning 70 natural language processing paper clusters, where each cluster represents a primary paper along with all its cited documents, mirroring the workflow of comprehending a single paper by requiring multi-modal and multi-document data. With M3SciQA, we conduct a comprehensive evaluation of 18 foundation models. Our results indicate that current foundation models still significantly underperform compared to human experts in multi-modal information retrieval and in reasoning across multiple scientific documents. Additionally, we explore the implications of these findings for the future advancement of applying foundation models in multi-modal scientific literature analysis.', 'score': 10, 'issue_id': 480, 'pub_date': '2024-11-06', 'pub_date_card': {'ru': '6 ноября', 'en': 'November 6', 'zh': '11月6日'}, 'hash': '654e787a9f0ab7ff', 'data': {'categories': ['#multimodal', '#benchmark', '#reasoning', '#science'], 'emoji': '🧠', 'ru': {'title': 'M3SciQA: Новый рубеж в оценке фундаментальных моделей для научного анализа', 'desc': 'M3SciQA - это новый бенчмарк для оценки фундаментальных моделей в области научных вопросов и ответов. Он включает в себя мультимодальные и мультидокументные задачи, охватывающие 70 кластеров статей по обработке естественного языка. Результаты тестирования 18 моделей показали, что их производительность значительно уступает экспертам-людям в задачах мультимодального поиска информации и рассуждений по нескольким научным документам. Этот бенчмарк открывает новые перспективы для развития применения фундаментальных моделей в анализе научной литературы.'}, 'en': {'title': 'M3SciQA: Bridging the Gap in Multi-Modal Scientific Understanding', 'desc': 'This paper introduces M3SciQA, a new benchmark for evaluating foundation models in the context of scientific question answering. Unlike existing benchmarks that focus solely on single-document, text-only tasks, M3SciQA incorporates multi-modal and multi-document elements to better reflect real research workflows. The benchmark includes 1,452 expert-annotated questions related to clusters of natural language processing papers, requiring models to interpret both textual and non-textual data. Evaluation results show that current foundation models still lag behind human experts in retrieving multi-modal information and reasoning across multiple documents, highlighting the need for further advancements in this area.'}, 'zh': {'title': 'M3SciQA：多模态科学问答的新基准', 'desc': '现有的基础模型评估基准主要集中在单文档、文本任务上，无法全面捕捉研究工作流程的复杂性。为了解决这个问题，我们提出了M3SciQA，这是一个多模态、多文档的科学问答基准，旨在更全面地评估基础模型。M3SciQA包含1452个专家注释的问题，涵盖70个自然语言处理论文集群，模拟理解单篇论文的工作流程。我们的评估结果表明，当前的基础模型在多模态信息检索和跨多个科学文档推理方面仍显著低于人类专家的表现。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (2)', '#agents (4)', '#agi', '#alignment (2)', '#architecture (3)', '#audio', '#benchmark (3)', '#cv (4)', '#data (3)', '#dataset (8)', '#diffusion (4)', '#ethics', '#games (2)', '#graphs', '#hallucinations (1)', '#healthcare', '#inference (2)', '#interpretability (1)', '#leakage', '#long_context (2)', '#low_resource', '#machine_translation', '#math', '#multilingual (1)', '#multimodal (9)', '#open_source', '#optimization (4)', '#plp (1)', '#rag (1)', '#reasoning (1)', '#rl', '#rlhf', '#robotics (1)', '#science (1)', '#security', '#small_models', '#story_generation', '#survey', '#synthetic (2)', '#training (4)', '#transfer_learning', '#video (5)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].join(" ");
                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="background-digit">${index + 1}</div>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <h2>${item['data']['emoji']} ${item['title']}</h2>
                            <p class="meta"><svg class="text-sm peer-checked:text-gray-500 group-hover:text-gray-500" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 12 12"><path transform="translate(0, 2)" fill="currentColor" d="M5.19 2.67a.94.94 0 0 1 1.62 0l3.31 5.72a.94.94 0 0 1-.82 1.4H2.7a.94.94 0 0 1-.82-1.4l3.31-5.7v-.02Z"></path></svg> ${item['score']}. ${title}</p>
                            <p class="pub-date">📝 ${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>
                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>
                            <p class="tags">${cats}</p>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2024-11-09 16:12',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2024-11-09 16:12')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2024-11-09 16:12')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    