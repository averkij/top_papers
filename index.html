
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 29 papers. October 13.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">13 октября</span> | <span id="title-articles-count">29 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-10-10.html">⬅️ <span id="prev-date">10.10</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-10-14.html">➡️ <span id="next-date">14.10</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-10.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '13 октября', 'en': 'October 13', 'zh': '10月13日'};
        let feedDateNext = {'ru': '14.10', 'en': '10/14', 'zh': '10月14日'};
        let feedDatePrev = {'ru': '10.10', 'en': '10/10', 'zh': '10月10日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2510.08673', 'title': 'Thinking with Camera: A Unified Multimodal Model for Camera-Centric\n  Understanding and Generation', 'url': 'https://huggingface.co/papers/2510.08673', 'abstract': 'Puffin, a unified multimodal model, integrates language regression and diffusion-based generation to enhance camera-centric spatial understanding and generation by treating camera parameters as language.  \t\t\t\t\tAI-generated summary \t\t\t\t Camera-centric understanding and generation are two cornerstones of spatial intelligence, yet they are typically studied in isolation. We present Puffin, a unified camera-centric multimodal model that extends spatial awareness along the camera dimension. Puffin integrates language regression and diffusion-based generation to interpret and create scenes from arbitrary viewpoints. To bridge the modality gap between cameras and vision-language, we introduce a novel paradigm that treats camera as language, enabling thinking with camera. This guides the model to align spatially grounded visual cues with photographic terminology while reasoning across geometric context. Puffin is trained on Puffin-4M, a large-scale dataset of 4 million vision-language-camera triplets. We incorporate both global camera parameters and pixel-wise camera maps, yielding flexible and reliable spatial generation. Experiments demonstrate Puffin superior performance over specialized models for camera-centric generation and understanding. With instruction tuning, Puffin generalizes to diverse cross-view tasks such as spatial imagination, world exploration, and photography guidance. We will release the code, models, dataset pipeline, and benchmark to advance multimodal spatial intelligence research.', 'score': 46, 'issue_id': 6375, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': '2b4c322ac948b29e', 'authors': ['Kang Liao', 'Size Wu', 'Zhonghua Wu', 'Linyi Jin', 'Chao Wang', 'Yikai Wang', 'Fei Wang', 'Wei Li', 'Chen Change Loy'], 'affiliations': ['Max-Planck Institute for Informatics', 'S-Lab, Nanyang Technological University', 'SenseTime Research', 'University of Michigan'], 'pdf_title_img': 'assets/pdf/title_img/2510.08673.jpg', 'data': {'categories': ['#cv', '#diffusion', '#dataset', '#multimodal', '#benchmark', '#alignment', '#open_source'], 'emoji': '📸', 'ru': {'title': 'Камера как язык: единая модель для понимания и генерации сцен', 'desc': 'Puffin — это мультимодальная модель, которая объединяет понимание и генерацию изображений с учётом параметров камеры. Авторы предлагают новый подход «камера как язык», при котором параметры камеры обрабатываются как текстовые данные, что позволяет модели рассуждать о геометрическом контексте сцены. Модель обучена на датасете Puffin-4M из 4 миллионов триплетов изображение-текст-камера и использует как глобальные параметры камеры, так и попиксельные карты. Puffin демонстрирует превосходные результаты в задачах генерации изображений с заданной точки обзора и понимания пространственных характеристик сцены.'}, 'en': {'title': 'Puffin: Bridging Language and Camera for Enhanced Spatial Intelligence', 'desc': 'Puffin is a new multimodal model designed to improve how machines understand and generate images based on camera perspectives. It combines language regression and diffusion-based generation techniques to interpret scenes from different viewpoints. By treating camera parameters as a form of language, Puffin aligns visual information with photographic terms, enhancing its spatial reasoning capabilities. Trained on a large dataset of vision-language-camera triplets, Puffin outperforms existing models in tasks related to camera-centric understanding and generation.'}, 'zh': {'title': 'Puffin：相机视角下的空间智能新突破', 'desc': 'Puffin是一种统一的多模态模型，旨在增强基于相机的空间理解和生成。它通过将相机参数视为语言，结合语言回归和基于扩散的生成方法，来处理和创建不同视角的场景。Puffin在一个包含400万对视觉-语言-相机三元组的大规模数据集上进行训练，能够灵活可靠地进行空间生成。实验表明，Puffin在相机中心生成和理解方面的表现优于专门模型，并且通过指令调优，能够适应多样的跨视角任务。'}}}, {'id': 'https://huggingface.co/papers/2510.04533', 'title': 'TAG:Tangential Amplifying Guidance for Hallucination-Resistant Diffusion\n  Sampling', 'url': 'https://huggingface.co/papers/2510.04533', 'abstract': 'Tangential Amplifying Guidance (TAG) improves diffusion model sample quality by directly amplifying tangential components of estimated scores without modifying the model architecture.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent diffusion models achieve the state-of-the-art performance in image generation, but often suffer from semantic inconsistencies or hallucinations. While various inference-time guidance methods can enhance generation, they often operate indirectly by relying on external signals or architectural modifications, which introduces additional computational overhead. In this paper, we propose Tangential Amplifying Guidance (TAG), a more efficient and direct guidance method that operates solely on trajectory signals without modifying the underlying diffusion model. TAG leverages an intermediate sample as a projection basis and amplifies the tangential components of the estimated scores with respect to this basis to correct the sampling trajectory. We formalize this guidance process by leveraging a first-order Taylor expansion, which demonstrates that amplifying the tangential component steers the state toward higher-probability regions, thereby reducing inconsistencies and enhancing sample quality. TAG is a plug-and-play, architecture-agnostic module that improves diffusion sampling fidelity with minimal computational addition, offering a new perspective on diffusion guidance.', 'score': 30, 'issue_id': 6375, 'pub_date': '2025-10-06', 'pub_date_card': {'ru': '6 октября', 'en': 'October 6', 'zh': '10月6日'}, 'hash': '0b9aca186679e05a', 'authors': ['Hyunmin Cho', 'Donghoon Ahn', 'Susung Hong', 'Jee Eun Kim', 'Seungryong Kim', 'Kyong Hwan Jin'], 'affiliations': ['KAIST AI', 'Korea University', 'University of California, Berkeley', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2510.04533.jpg', 'data': {'categories': ['#cv', '#diffusion', '#inference', '#optimization', '#hallucinations'], 'emoji': '📐', 'ru': {'title': 'Улучшение генерации через усиление касательных компонент', 'desc': 'Статья предлагает метод Tangential Amplifying Guidance (TAG) для улучшения качества генерации диффузионных моделей. Вместо использования внешних сигналов или изменения архитектуры, TAG работает напрямую с траекторией сэмплирования, усиливая касательные компоненты оценочных скоров. Метод направляет процесс генерации в области с более высокой вероятностью, что уменьшает семантические несоответствия и галлюцинации. TAG является plug-and-play модулем, который добавляет минимальные вычислительные затраты и работает с любой архитектурой диффузионной модели.'}, 'en': {'title': 'Enhancing Diffusion Models with Direct Tangential Guidance', 'desc': 'Tangential Amplifying Guidance (TAG) is a novel method designed to enhance the quality of samples generated by diffusion models. Unlike traditional guidance methods that modify the model architecture or rely on external signals, TAG directly amplifies the tangential components of estimated scores during the sampling process. This approach uses an intermediate sample as a basis for projection, allowing for a more efficient correction of the sampling trajectory. By applying a first-order Taylor expansion, TAG effectively steers the sampling towards higher-probability regions, thereby reducing semantic inconsistencies and improving overall sample fidelity.'}, 'zh': {'title': '切向放大引导：提升扩散模型生成质量的新方法', 'desc': '本文提出了一种新的引导方法，称为切向放大引导（TAG），旨在提高扩散模型生成图像的质量。TAG 通过直接放大估计分数的切向分量来修正采样轨迹，而不需要修改模型架构。该方法利用中间样本作为投影基础，采用一阶泰勒展开形式化引导过程，从而将状态引导至更高概率区域，减少语义不一致性。TAG 是一个即插即用的模块，能够在不增加计算负担的情况下提升扩散采样的保真度。'}}}, {'id': 'https://huggingface.co/papers/2510.09201', 'title': 'Multimodal Prompt Optimization: Why Not Leverage Multiple Modalities for\n  MLLMs', 'url': 'https://huggingface.co/papers/2510.09201', 'abstract': 'Multimodal Prompt Optimizer (MPO) extends prompt optimization to handle multiple data types, improving performance over text-only methods in various applications.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have shown remarkable success, and their multimodal expansions (MLLMs) further unlock capabilities spanning images, videos, and other modalities beyond text. However, despite this shift, prompt optimization approaches, designed to reduce the burden of manual prompt crafting while maximizing performance, remain confined to text, ultimately limiting the full potential of MLLMs. Motivated by this gap, we introduce the new problem of multimodal prompt optimization, which expands the prior definition of prompt optimization to the multimodal space defined by the pairs of textual and non-textual prompts. To tackle this problem, we then propose the Multimodal Prompt Optimizer (MPO), a unified framework that not only performs the joint optimization of multimodal prompts through alignment-preserving updates but also guides the selection process of candidate prompts by leveraging earlier evaluations as priors in a Bayesian-based selection strategy. Through extensive experiments across diverse modalities that go beyond text, such as images, videos, and even molecules, we demonstrate that MPO outperforms leading text-only optimization methods, establishing multimodal prompt optimization as a crucial step to realizing the potential of MLLMs.', 'score': 29, 'issue_id': 6376, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '349a39e2011c9064', 'authors': ['Yumin Choi', 'Dongki Kim', 'Jinheon Baek', 'Sung Ju Hwang'], 'affiliations': ['DeepAuto.ai', 'KAIST'], 'pdf_title_img': 'assets/pdf/title_img/2510.09201.jpg', 'data': {'categories': ['#optimization', '#training', '#multimodal'], 'emoji': '🎨', 'ru': {'title': 'Оптимизация промптов для всех модальностей одновременно', 'desc': 'Статья представляет Multimodal Prompt Optimizer (MPO) — новый подход к оптимизации промптов для мультимодальных языковых моделей (MLLM). В отличие от существующих методов, работающих только с текстом, MPO выполняет совместную оптимизацию текстовых и нетекстовых промптов (изображения, видео, молекулы) с сохранением выравнивания между модальностями. Система использует байесовскую стратегию выбора, которая учитывает результаты предыдущих оценок для более эффективного отбора кандидатов. Эксперименты показывают, что MPO превосходит текстовые методы оптимизации, раскрывая полный потенциал мультимодальных LLM.'}, 'en': {'title': 'Unlocking Multimodal Potential with MPO', 'desc': 'The Multimodal Prompt Optimizer (MPO) introduces a new approach to prompt optimization that accommodates various data types, such as text, images, and videos. This method enhances the performance of large language models (LLMs) by allowing for the joint optimization of multimodal prompts, rather than being limited to text-only prompts. MPO employs alignment-preserving updates and a Bayesian-based selection strategy to effectively choose candidate prompts based on prior evaluations. Experimental results show that MPO significantly outperforms traditional text-only optimization techniques, highlighting its importance in maximizing the capabilities of multimodal large language models (MLLMs).'}, 'zh': {'title': '多模态提示优化，释放AI潜力！', 'desc': '多模态提示优化器（MPO）扩展了提示优化的概念，以处理多种数据类型，从而在各种应用中提高性能。尽管大语言模型（LLMs）取得了显著成功，但现有的提示优化方法仍然局限于文本，限制了多模态大语言模型（MLLMs）的潜力。MPO通过联合优化多模态提示，利用贝叶斯选择策略指导候选提示的选择，解决了这一问题。实验结果表明，MPO在图像、视频等多种模态上优于传统的文本优化方法，标志着多模态提示优化是实现MLLMs潜力的重要一步。'}}}, {'id': 'https://huggingface.co/papers/2510.06499', 'title': 'Webscale-RL: Automated Data Pipeline for Scaling RL Data to Pretraining\n  Levels', 'url': 'https://huggingface.co/papers/2510.06499', 'abstract': 'A scalable data engine converts large-scale pre-training documents into diverse question-answer pairs for reinforcement learning, significantly improving model performance and efficiency.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have achieved remarkable success through imitation learning on vast text corpora, but this paradigm creates a training-generation gap and limits robust reasoning. Reinforcement learning (RL) offers a more data-efficient solution capable of bridging this gap, yet its application has been constrained by a critical data bottleneck: existing RL datasets are orders of magnitude smaller and less diverse than web-scale pre-training corpora. To address this, we introduce the Webscale-RL pipeline, a scalable data engine that systematically converts large-scale pre-training documents into millions of diverse, verifiable question-answer pairs for RL. Using this pipeline, we construct the Webscale-RL dataset, containing 1.2 million examples across more than 9 domains. Our experiments show that the model trained on this dataset significantly outperforms continual pretraining and strong data refinement baselines across a suite of benchmarks. Notably, RL training with our dataset proves substantially more efficient, achieving the performance of continual pre-training with up to 100times fewer tokens. Our work presents a viable path toward scaling RL to pre-training levels, enabling more capable and efficient language models.', 'score': 17, 'issue_id': 6376, 'pub_date': '2025-10-07', 'pub_date_card': {'ru': '7 октября', 'en': 'October 7', 'zh': '10月7日'}, 'hash': '8a5d9b213feffe3c', 'authors': ['Zhepeng Cen', 'Haolin Chen', 'Shiyu Wang', 'Zuxin Liu', 'Zhiwei Liu', 'Ding Zhao', 'Silvio Savarese', 'Caiming Xiong', 'Huan Wang', 'Weiran Yao'], 'affiliations': ['Carnegie Mellon University', 'Salesforce AI Research'], 'pdf_title_img': 'assets/pdf/title_img/2510.06499.jpg', 'data': {'categories': ['#benchmark', '#dataset', '#rl', '#data', '#reasoning', '#optimization'], 'emoji': '🔄', 'ru': {'title': 'От текстов к вопросам: масштабирование RL для языковых моделей', 'desc': 'Исследователи разработали Webscale-RL pipeline — масштабируемый движок данных, который преобразует большие объёмы текстов для предобучения в миллионы разнообразных пар вопрос-ответ для reinforcement learning. Созданный датасет содержит 1.2 миллиона примеров из более чем 9 доменов и позволяет обучать LLM значительно эффективнее традиционного continual pretraining. Модели, обученные с использованием RL на этом датасете, достигают той же производительности, используя в 100 раз меньше токенов. Работа открывает путь к масштабированию reinforcement learning до уровня предобучения, делая языковые модели более способными и эффективными.'}, 'en': {'title': 'Revolutionizing Reinforcement Learning with Scalable Data Generation', 'desc': 'This paper introduces a new method called the Webscale-RL pipeline, which transforms large amounts of pre-training documents into a wide variety of question-answer pairs for reinforcement learning (RL). This approach addresses the issue of limited and less diverse RL datasets, which have hindered the effectiveness of RL in training language models. By creating a dataset with 1.2 million examples from over 9 domains, the authors demonstrate that models trained on this data can significantly outperform traditional methods. The results show that using this dataset allows for more efficient training, achieving high performance with far fewer training tokens compared to continual pre-training methods.'}, 'zh': {'title': '可扩展的强化学习数据引擎', 'desc': '本文介绍了一种可扩展的数据引擎，能够将大规模的预训练文档转换为多样化的问题-答案对，以用于强化学习，从而显著提高模型的性能和效率。传统的大型语言模型通过模仿学习取得了成功，但存在训练与生成之间的差距，限制了推理能力。强化学习提供了一种更高效的数据解决方案，但受限于现有数据集的规模和多样性。我们提出的Webscale-RL管道能够系统性地生成大量问题-答案对，构建了包含120万个示例的Webscale-RL数据集，实验结果表明，使用该数据集训练的模型在多个基准测试中表现优异。'}}}, {'id': 'https://huggingface.co/papers/2510.09606', 'title': 'SpaceVista: All-Scale Visual Spatial Reasoning from mm to km', 'url': 'https://huggingface.co/papers/2510.09606', 'abstract': 'A spatial reasoning model using scale-aware experts and progressive rewards demonstrates competitive performance across diverse tasks and scales using a large, curated dataset.  \t\t\t\t\tAI-generated summary \t\t\t\t With the current surge in spatial reasoning explorations, researchers have made significant progress in understanding indoor scenes, but still struggle with diverse applications such as robotics and autonomous driving. This paper aims to advance all-scale spatial reasoning across diverse scenarios by tackling two key challenges: 1) the heavy reliance on indoor 3D scans and labor-intensive manual annotations for dataset curation; 2) the absence of effective all-scale scene modeling, which often leads to overfitting to individual scenes. In this paper, we introduce a holistic solution that integrates a structured spatial reasoning knowledge system, scale-aware modeling, and a progressive training paradigm, as the first attempt to broaden the all-scale spatial intelligence of MLLMs to the best of our knowledge. Using a task-specific, specialist-driven automated pipeline, we curate over 38K video scenes across 5 spatial scales to create SpaceVista-1M, a dataset comprising approximately 1M spatial QA pairs spanning 19 diverse task types. While specialist models can inject useful domain knowledge, they are not reliable for evaluation. We then build an all-scale benchmark with precise annotations by manually recording, retrieving, and assembling video-based data. However, naive training with SpaceVista-1M often yields suboptimal results due to the potential knowledge conflict. Accordingly, we introduce SpaceVista-7B, a spatial reasoning model that accepts dense inputs beyond semantics and uses scale as an anchor for scale-aware experts and progressive rewards. Finally, extensive evaluations across 5 benchmarks, including our SpaceVista-Bench, demonstrate competitive performance, showcasing strong generalization across all scales and scenarios. Our dataset, model, and benchmark will be released on https://peiwensun2000.github.io/mm2km .', 'score': 12, 'issue_id': 6375, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '892c43f9f20768e2', 'authors': ['Peiwen Sun', 'Shiqiang Lang', 'Dongming Wu', 'Yi Ding', 'Kaituo Feng', 'Huadai Liu', 'Zhen Ye', 'Rui Liu', 'Yun-Hui Liu', 'Jianan Wang', 'Xiangyu Yue'], 'affiliations': ['Astribot, Beijing University of Posts and Telecommunications', 'Hong Kong University of Science and Technology', 'Multimedia Lab, Chinese University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2510.09606.jpg', 'data': {'categories': ['#data', '#cv', '#training', '#dataset', '#reasoning', '#survey', '#benchmark', '#optimization'], 'emoji': '🔭', 'ru': {'title': 'Пространственное мышление на всех масштабах: от объектов до городских сцен', 'desc': 'Исследователи представили SpaceVista-7B — модель для пространственного рассуждения, которая работает на всех масштабах от маленьких объектов до больших сцен. Они создали датасет SpaceVista-1M с примерно 1 миллионом пар вопросов-ответов, используя автоматизированный pipeline на основе специализированных моделей для обработки 38 тысяч видео сцен. Модель использует scale-aware экспертов и прогрессивное обучение с наградами, чтобы избежать конфликта знаний между разными масштабами. Эксперименты показали конкурентоспособную производительность на 5 бенчмарках, демонстрируя хорошую генерализацию для робототехники, автономного вождения и других задач.'}, 'en': {'title': 'Advancing Spatial Reasoning with Scale-Aware Models', 'desc': 'This paper presents a novel spatial reasoning model that effectively handles various tasks and scales by utilizing scale-aware experts and a progressive reward system. It addresses challenges in spatial reasoning, particularly the dependence on indoor 3D scans and the need for effective all-scale scene modeling. The authors introduce SpaceVista-1M, a large dataset with over 1 million spatial question-answer pairs, curated from diverse video scenes across multiple scales. The proposed SpaceVista-7B model demonstrates strong generalization capabilities, achieving competitive performance on several benchmarks, thus advancing the field of spatial reasoning in machine learning.'}, 'zh': {'title': '全尺度空间推理的创新解决方案', 'desc': '本论文提出了一种空间推理模型，利用规模感知专家和渐进奖励，在多种任务和尺度上表现出色。研究者们面临的主要挑战包括对室内3D扫描和人工标注的依赖，以及缺乏有效的全尺度场景建模。为了解决这些问题，论文介绍了一种整合结构化空间推理知识系统、规模感知建模和渐进训练范式的整体解决方案。通过创建一个包含38,000个视频场景的SpaceVista-1M数据集，模型在多个基准测试中展示了强大的泛化能力。'}}}, {'id': 'https://huggingface.co/papers/2510.09558', 'title': "AutoPR: Let's Automate Your Academic Promotion!", 'url': 'https://huggingface.co/papers/2510.09558', 'abstract': 'AutoPR, a multi-agent framework, automates the promotion of research papers by transforming them into engaging public content, significantly improving engagement metrics compared to direct LLM pipelines.  \t\t\t\t\tAI-generated summary \t\t\t\t As the volume of peer-reviewed research surges, scholars increasingly rely on social platforms for discovery, while authors invest considerable effort in promoting their work to ensure visibility and citations. To streamline this process and reduce the reliance on human effort, we introduce Automatic Promotion (AutoPR), a novel task that transforms research papers into accurate, engaging, and timely public content. To enable rigorous evaluation, we release PRBench, a multimodal benchmark that links 512 peer-reviewed articles to high-quality promotional posts, assessing systems along three axes: Fidelity (accuracy and tone), Engagement (audience targeting and appeal), and Alignment (timing and channel optimization). We also introduce PRAgent, a multi-agent framework that automates AutoPR in three stages: content extraction with multimodal preparation, collaborative synthesis for polished outputs, and platform-specific adaptation to optimize norms, tone, and tagging for maximum reach. When compared to direct LLM pipelines on PRBench, PRAgent demonstrates substantial improvements, including a 604% increase in total watch time, a 438% rise in likes, and at least a 2.9x boost in overall engagement. Ablation studies show that platform modeling and targeted promotion contribute the most to these gains. Our results position AutoPR as a tractable, measurable research problem and provide a roadmap for scalable, impactful automated scholarly communication.', 'score': 12, 'issue_id': 6377, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': 'f23989f659120bb4', 'authors': ['Qiguang Chen', 'Zheng Yan', 'Mingda Yang', 'Libo Qin', 'Yixin Yuan', 'Hanjing Li', 'Jinhao Liu', 'Yiyan Ji', 'Dengyun Peng', 'Jiannan Guan', 'Mengkang Hu', 'Yantao Du', 'Wanxiang Che'], 'affiliations': ['ByteDance China (Seed)', 'LARG, Research Center for Social Computing and Interactive Robotics, Harbin Institute of Technology', 'School of Computer Science and Engineering, Central South University', 'The University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2510.09558.jpg', 'data': {'categories': ['#agents', '#benchmark', '#optimization', '#multimodal', '#alignment'], 'emoji': '📢', 'ru': {'title': 'Автоматическое продвижение научных статей с помощью мультиагентной системы', 'desc': 'Исследователи представили AutoPR — новую задачу автоматического превращения научных статей в привлекательный контент для социальных сетей. Они создали PRBench — бенчмарк из 512 статей с качественными промо-постами для оценки точности, вовлечённости и соответствия платформе. Их мультиагентный фреймворк PRAgent работает в три этапа: извлечение контента, совместный синтез и адаптация под конкретную платформу. Система показала впечатляющие результаты: увеличение времени просмотра на 604%, лайков на 438% и общей вовлечённости в 2.9 раза по сравнению с прямым использованием LLM.'}, 'en': {'title': 'Transforming Research Promotion with AutoPR', 'desc': 'AutoPR is a multi-agent framework designed to automate the promotion of research papers by converting them into engaging public content. It addresses the challenge of increasing visibility and citations for scholarly work in a crowded digital landscape. The framework includes a benchmark called PRBench, which evaluates promotional effectiveness based on fidelity, engagement, and alignment. Results show that AutoPR significantly outperforms traditional LLM pipelines, enhancing audience engagement metrics like watch time and likes.'}, 'zh': {'title': '自动化推广研究论文的未来', 'desc': 'AutoPR是一个多智能体框架，旨在通过将研究论文转化为引人入胜的公共内容，自动化研究论文的推广。随着同行评审研究数量的激增，学者们越来越依赖社交平台来发现研究，而作者则投入大量精力来提升其工作的可见性和引用率。我们提出的PRBench基准测试，连接了512篇同行评审的文章与高质量的推广帖子，从准确性、受众吸引力和时效性等方面评估系统的表现。与直接的LLM管道相比，PRAgent在提升观看时间、点赞数和整体参与度方面显示出显著的改进。'}}}, {'id': 'https://huggingface.co/papers/2510.09608', 'title': 'StreamingVLM: Real-Time Understanding for Infinite Video Streams', 'url': 'https://huggingface.co/papers/2510.09608', 'abstract': 'StreamingVLM is a real-time vision-language model that efficiently processes infinite video streams using a compact KV cache and supervised fine-tuning, achieving high performance on long videos and diverse benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Vision-language models (VLMs) could power real-time assistants and autonomous agents, but they face a critical challenge: understanding near-infinite video streams without escalating latency and memory usage. Processing entire videos with full attention leads to quadratic computational costs and poor performance on long videos. Meanwhile, simple sliding window methods are also flawed, as they either break coherence or suffer from high latency due to redundant recomputation. In this paper, we introduce StreamingVLM, a model designed for real-time, stable understanding of infinite visual input. Our approach is a unified framework that aligns training with streaming inference. During inference, we maintain a compact KV cache by reusing states of attention sinks, a short window of recent vision tokens, and a long window of recent text tokens. This streaming ability is instilled via a simple supervised fine-tuning (SFT) strategy that applies full attention on short, overlapped video chunks, which effectively mimics the inference-time attention pattern without training on prohibitively long contexts. For evaluation, we build Inf-Streams-Eval, a new benchmark with videos averaging over two hours that requires dense, per-second alignment between frames and text. On Inf-Streams-Eval, StreamingVLM achieves a 66.18% win rate against GPT-4O mini and maintains stable, real-time performance at up to 8 FPS on a single NVIDIA H100. Notably, our SFT strategy also enhances general VQA abilities without any VQA-specific fine-tuning, improving performance on LongVideoBench by +4.30 and OVOBench Realtime by +5.96. Code is available at https://github.com/mit-han-lab/streaming-vlm.', 'score': 8, 'issue_id': 6375, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': 'ef99bf0338c5c2c5', 'authors': ['Ruyi Xu', 'Guangxuan Xiao', 'Yukang Chen', 'Liuning He', 'Kelly Peng', 'Yao Lu', 'Song Han'], 'affiliations': ['First Intelligence', 'MIT', 'NVIDIA'], 'pdf_title_img': 'assets/pdf/title_img/2510.09608.jpg', 'data': {'categories': ['#cv', '#video', '#long_context', '#training', '#multimodal', '#benchmark', '#optimization', '#agents'], 'emoji': '🎬', 'ru': {'title': 'Бесконечные видеопотоки без перегрузки памяти', 'desc': 'StreamingVLM - это модель для обработки бесконечных видеопотоков в реальном времени, которая решает проблему растущих затрат памяти и вычислений. Модель использует компактный KV-кеш, сохраняя только ключевые токены (attention sinks, недавние визуальные и текстовые токены) вместо всей истории. Обучение происходит через supervised fine-tuning на коротких перекрывающихся фрагментах видео, что имитирует паттерн внимания при инференсе. На новом бенчмарке с двухчасовыми видео модель достигает 66.18% win rate против GPT-4O mini и работает в реальном времени на одной H100.'}, 'en': {'title': 'Real-Time Understanding of Infinite Video Streams', 'desc': 'StreamingVLM is a vision-language model designed to process continuous video streams in real-time while minimizing latency and memory usage. It utilizes a compact key-value (KV) cache and a supervised fine-tuning (SFT) strategy to maintain coherence and efficiency during inference. By applying full attention on short, overlapping video segments, it effectively simulates the attention patterns needed for long videos without the computational burden of processing entire videos at once. The model demonstrates superior performance on the new Inf-Streams-Eval benchmark, achieving high win rates against existing models and improving visual question answering capabilities without specific fine-tuning.'}, 'zh': {'title': '实时处理无限视频流的智能模型', 'desc': 'StreamingVLM是一种实时视觉-语言模型，能够高效处理无限的视频流。它通过紧凑的KV缓存和监督微调，解决了长视频处理中的延迟和内存使用问题。该模型在推理时重用注意力状态，结合短窗口和长窗口的视觉和文本标记，确保了稳定的理解能力。评估结果显示，StreamingVLM在新的基准测试中表现优异，具有实时性能和增强的视觉问答能力。'}}}, {'id': 'https://huggingface.co/papers/2510.08696', 'title': "Don't Waste Mistakes: Leveraging Negative RL-Groups via Confidence\n  Reweighting", 'url': 'https://huggingface.co/papers/2510.08696', 'abstract': 'LENS modifies GRPO by assigning confidence-dependent rewards to incorrect responses, improving efficiency and performance in reinforcement learning with verifiable rewards.  \t\t\t\t\tAI-generated summary \t\t\t\t Reinforcement learning with verifiable rewards (RLVR) has become a standard recipe for improving large language models (LLMs) on reasoning tasks, with Group Relative Policy Optimization (GRPO) widely used in practice. Yet GRPO wastes substantial compute on negative groups: groups in which no sampled response is correct yield zero advantage and thus no gradient. We ask whether negative groups can be leveraged without extra supervision. Starting from a maximum-likelihood (MLE) objective in reward modeling, we show that the MLE gradient is equivalent to a policy gradient for a modified value function. This value function adds a confidence-weighted penalty on incorrect responses, imposing larger penalties on more confident mistakes. We refer to this as Likelihood Estimation with Negative Samples (LENS). LENS modifies GRPO to assign non-zero, confidence-dependent rewards to incorrect generations, making negative groups informative and converting previously wasted samples into useful gradient updates. On the MATH benchmark with Llama-3.1-8B and Qwen-2.5-3B, the proposed variant consistently outperforms GRPO baseline, with significant gains on harder items. These results demonstrate a principled and practical way to "rescue" negative groups, improving efficiency and performance in RLVR.', 'score': 8, 'issue_id': 6375, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': '8ebc9455daa7299d', 'authors': ['Yunzhen Feng', 'Parag Jain', 'Anthony Hartshorn', 'Yaqi Duan', 'Julia Kempe'], 'affiliations': ['Meta Superintelligence Labs', 'New York University'], 'pdf_title_img': 'assets/pdf/title_img/2510.08696.jpg', 'data': {'categories': ['#training', '#reasoning', '#benchmark', '#rl', '#optimization', '#rlhf'], 'emoji': '🔍', 'ru': {'title': 'Превращая ошибки в уроки: как извлечь пользу из неправильных ответов LLM', 'desc': 'Статья представляет метод LENS, который улучшает алгоритм GRPO для обучения языковых моделей на задачах рассуждения. Проблема GRPO в том, что он тратит вычислительные ресурсы впустую на «негативные группы» — случаи, где все сгенерированные ответы неверные и не дают обучающего сигнала. LENS решает это, назначая неправильным ответам штрафы, зависящие от уверенности модели: чем увереннее модель в неправильном ответе, тем больше штраф. Эксперименты на бенчмарке MATH показывают, что LENS превосходит базовый GRPO, особенно на сложных задачах, превращая ранее бесполезные примеры в полезные обновления градиентов.'}, 'en': {'title': 'Transforming Mistakes into Learning: LENS in Reinforcement Learning', 'desc': 'This paper introduces LENS, a method that enhances Group Relative Policy Optimization (GRPO) by incorporating confidence-dependent rewards for incorrect responses in reinforcement learning. By leveraging negative groups, which traditionally provide no gradient information, LENS assigns non-zero penalties based on the confidence of mistakes, thus transforming wasted computational resources into valuable learning signals. The approach is grounded in a maximum-likelihood objective, showing that the modified value function can effectively guide policy updates. Experimental results on the MATH benchmark demonstrate that LENS significantly outperforms the GRPO baseline, particularly on challenging tasks, highlighting its efficiency and effectiveness in reinforcement learning with verifiable rewards.'}, 'zh': {'title': '利用置信度提升强化学习效率', 'desc': 'LENS是一种改进的强化学习方法，通过对错误响应分配与置信度相关的奖励，提升了效率和性能。它在奖励建模中采用最大似然估计（MLE）目标，展示了MLE梯度与修改后的价值函数的策略梯度等价。该价值函数对错误响应施加置信度加权的惩罚，对更自信的错误施加更大的惩罚。通过这种方式，LENS使得负样本组变得有用，从而提高了强化学习的效果。'}}}, {'id': 'https://huggingface.co/papers/2510.08189', 'title': 'R-Horizon: How Far Can Your Large Reasoning Model Really Go in Breadth\n  and Depth?', 'url': 'https://huggingface.co/papers/2510.08189', 'abstract': "R-HORIZON, a method using query composition, improves long-horizon reasoning in Large Reasoning Models through a benchmark of complex multi-step tasks, enhancing performance and accuracy.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent trends in test-time scaling for reasoning models (e.g., OpenAI o1, DeepSeek-R1) have led to remarkable improvements through long Chain-of-Thought (CoT). However, existing benchmarks mainly focus on immediate, single-horizon tasks, failing to adequately evaluate models' ability to understand and respond to complex, long-horizon scenarios. To address this incomplete evaluation of Large Reasoning Models (LRMs), we propose R-HORIZON, a method designed to stimulate long-horizon reasoning behaviors in LRMs through query composition. Based on R-HORIZON, we construct a long-horizon reasoning benchmark, comprising complex multi-step reasoning tasks with interdependent problems that span long reasoning horizons. Through comprehensive evaluation of LRMs using the R-HORIZON benchmark, we find that even the most advanced LRMs suffer significant performance degradation. Our analysis reveals that LRMs exhibit limited effective reasoning length and struggle to allocate thinking budget across multiple problems appropriately. Recognizing these limitations, we use R-HORIZON to construct long-horizon reasoning data for reinforcement learning with verified rewards (RLVR). Compared to training with single-horizon data, RLVR with R-HORIZON not only substantially improves performance on the multi-horizon reasoning tasks, but also promotes accuracy on standard reasoning tasks, with an increase of 7.5 on AIME2024. These results position R-HORIZON as a scalable, controllable, and low-cost paradigm for enhancing and evaluating the long-horizon reasoning capabilities of LRMs.", 'score': 8, 'issue_id': 6375, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': '4d2818b42a388048', 'authors': ['Yi Lu', 'Jianing Wang', 'Linsen Guo', 'Wei He', 'Hongyin Tang', 'Tao Gui', 'Xuanjing Huang', 'Xuezhi Cao', 'Wei Wang', 'Xunliang Cai'], 'affiliations': ['Fudan University', 'Meituan'], 'pdf_title_img': 'assets/pdf/title_img/2510.08189.jpg', 'data': {'categories': ['#long_context', '#training', '#reasoning', '#benchmark', '#rl'], 'emoji': '🔭', 'ru': {'title': 'R-HORIZON: Обучение AI мыслить на дальние дистанции', 'desc': 'Статья представляет R-HORIZON - метод для оценки и улучшения способности больших языковых моделей к долгосрочному многоэтапному рассуждению. Авторы создали бенчмарк из сложных взаимосвязанных задач и обнаружили, что даже продвинутые модели показывают значительное снижение качества на длинных цепочках рассуждений. Модели имеют ограниченную эффективную длину рассуждений и плохо распределяют вычислительный бюджет между несколькими подзадачами. Использование R-HORIZON для обучения с подкреплением улучшает производительность на многошаговых задачах и повышает точность на стандартных задачах на 7.5 пунктов.'}, 'en': {'title': 'R-HORIZON: Elevating Long-Horizon Reasoning in AI Models', 'desc': "The paper introduces R-HORIZON, a novel method that enhances long-horizon reasoning in Large Reasoning Models (LRMs) through query composition. It identifies a gap in existing benchmarks that primarily assess immediate tasks, which do not challenge models' abilities to handle complex, multi-step reasoning scenarios. By creating a benchmark that includes interdependent problems requiring extended reasoning, R-HORIZON reveals significant performance limitations in current LRMs. The study demonstrates that using R-HORIZON for reinforcement learning with verified rewards leads to substantial improvements in both multi-horizon and standard reasoning tasks."}, 'zh': {'title': 'R-HORIZON：提升长时间推理能力的创新方法', 'desc': 'R-HORIZON是一种通过查询组合的方法，旨在提高大型推理模型在长时间推理任务中的表现。该方法构建了一个包含复杂多步骤推理任务的基准，能够更好地评估模型在长时间推理场景中的能力。研究发现，现有的推理模型在处理长时间推理时表现不佳，尤其是在多个问题之间分配思考资源方面存在困难。通过使用R-HORIZON进行强化学习训练，模型在多时间推理任务上的表现显著提升，准确率也有所提高。'}}}, {'id': 'https://huggingface.co/papers/2510.08457', 'title': 'ARES: Multimodal Adaptive Reasoning via Difficulty-Aware Token-Level\n  Entropy Shaping', 'url': 'https://huggingface.co/papers/2510.08457', 'abstract': 'ARES, a unified framework for adaptive reasoning, dynamically adjusts exploration effort based on task difficulty using high window-entropy tokens and hierarchical entropy rewards, improving performance and efficiency across various benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in multimodal large reasoning models (MLRMs) have substantially improved their ability to solve complex textual and visual tasks. However, these models tend to overthink on simple problems, producing unnecessarily lengthy reasoning traces, while under-exploring on challenging ones, leading to missed solutions. To address this imbalance, we propose ARES, a unified open-source framework for adaptive reasoning that dynamically allocates exploration effort based on task difficulty. Our approach is motivated by two key empirical findings: (i) while single-token entropy is noisy, high window-entropy (HWE) tokens (token-level entropies averaged under a sliding window) can reliably capture reasoning-critical moments; and (ii) reducing HWE usage benefits easy problems, while increasing it is essential for solving hard ones. Building on these insights, ARES introduces a two-stage training pipeline. In the Adaptive Cold-Start stage, we curate multimodal and textual data paired with reasoning traces of length proportional to problem difficulty, equipping the model with initial difficulty awareness. In the second stage, we develop Adaptive Entropy Policy Optimization (AEPO), which uses HWE tokens as exploration triggers to decide when to explore, and a hierarchical entropy reward with dynamic KL control to decide how much to explore. Extensive experiments demonstrate that ARES achieves superior performance and reasoning efficiency across diverse mathematical, logical, and multimodal benchmarks, while closing the gap to leading commercial systems under significantly lower inference costs.', 'score': 7, 'issue_id': 6377, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': 'a820ad18887c9b93', 'authors': ['Shuang Chen', 'Yue Guo', 'Yimeng Ye', 'Shijue Huang', 'Wenbo Hu', 'Haoxi Li', 'Manyuan Zhang', 'Jiayu Chen', 'Song Guo', 'Nanyun Peng'], 'affiliations': ['Columbia University', 'The Chinese University of Hong Kong', 'The Hong Kong University of Science and Technology', 'University of California, Los Angeles'], 'pdf_title_img': 'assets/pdf/title_img/2510.08457.jpg', 'data': {'categories': ['#training', '#reasoning', '#benchmark', '#optimization', '#open_source', '#multimodal', '#dataset'], 'emoji': '🎯', 'ru': {'title': 'ARES: Адаптивное мышление AI в зависимости от сложности задачи', 'desc': 'Статья представляет фреймворк ARES, который решает проблему неэффективного распределения вычислительных усилий в multimodal LLM: модели слишком много «думают» над простыми задачами и недостаточно над сложными. ARES использует high window-entropy токены для определения критических моментов рассуждения и динамически регулирует глубину исследования в зависимости от сложности задачи. Обучение происходит в два этапа: сначала модель учится на данных с длиной рассуждений, пропорциональной сложности, затем применяется метод Adaptive Entropy Policy Optimization для управления исследованием. В результате достигается улучшенная производительность на математических, логических и мультимодальных бенчмарках при значительно меньших затратах на inference по сравнению с коммерческими системами.'}, 'en': {'title': 'Adaptive Reasoning Made Efficient with ARES', 'desc': 'ARES is a novel framework designed to enhance adaptive reasoning in multimodal large reasoning models (MLRMs) by adjusting exploration efforts based on the difficulty of tasks. It utilizes high window-entropy tokens to identify critical reasoning moments and employs hierarchical entropy rewards to optimize exploration strategies. The framework consists of a two-stage training process that first establishes difficulty awareness through curated data and then applies Adaptive Entropy Policy Optimization to fine-tune exploration. As a result, ARES improves both performance and efficiency in solving complex problems while reducing unnecessary reasoning for simpler tasks.'}, 'zh': {'title': 'ARES：自适应推理的统一框架', 'desc': 'ARES是一个统一的自适应推理框架，能够根据任务难度动态调整探索力度。它利用高窗口熵令牌和层次熵奖励来提高在各种基准测试中的性能和效率。通过两阶段的训练流程，ARES首先通过与推理轨迹相匹配的数据来增强模型的难度意识，然后通过自适应熵策略优化来决定何时和如何进行探索。实验结果表明，ARES在数学、逻辑和多模态基准测试中表现优异，同时在推理成本上显著低于领先的商业系统。'}}}, {'id': 'https://huggingface.co/papers/2510.09517', 'title': 'StatEval: A Comprehensive Benchmark for Large Language Models in\n  Statistics', 'url': 'https://huggingface.co/papers/2510.09517', 'abstract': 'StatEval is a comprehensive benchmark for statistical reasoning, covering foundational and research-level problems, and highlights the limitations of current LLMs in this domain.  \t\t\t\t\tAI-generated summary \t\t\t\t Large language models (LLMs) have demonstrated remarkable advances in mathematical and logical reasoning, yet statistics, as a distinct and integrative discipline, remains underexplored in benchmarking efforts. To address this gap, we introduce StatEval, the first comprehensive benchmark dedicated to statistics, spanning both breadth and depth across difficulty levels. StatEval consists of 13,817 foundational problems covering undergraduate and graduate curricula, together with 2374 research-level proof tasks extracted from leading journals. To construct the benchmark, we design a scalable multi-agent pipeline with human-in-the-loop validation that automates large-scale problem extraction, rewriting, and quality control, while ensuring academic rigor. We further propose a robust evaluation framework tailored to both computational and proof-based tasks, enabling fine-grained assessment of reasoning ability. Experimental results reveal that while closed-source models such as GPT5-mini achieve below 57\\% on research-level problems, with open-source models performing significantly lower. These findings highlight the unique challenges of statistical reasoning and the limitations of current LLMs. We expect StatEval to serve as a rigorous benchmark for advancing statistical intelligence in large language models. All data and code are available on our web platform: https://stateval.github.io/.', 'score': 6, 'issue_id': 6376, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': 'e02b9230dd95512d', 'authors': ['Yuchen Lu', 'Run Yang', 'Yichen Zhang', 'Shuguang Yu', 'Runpeng Dai', 'Ziwei Wang', 'Jiayi Xiang', 'Wenxin E', 'Siran Gao', 'Xinyao Ruan', 'Yirui Huang', 'Chenjing Xi', 'Haibo Hu', 'Yueming Fu', 'Qinglan Yu', 'Xiaobing Wei', 'Jiani Gu', 'Rui Sun', 'Jiaxuan Jia', 'Fan Zhou'], 'affiliations': ['Shanghai University of Finance and Economics', 'University of North Carolina at Chapel Hill'], 'pdf_title_img': 'assets/pdf/title_img/2510.09517.jpg', 'data': {'categories': ['#benchmark', '#dataset', '#survey', '#reasoning'], 'emoji': '📊', 'ru': {'title': 'StatEval: бенчмарк, который показал слабость LLM в статистике', 'desc': 'Статья представляет StatEval — первый комплексный бенчмарк для оценки статистического мышления LLM, включающий 13,817 базовых задач уровня бакалавриата и магистратуры, а также 2,374 исследовательских задач на доказательство из ведущих научных журналов. Для создания бенчмарка авторы разработали масштабируемый multi-agent pipeline с участием человека, который автоматизирует извлечение, переписывание и контроль качества задач. Экспериментальные результаты показывают, что даже лучшие closed-source модели вроде GPT-4-mini решают менее 57% исследовательских задач, а open-source модели справляются ещё хуже. Это подчёркивает уникальные сложности статистического рассуждения и ограничения современных LLM в этой области.'}, 'en': {'title': 'StatEval: Advancing Statistical Reasoning in LLMs', 'desc': 'StatEval is a new benchmark designed to evaluate statistical reasoning in large language models (LLMs). It includes a wide range of problems, from foundational undergraduate tasks to advanced research-level proofs, totaling over 16,000 questions. The benchmark uses a multi-agent system with human validation to ensure high-quality problem extraction and assessment. Results show that current LLMs struggle with statistical reasoning, indicating a need for improvement in this area.'}, 'zh': {'title': 'StatEval：统计推理的新基准', 'desc': 'StatEval是一个全面的统计推理基准，涵盖基础和研究级别的问题，突显了当前大型语言模型在这一领域的局限性。该基准包含13,817个基础问题，涉及本科和研究生课程，以及2,374个从顶级期刊提取的研究级证明任务。为了构建这个基准，我们设计了一个可扩展的多代理管道，结合人工验证，自动化大规模问题提取、重写和质量控制。实验结果显示，尽管一些封闭源模型在研究级问题上的表现不佳，但StatEval为提升大型语言模型的统计智能提供了严格的评估框架。'}}}, {'id': 'https://huggingface.co/papers/2510.04759', 'title': 'Progressive Gaussian Transformer with Anisotropy-aware Sampling for Open\n  Vocabulary Occupancy Prediction', 'url': 'https://huggingface.co/papers/2510.04759', 'abstract': 'PG-Occ, a Progressive Gaussian Transformer Framework, enhances 3D occupancy prediction with progressive densification and anisotropy-aware sampling, achieving state-of-the-art performance.  \t\t\t\t\tAI-generated summary \t\t\t\t The 3D occupancy prediction task has witnessed remarkable progress in recent years, playing a crucial role in vision-based autonomous driving systems. While traditional methods are limited to fixed semantic categories, recent approaches have moved towards predicting text-aligned features to enable open-vocabulary text queries in real-world scenes. However, there exists a trade-off in text-aligned scene modeling: sparse Gaussian representation struggles to capture small objects in the scene, while dense representation incurs significant computational overhead. To address these limitations, we present PG-Occ, an innovative Progressive Gaussian Transformer Framework that enables open-vocabulary 3D occupancy prediction. Our framework employs progressive online densification, a feed-forward strategy that gradually enhances the 3D Gaussian representation to capture fine-grained scene details. By iteratively enhancing the representation, the framework achieves increasingly precise and detailed scene understanding. Another key contribution is the introduction of an anisotropy-aware sampling strategy with spatio-temporal fusion, which adaptively assigns receptive fields to Gaussians at different scales and stages, enabling more effective feature aggregation and richer scene information capture. Through extensive evaluations, we demonstrate that PG-Occ achieves state-of-the-art performance with a relative 14.3% mIoU improvement over the previous best performing method. Code and pretrained models will be released upon publication on our project page: https://yanchi-3dv.github.io/PG-Occ', 'score': 6, 'issue_id': 6375, 'pub_date': '2025-10-06', 'pub_date_card': {'ru': '6 октября', 'en': 'October 6', 'zh': '10月6日'}, 'hash': '681d2ff717aff51e', 'authors': ['Chi Yan', 'Dan Xu'], 'affiliations': ['The Hong Kong University of Science and Technology (HKUST)', 'ZEEKR Automobile R&D Co., Ltd'], 'pdf_title_img': 'assets/pdf/title_img/2510.04759.jpg', 'data': {'categories': ['#3d', '#cv', '#open_source', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Прогрессивное уплотнение гауссиан для понимания 3D-сцен', 'desc': 'Статья представляет PG-Occ — фреймворк на основе Gaussian Transformer для предсказания 3D occupancy с поддержкой open-vocabulary запросов. Ключевая идея — прогрессивное уплотнение 3D-гауссиан, которое постепенно улучшает детализацию представления сцены без огромных вычислительных затрат. Метод использует анизотропную стратегию сэмплирования с пространственно-временным слиянием для адаптивного назначения рецептивных полей гауссианам разных масштабов. Фреймворк достигает state-of-the-art результатов с улучшением mIoU на 14.3% по сравнению с предыдущими методами для автономного вождения.'}, 'en': {'title': 'Revolutionizing 3D Occupancy Prediction with PG-Occ', 'desc': 'The paper introduces PG-Occ, a Progressive Gaussian Transformer Framework designed to improve 3D occupancy prediction, which is essential for autonomous driving systems. It addresses the limitations of traditional methods by using progressive online densification to enhance Gaussian representations, allowing for better detail capture in complex scenes. Additionally, the framework incorporates an anisotropy-aware sampling strategy that optimizes feature aggregation across different scales, leading to richer scene understanding. The results show that PG-Occ outperforms previous methods, achieving a 14.3% improvement in mean Intersection over Union (mIoU).'}, 'zh': {'title': 'PG-Occ：提升3D占用预测的创新框架', 'desc': 'PG-Occ是一种进步的高斯变换框架，旨在提升3D占用预测的精度。该框架通过逐步在线稠密化，逐渐增强3D高斯表示，以捕捉场景中的细节。它还引入了一个考虑各向异性的采样策略，能够在不同尺度和阶段自适应地分配感受野，从而更有效地聚合特征。通过广泛的评估，PG-Occ在性能上超越了之前的最佳方法，取得了14.3%的mIoU提升。'}}}, {'id': 'https://huggingface.co/papers/2510.09510', 'title': 'MRMR: A Realistic and Expert-Level Multidisciplinary Benchmark for\n  Reasoning-Intensive Multimodal Retrieval', 'url': 'https://huggingface.co/papers/2510.09510', 'abstract': 'MRMR is a benchmark for expert-level multidisciplinary multimodal retrieval that includes reasoning-intensive tasks, contradiction retrieval, and image-text interleaved sequences, highlighting the need for improved multimodal models.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce MRMR, the first expert-level multidisciplinary multimodal retrieval benchmark requiring intensive reasoning. MRMR contains 1,502 queries spanning 23 domains, with positive documents carefully verified by human experts. Compared to prior benchmarks, MRMR introduces three key advancements. First, it challenges retrieval systems across diverse areas of expertise, enabling fine-grained model comparison across domains. Second, queries are reasoning-intensive, with images requiring deeper interpretation such as diagnosing microscopic slides. We further introduce Contradiction Retrieval, a novel task requiring models to identify conflicting concepts. Finally, queries and documents are constructed as image-text interleaved sequences. Unlike earlier benchmarks restricted to single images or unimodal documents, MRMR offers a realistic setting with multi-image queries and mixed-modality corpus documents. We conduct an extensive evaluation of 4 categories of multimodal retrieval systems and 14 frontier models on MRMR. The text embedding model Qwen3-Embedding with LLM-generated image captions achieves the highest performance, highlighting substantial room for improving multimodal retrieval models. Although latest multimodal models such as Ops-MM-Embedding perform competitively on expert-domain queries, they fall short on reasoning-intensive tasks. We believe that MRMR paves the way for advancing multimodal retrieval in more realistic and challenging scenarios.', 'score': 5, 'issue_id': 6376, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '7df9f5952a859ef9', 'authors': ['Siyue Zhang', 'Yuan Gao', 'Xiao Zhou', 'Yilun Zhao', 'Tingyu Song', 'Arman Cohan', 'Anh Tuan Luu', 'Chen Zhao'], 'affiliations': ['Center for Data Science, New York University', 'NYU Shanghai', 'Nanyang Technological University', 'Shanghai Jiao Tong University', 'University of the Chinese Academy of Sciences', 'Yale University'], 'pdf_title_img': 'assets/pdf/title_img/2510.09510.jpg', 'data': {'categories': ['#benchmark', '#games', '#reasoning', '#multimodal'], 'emoji': '🔬', 'ru': {'title': 'Мультимодальный поиск экспертного уровня с глубоким reasoning', 'desc': 'MRMR — это первый бенчмарк для мультимодального retrieval экспертного уровня, требующий интенсивного reasoning. Он содержит 1502 запроса из 23 областей знаний с документами, проверенными экспертами, и включает image-text interleaved sequences (чередующиеся последовательности изображений и текста). Бенчмарк вводит новую задачу Contradiction Retrieval — поиск противоречащих концепций, и требует глубокой интерпретации изображений, например, диагностики микроскопических снимков. Тестирование 14 frontier моделей показало, что текстовая embedding модель Qwen3-Embedding с описаниями изображений от LLM показывает лучшие результаты, но современные мультимодальные модели всё ещё испытывают трудности с reasoning-intensive задачами.'}, 'en': {'title': 'MRMR: Advancing Multimodal Retrieval with Expert-Level Challenges', 'desc': 'The MRMR benchmark is designed to test advanced multimodal retrieval systems by incorporating complex reasoning tasks and contradiction retrieval. It includes 1,502 queries across 23 different domains, with documents verified by experts to ensure quality. This benchmark emphasizes the need for models that can interpret images deeply and handle mixed modalities effectively. The evaluation shows that while some models perform well, there is significant potential for improvement in reasoning capabilities within multimodal retrieval.'}, 'zh': {'title': 'MRMR：推动多模态检索的新基准', 'desc': 'MRMR是一个针对专家级多学科多模态检索的基准，强调了对多模态模型的改进需求。该基准包含1502个查询，覆盖23个领域，所有正面文档均由人类专家仔细验证。MRMR引入了三个关键进展，包括跨领域的检索挑战、需要深入推理的查询以及矛盾检索任务。通过对多模态检索系统的广泛评估，MRMR为更真实和具有挑战性的场景中的多模态检索提供了新的发展方向。'}}}, {'id': 'https://huggingface.co/papers/2510.09577', 'title': 'Dyna-Mind: Learning to Simulate from Experience for Better AI Agents', 'url': 'https://huggingface.co/papers/2510.09577', 'abstract': "Introducing Dyna-Mind, a two-stage training framework that enhances AI agents' reasoning and planning abilities through simulation, leading to improved performance in complex interactive environments.  \t\t\t\t\tAI-generated summary \t\t\t\t Reasoning models have recently shown remarkable progress in domains such as math and coding. However, their expert-level abilities in math and coding contrast sharply with their performance in long-horizon, interactive tasks such as web navigation and computer/phone-use. Inspired by literature on human cognition, we argue that current AI agents need ''vicarious trial and error'' - the capacity to mentally simulate alternative futures before acting - in order to enhance their understanding and performance in complex interactive environments. We introduce Dyna-Mind, a two-stage training framework that explicitly teaches (V)LM agents to integrate such simulation into their reasoning. In stage 1, we introduce Reasoning with Simulations (ReSim), which trains the agent to generate structured reasoning traces from expanded search trees built from real experience gathered through environment interactions. ReSim thus grounds the agent's reasoning in faithful world dynamics and equips it with the ability to anticipate future states in its reasoning. In stage 2, we propose Dyna-GRPO, an online reinforcement learning method to further strengthen the agent's simulation and decision-making ability by using both outcome rewards and intermediate states as feedback from real rollouts. Experiments on two synthetic benchmarks (Sokoban and ALFWorld) and one realistic benchmark (AndroidWorld) demonstrate that (1) ReSim effectively infuses simulation ability into AI agents, and (2) Dyna-GRPO leverages outcome and interaction-level signals to learn better policies for long-horizon, planning-intensive tasks. Together, these results highlight the central role of simulation in enabling AI agents to reason, plan, and act more effectively in the ever more challenging environments.", 'score': 4, 'issue_id': 6375, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': 'c25b935d58908751', 'authors': ['Xiao Yu', 'Baolin Peng', 'Michel Galley', 'Hao Cheng', 'Qianhui Wu', 'Janardhan Kulkarni', 'Suman Nath', 'Zhou Yu', 'Jianfeng Gao'], 'affiliations': ['Columbia University, NY', 'Microsoft Research, Redmond'], 'pdf_title_img': 'assets/pdf/title_img/2510.09577.jpg', 'data': {'categories': ['#synthetic', '#training', '#reasoning', '#rl', '#optimization', '#agents'], 'emoji': '🎮', 'ru': {'title': 'Учим AI-агентов думать перед действием через симуляцию', 'desc': 'Dyna-Mind — это двухэтапный фреймворк для обучения AI-агентов, который улучшает их способность к рассуждению и планированию через ментальную симуляцию возможных сценариев. На первом этапе метод ReSim учит агента генерировать структурированные цепочки рассуждений на основе деревьев поиска, построенных из реального опыта взаимодействия со средой. На втором этапе Dyna-GRPO использует онлайн reinforcement learning с учётом как финальных наград, так и промежуточных состояний для улучшения навыков симуляции и принятия решений. Эксперименты на синтетических бенчмарках (Sokoban, ALFWorld) и реалистичном AndroidWorld показали, что симуляция будущих состояний существенно повышает эффективность агентов в долгосрочных интерактивных задачах.'}, 'en': {'title': 'Empowering AI with Simulation for Smarter Decision-Making', 'desc': "Dyna-Mind is a two-stage training framework designed to improve AI agents' reasoning and planning skills through simulation. The first stage, Reasoning with Simulations (ReSim), helps agents create structured reasoning paths by simulating potential future scenarios based on real experiences. The second stage, Dyna-GRPO, employs online reinforcement learning to enhance decision-making by utilizing both rewards and intermediate feedback from real interactions. This approach demonstrates that incorporating simulation significantly boosts AI agents' performance in complex tasks that require long-term planning and reasoning."}, 'zh': {'title': 'Dyna-Mind：通过模拟提升 AI 代理的推理与规划能力', 'desc': 'Dyna-Mind 是一个两阶段的训练框架，旨在通过模拟增强 AI 代理的推理和规划能力，从而提高其在复杂交互环境中的表现。第一阶段是模拟推理（ReSim），它训练代理从真实环境交互中生成结构化的推理轨迹，帮助代理理解世界动态并预测未来状态。第二阶段是 Dyna-GRPO，这是一种在线强化学习方法，通过使用结果奖励和中间状态反馈，进一步增强代理的模拟和决策能力。实验结果表明，Dyna-Mind 有效地提升了 AI 代理在长时间规划任务中的表现，强调了模拟在推理和决策中的重要性。'}}}, {'id': 'https://huggingface.co/papers/2510.08697', 'title': 'BigCodeArena: Unveiling More Reliable Human Preferences in Code\n  Generation via Execution', 'url': 'https://huggingface.co/papers/2510.08697', 'abstract': 'BigCodeArena is an open human evaluation platform for code generation that enables real-time execution and interaction, revealing preferences and capabilities of LLMs in coding tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t Crowdsourced model evaluation platforms, such as Chatbot Arena, enable real-time evaluation from human perspectives to assess the quality of model responses. In the coding domain, manually examining the quality of LLM-generated content is extremely challenging, as it requires understanding long chunks of raw code and deliberately simulating code execution. To this end, we introduce BigCodeArena, an open human evaluation platform for code generation backed by a comprehensive and on-the-fly execution environment. Built on top of Chatbot Arena, BigCodeArena enables the execution of LLM-generated code and allows humans to interact with the execution process and outcomes. We collected over 14,000 raw code-centric conversation sessions across 10 widely used LLMs, spanning 10 languages and 8 types of execution environments. Among these conversations, we identified more than 4,700 multi-turn samples with pairwise human preferences. Further analysis uncovers underexplored preferences of LLMs in fine-grained domains characterized by tasks, languages, and frameworks. To systematically examine code understanding and generation capabilities of frontier LLMs, we curated two benchmarks based on the collected data, namely BigCodeReward and AutoCodeArena. For BigCodeReward, we post-processed the 4,700 conversations and evaluated the consistency between reward models and human preferences. The evaluation shows that most LLMs have superior performance in judging coding preferences when the execution results are available. Inspired by these findings, we propose AutoCodeArena, an automatic Elo rating benchmark designed to assess the coding quality of LLMs without human involvement. We find that proprietary LLMs like GPT-5, Claude-Sonnet-4, and Claude-Opus-4 still lead in code generation performance among recent emerging models.', 'score': 4, 'issue_id': 6375, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': 'ad4cd46a5b83fe05', 'authors': ['Terry Yue Zhuo', 'Xiaolong Jin', 'Hange Liu', 'Juyong Jiang', 'Tianyang Liu', 'Chen Gong', 'Bhupesh Bishnoi', 'Vaisakhi Mishra', 'Marek Suppa', 'Noah Ziems', 'Saiteja Utpala', 'Ming Xu', 'Guangyu Song', 'Kaixin Li', 'Yuhan Cao', 'Bo Liu', 'Zheng Liu', 'Sabina Abdurakhmanova', 'Wenhao Yu', 'Mengzhao Jia', 'Jihan Yao', 'Kenneth Hamilton', 'Kumar Shridhar', 'Minh Chien Vu', 'Dingmin Wang', 'Jiawei Liu', 'Zijian Wang', 'Qian Liu', 'Binyuan Hui', 'Meg Risdal', 'Ahsen Khaliq', 'Atin Sood', 'Zhenchang Xing', 'Wasi Uddin Ahmad', 'John Grundy', 'David Lo', 'Banghua Zhu', 'Xiaoning Du', 'Torsten Scholak', 'Leandro von Werra'], 'affiliations': ['CNRS, France', 'CSIROs Data61', 'Cisco', 'Comenius University in Bratislava', 'Detomo Inc', 'ETH Zurich', 'Google', 'HKUST (Guangzhou)', 'Hugging Face', 'IBM', 'Independent', 'Institute of Automation, CAS', 'Monash University', 'NUS', 'NVIDIA', 'Nevsky Collective', 'Purdue University', 'ServiceNow Research', 'Singapore Management University', 'Tano Labs', 'Tencent AI Lab', 'UCSD', 'UIUC', 'UVA', 'Uber', 'University of Notre Dame', 'University of Oxford', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2510.08697.jpg', 'data': {'categories': ['#games', '#dataset', '#multilingual', '#benchmark', '#open_source'], 'emoji': '⚔️', 'ru': {'title': 'Арена для кода: краудсорсинговая оценка способностей LLM в программировании', 'desc': 'BigCodeArena — это открытая платформа для оценки генерации кода с помощью людей, которая позволяет выполнять код в реальном времени и взаимодействовать с процессом выполнения. Исследователи собрали более 14,000 диалогов с участием 10 популярных LLM и выделили 4,700 примеров с предпочтениями пользователей. На основе собранных данных созданы два бенчмарка: BigCodeReward для оценки reward-моделей и AutoCodeArena для автоматического ранжирования качества кода. Результаты показывают, что проприетарные модели вроде GPT-5, Claude-Sonnet-4 и Claude-Opus-4 по-прежнему лидируют в генерации кода среди современных моделей.'}, 'en': {'title': 'Revolutionizing Code Evaluation with BigCodeArena', 'desc': 'BigCodeArena is a platform designed for evaluating code generation by large language models (LLMs) through real-time human interaction and code execution. It allows users to execute LLM-generated code and observe the outcomes, making it easier to assess the quality of the generated content. The platform has gathered extensive data from over 14,000 coding sessions across various LLMs and programming languages, revealing insights into human preferences and model capabilities. Additionally, it introduces benchmarks like BigCodeReward and AutoCodeArena to systematically evaluate LLM performance in coding tasks, highlighting the strengths of leading models in this domain.'}, 'zh': {'title': 'BigCodeArena：实时评估代码生成的开放平台', 'desc': 'BigCodeArena是一个开放的人类评估平台，专注于代码生成，能够实时执行和互动，揭示大型语言模型（LLMs）在编码任务中的偏好和能力。该平台基于Chatbot Arena，支持对LLM生成的代码进行执行，并允许人类与执行过程和结果进行互动。我们收集了超过14,000个与代码相关的对话会话，涵盖10种流行的LLM和8种执行环境，识别出超过4,700个多轮样本及其人类偏好。通过分析，我们发现LLMs在细分领域的偏好尚未被充分探索，并提出了BigCodeReward和AutoCodeArena两个基准，以系统性地评估前沿LLMs的代码理解和生成能力。'}}}, {'id': 'https://huggingface.co/papers/2510.08047', 'title': 'Pseudo2Real: Task Arithmetic for Pseudo-Label Correction in Automatic\n  Speech Recognition', 'url': 'https://huggingface.co/papers/2510.08047', 'abstract': 'A parameter-space correction method reduces Word Error Rate in ASR systems by addressing pseudo-label biases without target ground truth.  \t\t\t\t\tAI-generated summary \t\t\t\t Robust ASR under domain shift is crucial because real-world systems encounter unseen accents and domains with limited labeled data. Although pseudo-labeling offers a practical workaround, it often introduces systematic, accent-specific errors that filtering fails to fix. We ask: How can we correct these recurring biases without target ground truth? We propose a simple parameter-space correction: in a source domain containing both real and pseudo-labeled data, two ASR models are fine-tuned from the same initialization, one on ground-truth labels and the other on pseudo-labels, and their weight difference forms a correction vector that captures pseudo-label biases. When applied to a pseudo-labeled target model, this vector enhances recognition, achieving up to a 35% relative Word Error Rate (WER) reduction on AfriSpeech-200 across ten African accents with the Whisper tiny model.', 'score': 4, 'issue_id': 6375, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': 'abba5710f84f98b1', 'authors': ['Yi-Cheng Lin', 'Yu-Hsuan Li Liang', 'Hsuan Su', 'Tzu-Quan Lin', 'Shang-Tse Chen', 'Yun-Nung Chen', 'Hung-yi Lee'], 'affiliations': ['National Taiwan University, Taipei, Taiwan'], 'pdf_title_img': 'assets/pdf/title_img/2510.08047.jpg', 'data': {'categories': ['#data', '#training', '#low_resource', '#optimization', '#audio'], 'emoji': '🗣️', 'ru': {'title': 'Коррекция параметров для улучшения распознавания речи', 'desc': 'В статье рассматривается метод коррекции параметров для снижения уровня ошибок в системах распознавания речи (ASR) без использования истинных меток. Проблема заключается в том, что псевдо-метки часто вносят систематические ошибки, связанные с акцентами, которые сложно исправить. Предложенный метод использует разницу в весах двух моделей, обученных на реальных и псевдо-метках, для создания вектора коррекции. Этот вектор позволяет улучшить распознавание речи, снижая уровень ошибок до 35% на различных африканских акцентах.'}, 'en': {'title': 'Correcting Pseudo-Label Biases for Better ASR Performance', 'desc': 'This paper presents a method to improve Automatic Speech Recognition (ASR) systems by correcting biases introduced by pseudo-labels, which are labels generated without ground truth. The authors highlight that ASR systems often struggle with unseen accents and limited labeled data, leading to increased errors. They propose a parameter-space correction technique that involves fine-tuning two ASR models: one on real labels and the other on pseudo-labels, to create a correction vector. This vector is then used to adjust a target model, resulting in a significant reduction in Word Error Rate (WER), demonstrating the effectiveness of the approach across various African accents.'}, 'zh': {'title': '修正伪标签偏差，提升语音识别准确率', 'desc': '本文提出了一种参数空间修正方法，用于减少自动语音识别（ASR）系统中的词错误率（WER）。该方法解决了伪标签偏差的问题，而无需目标真实标签。通过在源域中对两个ASR模型进行微调，一个使用真实标签，另一个使用伪标签，形成的权重差异构成了捕捉伪标签偏差的修正向量。应用该向量后，在AfriSpeech-200数据集上，识别率提高，词错误率相对降低了35%。'}}}, {'id': 'https://huggingface.co/papers/2510.07745', 'title': 'Parallel Test-Time Scaling for Latent Reasoning Models', 'url': 'https://huggingface.co/papers/2510.07745', 'abstract': 'Parallel test-time scaling is enabled for latent reasoning models using uncertainty-inspired sampling strategies and a Latent Reward Model for effective trajectory selection.  \t\t\t\t\tAI-generated summary \t\t\t\t Parallel test-time scaling (TTS) is a pivotal approach for enhancing large language models (LLMs), typically by sampling multiple token-based chains-of-thought in parallel and aggregating outcomes through voting or search. Recent advances in latent reasoning, where intermediate reasoning unfolds in continuous vector spaces, offer a more efficient alternative to explicit Chain-of-Thought, yet whether such latent models can similarly benefit from parallel TTS remains open, mainly due to the absence of sampling mechanisms in continuous space, and the lack of probabilistic signals for advanced trajectory aggregation. \\ This work enables parallel TTS for latent reasoning models by addressing the above issues. For sampling, we introduce two uncertainty-inspired stochastic strategies: Monte Carlo Dropout and Additive Gaussian Noise. For aggregation, we design a Latent Reward Model (LatentRM) trained with step-wise contrastive objective to score and guide latent reasoning. Extensive experiments and visualization analyses show that both sampling strategies scale effectively with compute and exhibit distinct exploration dynamics, while LatentRM enables effective trajectory selection. Together, our explorations open a new direction for scalable inference in continuous spaces. Code released at https://github.com/YRYangang/LatentTTS.', 'score': 4, 'issue_id': 6376, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': 'ee812aca3f8a40eb', 'authors': ['Runyang You', 'Yongqi Li', 'Meng Liu', 'Wenjie Wang', 'Liqiang Nie', 'Wenjie Li'], 'affiliations': ['Harbin Institute of Technology (Shenzhen)', 'Shandong Jianzhu University', 'The Hong Kong Polytechnic University', 'University of Science and Technology of China'], 'pdf_title_img': 'assets/pdf/title_img/2510.07745.jpg', 'data': {'categories': ['#inference', '#architecture', '#reasoning', '#optimization', '#training'], 'emoji': '🔍', 'ru': {'title': 'Новые горизонты масштабирования в латентных моделях рассуждения', 'desc': 'В статье рассматривается метод параллельного масштабирования во время тестирования для моделей латентного рассуждения, который улучшает работу больших языковых моделей (LLM). Авторы предлагают использовать две стохастические стратегии, вдохновленные неопределенностью: Monte Carlo Dropout и аддитивный гауссовский шум для выборки. Для агрегации результатов разработана модель латентного вознаграждения, которая помогает в выборе траекторий рассуждения. Эксперименты показывают, что предложенные методы эффективно масштабируются и открывают новые возможности для вывода в непрерывных пространствах.'}, 'en': {'title': 'Enhancing Latent Reasoning with Parallel Test-Time Scaling', 'desc': 'This paper presents a method to improve the performance of latent reasoning models during test-time by using parallel test-time scaling (TTS). It introduces two innovative sampling strategies, Monte Carlo Dropout and Additive Gaussian Noise, which help in selecting effective reasoning trajectories in continuous vector spaces. Additionally, a Latent Reward Model (LatentRM) is developed to score these trajectories, enhancing the aggregation process. The results demonstrate that these techniques not only scale well with computational resources but also provide unique exploration dynamics for better inference.'}, 'zh': {'title': '提升潜在推理模型的并行测试扩展能力', 'desc': '本文提出了一种新的方法，使潜在推理模型能够在测试时进行并行扩展。通过引入不确定性启发的采样策略，如蒙特卡洛丢弃法和加性高斯噪声，解决了在连续空间中缺乏采样机制的问题。同时，设计了一种潜在奖励模型（LatentRM），用于有效地选择推理轨迹。实验结果表明，这些方法在计算资源上具有良好的扩展性，并且能够有效引导潜在推理。'}}}, {'id': 'https://huggingface.co/papers/2510.08867', 'title': 'ReviewerToo: Should AI Join The Program Committee? A Look At The Future\n  of Peer Review', 'url': 'https://huggingface.co/papers/2510.08867', 'abstract': 'ReviewerToo, a modular AI-assisted peer review framework, complements human judgment with systematic assessments, achieving high accuracy and quality in specific domains while highlighting areas where human expertise remains essential.  \t\t\t\t\tAI-generated summary \t\t\t\t Peer review is the cornerstone of scientific publishing, yet it suffers from inconsistencies, reviewer subjectivity, and scalability challenges. We introduce ReviewerToo, a modular framework for studying and deploying AI-assisted peer review to complement human judgment with systematic and consistent assessments. ReviewerToo supports systematic experiments with specialized reviewer personas and structured evaluation criteria, and can be partially or fully integrated into real conference workflows. We validate ReviewerToo on a carefully curated dataset of 1,963 paper submissions from ICLR 2025, where our experiments with the gpt-oss-120b model achieves 81.8% accuracy for the task of categorizing a paper as accept/reject compared to 83.9% for the average human reviewer. Additionally, ReviewerToo-generated reviews are rated as higher quality than the human average by an LLM judge, though still trailing the strongest expert contributions. Our analysis highlights domains where AI reviewers excel (e.g., fact-checking, literature coverage) and where they struggle (e.g., assessing methodological novelty and theoretical contributions), underscoring the continued need for human expertise. Based on these findings, we propose guidelines for integrating AI into peer-review pipelines, showing how AI can enhance consistency, coverage, and fairness while leaving complex evaluative judgments to domain experts. Our work provides a foundation for systematic, hybrid peer-review systems that scale with the growth of scientific publishing.', 'score': 3, 'issue_id': 6375, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': '2d81b8196c727d2e', 'authors': ['Gaurav Sahu', 'Hugo Larochelle', 'Laurent Charlin', 'Christopher Pal'], 'affiliations': ['Canada CIFAR Chair', 'HEC Montreal', 'Mila Quebec AI Institute', 'Polytechnique Montreal', 'ServiceNow Research', 'Universite de Montreal'], 'pdf_title_img': 'assets/pdf/title_img/2510.08867.jpg', 'data': {'categories': ['#data', '#dataset', '#multimodal', '#ethics', '#benchmark', '#science'], 'emoji': '🔍', 'ru': {'title': 'AI-рецензент: систематичность машины плюс экспертиза человека', 'desc': 'В статье представлен ReviewerToo — модульный фреймворк для AI-ассистированного научного рецензирования, который дополняет человеческую экспертизу систематической оценкой. На датасете из 1963 статей с конференции ICLR 2025 система достигла 81.8% точности в классификации accept/reject (против 83.9% у среднего человека-рецензента), а качество AI-генерируемых рецензий оценивается выше человеческого среднего. Анализ показал, что AI хорошо справляется с проверкой фактов и охватом литературы, но испытывает трудности с оценкой методологической новизны и теоретического вклада. Работа предлагает рекомендации по внедрению гибридных систем рецензирования, где AI повышает консистентность и справедливость, а сложные оценочные суждения остаются за экспертами.'}, 'en': {'title': 'Enhancing Peer Review with AI: A Hybrid Approach', 'desc': 'ReviewerToo is a modular framework designed to enhance the peer review process in scientific publishing by integrating AI with human judgment. It systematically evaluates paper submissions, achieving high accuracy in categorizing them as accept or reject, while also providing consistent assessments. The framework has been validated using a dataset from ICLR 2025, showing that AI-generated reviews can match human accuracy and are often rated higher in quality. However, it also identifies areas where human expertise is crucial, particularly in evaluating methodological novelty and theoretical contributions, suggesting a hybrid approach for future peer review systems.'}, 'zh': {'title': 'AI辅助同行评审，提升科学出版质量', 'desc': 'ReviewerToo是一个模块化的AI辅助同行评审框架，旨在通过系统化评估来补充人类判断，从而在特定领域实现高准确性和质量。该框架支持使用专业评审角色和结构化评估标准进行系统实验，可以部分或完全融入实际会议工作流程。我们的实验表明，ReviewerToo在对论文进行接受/拒绝分类时，准确率达到81.8%，接近人类评审者的83.9%。分析结果显示，AI评审在事实核查和文献覆盖等领域表现优异，但在评估方法新颖性和理论贡献方面仍需依赖人类专家。'}}}, {'id': 'https://huggingface.co/papers/2510.05608', 'title': 'A Goal Without a Plan Is Just a Wish: Efficient and Effective Global\n  Planner Training for Long-Horizon Agent Tasks', 'url': 'https://huggingface.co/papers/2510.05608', 'abstract': "A plan-and-execute framework with EAGLET enhances LLM-based agents' planning abilities, achieving state-of-the-art performance in long-horizon tasks with reduced training costs.  \t\t\t\t\tAI-generated summary \t\t\t\t Agents based on large language models (LLMs) struggle with brainless trial-and-error and generating hallucinatory actions due to a lack of global planning in long-horizon tasks. In this paper, we introduce a plan-and-execute framework and propose EAGLET, an efficient and effective planner training method to enhance the executor agent's planning abilities without human effort. Specifically, we train a plug-and-play global planner through a two-step process: we first synthesize high-quality plans from an advanced LLM using our proposed homologous consensus filtering strategy, and apply fine-tuning as a cold start. Moreover, we further improve the planner with a rule-based reinforcement learning stage using a novel executor capability gain reward, ensuring it can handle task instructions of varying difficulty. Experiments on three long-horizon agent tasks show that executor agents equipped with our planner outperform existing methods, achieving new state-of-the-art performance. Meanwhile, EAGLET reduces training costs by 8x compared to RL-based baselines, and it does not require manual effort or extra training data, offering an efficient and effective solution.", 'score': 3, 'issue_id': 6376, 'pub_date': '2025-10-07', 'pub_date_card': {'ru': '7 октября', 'en': 'October 7', 'zh': '10月7日'}, 'hash': '626ab2660f2e0d4b', 'authors': ['Shuzheng Si', 'Haozhe Zhao', 'Kangyang Luo', 'Gang Chen', 'Fanchao Qi', 'Minjia Zhang', 'Baobao Chang', 'Maosong Sun'], 'affiliations': ['DeepLang AI', 'Peking University', 'Tsinghua University', 'University of Illinois Urbana-Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2510.05608.jpg', 'data': {'categories': ['#rl', '#agents', '#hallucinations', '#reasoning', '#optimization', '#training', '#long_context'], 'emoji': '🦅', 'ru': {'title': 'EAGLET: умный планировщик для LLM-агентов без лишних затрат', 'desc': 'Исследователи предложили фреймворк plan-and-execute с методом EAGLET для улучшения способностей LLM-агентов к планированию в задачах с длинным горизонтом. EAGLET обучает глобальный планировщик в два этапа: сначала синтезирует качественные планы от продвинутой LLM с помощью стратегии гомологичной консенсусной фильтрации, затем дообучает его через reinforcement learning с наградой, основанной на росте возможностей исполнителя. Метод достигает state-of-the-art результатов на трёх задачах с длинным горизонтом, при этом снижая затраты на обучение в 8 раз по сравнению с RL-базовыми методами. Решение не требует ручной разметки или дополнительных данных, предлагая эффективный подход к созданию AI-агентов с улучшенным планированием.'}, 'en': {'title': 'EAGLET: Revolutionizing Planning for LLM Agents', 'desc': 'This paper presents a novel plan-and-execute framework called EAGLET, designed to improve the planning capabilities of large language model (LLM)-based agents. Traditional LLM agents often struggle with ineffective trial-and-error methods and generating incorrect actions due to insufficient global planning for long-horizon tasks. EAGLET enhances planning by synthesizing high-quality plans through a two-step process, which includes using a consensus filtering strategy and fine-tuning the planner. The results demonstrate that agents using EAGLET achieve superior performance on long-horizon tasks while significantly reducing training costs and eliminating the need for manual intervention.'}, 'zh': {'title': '提升LLM代理规划能力的高效框架', 'desc': '本文提出了一种计划与执行框架，并引入了EAGLET，这是一种高效的规划者训练方法，旨在增强基于大型语言模型（LLM）的代理的规划能力。通过两步过程，我们首先利用先进的LLM合成高质量的计划，并应用冷启动的微调。接着，我们通过基于规则的强化学习阶段进一步提升规划者的能力，确保其能够处理不同难度的任务指令。实验结果表明，配备我们规划者的执行代理在三项长时间任务中表现优于现有方法，且训练成本降低了8倍。'}}}, {'id': 'https://huggingface.co/papers/2510.09592', 'title': 'Mind-Paced Speaking: A Dual-Brain Approach to Real-Time Reasoning in\n  Spoken Language Models', 'url': 'https://huggingface.co/papers/2510.09592', 'abstract': 'Mind-Paced Speaking (MPS) is a brain-inspired framework that enables real-time reasoning and fluent speech generation by dividing the process into a "Formulation Brain" for reasoning and an "Articulation Brain" for speech, achieving high accuracy with low latency.  \t\t\t\t\tAI-generated summary \t\t\t\t Real-time Spoken Language Models (SLMs) struggle to leverage Chain-of-Thought (CoT) reasoning due to the prohibitive latency of generating the entire thought process sequentially. Enabling SLMs to think while speaking, similar to humans, is attracting increasing attention. We present, for the first time, Mind-Paced Speaking (MPS), a brain-inspired framework that enables high-fidelity, real-time reasoning. Similar to how humans utilize distinct brain regions for thinking and responding, we propose a novel dual-brain approach, employing a "Formulation Brain" for high-level reasoning to pace and guide a separate "Articulation Brain" for fluent speech generation. This division of labor eliminates mode-switching, preserving the integrity of the reasoning process. Experiments show that MPS significantly outperforms existing think-while-speaking methods and achieves reasoning performance comparable to models that pre-compute the full CoT before speaking, while drastically reducing latency. Under a zero-latency configuration, the proposed method achieves an accuracy of 92.8% on the mathematical reasoning task Spoken-MQA and attains a score of 82.5 on the speech conversation task URO-Bench. Our work effectively bridges the gap between high-quality reasoning and real-time interaction.', 'score': 2, 'issue_id': 6375, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': 'd8062cbce503ccc1', 'authors': ['Donghang Wu', 'Haoyang Zhang', 'Jun Chen', 'Xiangyu', 'Zhang', 'Hexin Liu', 'Eng Siong Chng', 'Fei Tian', 'Xuerui Yang', 'Xiangyu Zhang', 'Daxin Jiang', 'Gang Yu'], 'affiliations': ['Nanyang Technological University', 'StepFun', 'University of New South Wales'], 'pdf_title_img': 'assets/pdf/title_img/2510.09592.jpg', 'data': {'categories': ['#audio', '#reasoning', '#training', '#multimodal'], 'emoji': '🧠', 'ru': {'title': 'Думай и говори одновременно: архитектура двух мозгов для разговорного AI', 'desc': 'Исследователи представили Mind-Paced Speaking (MPS) — фреймворк, вдохновлённый работой человеческого мозга, который позволяет AI-моделям рассуждать и генерировать речь одновременно в режиме реального времени. Система использует архитектуру «двух мозгов»: «Мозг Формулирования» отвечает за высокоуровневое рассуждение по методу Chain-of-Thought, а «Мозг Артикуляции» генерирует плавную речь. Такое разделение задач устраняет необходимость переключения между режимами и сохраняет целостность процесса рассуждения. MPS достигает точности 92.8% на математических задачах и 82.5 баллов на разговорных бенчмарках при практически нулевой задержке, что значительно превосходит существующие методы.'}, 'en': {'title': 'Think and Speak Like a Human with MPS!', 'desc': "Mind-Paced Speaking (MPS) is a novel framework designed to enhance real-time reasoning and speech generation by mimicking human brain functions. It separates the reasoning process into two components: a 'Formulation Brain' for high-level reasoning and an 'Articulation Brain' for fluent speech output. This dual-brain approach allows for simultaneous thinking and speaking, reducing latency and improving accuracy. Experimental results demonstrate that MPS outperforms existing methods, achieving high accuracy in reasoning tasks while maintaining real-time interaction capabilities."}, 'zh': {'title': '实时推理与流畅表达的完美结合', 'desc': 'Mind-Paced Speaking (MPS) 是一种受大脑启发的框架，能够实现实时推理和流畅的语言生成。它将过程分为“推理大脑”和“表达大脑”，前者负责高层次的推理，后者负责流畅的语言表达。通过这种分工，MPS 消除了模式切换，保持了推理过程的完整性。实验表明，MPS 在推理性能和实时交互方面显著优于现有方法。'}}}, {'id': 'https://huggingface.co/papers/2510.09507', 'title': 'PhysToolBench: Benchmarking Physical Tool Understanding for MLLMs', 'url': 'https://huggingface.co/papers/2510.09507', 'abstract': "PhysToolBench evaluates MLLMs' comprehension of physical tools through a VQA dataset, revealing significant deficiencies in tool understanding.  \t\t\t\t\tAI-generated summary \t\t\t\t The ability to use, understand, and create tools is a hallmark of human intelligence, enabling sophisticated interaction with the physical world. For any general-purpose intelligent agent to achieve true versatility, it must also master these fundamental skills. While modern Multimodal Large Language Models (MLLMs) leverage their extensive common knowledge for high-level planning in embodied AI and in downstream Vision-Language-Action (VLA) models, the extent of their true understanding of physical tools remains unquantified. To bridge this gap, we present PhysToolBench, the first benchmark dedicated to evaluating the comprehension of physical tools by MLLMs. Our benchmark is structured as a Visual Question Answering (VQA) dataset comprising over 1,000 image-text pairs. It assesses capabilities across three distinct difficulty levels: (1) Tool Recognition: Requiring the recognition of a tool's primary function. (2) Tool Understanding: Testing the ability to grasp the underlying principles of a tool's operation. (3) Tool Creation: Challenging the model to fashion a new tool from surrounding objects when conventional options are unavailable. Our comprehensive evaluation of 32 MLLMs-spanning proprietary, open-source, specialized embodied, and backbones in VLAs-reveals a significant deficiency in tool understanding. Furthermore, we provide an in-depth analysis and propose preliminary solutions. Code and dataset are publicly available.", 'score': 2, 'issue_id': 6376, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '7373cdd0bfe24dc0', 'authors': ['Zixin Zhang', 'Kanghao Chen', 'Xingwang Lin', 'Lutao Jiang', 'Xu Zheng', 'Yuanhuiyi Lyu', 'Litao Guo', 'Yinchuan Li', 'Ying-Cong Chen'], 'affiliations': ['Beihang University', 'HKUST', 'HKUST(GZ)', 'Knowin'], 'pdf_title_img': 'assets/pdf/title_img/2510.09507.jpg', 'data': {'categories': ['#benchmark', '#dataset', '#agi', '#multimodal', '#interpretability', '#open_source'], 'emoji': '🔧', 'ru': {'title': 'Проверка понимания физических инструментов у мультимодальных LLM', 'desc': 'PhysToolBench — это первый бенчмарк для оценки того, насколько хорошо мультимодальные LLM понимают физические инструменты и их применение. Датасет содержит более 1000 пар изображений и текстов в формате Visual Question Answering с тремя уровнями сложности: распознавание инструмента, понимание принципов его работы и создание нового инструмента из подручных материалов. Тестирование 32 различных MLLM показало существенные недостатки в понимании инструментов даже у продвинутых моделей, включая специализированные embodied AI системы. Авторы предоставляют детальный анализ проблемы и предлагают предварительные решения для улучшения этой способности у AI-агентов.'}, 'en': {'title': 'Bridging the Gap in Tool Comprehension for MLLMs', 'desc': "The paper introduces PhysToolBench, a benchmark designed to evaluate how well Multimodal Large Language Models (MLLMs) understand physical tools. It uses a Visual Question Answering (VQA) dataset with over 1,000 image-text pairs to assess MLLMs on three levels: recognizing tools, understanding their functions, and creating new tools. The evaluation of 32 different MLLMs shows that they struggle significantly with tool comprehension. The authors also offer insights and initial solutions to improve MLLMs' understanding of physical tools, with the dataset and code made publicly accessible."}, 'zh': {'title': '评估多模态模型的工具理解能力', 'desc': 'PhysToolBench是一个评估多模态大型语言模型（MLLMs）理解物理工具能力的基准测试。它通过一个视觉问答（VQA）数据集，包含超过1000个图像-文本对，来评估工具识别、理解和创造的能力。研究发现，当前的MLLMs在工具理解方面存在显著不足，无法有效掌握工具的基本功能和操作原理。本文还提供了深入分析和初步解决方案，并公开了代码和数据集。'}}}, {'id': 'https://huggingface.co/papers/2510.07861', 'title': 'Understanding DeepResearch via Reports', 'url': 'https://huggingface.co/papers/2510.07861', 'abstract': 'A framework evaluates DeepResearch systems by assessing the quality, redundancy, and factuality of their research reports using an LLM-as-a-Judge methodology.  \t\t\t\t\tAI-generated summary \t\t\t\t DeepResearch agents represent a transformative AI paradigm, conducting expert-level research through sophisticated reasoning and multi-tool integration. However, evaluating these systems remains critically challenging due to open-ended research scenarios and existing benchmarks that focus on isolated capabilities rather than holistic performance. Unlike traditional LLM tasks, DeepResearch systems must synthesize diverse sources, generate insights, and present coherent findings, which are capabilities that resist simple verification. To address this gap, we introduce DeepResearch-ReportEval, a comprehensive framework designed to assess DeepResearch systems through their most representative outputs: research reports. Our approach systematically measures three dimensions: quality, redundancy, and factuality, using an innovative LLM-as-a-Judge methodology achieving strong expert concordance. We contribute a standardized benchmark of 100 curated queries spanning 12 real-world categories, enabling systematic capability comparison. Our evaluation of four leading commercial systems reveals distinct design philosophies and performance trade-offs, establishing foundational insights as DeepResearch evolves from information assistants toward intelligent research partners. Source code and data are available at: https://github.com/HKUDS/DeepResearch-Eval.', 'score': 2, 'issue_id': 6376, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': '1e9e0bbf3fa6c570', 'authors': ['Tianyu Fan', 'Xinyao Niu', 'Yuxiang Zheng', 'Fengji Zhang', 'Chengen Huang', 'Bei Chen', 'Junyang Lin', 'Chao Huang'], 'affiliations': ['Alibaba Group', 'City University of Hong Kong', 'Shanghai Jiao Tong University', 'The University of Hong Kong'], 'pdf_title_img': 'assets/pdf/title_img/2510.07861.jpg', 'data': {'categories': ['#benchmark', '#agents', '#reasoning', '#optimization', '#survey'], 'emoji': '🔬', 'ru': {'title': 'Оценка AI-исследователей: как измерить качество глубокого анализа', 'desc': 'Статья представляет DeepResearch-ReportEval — фреймворк для оценки AI-систем, способных проводить глубокие исследования на экспертном уровне. В отличие от традиционных бенчмарков, которые тестируют отдельные возможности LLM, этот подход оценивает целостную способность систем синтезировать информацию из разных источников и создавать связные исследовательские отчёты. Фреймворк измеряет три ключевых параметра — качество, избыточность и фактологическую точность — используя методологию LLM-as-a-Judge с высоким уровнем согласованности с экспертными оценками. Исследователи создали бенчмарк из 100 запросов по 12 реальным категориям и протестировали четыре коммерческие системы, выявив их различные подходы к дизайну и компромиссы в производительности.'}, 'en': {'title': 'Evaluating AI Research: Quality, Redundancy, and Factuality in DeepResearch Systems', 'desc': 'This paper presents a framework called DeepResearch-ReportEval, which evaluates DeepResearch systems by analyzing the quality, redundancy, and factuality of their research reports. The framework utilizes an LLM-as-a-Judge methodology to provide a comprehensive assessment of these systems, which are designed to conduct expert-level research through advanced reasoning and tool integration. The authors highlight the challenges in evaluating these systems due to their need to synthesize diverse information and generate coherent insights, which traditional benchmarks do not adequately address. By introducing a standardized benchmark of 100 curated queries across various categories, the study facilitates systematic comparisons of different DeepResearch systems and their performance characteristics.'}, 'zh': {'title': '评估DeepResearch系统的创新框架', 'desc': '本论文提出了一个框架，用于评估DeepResearch系统的研究报告质量、冗余性和事实准确性，采用了LLM作为评判者的方法。DeepResearch代理通过复杂的推理和多工具集成，进行专家级研究，但评估这些系统的挑战性很大。我们引入了DeepResearch-ReportEval框架，系统地测量三个维度，并提供了100个经过精心挑选的查询作为标准基准。通过对四个领先商业系统的评估，我们揭示了不同的设计理念和性能权衡，为DeepResearch从信息助手向智能研究伙伴的演变奠定了基础。'}}}, {'id': 'https://huggingface.co/papers/2510.09561', 'title': 'TC-LoRA: Temporally Modulated Conditional LoRA for Adaptive Diffusion\n  Control', 'url': 'https://huggingface.co/papers/2510.09561', 'abstract': "TC-LoRA enhances generative fidelity and adherence to spatial conditions by dynamically conditioning model weights through a hypernetwork, improving upon static activation-based methods in diffusion models.  \t\t\t\t\tAI-generated summary \t\t\t\t Current controllable diffusion models typically rely on fixed architectures that modify intermediate activations to inject guidance conditioned on a new modality. This approach uses a static conditioning strategy for a dynamic, multi-stage denoising process, limiting the model's ability to adapt its response as the generation evolves from coarse structure to fine detail. We introduce TC-LoRA (Temporally Modulated Conditional LoRA), a new paradigm that enables dynamic, context-aware control by conditioning the model's weights directly. Our framework uses a hypernetwork to generate LoRA adapters on-the-fly, tailoring weight modifications for the frozen backbone at each diffusion step based on time and the user's condition. This mechanism enables the model to learn and execute an explicit, adaptive strategy for applying conditional guidance throughout the entire generation process. Through experiments on various data domains, we demonstrate that this dynamic, parametric control significantly enhances generative fidelity and adherence to spatial conditions compared to static, activation-based methods. TC-LoRA establishes an alternative approach in which the model's conditioning strategy is modified through a deeper functional adaptation of its weights, allowing control to align with the dynamic demands of the task and generative stage.", 'score': 1, 'issue_id': 6375, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '88da4f7bc3556972', 'authors': ['Minkyoung Cho', 'Ruben Ohana', 'Christian Jacobsen', 'Adityan Jothi', 'Min-Hung Chen', 'Z. Morley Mao', 'Ethem Can'], 'affiliations': ['NVIDIA', 'University of Michigan'], 'pdf_title_img': 'assets/pdf/title_img/2510.09561.jpg', 'data': {'categories': ['#cv', '#training', '#diffusion', '#optimization', '#architecture'], 'emoji': '🎛️', 'ru': {'title': 'Динамическая настройка весов для адаптивного контроля диффузионных моделей', 'desc': 'TC-LoRA представляет новый подход к управлению диффузионными моделями через динамическое изменение весов модели, а не активаций. Гиперсеть генерирует LoRA-адаптеры на лету для каждого шага диффузии, учитывая временной этап и условия пользователя. Это позволяет модели адаптивно применять управляющие сигналы на протяжении всего процесса генерации - от грубой структуры до мелких деталей. Эксперименты показывают, что такой параметрический контроль значительно улучшает качество генерации и соответствие пространственным условиям по сравнению со статическими методами.'}, 'en': {'title': 'Dynamic Control for Enhanced Generative Fidelity', 'desc': 'TC-LoRA introduces a novel method for enhancing generative models by dynamically adjusting model weights using a hypernetwork. Unlike traditional methods that rely on fixed architectures and static activations, TC-LoRA allows for context-aware control throughout the denoising process. This approach enables the model to adapt its responses as it transitions from coarse to fine details, improving the overall quality of generated outputs. Experiments show that TC-LoRA significantly outperforms static methods in terms of generative fidelity and adherence to spatial conditions.'}, 'zh': {'title': '动态控制，提升生成质量', 'desc': 'TC-LoRA是一种新方法，通过超网络动态调整模型权重，从而增强生成的真实性和空间条件的遵循。与传统的静态激活方法不同，TC-LoRA允许模型在生成过程中根据时间和用户条件实时调整权重。该框架通过生成LoRA适配器，使得模型能够在每个去噪步骤中灵活应对变化。实验表明，TC-LoRA在多个数据领域中显著提高了生成的质量和对空间条件的遵循能力。'}}}, {'id': 'https://huggingface.co/papers/2510.08872', 'title': 'GTAlign: Game-Theoretic Alignment of LLM Assistants for Mutual Welfare', 'url': 'https://huggingface.co/papers/2510.08872', 'abstract': "Game-Theoretic Alignment (GTAlign) improves Large Language Model (LLM) performance by integrating game-theoretic decision making into reasoning and training, enhancing efficiency, answer quality, and mutual welfare.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have achieved remarkable progress in reasoning, yet sometimes produce responses that are suboptimal for users in tasks such as writing, information seeking, or providing practical guidance. Conventional alignment practices typically assume that maximizing model reward also maximizes user welfare, but this assumption frequently fails in practice: models may over-clarify or generate overly verbose reasoning when users prefer concise answers. Such behaviors resemble the prisoner's dilemma, where individually rational choices lead to socially suboptimal outcomes. The fundamental challenge is the lack of a principled decision making mechanism that mutually benefits both the LLM and the user. We propose Game-Theoretic Alignment (GTAlign), an alignment framework that integrates game-theoretic decision making into both reasoning and training. During reasoning, the model explicitly treats user-LLM interaction as a strategic game: it constructs payoff matrices within its reasoning chain to estimate welfare for both itself and the user, and then selects actions that are mutually beneficial. During training, we introduce a mutual welfare reward that reinforces cooperative responses, aligning model behavior with socially efficient outcomes. In addition, we introduce an inference technique that leverages game-theoretic reasoning to dynamically adapt LLM's response when pricing policies of LLM service change. Extensive experiments demonstrate that GTAlign substantially improves reasoning efficiency, answer quality, and mutual welfare compared to baselines across diverse tasks. The code is available at https://github.com/ulab-uiuc/GTAlign .", 'score': 1, 'issue_id': 6377, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '0a412d94a9cf2484', 'authors': ['Siqi Zhu', 'David Zhang', 'Pedro Cisneros-Velarde', 'Jiaxuan You'], 'affiliations': ['University of Illinois Urbana-Champaign', 'VMware Research'], 'pdf_title_img': 'assets/pdf/title_img/2510.08872.jpg', 'data': {'categories': ['#rlhf', '#alignment', '#training', '#reasoning'], 'emoji': '🎮', 'ru': {'title': 'Когда LLM играет в игры с пользователем: теоретико-игровой alignment', 'desc': 'Статья представляет GTAlign — новый подход к alignment LLM, основанный на теории игр. Авторы решают проблему, когда модель генерирует избыточно подробные ответы, хотя пользователь предпочитает краткость — ситуация, похожая на дилемму заключённого. Во время inference модель строит матрицы выигрышей для оценки благосостояния как себя, так и пользователя, выбирая взаимовыгодные действия. При обучении используется reward функция взаимного благосостояния, которая поощряет кооперативное поведение модели.'}, 'en': {'title': 'Aligning AI for Mutual Benefit with Game Theory', 'desc': "Game-Theoretic Alignment (GTAlign) enhances the performance of Large Language Models (LLMs) by applying game-theoretic principles to their reasoning and training processes. This approach addresses the common issue where LLMs produce responses that do not align with user preferences, such as being overly verbose. By treating the interaction between the user and the LLM as a strategic game, GTAlign allows the model to evaluate the benefits of its responses for both parties, leading to more efficient and relevant answers. The framework also introduces a mutual welfare reward during training, promoting cooperative behavior that aligns the model's outputs with user needs, resulting in improved overall performance."}, 'zh': {'title': '博弈论对齐：提升LLM的互惠福利与推理效率', 'desc': '游戏理论对齐（GTAlign）通过将博弈论决策融入推理和训练中，提升了大型语言模型（LLM）的性能。传统的对齐方法假设最大化模型奖励也能最大化用户福利，但这种假设在实际中常常失效。GTAlign框架通过将用户与LLM的互动视为战略游戏，构建收益矩阵来估计双方的福利，从而选择互利的行动。实验表明，GTAlign在推理效率、答案质量和互惠福利方面显著优于基线方法。'}}}, {'id': 'https://huggingface.co/papers/2510.07896', 'title': 'ACE: Attribution-Controlled Knowledge Editing for Multi-hop Factual\n  Recall', 'url': 'https://huggingface.co/papers/2510.07896', 'abstract': 'ACE, a framework using neuron-level attribution, enhances multi-hop factual recall in LLMs by editing critical query-value pathways, outperforming existing methods.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) require efficient knowledge editing (KE) to update factual information, yet existing methods exhibit significant performance decay in multi-hop factual recall. This failure is particularly acute when edits involve intermediate implicit subjects within reasoning chains. Through causal analysis, we reveal that this limitation stems from an oversight of how chained knowledge is dynamically represented and utilized at the neuron level. We discover that during multi hop reasoning, implicit subjects function as query neurons, which sequentially activate corresponding value neurons across transformer layers to accumulate information toward the final answer, a dynamic prior KE work has overlooked. Guided by this insight, we propose ACE: Attribution-Controlled Knowledge Editing for Multi-hop Factual Recall, a framework that leverages neuron-level attribution to identify and edit these critical query-value (Q-V) pathways. ACE provides a mechanistically grounded solution for multi-hop KE, empirically outperforming state-of-the-art methods by 9.44% on GPT-J and 37.46% on Qwen3-8B. Our analysis further reveals more fine-grained activation patterns in Qwen3 and demonstrates that the semantic interpretability of value neurons is orchestrated by query-driven accumulation. These findings establish a new pathway for advancing KE capabilities based on the principled understanding of internal reasoning mechanisms.', 'score': 1, 'issue_id': 6378, 'pub_date': '2025-10-09', 'pub_date_card': {'ru': '9 октября', 'en': 'October 9', 'zh': '10月9日'}, 'hash': '0e8853762186b621', 'authors': ['Jiayu Yang', 'Yuxuan Fan', 'Songning Lai', 'Shengen Wu', 'Jiaqi Tang', 'Chun Kang', 'Zhijiang Guo', 'Yutao Yue'], 'affiliations': ['HKUST', 'HKUST(GZ)', 'HKUST(GZ) Deep Interdisciplinary Intelligence Lab', 'Institute of Deep Perception Technology, JITRI'], 'pdf_title_img': 'assets/pdf/title_img/2510.07896.jpg', 'data': {'categories': ['#training', '#optimization', '#reasoning', '#architecture', '#data', '#interpretability'], 'emoji': '🔗', 'ru': {'title': 'Редактирование знаний через управление нейронными путями', 'desc': 'Статья представляет фреймворк ACE для улучшения редактирования знаний в LLM, особенно для многошаговых цепочек рассуждений. Авторы обнаружили, что неявные промежуточные субъекты работают как query-нейроны, последовательно активирующие value-нейроны в слоях трансформера для накопления информации. Метод ACE использует нейронную атрибуцию для идентификации и редактирования критических путей query-value, что позволяет точечно обновлять фактическую информацию. Эксперименты показывают превосходство над существующими методами на 9.44% для GPT-J и 37.46% для Qwen3-8B в задачах многошагового воспроизведения фактов.'}, 'en': {'title': 'Enhancing Multi-hop Recall with Neuron-Level Knowledge Editing', 'desc': 'The paper introduces ACE, a novel framework that improves multi-hop factual recall in Large Language Models (LLMs) by focusing on neuron-level attribution. It identifies and edits critical query-value pathways that are essential for effective knowledge editing, addressing the limitations of existing methods that struggle with implicit subjects in reasoning chains. Through causal analysis, the authors demonstrate how these implicit subjects act as query neurons, activating value neurons to gather information for answers. ACE outperforms current state-of-the-art techniques, showcasing a significant enhancement in knowledge editing capabilities by leveraging a deeper understanding of the internal mechanisms of LLMs.'}, 'zh': {'title': 'ACE：提升多跳事实回忆的知识编辑新框架', 'desc': 'ACE是一个框架，通过神经元级别的归因来增强大型语言模型（LLMs）在多跳事实回忆中的表现。现有的知识编辑方法在处理多跳推理时效果不佳，尤其是在涉及中间隐含主题时。通过因果分析，我们发现这一限制源于对链式知识在神经元层面动态表示和利用的忽视。ACE通过识别和编辑关键的查询-值路径，提供了一种基于机制的解决方案，显著提高了多跳知识编辑的效果。'}}}, {'id': 'https://huggingface.co/papers/2510.07319', 'title': 'Temporal Prompting Matters: Rethinking Referring Video Object\n  Segmentation', 'url': 'https://huggingface.co/papers/2510.07319', 'abstract': 'The Tenet framework decomposes the RVOS task into referring, video, and segmentation factors, using temporal prompts and prompt preference learning to adapt image-based foundation segmentation models for efficient RVOS.  \t\t\t\t\tAI-generated summary \t\t\t\t Referring Video Object Segmentation (RVOS) aims to segment the object referred to by the query sentence in the video. Most existing methods require end-to-end training with dense mask annotations, which could be computation-consuming and less scalable. In this work, we rethink the RVOS problem and aim to investigate the key to this task. Based on existing foundation segmentation models, we decompose the RVOS task into referring, video, and segmentation factors, and propose a Temporal Prompt Generation and Selection (Tenet) framework to address the referring and video factors while leaving the segmentation problem to foundation models. To efficiently adapt image-based foundation segmentation models to referring video object segmentation, we leverage off-the-shelf object detectors and trackers to produce temporal prompts associated with the referring sentence. While high-quality temporal prompts could be produced, they can not be easily identified from confidence scores. To tackle this issue, we propose Prompt Preference Learning to evaluate the quality of the produced temporal prompts. By taking such prompts to instruct image-based foundation segmentation models, we would be able to produce high-quality masks for the referred object, enabling efficient model adaptation to referring video object segmentation. Experiments on RVOS benchmarks demonstrate the effectiveness of the Tenet framework.', 'score': 1, 'issue_id': 6375, 'pub_date': '2025-10-08', 'pub_date_card': {'ru': '8 октября', 'en': 'October 8', 'zh': '10月8日'}, 'hash': '574ecd29563b6aa8', 'authors': ['Ci-Siang Lin', 'Min-Hung Chen', 'I-Jieh Liu', 'Chien-Yi Wang', 'Sifei Liu', 'Yu-Chiang Frank Wang'], 'affiliations': ['Graduate Institute of Communication Engineering, National Taiwan University, Taiwan', 'NVIDIA'], 'pdf_title_img': 'assets/pdf/title_img/2510.07319.jpg', 'data': {'categories': ['#cv', '#benchmark', '#video', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Декомпозиция задачи видеосегментации через временные промпты', 'desc': 'Статья представляет фреймворк Tenet для задачи сегментации объектов в видео по текстовому описанию (RVOS). Авторы декомпозируют задачу на три фактора: понимание текстового запроса, обработку видео и саму сегментацию, используя готовые foundation модели для сегментации. Ключевая идея — генерация временных промптов с помощью детекторов и трекеров объектов, качество которых оценивается через специальный механизм Prompt Preference Learning. Подход позволяет эффективно адаптировать модели сегментации изображений для работы с видео без затратного end-to-end обучения на размеченных масках.'}, 'en': {'title': 'Efficient RVOS through Temporal Prompting and Preference Learning', 'desc': 'The paper introduces the Tenet framework, which breaks down the Referring Video Object Segmentation (RVOS) task into three main components: referring, video, and segmentation factors. It utilizes temporal prompts generated from object detectors and trackers to enhance the performance of existing image-based segmentation models without requiring extensive training on dense mask annotations. To ensure the quality of these prompts, the authors implement Prompt Preference Learning, which assesses the effectiveness of the generated prompts. The results show that the Tenet framework significantly improves the efficiency and accuracy of RVOS tasks by leveraging pre-trained segmentation models.'}, 'zh': {'title': '高效的参考视频物体分割新方法', 'desc': '本文提出了Tenet框架，将参考视频物体分割（RVOS）任务分解为参考、视频和分割三个因素。通过使用时间提示和提示偏好学习，Tenet框架能够有效地将基于图像的基础分割模型适应于RVOS任务。我们利用现成的物体检测器和跟踪器生成与查询句子相关的时间提示，并通过提示偏好学习评估这些提示的质量。实验结果表明，Tenet框架在RVOS基准测试中表现出色，能够生成高质量的分割掩码。'}}}, {'id': 'https://huggingface.co/papers/2510.09535', 'title': 'Mitigating Overthinking through Reasoning Shaping', 'url': 'https://huggingface.co/papers/2510.09535', 'abstract': 'Group Relative Segment Penalization (GRSP) improves token efficiency in large reasoning models without significantly reducing accuracy, especially for complex problems, by regularizing reasoning at the step level.  \t\t\t\t\tAI-generated summary \t\t\t\t Large reasoning models (LRMs) boosted by Reinforcement Learning from Verifier Reward (RLVR) have shown great power in problem solving, yet they often cause overthinking: excessive, meandering reasoning that inflates computational cost. Prior designs of penalization in RLVR manage to reduce token consumption while often harming model performance, which arises from the oversimplicity of token-level supervision. In this paper, we argue that the granularity of supervision plays a crucial role in balancing efficiency and accuracy, and propose Group Relative Segment Penalization (GRSP), a step-level method to regularize reasoning. Since preliminary analyses show that reasoning segments are strongly correlated with token consumption and model performance, we design a length-aware weighting mechanism across segment clusters. Extensive experiments demonstrate that GRSP achieves superior token efficiency without heavily compromising accuracy, especially the advantages with harder problems. Moreover, GRSP stabilizes RL training and scales effectively across model sizes.', 'score': 0, 'issue_id': 6376, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '160cfe01bcfb9a51', 'authors': ['Feifan Song', 'Shaohang Wei', 'Bofei Gao', 'Yejie Wang', 'Wen Luo', 'Wei Li', 'Linli Yao', 'Weimin Xiong', 'Liang Chen', 'Tianyu Liu', 'Houfeng Wang'], 'affiliations': ['Moonshot AI', 'State Key Laboratory of Multimedia Information Processing School of Computer Science, Peking University'], 'pdf_title_img': 'assets/pdf/title_img/2510.09535.jpg', 'data': {'categories': ['#rl', '#reasoning', '#training', '#optimization'], 'emoji': '✂️', 'ru': {'title': 'Эффективное мышление: как научить AI рассуждать короче, но не глупее', 'desc': 'Большие модели рассуждений (LRM) часто страдают от «overthinking» — избыточных рассуждений, которые увеличивают вычислительные затраты. Авторы предлагают метод Group Relative Segment Penalization (GRSP), который регулирует рассуждения на уровне логических шагов, а не отдельных токенов. Метод использует механизм взвешивания сегментов по длине, что позволяет сократить потребление токенов без существенной потери точности. GRSP особенно эффективен на сложных задачах и стабилизирует процесс обучения с подкреплением для моделей разных размеров.'}, 'en': {'title': 'Enhancing Efficiency in Reasoning Models with GRSP', 'desc': 'This paper introduces Group Relative Segment Penalization (GRSP), a method designed to enhance token efficiency in large reasoning models (LRMs) while maintaining accuracy. GRSP focuses on regularizing reasoning at the step level, addressing the issue of overthinking that can lead to increased computational costs. By implementing a length-aware weighting mechanism for reasoning segments, GRSP effectively reduces token consumption without sacrificing performance. The results show that GRSP not only improves efficiency, particularly for complex problems, but also stabilizes reinforcement learning training across various model sizes.'}, 'zh': {'title': '群体相对段惩罚：提升推理模型的效率与准确性', 'desc': '本文提出了一种新的方法，称为群体相对段惩罚（GRSP），旨在提高大型推理模型的令牌效率，同时保持准确性。GRSP通过在推理步骤级别进行正则化，解决了以往方法在减少令牌消耗时常常导致模型性能下降的问题。研究表明，推理段与令牌消耗和模型性能之间存在强相关性，因此我们设计了一种基于段集群的长度感知加权机制。实验结果表明，GRSP在处理复杂问题时，能够显著提高令牌效率，而不会严重影响模型的准确性。'}}}, {'id': 'https://huggingface.co/papers/2510.08994', 'title': 'Speculative Jacobi-Denoising Decoding for Accelerating Autoregressive\n  Text-to-image Generation', 'url': 'https://huggingface.co/papers/2510.08994', 'abstract': 'Speculative Jacobi-Denoising Decoding accelerates autoregressive text-to-image generation by enabling parallel token prediction and reducing model forward passes.  \t\t\t\t\tAI-generated summary \t\t\t\t As a new paradigm of visual content generation, autoregressive text-to-image models suffer from slow inference due to their sequential token-by-token decoding process, often requiring thousands of model forward passes to generate a single image. To address this inefficiency, we propose Speculative Jacobi-Denoising Decoding (SJD2), a framework that incorporates the denoising process into Jacobi iterations to enable parallel token generation in autoregressive models. Our method introduces a next-clean-token prediction paradigm that enables the pre-trained autoregressive models to accept noise-perturbed token embeddings and predict the next clean tokens through low-cost fine-tuning. This denoising paradigm guides the model towards more stable Jacobi trajectories. During inference, our method initializes token sequences with Gaussian noise and performs iterative next-clean-token-prediction in the embedding space. We employ a probabilistic criterion to verify and accept multiple tokens in parallel, and refine the unaccepted tokens for the next iteration with the denoising trajectory. Experiments show that our method can accelerate generation by reducing model forward passes while maintaining the visual quality of generated images.', 'score': 0, 'issue_id': 6377, 'pub_date': '2025-10-10', 'pub_date_card': {'ru': '10 октября', 'en': 'October 10', 'zh': '10月10日'}, 'hash': '54fbfde4c298e267', 'authors': ['Yao Teng', 'Fuyun Wang', 'Xian Liu', 'Zhekai Chen', 'Han Shi', 'Yu Wang', 'Zhenguo Li', 'Weiyang Liu', 'Difan Zou', 'Xihui Liu'], 'affiliations': ['CUHK', 'Huawei Noahs Ark Lab', 'The University of Hong Kong', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2510.08994.jpg', 'data': {'categories': ['#inference', '#optimization', '#cv', '#video'], 'emoji': '🎨', 'ru': {'title': 'Параллельная генерация изображений через шумоподавление', 'desc': 'Авторегрессионные модели генерации изображений из текста работают медленно, так как создают токены последовательно, требуя тысячи проходов через модель для одной картинки. Предложенный метод SJD2 использует процесс шумоподавления в итерациях Якоби, позволяя предсказывать несколько токенов параллельно. Модель дообучается принимать зашумлённые эмбеддинги токенов и предсказывать следующие чистые токены, что делает траекторию итераций более стабильной. Эксперименты показывают ускорение генерации при сохранении качества изображений благодаря параллельной верификации и принятию множества токенов одновременно.'}, 'en': {'title': 'Accelerating Image Generation with Parallel Token Prediction', 'desc': 'This paper introduces Speculative Jacobi-Denoising Decoding (SJD2), a novel approach to enhance the efficiency of autoregressive text-to-image generation. Traditional models generate images sequentially, which is slow and requires many forward passes through the model. SJD2 allows for parallel token prediction by integrating a denoising process into Jacobi iterations, enabling the model to predict clean tokens from noise-perturbed embeddings. The results demonstrate that this method significantly speeds up image generation while preserving high visual quality.'}, 'zh': {'title': '加速图像生成的投机性去噪解码方法', 'desc': '本文提出了一种新的文本到图像生成方法，称为投机性雅可比去噪解码（SJD2），旨在加速自回归模型的推理过程。传统的自回归模型在生成图像时需要逐个令牌解码，导致推理速度缓慢。SJD2通过将去噪过程与雅可比迭代结合，允许并行生成令牌，从而减少模型的前向传递次数。实验结果表明，该方法在保持生成图像视觉质量的同时，显著提高了生成速度。'}}}, {'id': 'https://huggingface.co/papers/2510.01119', 'title': 'Instant4D: 4D Gaussian Splatting in Minutes', 'url': 'https://huggingface.co/papers/2510.01119', 'abstract': 'Instant4D uses deep visual SLAM and a 4D Gaussian representation to efficiently reconstruct scenes from uncalibrated video sequences in minutes.  \t\t\t\t\tAI-generated summary \t\t\t\t Dynamic view synthesis has seen significant advances, yet reconstructing scenes from uncalibrated, casual video remains challenging due to slow optimization and complex parameter estimation. In this work, we present Instant4D, a monocular reconstruction system that leverages native 4D representation to efficiently process casual video sequences within minutes, without calibrated cameras or depth sensors. Our method begins with geometric recovery through deep visual SLAM, followed by grid pruning to optimize scene representation. Our design significantly reduces redundancy while maintaining geometric integrity, cutting model size to under 10% of its original footprint. To handle temporal dynamics efficiently, we introduce a streamlined 4D Gaussian representation, achieving a 30x speed-up and reducing training time to within two minutes, while maintaining competitive performance across several benchmarks. Our method reconstruct a single video within 10 minutes on the Dycheck dataset or for a typical 200-frame video. We further apply our model to in-the-wild videos, showcasing its generalizability. Our project website is published at https://instant4d.github.io/.', 'score': 0, 'issue_id': 6375, 'pub_date': '2025-10-01', 'pub_date_card': {'ru': '1 октября', 'en': 'October 1', 'zh': '10月1日'}, 'hash': '9c375f4bf8782c80', 'authors': ['Zhanpeng Luo', 'Haoxi Ran', 'Li Lu'], 'affiliations': ['Carnegie Mellon University', 'Sichuan University', 'University of Pittsburgh'], 'pdf_title_img': 'assets/pdf/title_img/2510.01119.jpg', 'data': {'categories': ['#games', '#cv', '#video', '#dataset', '#inference', '#benchmark', '#optimization'], 'emoji': '⚡', 'ru': {'title': 'Мгновенная 4D реконструкция сцен из обычного видео за минуты', 'desc': 'Instant4D — это система для реконструкции динамических сцен из некалиброванного видео, которая работает за считанные минуты. Метод использует deep visual SLAM для восстановления геометрии и компактное 4D представление на основе гауссианов. Авторы сократили размер модели до 10% от исходного и ускорили обучение в 30 раз — теперь оно занимает всего две минуты. Система обрабатывает типичное 200-кадровое видео за 10 минут и работает даже на произвольных роликах из интернета.'}, 'en': {'title': 'Revolutionizing Scene Reconstruction in Minutes with Instant4D', 'desc': 'Instant4D is a novel system that utilizes deep visual SLAM and a 4D Gaussian representation to reconstruct scenes from uncalibrated video sequences quickly. It addresses the challenges of slow optimization and complex parameter estimation by processing casual videos in minutes without the need for calibrated cameras or depth sensors. The method employs geometric recovery and grid pruning to optimize the scene representation, significantly reducing redundancy while preserving geometric integrity. With a 30x speed-up in processing time, Instant4D can reconstruct a typical 200-frame video in just 10 minutes, demonstrating its efficiency and effectiveness across various benchmarks.'}, 'zh': {'title': '快速重建，瞬间呈现', 'desc': 'Instant4D 是一个单目重建系统，利用深度视觉 SLAM 和 4D 高斯表示法，能够在几分钟内高效地从未校准的视频序列中重建场景。该方法通过几何恢复和网格修剪来优化场景表示，显著减少冗余，同时保持几何完整性。Instant4D 的设计使得模型大小减少到原始的 10% 以下，并且在处理时间动态方面实现了 30 倍的加速。该系统在 Dycheck 数据集上能够在 10 分钟内重建单个视频，展示了其在实际视频中的广泛适用性。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (1)', '#agents (5)', '#agi (1)', '#alignment (3)', '#architecture (3)', '#audio (2)', '#benchmark (16)', '#cv (9)', '#data (5)', '#dataset (9)', '#diffusion (3)', '#ethics (1)', '#games (3)', '#graphs', '#hallucinations (2)', '#healthcare', '#inference (4)', '#interpretability (2)', '#leakage', '#long_context (3)', '#low_resource (1)', '#machine_translation', '#math', '#multilingual (1)', '#multimodal (9)', '#open_source (5)', '#optimization (20)', '#plp', '#rag', '#reasoning (15)', '#rl (6)', '#rlhf (2)', '#robotics', '#science (1)', '#security', '#small_models', '#story_generation', '#survey (3)', '#synthetic (1)', '#training (15)', '#transfer_learning', '#video (4)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-10-13 06:19',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-10-13 06:19')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-10-13 06:19')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    