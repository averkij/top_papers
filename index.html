
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 25 papers. June 24.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">24 июня</span> | <span id="title-articles-count">25 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-06-23.html">⬅️ <span id="prev-date">23.06</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-06-25.html">➡️ <span id="next-date">25.06</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-06.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '24 июня', 'en': 'June 24', 'zh': '6月24日'};
        let feedDateNext = {'ru': '25.06', 'en': '06/25', 'zh': '6月25日'};
        let feedDatePrev = {'ru': '23.06', 'en': '06/23', 'zh': '6月23日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2506.18882', 'title': 'Light of Normals: Unified Feature Representation for Universal\n  Photometric Stereo', 'url': 'https://huggingface.co/papers/2506.18882', 'abstract': '', 'score': 64, 'issue_id': 4450, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '39545287159810c0', 'authors': ['Hong Li', 'Houyuan Chen', 'Chongjie Ye', 'Zhaoxi Chen', 'Bohan Li', 'Shaocong Xu', 'Xianda Guo', 'Xuhui Liu', 'Yikai Wang', 'Baochang Zhang', 'Satoshi Ikehata', 'Boxin Shi', 'Anyi Rao', 'Hao Zhao'], 'affiliations': ['AIR, THU', 'BAAI', 'BNU', 'BUAA', 'FNii, CUHKSZ', 'HKUST', 'NII', 'NJU', 'PKU'], 'pdf_title_img': 'assets/pdf/title_img/2506.18882.jpg', 'data': {'categories': [], 'emoji': '🧠', 'ru': {'title': 'Улучшение понимания контекста в LLM', 'desc': 'В статье рассматривается новая архитектура LLM, которая улучшает понимание контекста в текстах. Авторы предлагают метод, который позволяет модели более эффективно обрабатывать длинные последовательности слов. Это достигается за счёт оптимизации внимания и использования дополнительных слоёв нейронной сети. Результаты экспериментов показывают значительное улучшение точности в задачах обработки естественного языка.'}, 'en': {'title': 'Hybrid Deep Learning: Merging CNNs and RNNs for Superior Performance', 'desc': "This paper presents a novel approach to improve the performance of deep learning models by utilizing a hybrid architecture that combines convolutional neural networks (CNNs) with recurrent neural networks (RNNs). The proposed method enhances feature extraction from spatial data while also capturing temporal dependencies, making it suitable for tasks like video analysis and time-series prediction. The authors demonstrate that their model outperforms existing state-of-the-art techniques on several benchmark datasets. Additionally, they provide insights into the model's interpretability and robustness against adversarial attacks."}, 'zh': {'title': '提升预测准确性的创新算法', 'desc': '这篇论文探讨了一种新的机器学习算法，旨在提高模型的预测准确性。作者提出了一种改进的特征选择方法，可以有效减少数据维度，同时保留重要信息。实验结果表明，该算法在多个数据集上表现优于传统方法。通过优化模型的训练过程，研究者希望推动机器学习在实际应用中的效果。'}}}, {'id': 'https://huggingface.co/papers/2506.18871', 'title': 'OmniGen2: Exploration to Advanced Multimodal Generation', 'url': 'https://huggingface.co/papers/2506.18871', 'abstract': 'OmniGen2, a versatile generative model, introduces dual decoding pathways for text and images, preserves original text generation, and achieves competitive results with a new subject-driven benchmark.  \t\t\t\t\tAI-generated summary \t\t\t\t In this work, we introduce OmniGen2, a versatile and open-source generative model designed to provide a unified solution for diverse generation tasks, including text-to-image, image editing, and in-context generation. Unlike OmniGen v1, OmniGen2 features two distinct decoding pathways for text and image modalities, utilizing unshared parameters and a decoupled image tokenizer. This design enables OmniGen2 to build upon existing multimodal understanding models without the need to re-adapt VAE inputs, thereby preserving the original text generation capabilities. To facilitate the training of OmniGen2, we developed comprehensive data construction pipelines, encompassing image editing and in-context generation data. Additionally, we introduce a reflection mechanism tailored for image generation tasks and curate a dedicated reflection dataset based on OmniGen2. Despite its relatively modest parameter size, OmniGen2 achieves competitive results on multiple task benchmarks, including text-to-image and image editing. To further evaluate in-context generation, also referred to as subject-driven tasks, we introduce a new benchmark named OmniContext. OmniGen2 achieves state-of-the-art performance among open-source models in terms of consistency. We will release our models, training code, datasets, and data construction pipeline to support future research in this field. Project Page: https://vectorspacelab.github.io/OmniGen2; GitHub Link: https://github.com/VectorSpaceLab/OmniGen2', 'score': 37, 'issue_id': 4447, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '18382718ba53ccf7', 'authors': ['Chenyuan Wu', 'Pengfei Zheng', 'Ruiran Yan', 'Shitao Xiao', 'Xin Luo', 'Yueze Wang', 'Wanli Li', 'Xiyan Jiang', 'Yexin Liu', 'Junjie Zhou', 'Ze Liu', 'Ziyi Xia', 'Chaofan Li', 'Haoge Deng', 'Jiahao Wang', 'Kun Luo', 'Bo Zhang', 'Defu Lian', 'Xinlong Wang', 'Zhongyuan Wang', 'Tiejun Huang', 'Zheng Liu'], 'affiliations': ['Beijing Academy of Artificial Intelligence'], 'pdf_title_img': 'assets/pdf/title_img/2506.18871.jpg', 'data': {'categories': ['#training', '#open_source', '#data', '#dataset', '#multimodal', '#benchmark', '#diffusion'], 'emoji': '🎨', 'ru': {'title': 'OmniGen2: Универсальная модель для многозадачной генерации текста и изображений', 'desc': 'OmniGen2 - это универсальная генеративная модель с открытым исходным кодом, способная решать различные задачи генерации, включая преобразование текста в изображение, редактирование изображений и генерацию в контексте. Модель имеет два отдельных пути декодирования для текста и изображений, что позволяет сохранить исходные возможности генерации текста. Несмотря на относительно небольшой размер параметров, OmniGen2 достигает конкурентоспособных результатов на нескольких эталонных тестах. Авторы также представили новый бенчмарк OmniContext для оценки генерации в контексте.'}, 'en': {'title': 'OmniGen2: Unifying Text and Image Generation with Dual Pathways', 'desc': 'OmniGen2 is a generative model that enhances the creation of text and images through dual decoding pathways, allowing for specialized processing of each modality. It maintains the original text generation capabilities while introducing a new image tokenizer and reflection mechanism for improved image tasks. The model is trained using comprehensive data pipelines that support various generation tasks, including image editing and in-context generation. Despite its smaller size, OmniGen2 achieves competitive performance on benchmarks, particularly in subject-driven tasks, and aims to advance research in multimodal generation.'}, 'zh': {'title': 'OmniGen2：多模态生成的统一解决方案', 'desc': 'OmniGen2是一种多功能的生成模型，旨在为文本和图像生成任务提供统一的解决方案。与OmniGen v1不同，OmniGen2采用了两个独立的解码路径，分别处理文本和图像，使用了不共享的参数和解耦的图像标记器。这种设计使得OmniGen2能够在不重新适配VAE输入的情况下，保留原有的文本生成能力。尽管参数量相对较小，OmniGen2在多个任务基准上取得了竞争力的结果，特别是在文本到图像生成和图像编辑方面。'}}}, {'id': 'https://huggingface.co/papers/2506.18841', 'title': 'LongWriter-Zero: Mastering Ultra-Long Text Generation via Reinforcement\n  Learning', 'url': 'https://huggingface.co/papers/2506.18841', 'abstract': "An incentivization-based reinforcement learning approach is used to develop a large language model capable of generating ultra-long, high-quality text without the need for synthetic data or supervised fine-tuning.  \t\t\t\t\tAI-generated summary \t\t\t\t Ultra-long generation by large language models (LLMs) is a widely demanded scenario, yet it remains a significant challenge due to their maximum generation length limit and overall quality degradation as sequence length increases. Previous approaches, exemplified by LongWriter, typically rely on ''teaching'', which involves supervised fine-tuning (SFT) on synthetic long-form outputs. However, this strategy heavily depends on synthetic SFT data, which is difficult and costly to construct, often lacks coherence and consistency, and tends to be overly artificial and structurally monotonous. In this work, we propose an incentivization-based approach that, starting entirely from scratch and without relying on any annotated or synthetic data, leverages reinforcement learning (RL) to foster the emergence of ultra-long, high-quality text generation capabilities in LLMs. We perform RL training starting from a base model, similar to R1-Zero, guiding it to engage in reasoning that facilitates planning and refinement during the writing process. To support this, we employ specialized reward models that steer the LLM towards improved length control, writing quality, and structural formatting. Experimental evaluations show that our LongWriter-Zero model, trained from Qwen2.5-32B, consistently outperforms traditional SFT methods on long-form writing tasks, achieving state-of-the-art results across all metrics on WritingBench and Arena-Write, and even surpassing 100B+ models such as DeepSeek R1 and Qwen3-235B. We open-source our data and model checkpoints under https://huggingface.co/THU-KEG/LongWriter-Zero-32B", 'score': 30, 'issue_id': 4447, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '8589c05aae4b8258', 'authors': ['Yuhao Wu', 'Yushi Bai', 'Zhiqiang Hu', 'Roy Ka-Wei Lee', 'Juanzi Li'], 'affiliations': ['Singapore University of Technology and Design, Singapore', 'Tsinghua University, Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2506.18841.jpg', 'data': {'categories': ['#training', '#long_context', '#rl', '#open_source', '#dataset', '#benchmark'], 'emoji': '📝', 'ru': {'title': 'Революция в генерации длинных текстов: RL вместо синтетических данных', 'desc': 'В этой статье представлен новый подход к обучению больших языковых моделей (LLM) для генерации сверхдлинных и качественных текстов без использования синтетических данных или контролируемой дообучения. Метод основан на обучении с подкреплением (RL) и стимулировании модели к планированию и улучшению процесса написания. Авторы разработали специальные модели вознаграждения для улучшения контроля длины, качества письма и структурного форматирования. Эксперименты показали, что их модель LongWriter-Zero превосходит традиционные методы на задачах написания длинных текстов, достигая лучших результатов на бенчмарках WritingBench и Arena-Write.'}, 'en': {'title': 'Reinforcement Learning for Ultra-Long Text Generation Without Synthetic Data', 'desc': 'This paper presents a novel approach to generating ultra-long, high-quality text using a large language model (LLM) without relying on synthetic data or supervised fine-tuning. The authors introduce an incentivization-based reinforcement learning (RL) method that allows the model to learn from scratch, enhancing its ability to produce coherent and structured long-form content. By employing specialized reward models, the LLM is guided to improve its writing quality, length control, and formatting during the generation process. Experimental results demonstrate that the proposed LongWriter-Zero model outperforms traditional methods, achieving state-of-the-art performance on long-form writing benchmarks.'}, 'zh': {'title': '激励强化学习，超长文本生成新突破', 'desc': '本论文提出了一种基于激励的强化学习方法，旨在开发一种大型语言模型，能够生成超长且高质量的文本，而无需合成数据或监督微调。以往的方法通常依赖于监督微调（SFT），这需要构建合成的长文本输出，成本高且难以实现。我们的方法从零开始，通过强化学习（RL）训练模型，促进超长高质量文本生成能力的出现。实验结果表明，我们的LongWriter-Zero模型在长文本写作任务中表现优于传统的SFT方法，达到了最新的技术水平。'}}}, {'id': 'https://huggingface.co/papers/2506.18851', 'title': 'Phantom-Data : Towards a General Subject-Consistent Video Generation\n  Dataset', 'url': 'https://huggingface.co/papers/2506.18851', 'abstract': 'A cross-pair dataset called Phantom-Data improves subject-to-video generation by enhancing prompt alignment and visual quality while maintaining identity consistency.  \t\t\t\t\tAI-generated summary \t\t\t\t Subject-to-video generation has witnessed substantial progress in recent years. However, existing models still face significant challenges in faithfully following textual instructions. This limitation, commonly known as the copy-paste problem, arises from the widely used in-pair training paradigm. This approach inherently entangles subject identity with background and contextual attributes by sampling reference images from the same scene as the target video. To address this issue, we introduce Phantom-Data, the first general-purpose cross-pair subject-to-video consistency dataset, containing approximately one million identity-consistent pairs across diverse categories. Our dataset is constructed via a three-stage pipeline: (1) a general and input-aligned subject detection module, (2) large-scale cross-context subject retrieval from more than 53 million videos and 3 billion images, and (3) prior-guided identity verification to ensure visual consistency under contextual variation. Comprehensive experiments show that training with Phantom-Data significantly improves prompt alignment and visual quality while preserving identity consistency on par with in-pair baselines.', 'score': 22, 'issue_id': 4447, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '525a4c676b83f9a6', 'authors': ['Zhuowei Chen', 'Bingchuan Li', 'Tianxiang Ma', 'Lijie Liu', 'Mingcong Liu', 'Yi Zhang', 'Gen Li', 'Xinghui Li', 'Siyu Zhou', 'Qian He', 'Xinglong Wu'], 'affiliations': ['Intelligent Creation Lab, ByteDance'], 'pdf_title_img': 'assets/pdf/title_img/2506.18851.jpg', 'data': {'categories': ['#data', '#dataset', '#synthetic'], 'emoji': '🎭', 'ru': {'title': 'Phantom-Data: преодоление ограничений генерации видео по субъекту', 'desc': 'Представлен новый набор данных Phantom-Data для улучшения генерации видео по субъекту. Он содержит около миллиона пар изображений с согласованной идентичностью субъекта в разных контекстах. Набор данных создан с помощью трехэтапного процесса, включающего обнаружение субъекта, поиск по большой базе видео и изображений, и проверку идентичности. Эксперименты показывают, что обучение на Phantom-Data значительно улучшает соответствие промпту и визуальное качество при сохранении согласованности идентичности.'}, 'en': {'title': 'Phantom-Data: Enhancing Video Generation with Identity Consistency', 'desc': "The paper introduces Phantom-Data, a new dataset designed to enhance subject-to-video generation in machine learning. This dataset addresses the 'copy-paste problem' by providing identity-consistent pairs that are not tied to specific backgrounds or contexts. It is created through a three-stage process that includes subject detection, cross-context retrieval, and identity verification. Experiments demonstrate that using Phantom-Data leads to better alignment with prompts and improved visual quality while maintaining consistent subject identity."}, 'zh': {'title': 'Phantom-Data：提升视频生成的身份一致性与视觉质量', 'desc': '本文介绍了一种名为Phantom-Data的跨对数据集，旨在改善基于文本生成视频的效果。该数据集通过增强提示对齐和视觉质量，同时保持身份一致性，解决了现有模型在遵循文本指令时面临的挑战。Phantom-Data包含约一百万个身份一致的配对，涵盖多种类别，采用三阶段流程构建。实验结果表明，使用Phantom-Data进行训练显著提高了生成视频的质量和一致性。'}}}, {'id': 'https://huggingface.co/papers/2506.18254', 'title': 'RLPR: Extrapolating RLVR to General Domains without Verifiers', 'url': 'https://huggingface.co/papers/2506.18254', 'abstract': "RLPR, a verifier-free framework using LLM's token probability scores as reward signals, enhances reasoning capabilities across both general and mathematical domains, outperforming other methods in various benchmarks.  \t\t\t\t\tAI-generated summary \t\t\t\t Reinforcement Learning with Verifiable Rewards (RLVR) demonstrates promising potential in advancing the reasoning capabilities of LLMs. However, its success remains largely confined to mathematical and code domains. This primary limitation stems from the heavy reliance on domain-specific verifiers, which results in prohibitive complexity and limited scalability. To address the challenge, our key observation is that LLM's intrinsic probability of generating a correct free-form answer directly indicates its own evaluation of the reasoning reward (i.e., how well the reasoning process leads to the correct answer). Building on this insight, we propose RLPR, a simple verifier-free framework that extrapolates RLVR to broader general domains. RLPR uses the LLM's own token probability scores for reference answers as the reward signal and maximizes the expected reward during training. We find that addressing the high variance of this noisy probability reward is crucial to make it work, and propose prob-to-reward and stabilizing methods to ensure a precise and stable reward from LLM intrinsic probabilities. Comprehensive experiments in four general-domain benchmarks and three mathematical benchmarks show that RLPR consistently improves reasoning capabilities in both areas for Gemma, Llama, and Qwen based models. Notably, RLPR outperforms concurrent VeriFree by 7.6 points on TheoremQA and 7.5 points on Minerva, and even surpasses strong verifier-model-dependent approaches General-Reasoner by 1.6 average points across seven benchmarks.", 'score': 22, 'issue_id': 4451, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': 'f96aa2817f2af792', 'authors': ['Tianyu Yu', 'Bo Ji', 'Shouli Wang', 'Shu Yao', 'Zefan Wang', 'Ganqu Cui', 'Lifan Yuan', 'Ning Ding', 'Yuan Yao', 'Zhiyuan Liu', 'Maosong Sun', 'Tat-Seng Chua'], 'affiliations': ['Beijing University of Posts and Telecommunications', 'Harbin Institute of Technology', 'National University of Singapore', 'Shanghai Qi Zhi Institute', 'Tsinghua University', 'University of Illinois Urbana-Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2506.18254.jpg', 'data': {'categories': ['#reasoning', '#training', '#rl', '#benchmark'], 'emoji': '🧠', 'ru': {'title': 'RLPR: Усиление рассуждений ИИ без верификаторов', 'desc': 'RLPR - это новый фреймворк для улучшения способностей рассуждения языковых моделей (LLM) без использования верификаторов. Он использует вероятностные оценки токенов самой модели в качестве сигналов вознаграждения. RLPR превосходит другие методы как в общих, так и в математических задачах, что показано на различных бенчмарках. Ключевое наблюдение заключается в том, что внутренняя вероятность LLM генерировать правильный ответ напрямую указывает на оценку вознаграждения за рассуждение.'}, 'en': {'title': 'Reinforcement Learning Without Verifiers: Unlocking LLM Reasoning', 'desc': 'The paper introduces RLPR, a new framework that enhances the reasoning abilities of large language models (LLMs) without needing external verifiers. It leverages the token probability scores from LLMs as reward signals, allowing for a more scalable and efficient training process. By addressing the high variance in these probability rewards, the authors implement methods to stabilize the reward signal, leading to improved performance in both general and mathematical reasoning tasks. Experimental results show that RLPR significantly outperforms existing methods, demonstrating its effectiveness across various benchmarks.'}, 'zh': {'title': 'RLPR：无需验证器的推理能力提升框架', 'desc': 'RLPR是一种无需验证器的框架，利用大型语言模型（LLM）生成的标记概率分数作为奖励信号，增强了其在一般和数学领域的推理能力。该方法克服了传统强化学习方法在特定领域验证器依赖性带来的复杂性和可扩展性限制。通过使用LLM自身的标记概率分数作为参考答案的奖励信号，RLPR在训练过程中最大化期望奖励。实验结果表明，RLPR在多个基准测试中显著提升了推理能力，超越了其他方法。'}}}, {'id': 'https://huggingface.co/papers/2506.18896', 'title': 'ReasonFlux-PRM: Trajectory-Aware PRMs for Long Chain-of-Thought\n  Reasoning in LLMs', 'url': 'https://huggingface.co/papers/2506.18896', 'abstract': 'ReasonFlux-PRM, a novel trajectory-aware Process Reward Model, evaluates reasoning traces with step-level and trajectory-level supervision, enhancing performance in model distillation, reinforcement learning, and test-time scaling.  \t\t\t\t\tAI-generated summary \t\t\t\t Process Reward Models (PRMs) have recently emerged as a powerful framework for supervising intermediate reasoning steps in large language models (LLMs). Previous PRMs are primarily trained on model final output responses and struggle to evaluate intermediate thinking trajectories robustly, especially in the emerging setting of trajectory-response outputs generated by frontier reasoning models like Deepseek-R1. In this work, we introduce ReasonFlux-PRM, a novel trajectory-aware PRM explicitly designed to evaluate the trajectory-response type of reasoning traces. ReasonFlux-PRM incorporates both step-level and trajectory-level supervision, enabling fine-grained reward assignment aligned with structured chain-of-thought data. We adapt ReasonFlux-PRM to support reward supervision under both offline and online settings, including (i) selecting high-quality model distillation data for downstream supervised fine-tuning of smaller models, (ii) providing dense process-level rewards for policy optimization during reinforcement learning, and (iii) enabling reward-guided Best-of-N test-time scaling. Empirical results on challenging downstream benchmarks such as AIME, MATH500, and GPQA-Diamond demonstrate that ReasonFlux-PRM-7B selects higher quality data than strong PRMs (e.g., Qwen2.5-Math-PRM-72B) and human-curated baselines. Furthermore, our derived ReasonFlux-PRM-7B yields consistent performance improvements, achieving average gains of 12.1% in supervised fine-tuning, 4.5% in reinforcement learning, and 6.3% in test-time scaling. We also release our efficient ReasonFlux-PRM-1.5B for resource-constrained applications and edge deployment. Projects: https://github.com/Gen-Verse/ReasonFlux', 'score': 21, 'issue_id': 4447, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '6a30d79f40f7d98d', 'authors': ['Jiaru Zou', 'Ling Yang', 'Jingwen Gu', 'Jiahao Qiu', 'Ke Shen', 'Jingrui He', 'Mengdi Wang'], 'affiliations': ['ByteDance', 'Cornell University', 'Princeton University', 'UIUC'], 'pdf_title_img': 'assets/pdf/title_img/2506.18896.jpg', 'data': {'categories': ['#training', '#small_models', '#optimization', '#rl', '#dataset', '#benchmark', '#reasoning'], 'emoji': '🧠', 'ru': {'title': 'Улучшение рассуждений ИИ через оценку траекторий мышления', 'desc': 'ReasonFlux-PRM - это новая модель оценки процесса рассуждений, которая улучшает работу больших языковых моделей (LLM). Она оценивает промежуточные шаги рассуждений и целые траектории мышления, что позволяет более точно назначать награды в процессе обучения. ReasonFlux-PRM применяется для отбора качественных данных при дистилляции моделей, оптимизации политики в обучении с подкреплением и масштабировании во время тестирования. Эксперименты показали, что ReasonFlux-PRM превосходит существующие модели оценки процесса рассуждений на сложных задачах.'}, 'en': {'title': 'Enhancing Reasoning Evaluation with ReasonFlux-PRM', 'desc': 'ReasonFlux-PRM is a new model that improves how we evaluate reasoning processes in large language models by focusing on both individual steps and overall trajectories. It addresses the limitations of previous Process Reward Models that mainly assessed final outputs, which often missed the nuances of intermediate reasoning. By using both step-level and trajectory-level supervision, it provides more accurate rewards that align with structured reasoning data. The model has shown significant performance improvements in tasks like model distillation, reinforcement learning, and test-time scaling, outperforming existing models and human-curated benchmarks.'}, 'zh': {'title': '推理轨迹的智能评估', 'desc': 'ReasonFlux-PRM是一种新颖的过程奖励模型，专注于评估推理轨迹，结合了逐步和轨迹级的监督。这种模型能够在模型蒸馏、强化学习和测试时扩展中提升性能。通过对推理过程的细致奖励分配，ReasonFlux-PRM能够更好地处理复杂的推理任务。实验证明，该模型在多个基准测试中表现优于传统的过程奖励模型。'}}}, {'id': 'https://huggingface.co/papers/2506.15741', 'title': 'OAgents: An Empirical Study of Building Effective Agents', 'url': 'https://huggingface.co/papers/2506.15741', 'abstract': 'Recently, Agentic AI has become an increasingly popular research field. However, we argue that current agent research practices lack standardization and scientific rigor, making it hard to conduct fair comparisons among methods. As a result, it is still unclear how different design choices in agent frameworks affect effectiveness, and measuring their progress remains challenging. In this work, we conduct a systematic empirical study on GAIA benchmark and BrowseComp to examine the impact of popular design choices in key agent components in a fair and rigorous manner. We find that the lack of a standard evaluation protocol makes previous works, even open-sourced ones, non-reproducible, with significant variance between random runs. Therefore, we introduce a more robust evaluation protocol to stabilize comparisons. Our study reveals which components and designs are crucial for effective agents, while others are redundant, despite seeming logical. Based on our findings, we build and open-source OAgents, a new foundation agent framework that achieves state-of-the-art performance among open-source projects. OAgents offers a modular design for various agent components, promoting future research in Agentic AI.', 'score': 20, 'issue_id': 4452, 'pub_date': '2025-06-17', 'pub_date_card': {'ru': '17 июня', 'en': 'June 17', 'zh': '6月17日'}, 'hash': 'e2b3d701474597cc', 'authors': ['He Zhu', 'Tianrui Qin', 'King Zhu', 'Heyuan Huang', 'Yeyi Guan', 'Jinxiang Xia', 'Yi Yao', 'Hanhao Li', 'Ningning Wang', 'Pai Liu', 'Tianhao Peng', 'Xin Gui', 'Xiaowan Li', 'Yuhui Liu', 'Yuchen Eleanor Jiang', 'Jun Wang', 'Changwang Zhang', 'Xiangru Tang', 'Ge Zhang', 'Jian Yang', 'Minghao Liu', 'Xitong Gao', 'Jiaheng Liu', 'Wangchunshu Zhou'], 'affiliations': ['Nanjing University', 'OPPO'], 'pdf_title_img': 'assets/pdf/title_img/2506.15741.jpg', 'data': {'categories': ['#agents', '#benchmark', '#open_source', '#agi'], 'emoji': '🤖', 'ru': {'title': 'Стандартизация и оптимизация агентных систем ИИ', 'desc': 'Статья посвящена проблеме стандартизации и научной строгости в исследованиях агентных систем искусственного интеллекта. Авторы провели систематическое эмпирическое исследование на бенчмарках GAIA и BrowseComp для изучения влияния различных компонентов агентных фреймворков. Они обнаружили значительную вариативность результатов между случайными запусками и предложили более надежный протокол оценки. На основе полученных результатов был разработан открытый фреймворк OAgents, достигающий наилучших показателей среди открытых проектов.'}, 'en': {'title': 'Standardizing Agentic AI for Better Comparisons and Performance', 'desc': 'This paper addresses the challenges in the field of Agentic AI, particularly the lack of standardization and scientific rigor in current research practices. The authors conduct a systematic empirical study using the GAIA benchmark and BrowseComp to evaluate the impact of design choices on agent effectiveness. They highlight that previous evaluation methods are non-reproducible and exhibit significant variance, which complicates fair comparisons. To improve this, they propose a robust evaluation protocol and introduce OAgents, a new modular agent framework that enhances performance and supports future research in the field.'}, 'zh': {'title': '标准化评估，提升Agentic AI的有效性', 'desc': '最近，Agentic AI成为一个越来越受欢迎的研究领域。然而，我们认为当前的代理研究实践缺乏标准化和科学严谨性，这使得不同方法之间的公平比较变得困难。因此，尚不清楚代理框架中的不同设计选择如何影响其有效性，并且测量其进展仍然具有挑战性。我们的研究通过系统的实证研究，提出了一种更稳健的评估协议，以稳定比较，并揭示了哪些组件和设计对有效代理至关重要。'}}}, {'id': 'https://huggingface.co/papers/2506.18898', 'title': 'Vision as a Dialect: Unifying Visual Understanding and Generation via\n  Text-Aligned Representations', 'url': 'https://huggingface.co/papers/2506.18898', 'abstract': "A multimodal framework uses a Text-Aligned Tokenizer (TA-Tok) to integrate vision and text into a unified space, employing a generative de-tokenizer with autoregressive and diffusion-based models for efficient and high-fidelity visual outputs.  \t\t\t\t\tAI-generated summary \t\t\t\t This paper presents a multimodal framework that attempts to unify visual understanding and generation within a shared discrete semantic representation. At its core is the Text-Aligned Tokenizer (TA-Tok), which converts images into discrete tokens using a text-aligned codebook projected from a large language model's (LLM) vocabulary. By integrating vision and text into a unified space with an expanded vocabulary, our multimodal LLM, Tar, enables cross-modal input and output through a shared interface, without the need for modality-specific designs. Additionally, we propose scale-adaptive encoding and decoding to balance efficiency and visual detail, along with a generative de-tokenizer to produce high-fidelity visual outputs. To address diverse decoding needs, we utilize two complementary de-tokenizers: a fast autoregressive model and a diffusion-based model. To enhance modality fusion, we investigate advanced pre-training tasks, demonstrating improvements in both visual understanding and generation. Experiments across benchmarks show that Tar matches or surpasses existing multimodal LLM methods, achieving faster convergence and greater training efficiency. Code, models, and data are available at https://tar.csuhan.com", 'score': 18, 'issue_id': 4447, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '988f76bd08498ba9', 'authors': ['Jiaming Han', 'Hao Chen', 'Yang Zhao', 'Hanyu Wang', 'Qi Zhao', 'Ziyan Yang', 'Hao He', 'Xiangyu Yue', 'Lu Jiang'], 'affiliations': ['ByteDance Seed', 'CUHK MMLab'], 'pdf_title_img': 'assets/pdf/title_img/2506.18898.jpg', 'data': {'categories': ['#training', '#cv', '#multimodal', '#games', '#benchmark', '#diffusion'], 'emoji': '🖼️', 'ru': {'title': 'Единое пространство для текста и изображений в мультимодальных языковых моделях', 'desc': 'Эта статья представляет мультимодальную систему, объединяющую понимание и генерацию визуальной информации в едином дискретном семантическом представлении. В основе системы лежит Text-Aligned Tokenizer (TA-Tok), который преобразует изображения в дискретные токены, используя кодовую книгу, спроектированную из словаря большой языковой модели. Система использует масштабируемое кодирование и декодирование для баланса эффективности и визуальной детализации, а также генеративный детокенизатор для создания высококачественных визуальных выходов. Эксперименты показывают, что предложенная модель Tar соответствует или превосходит существующие мультимодальные методы на основе больших языковых моделей, достигая более быстрой сходимости и большей эффективности обучения.'}, 'en': {'title': 'Unifying Vision and Text with TA-Tok for Enhanced Multimodal Learning', 'desc': "This paper introduces a multimodal framework that combines visual and textual data into a single representation using a Text-Aligned Tokenizer (TA-Tok). The TA-Tok transforms images into discrete tokens aligned with a large language model's vocabulary, allowing for seamless interaction between text and images. The framework employs a generative de-tokenizer that includes both autoregressive and diffusion-based models to generate high-quality visual outputs efficiently. Experimental results indicate that this approach not only enhances visual understanding and generation but also outperforms existing multimodal models in terms of training speed and efficiency."}, 'zh': {'title': '统一视觉与文本的多模态框架', 'desc': '这篇论文提出了一种多模态框架，旨在将视觉理解和生成统一到一个共享的离散语义表示中。核心是文本对齐的标记器（TA-Tok），它使用大型语言模型的词汇将图像转换为离散标记。通过扩展词汇，我们的多模态大语言模型Tar实现了跨模态输入和输出，避免了特定模态设计的需求。此外，我们还提出了规模自适应的编码和解码方法，以平衡效率和视觉细节，并使用生成性去标记器生成高保真视觉输出。'}}}, {'id': 'https://huggingface.co/papers/2506.18903', 'title': 'VMem: Consistent Interactive Video Scene Generation with Surfel-Indexed\n  View Memory', 'url': 'https://huggingface.co/papers/2506.18903', 'abstract': 'A novel memory mechanism called Surfel-Indexed View Memory enhances video generation by efficiently remembering and retrieving relevant past views, improving long-term scene coherence and reducing computational cost.  \t\t\t\t\tAI-generated summary \t\t\t\t We propose a novel memory mechanism to build video generators that can explore environments interactively. Similar results have previously been achieved by out-painting 2D views of the scene while incrementally reconstructing its 3D geometry, which quickly accumulates errors, or by video generators with a short context window, which struggle to maintain scene coherence over the long term. To address these limitations, we introduce Surfel-Indexed View Memory (VMem), a mechanism that remembers past views by indexing them geometrically based on the 3D surface elements (surfels) they have observed. VMem enables the efficient retrieval of the most relevant past views when generating new ones. By focusing only on these relevant views, our method produces consistent explorations of imagined environments at a fraction of the computational cost of using all past views as context. We evaluate our approach on challenging long-term scene synthesis benchmarks and demonstrate superior performance compared to existing methods in maintaining scene coherence and camera control.', 'score': 10, 'issue_id': 4448, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': 'fe5d31c2b125d778', 'authors': ['Runjia Li', 'Philip Torr', 'Andrea Vedaldi', 'Tomas Jakab'], 'affiliations': ['University of Oxford'], 'pdf_title_img': 'assets/pdf/title_img/2506.18903.jpg', 'data': {'categories': ['#long_context', '#video', '#benchmark', '#optimization', '#3d'], 'emoji': '🎥', 'ru': {'title': 'Эффективная память для согласованной генерации видео', 'desc': 'Статья представляет новый механизм памяти под названием Surfel-Indexed View Memory (VMem) для улучшения генерации видео. VMem позволяет эффективно запоминать и извлекать релевантные прошлые виды сцены, используя индексацию на основе 3D поверхностных элементов (сурфелей). Этот подход улучшает долгосрочную согласованность сцены и снижает вычислительные затраты по сравнению с использованием всех прошлых видов в качестве контекста. Метод демонстрирует превосходную производительность на сложных задачах долгосрочного синтеза сцен по сравнению с существующими методами.'}, 'en': {'title': 'Enhancing Video Generation with Efficient Memory Retrieval', 'desc': 'This paper introduces a new memory mechanism called Surfel-Indexed View Memory (VMem) that improves video generation by efficiently recalling relevant past views. Unlike traditional methods that either accumulate errors or have limited context, VMem uses geometric indexing based on 3D surface elements to enhance long-term scene coherence. By focusing on the most pertinent past views, it reduces computational costs while generating consistent and coherent video outputs. The approach is evaluated against challenging benchmarks, showing better performance in maintaining scene integrity and camera control compared to existing techniques.'}, 'zh': {'title': '高效记忆，提升视频生成的一致性', 'desc': '本文提出了一种新颖的记忆机制，称为表面索引视图记忆（Surfel-Indexed View Memory），旨在提高视频生成的效果。该机制通过几何索引过去的视图，基于观察到的三维表面元素（surfels）来有效地记忆和检索相关的历史视图。与传统方法相比，VMem能够在生成新视图时高效地提取最相关的过去视图，从而在降低计算成本的同时保持长期场景的一致性。我们在长期场景合成基准测试中评估了该方法，结果显示其在场景一致性和相机控制方面的表现优于现有方法。'}}}, {'id': 'https://huggingface.co/papers/2506.18309', 'title': 'LettinGo: Explore User Profile Generation for Recommendation System', 'url': 'https://huggingface.co/papers/2506.18309', 'abstract': 'LettinGo enhances user profiling via diverse, adaptive profiles generated using LLMs and Direct Preference Optimization, improving recommendation accuracy and flexibility.  \t\t\t\t\tAI-generated summary \t\t\t\t User profiling is pivotal for recommendation systems, as it transforms raw user interaction data into concise and structured representations that drive personalized recommendations. While traditional embedding-based profiles lack interpretability and adaptability, recent advances with large language models (LLMs) enable text-based profiles that are semantically richer and more transparent. However, existing methods often adhere to fixed formats that limit their ability to capture the full diversity of user behaviors. In this paper, we introduce LettinGo, a novel framework for generating diverse and adaptive user profiles. By leveraging the expressive power of LLMs and incorporating direct feedback from downstream recommendation tasks, our approach avoids the rigid constraints imposed by supervised fine-tuning (SFT). Instead, we employ Direct Preference Optimization (DPO) to align the profile generator with task-specific performance, ensuring that the profiles remain adaptive and effective. LettinGo operates in three stages: (1) exploring diverse user profiles via multiple LLMs, (2) evaluating profile quality based on their impact in recommendation systems, and (3) aligning the profile generation through pairwise preference data derived from task performance. Experimental results demonstrate that our framework significantly enhances recommendation accuracy, flexibility, and contextual awareness. This work enhances profile generation as a key innovation for next-generation recommendation systems.', 'score': 6, 'issue_id': 4450, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '6f2beb5a53c301ed', 'authors': ['Lu Wang', 'Di Zhang', 'Fangkai Yang', 'Pu Zhao', 'Jianfeng Liu', 'Yuefeng Zhan', 'Hao Sun', 'Qingwei Lin', 'Weiwei Deng', 'Dongmei Zhang', 'Feng Sun', 'Qi Zhang'], 'affiliations': ['Microsoft Corporation Beijing, China', 'Peking University Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2506.18309.jpg', 'data': {'categories': ['#rlhf', '#training', '#interpretability', '#optimization'], 'emoji': '🎯', 'ru': {'title': 'Адаптивные профили пользователей для точных рекомендаций', 'desc': 'LettinGo - это новая система для создания разнообразных и адаптивных профилей пользователей в рекомендательных системах. Она использует большие языковые модели (LLM) и метод прямой оптимизации предпочтений (DPO) для генерации профилей, которые лучше отражают поведение пользователей. Система работает в три этапа: исследование разнообразных профилей с помощью нескольких LLM, оценка качества профилей на основе их влияния на рекомендации, и оптимизация генерации профилей с использованием данных о попарных предпочтениях. Эксперименты показывают, что LettinGo значительно повышает точность рекомендаций, гибкость и контекстуальную осведомленность.'}, 'en': {'title': 'LettinGo: Adaptive User Profiles for Smarter Recommendations', 'desc': 'LettinGo is a new framework designed to improve user profiling for recommendation systems by creating diverse and adaptive profiles. It utilizes large language models (LLMs) to generate richer, text-based profiles that are more interpretable than traditional methods. The framework employs Direct Preference Optimization (DPO) to ensure that the profiles are aligned with specific recommendation tasks, allowing for greater flexibility and effectiveness. By exploring various user profiles and evaluating their impact on recommendations, LettinGo significantly enhances the accuracy and contextual awareness of personalized suggestions.'}, 'zh': {'title': 'LettinGo：提升推荐系统的用户画像生成', 'desc': 'LettinGo 是一个新颖的框架，用于生成多样化和自适应的用户画像，以提高推荐系统的准确性和灵活性。它利用大型语言模型（LLMs）的表达能力，结合直接偏好优化（DPO），避免了传统方法中固定格式的限制。通过三个阶段的操作，LettinGo 能够探索多样的用户画像、评估其在推荐系统中的质量，并根据任务性能调整生成过程。实验结果表明，该框架显著提升了推荐的准确性、灵活性和上下文意识。'}}}, {'id': 'https://huggingface.co/papers/2506.18631', 'title': 'ReDit: Reward Dithering for Improved LLM Policy Optimization', 'url': 'https://huggingface.co/papers/2506.18631', 'abstract': "ReDit, a reward dithering method, addresses issues in discrete reward systems by introducing noise, leading to smoother optimization and faster convergence compared to standard methods.  \t\t\t\t\tAI-generated summary \t\t\t\t DeepSeek-R1 has successfully enhanced Large Language Model (LLM) reasoning capabilities through its rule-based reward system. While it's a ''perfect'' reward system that effectively mitigates reward hacking, such reward functions are often discrete. Our experimental observations suggest that discrete rewards can lead to gradient anomaly, unstable optimization, and slow convergence. To address this issue, we propose ReDit (Reward Dithering), a method that dithers the discrete reward signal by adding simple random noise. With this perturbed reward, exploratory gradients are continuously provided throughout the learning process, enabling smoother gradient updates and accelerating convergence. The injected noise also introduces stochasticity into flat reward regions, encouraging the model to explore novel policies and escape local optima. Experiments across diverse tasks demonstrate the effectiveness and efficiency of ReDit. On average, ReDit achieves performance comparable to vanilla GRPO with only approximately 10% the training steps, and furthermore, still exhibits a 4% performance improvement over vanilla GRPO when trained for a similar duration. Visualizations confirm significant mitigation of gradient issues with ReDit. Moreover, theoretical analyses are provided to further validate these advantages.", 'score': 5, 'issue_id': 4448, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': 'cc6b6162c9368cf4', 'authors': ['Chenxing Wei', 'Jiarui Yu', 'Ying Tiffany He', 'Hande Dong', 'Yao Shu', 'Fei Yu'], 'affiliations': ['College of Computer Science and Software Engineering, Shenzhen University, China', 'Guangdong Laboratory of Artificial Intelligence and Digital Economy (SZ), China', 'Hong Kong University of Science and Technology (Guangzhou), China', 'Tencent, Shenzhen, China'], 'pdf_title_img': 'assets/pdf/title_img/2506.18631.jpg', 'data': {'categories': ['#rlhf', '#training', '#rl', '#reasoning', '#optimization'], 'emoji': '🎲', 'ru': {'title': 'Шум во благо: ReDit улучшает обучение языковых моделей', 'desc': 'ReDit - это метод добавления шума в дискретные системы вознаграждения для улучшения обучения языковых моделей. Он решает проблемы аномалий градиента и медленной сходимости, характерные для дискретных наград. ReDit обеспечивает более плавную оптимизацию и ускоряет сходимость по сравнению со стандартными методами. Эксперименты показали, что ReDit достигает сопоставимой производительности примерно за 10% шагов обучения по сравнению с обычным GRPO.'}, 'en': {'title': 'ReDit: Smoother Rewards for Faster Learning', 'desc': 'ReDit is a novel method designed to improve optimization in systems that use discrete rewards by adding random noise to the reward signal. This noise helps to create smoother gradient updates, which leads to faster convergence during training. By introducing stochasticity, ReDit encourages exploration of new policies, helping models avoid getting stuck in local optima. Experimental results show that ReDit not only reduces training time significantly but also enhances performance compared to traditional methods.'}, 'zh': {'title': 'ReDit：提升离散奖励系统的优化效率', 'desc': 'ReDit是一种奖励抖动方法，旨在解决离散奖励系统中的问题。通过引入噪声，ReDit使得优化过程更加平滑，并且收敛速度比标准方法更快。实验表明，离散奖励可能导致梯度异常和不稳定的优化，而ReDit通过添加随机噪声来改善这一点。最终，ReDit在多个任务中表现出色，训练步骤仅为传统方法的10%，同时在相似训练时间内性能提升了4%。'}}}, {'id': 'https://huggingface.co/papers/2506.16962', 'title': 'Enhancing Step-by-Step and Verifiable Medical Reasoning in MLLMs', 'url': 'https://huggingface.co/papers/2506.16962', 'abstract': 'MICS, a novel reasoning-path searching scheme, enhances medical MLLMs like Chiron-o1 with robust generalizable reasoning and visual question-answering capabilities through comprehensive chain-of-thought data generation.  \t\t\t\t\tAI-generated summary \t\t\t\t Multimodal large language models (MLLMs) have begun to demonstrate robust reasoning capabilities on general tasks, yet their application in the medical domain remains in its early stages. Constructing chain-of-thought (CoT) training data is essential for bolstering the reasoning abilities of medical MLLMs. However, existing approaches exhibit a deficiency in offering a comprehensive framework for searching and evaluating effective reasoning paths towards critical diagnosis. To address this challenge, we propose Mentor-Intern Collaborative Search (MICS), a novel reasoning-path searching scheme to generate rigorous and effective medical CoT data. MICS first leverages mentor models to initialize the reasoning, one step at a time, then prompts each intern model to continue the thinking along those initiated paths, and finally selects the optimal reasoning path according to the overall reasoning performance of multiple intern models. The reasoning performance is determined by an MICS-Score, which assesses the quality of generated reasoning paths. Eventually, we construct MMRP, a multi-task medical reasoning dataset with ranked difficulty, and Chiron-o1, a new medical MLLM devised via a curriculum learning strategy, with robust visual question-answering and generalizable reasoning capabilities. Extensive experiments demonstrate that Chiron-o1, trained on our CoT dataset constructed using MICS, achieves state-of-the-art performance across a list of medical visual question answering and reasoning benchmarks. Codes are available at GitHub - manglu097/Chiron-o1: Enhancing Step-by-Step and Verifiable Medical Reasoning in MLLMs', 'score': 5, 'issue_id': 4449, 'pub_date': '2025-06-20', 'pub_date_card': {'ru': '20 июня', 'en': 'June 20', 'zh': '6月20日'}, 'hash': 'c1531ab3106ca207', 'authors': ['Haoran Sun', 'Yankai Jiang', 'Wenjie Lou', 'Yujie Zhang', 'Wenjie Li', 'Lilong Wang', 'Mianxin Liu', 'Lei Liu', 'Xiaosong Wang'], 'affiliations': ['Fudan University', 'Shanghai Artificial Intelligence Laboratory', 'Shanghai Jiao Tong University'], 'pdf_title_img': 'assets/pdf/title_img/2506.16962.jpg', 'data': {'categories': ['#science', '#benchmark', '#data', '#multimodal', '#dataset', '#training', '#healthcare', '#reasoning'], 'emoji': '🩺', 'ru': {'title': 'Улучшение медицинских ИИ-моделей через поиск оптимальных путей рассуждения', 'desc': 'В статье представлен новый метод MICS для улучшения медицинских мультимодальных языковых моделей (MLLM) путем генерации эффективных цепочек рассуждений. MICS использует модели-наставники и модели-стажеры для пошагового построения и оценки путей рассуждения. На основе этого метода создана новая медицинская MLLM Chiron-o1, обученная на специально сгенерированном наборе данных MMRP. Эксперименты показывают, что Chiron-o1 достигает передовых результатов в задачах медицинского визуального вопросно-ответного анализа и рассуждений.'}, 'en': {'title': 'Enhancing Medical Reasoning with MICS: A New Path to Better Diagnosis', 'desc': 'This paper introduces MICS, a new method for improving reasoning in medical multimodal large language models (MLLMs) like Chiron-o1. MICS generates high-quality chain-of-thought (CoT) data by using mentor models to guide the reasoning process and intern models to explore these paths. The effectiveness of the reasoning paths is evaluated using an MICS-Score, which helps in selecting the best paths for medical diagnosis. The results show that Chiron-o1, trained with MICS-generated data, outperforms existing models in medical visual question answering and reasoning tasks.'}, 'zh': {'title': 'MICS：提升医疗推理能力的新方案', 'desc': 'MICS是一种新颖的推理路径搜索方案，旨在增强医疗多模态大语言模型（MLLMs）的推理能力。通过生成全面的思维链（CoT）数据，MICS能够有效地构建医疗领域的推理框架。该方法利用导师模型逐步初始化推理，然后让实习模型沿着这些路径继续思考，最终选择最佳推理路径。实验结果表明，基于MICS构建的Chiron-o1模型在医疗视觉问答和推理基准测试中表现出色。'}}}, {'id': 'https://huggingface.co/papers/2506.16123', 'title': 'FinCoT: Grounding Chain-of-Thought in Expert Financial Reasoning', 'url': 'https://huggingface.co/papers/2506.16123', 'abstract': 'A structured chain-of-thought prompting method in financial natural language processing improves performance and reduces computational cost while enhancing interpretability.  \t\t\t\t\tAI-generated summary \t\t\t\t This paper presents FinCoT, a structured chain-of-thought (CoT) prompting approach that incorporates insights from domain-specific expert financial reasoning to guide the reasoning traces of large language models. We investigate that there are three main prompting styles in FinNLP: (1) standard prompting--zero-shot prompting; (2) unstructured CoT--CoT prompting without an explicit reasoning structure, such as the use of tags; and (3) structured CoT prompting--CoT prompting with explicit instructions or examples that define structured reasoning steps. Previously, FinNLP has primarily focused on prompt engineering with either standard or unstructured CoT prompting. However, structured CoT prompting has received limited attention in prior work. Furthermore, the design of reasoning structures in structured CoT prompting is often based on heuristics from non-domain experts. In this study, we investigate each prompting approach in FinNLP. We evaluate the three main prompting styles and FinCoT on CFA-style questions spanning ten financial domains. We observe that FinCoT improves performance from 63.2% to 80.5% and Qwen-2.5-7B-Instruct from 69.7% to 74.2%, while reducing generated tokens eight-fold compared to structured CoT prompting. Our findings show that domain-aligned structured prompts not only improve performance and reduce inference costs but also yield more interpretable and expert-aligned reasoning traces.', 'score': 5, 'issue_id': 4456, 'pub_date': '2025-06-19', 'pub_date_card': {'ru': '19 июня', 'en': 'June 19', 'zh': '6月19日'}, 'hash': 'faa22cef17fe9376', 'authors': ['Natapong Nitarach', 'Warit Sirichotedumrong', 'Panop Pitchayarthorn', 'Pittawat Taveekitworachai', 'Potsawee Manakul', 'Kunat Pipatanakul'], 'affiliations': ['SCB 10X', 'SCBX Group'], 'pdf_title_img': 'assets/pdf/title_img/2506.16123.jpg', 'data': {'categories': ['#reasoning', '#interpretability', '#multimodal', '#training', '#data'], 'emoji': '💡', 'ru': {'title': 'Структурированные подсказки повышают эффективность языковых моделей в финансовой аналитике', 'desc': 'В статье представлен метод FinCoT - структурированный подход к цепочке рассуждений (CoT) для задач обработки естественного языка в финансовой сфере. FinCoT использует знания экспертов в области финансов для направления рассуждений больших языковых моделей. Метод улучшает производительность с 63.2% до 80.5% на вопросах в стиле CFA по 10 финансовым областям. Кроме того, FinCoT снижает вычислительные затраты и повышает интерпретируемость результатов.'}, 'en': {'title': 'Enhancing Financial NLP with Structured Reasoning', 'desc': 'This paper introduces FinCoT, a new prompting method for financial natural language processing that enhances the reasoning capabilities of large language models. It categorizes prompting styles into three types: standard prompting, unstructured chain-of-thought (CoT) prompting, and structured CoT prompting, with a focus on the latter. The study demonstrates that structured CoT prompting, which uses explicit instructions from financial experts, significantly boosts model performance and reduces computational costs. Results show that FinCoT increases accuracy and provides clearer reasoning paths, making it a valuable tool for financial analysis.'}, 'zh': {'title': '结构化思维链提示：提升金融NLP性能的关键', 'desc': '本文提出了一种名为FinCoT的结构化思维链提示方法，旨在提升金融自然语言处理的性能并降低计算成本，同时增强可解释性。研究表明，FinNLP中主要有三种提示风格：标准提示、非结构化思维链提示和结构化思维链提示。以往的研究主要集中在标准或非结构化思维链提示上，而结构化思维链提示的关注较少。通过对十个金融领域的CFA风格问题进行评估，FinCoT的性能从63.2%提升至80.5%，并且生成的标记数量减少了八倍，显示出领域对齐的结构化提示在性能和推理可解释性方面的优势。'}}}, {'id': 'https://huggingface.co/papers/2506.18792', 'title': 'ViDAR: Video Diffusion-Aware 4D Reconstruction From Monocular Inputs', 'url': 'https://huggingface.co/papers/2506.18792', 'abstract': "ViDAR uses diffusion-aware reconstruction to generate high-quality novel views of dynamic scenes from monocular video, outperforming existing methods in visual quality and geometric consistency.  \t\t\t\t\tAI-generated summary \t\t\t\t Dynamic Novel View Synthesis aims to generate photorealistic views of moving subjects from arbitrary viewpoints. This task is particularly challenging when relying on monocular video, where disentangling structure from motion is ill-posed and supervision is scarce. We introduce Video Diffusion-Aware Reconstruction (ViDAR), a novel 4D reconstruction framework that leverages personalised diffusion models to synthesise a pseudo multi-view supervision signal for training a Gaussian splatting representation. By conditioning on scene-specific features, ViDAR recovers fine-grained appearance details while mitigating artefacts introduced by monocular ambiguity. To address the spatio-temporal inconsistency of diffusion-based supervision, we propose a diffusion-aware loss function and a camera pose optimisation strategy that aligns synthetic views with the underlying scene geometry. Experiments on DyCheck, a challenging benchmark with extreme viewpoint variation, show that ViDAR outperforms all state-of-the-art baselines in visual quality and geometric consistency. We further highlight ViDAR's strong improvement over baselines on dynamic regions and provide a new benchmark to compare performance in reconstructing motion-rich parts of the scene. Project page: https://vidar-4d.github.io", 'score': 4, 'issue_id': 4455, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': 'f8043a5d01c5fa35', 'authors': ['Michal Nazarczuk', 'Sibi Catley-Chandar', 'Thomas Tanay', 'Zhensong Zhang', 'Gregory Slabaugh', 'Eduardo Pérez-Pellitero'], 'affiliations': ['Huawei Noahs Ark Lab', 'Queen Mary University of London'], 'pdf_title_img': 'assets/pdf/title_img/2506.18792.jpg', 'data': {'categories': ['#diffusion', '#optimization', '#video', '#benchmark', '#cv'], 'emoji': '🎥', 'ru': {'title': 'ViDAR: Реалистичный синтез новых ракурсов динамичных сцен', 'desc': 'ViDAR - это новая система для синтеза реалистичных видов динамичных сцен из монокулярного видео. Она использует персонализированные диффузионные модели для создания псевдо-многоракурсного сигнала обучения для представления сцены в виде гауссовых сплатов. ViDAR применяет диффузионно-осведомленную функцию потерь и оптимизацию положения камеры для согласования синтетических видов с геометрией сцены. Эксперименты показывают, что ViDAR превосходит существующие методы по визуальному качеству и геометрической согласованности, особенно для динамичных областей сцены.'}, 'en': {'title': 'Revolutionizing View Synthesis with ViDAR!', 'desc': 'ViDAR is a new method for creating high-quality images of moving scenes from single video feeds. It uses a technique called diffusion-aware reconstruction to improve the visual quality and consistency of the generated views. By employing personalized diffusion models, ViDAR generates a training signal that helps in accurately capturing the details of the scene while reducing errors caused by motion ambiguity. The method also includes a special loss function and camera pose optimization to ensure that the generated views align well with the actual scene geometry, leading to better results in dynamic environments.'}, 'zh': {'title': 'ViDAR：动态场景的新视角重建', 'desc': 'ViDAR是一种新颖的4D重建框架，利用扩散感知重建技术，从单目视频中生成高质量的动态场景新视角。该方法通过个性化的扩散模型合成伪多视角监督信号，训练高斯点云表示，从而有效分离结构与运动。ViDAR通过场景特定特征恢复细致的外观细节，并减少单目模糊带来的伪影。实验结果表明，ViDAR在视觉质量和几何一致性方面超越了现有的所有基线方法，尤其在动态区域表现出显著的改进。'}}}, {'id': 'https://huggingface.co/papers/2506.18527', 'title': 'Auto-Regressively Generating Multi-View Consistent Images', 'url': 'https://huggingface.co/papers/2506.18527', 'abstract': '', 'score': 4, 'issue_id': 4450, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '5b7e755fbaf18d79', 'authors': ['JiaKui Hu', 'Yuxiao Yang', 'Jialun Liu', 'Jinbo Wu', 'Chen Zhao', 'Yanye Lu'], 'affiliations': ['Baidu VIS', 'Biomedical Engineering Department, College of Future Technology, Peking University', 'Institute of Medical Technology, Peking University Health Science Center, Peking University', 'National Biomedical Imaging Center, Peking University', 'Tsinghua University'], 'pdf_title_img': 'assets/pdf/title_img/2506.18527.jpg', 'data': {'categories': [], 'emoji': '🤖', 'ru': {'title': 'Новая эра понимания текста с LLM', 'desc': 'В статье рассматривается новая архитектура LLM, которая улучшает понимание контекста в текстах. Авторы предлагают метод, который позволяет модели более эффективно обрабатывать длинные последовательности слов. Это достигается за счёт оптимизации внимания и использования более глубоких нейронных сетей. Результаты экспериментов показывают, что предложенная модель превосходит существующие аналоги по точности и скорости обработки.'}, 'en': {'title': 'Hybrid Models: Bridging Spatial and Temporal Learning', 'desc': "This paper presents a novel approach to improve the performance of deep learning models by utilizing a hybrid architecture that combines convolutional neural networks (CNNs) with recurrent neural networks (RNNs). The proposed method enhances feature extraction from spatial data while also capturing temporal dependencies, making it suitable for tasks like video analysis and time-series prediction. The authors demonstrate that their model outperforms existing state-of-the-art techniques on several benchmark datasets. Additionally, they provide insights into the model's interpretability and robustness against adversarial attacks."}, 'zh': {'title': '提升预测准确性的创新算法', 'desc': '这篇论文探讨了一种新的机器学习算法，旨在提高模型的预测准确性。作者提出了一种改进的特征选择方法，可以有效减少数据维度，同时保留重要信息。实验结果表明，该算法在多个数据集上表现优于传统方法。通过优化模型的训练过程，研究者希望推动机器学习在实际应用中的效果。'}}}, {'id': 'https://huggingface.co/papers/2506.18349', 'title': 'SlimMoE: Structured Compression of Large MoE Models via Expert Slimming\n  and Distillation', 'url': 'https://huggingface.co/papers/2506.18349', 'abstract': "SlimMoE compresses large MoE models into smaller, efficient variants using multi-stage compression without full retraining, maintaining competitive performance with significantly fewer resources.  \t\t\t\t\tAI-generated summary \t\t\t\t The Mixture of Experts (MoE) architecture has emerged as a powerful paradigm for scaling large language models (LLMs) while maintaining inference efficiency. However, their enormous memory requirements make them prohibitively expensive to fine-tune or deploy in resource-constrained environments. To address this challenge, we introduce SlimMoE, a multi-stage compression framework for transforming large MoE models into much smaller, efficient variants without incurring the prohibitive costs of training from scratch. Our method systematically reduces parameter counts by slimming experts and transferring knowledge through intermediate stages, effectively mitigating the performance degradation common in one-shot pruning approaches. Using this framework, we compress Phi 3.5-MoE (41.9B total/6.6B activated parameters) to create Phi-mini-MoE (7.6B total/2.4B activated parameters) and Phi-tiny-MoE (3.8B total/1.1B activated parameters) using only 400B tokens--less than 10% of the original model's training data. These compressed models can be fine-tuned on a single GPU (A100 for Phi-mini-MoE, A6000 for Phi-tiny-MoE), making them highly suitable for academic and resource-limited settings. Our experiments demonstrate that these compressed models outperform others of similar size and remain competitive with larger models. For instance, Phi-mini-MoE achieves similar or better performance to Phi-3-mini using only 2/3 of the activated parameters and yields comparable MMLU scores to Llama 3.1 8B despite having significantly lower latency. Our findings demonstrate that structured pruning combined with staged distillation offers an effective path to creating high-quality, compact MoE models, paving the way for broader adoption of MoE architectures. We make our models publicly available at https://huggingface.co/microsoft/Phi-mini-MoE-instruct and https://huggingface.co/microsoft/Phi-tiny-MoE-instruct .", 'score': 4, 'issue_id': 4449, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': 'ae21c466bdfe4727', 'authors': ['Zichong Li', 'Chen Liang', 'Zixuan Zhang', 'Ilgee Hong', 'Young Jin Kim', 'Weizhu Chen', 'Tuo Zhao'], 'affiliations': ['Georgia Tech', 'Microsoft'], 'pdf_title_img': 'assets/pdf/title_img/2506.18349.jpg', 'data': {'categories': ['#transfer_learning', '#optimization', '#training', '#architecture', '#open_source', '#inference', '#small_models'], 'emoji': '🗜️', 'ru': {'title': 'SlimMoE: Эффективное сжатие MoE-моделей без потери качества', 'desc': 'SlimMoE - это фреймворк для многоэтапного сжатия крупных моделей Mixture of Experts (MoE) в более компактные и эффективные варианты. Метод уменьшает количество параметров путем сокращения экспертов и передачи знаний через промежуточные стадии, что позволяет избежать значительного падения производительности. Используя этот подход, авторы сжали модель Phi 3.5-MoE до Phi-mini-MoE и Phi-tiny-MoE, которые можно дообучать на одном GPU. Эксперименты показывают, что сжатые модели превосходят аналоги аналогичного размера и остаются конкурентоспособными с более крупными моделями.'}, 'en': {'title': 'Efficient Compression of MoE Models for Resource-Constrained Environments', 'desc': 'SlimMoE is a novel framework designed to compress large Mixture of Experts (MoE) models into smaller, more efficient versions without the need for extensive retraining. It employs a multi-stage compression approach that reduces the number of parameters while preserving model performance, making it feasible to deploy in environments with limited resources. By systematically slimming down experts and transferring knowledge through intermediate stages, SlimMoE mitigates the performance loss typically associated with one-shot pruning methods. The resulting models, Phi-mini-MoE and Phi-tiny-MoE, demonstrate competitive performance with significantly fewer activated parameters, making them ideal for academic and resource-constrained applications.'}, 'zh': {'title': 'SlimMoE：高效压缩大型MoE模型的解决方案', 'desc': 'SlimMoE是一种多阶段压缩框架，旨在将大型混合专家（MoE）模型压缩为更小、更高效的变体，而无需完全重新训练。该方法通过精简专家和在中间阶段转移知识，有效减少参数数量，避免了一次性剪枝方法常见的性能下降。实验表明，压缩后的模型在相似规模下表现优于其他模型，并且在较低延迟下与更大模型的性能相当。SlimMoE为在资源有限的环境中使用MoE架构提供了有效的解决方案。'}}}, {'id': 'https://huggingface.co/papers/2506.17538', 'title': 'ConsumerBench: Benchmarking Generative AI Applications on End-User\n  Devices', 'url': 'https://huggingface.co/papers/2506.17538', 'abstract': 'ConsumerBench evaluates GenAI system efficiency and response time on end-user devices through a comprehensive benchmarking framework, emphasizing realistic multi-application scenarios and customizable workflows.  \t\t\t\t\tAI-generated summary \t\t\t\t The recent shift in Generative AI (GenAI) applications from cloud-only environments to end-user devices introduces new challenges in resource management, system efficiency, and user experience. This paper presents ConsumerBench, a comprehensive benchmarking framework designed to evaluate the system efficiency and response time of GenAI models running on end-user devices. Unlike existing benchmarks that assume exclusive model access on dedicated GPUs, ConsumerBench simulates realistic multi-application scenarios executing concurrently on constrained hardware. Furthermore, ConsumerBench supports customizable workflows that simulate complex tasks requiring coordination among multiple applications. ConsumerBench captures both application-level metrics, including latency and Service Level Objective (SLO) attainment, and system-level metrics like CPU/GPU utilization and memory bandwidth. Through extensive experiments, ConsumerBench reveals inefficiencies in resource sharing, unfair scheduling under greedy allocation, and performance pitfalls of static model server configurations. The paper also provides practical insights for model developers and system designers, highlighting the benefits of custom kernels tailored to consumer-grade GPU architectures and the value of implementing SLO-aware scheduling strategies.', 'score': 4, 'issue_id': 4451, 'pub_date': '2025-06-21', 'pub_date_card': {'ru': '21 июня', 'en': 'June 21', 'zh': '6月21日'}, 'hash': '77484dbfc212d862', 'authors': ['Yile Gu', 'Rohan Kadekodi', 'Hoang Nguyen', 'Keisuke Kamahori', 'Yiyu Liu', 'Baris Kasikci'], 'affiliations': ['Shanghai Jiao Tong University', 'University of Washington'], 'pdf_title_img': 'assets/pdf/title_img/2506.17538.jpg', 'data': {'categories': ['#data', '#optimization', '#benchmark'], 'emoji': '📱', 'ru': {'title': 'ConsumerBench: Оценка GenAI на пользовательских устройствах', 'desc': 'ConsumerBench - это комплексная система оценки эффективности и времени отклика генеративных моделей искусственного интеллекта на пользовательских устройствах. Она симулирует реалистичные сценарии с несколькими приложениями, работающими одновременно на ограниченном оборудовании. ConsumerBench поддерживает настраиваемые рабочие процессы и собирает метрики на уровне приложений и системы. Эксперименты выявили неэффективность совместного использования ресурсов и проблемы производительности при статических конфигурациях серверов моделей.'}, 'en': {'title': 'Optimizing GenAI Performance on Everyday Devices', 'desc': 'ConsumerBench is a benchmarking framework that assesses the efficiency and response time of Generative AI (GenAI) systems on end-user devices. It addresses the challenges posed by running multiple applications simultaneously on limited hardware, unlike traditional benchmarks that focus on dedicated GPUs. The framework measures both application-level metrics, such as latency and Service Level Objectives (SLO), and system-level metrics like CPU/GPU utilization. The findings highlight issues in resource sharing and scheduling, offering insights for developers to optimize performance on consumer-grade devices.'}, 'zh': {'title': 'ConsumerBench：评估终端设备上GenAI系统的效率与响应时间', 'desc': 'ConsumerBench是一个全面的基准测试框架，用于评估在终端设备上运行的生成性人工智能（GenAI）系统的效率和响应时间。与现有基准测试不同，ConsumerBench模拟了在受限硬件上同时执行的多应用场景，强调了资源管理和用户体验的新挑战。该框架支持可定制的工作流程，能够模拟需要多个应用协调的复杂任务。通过实验，ConsumerBench揭示了资源共享中的低效、贪婪分配下的不公平调度以及静态模型服务器配置的性能陷阱。'}}}, {'id': 'https://huggingface.co/papers/2506.18879', 'title': 'CommVQ: Commutative Vector Quantization for KV Cache Compression', 'url': 'https://huggingface.co/papers/2506.18879', 'abstract': 'Commutative Vector Quantization (CommVQ) reduces memory usage in long-context LLM inference by compressing the KV cache with additive quantization and integration of Rotary Position Embedding (RoPE).  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) are increasingly used in applications requiring long context lengths, but the key-value (KV) cache often becomes a memory bottleneck on GPUs as context grows. To address this, we propose Commutative Vector Quantization (CommVQ) to significantly reduce memory usage for long-context LLM inference. We first introduce additive quantization with a lightweight encoder and codebook to compress the KV cache, which can be decoded via simple matrix multiplication. To further reduce computational costs during decoding, we design the codebook to be commutative with Rotary Position Embedding (RoPE) and train it using an Expectation-Maximization (EM) algorithm. This enables efficient integration of decoding into the self-attention mechanism. Our approach achieves high accuracy with additive quantization and low overhead via the RoPE-commutative codebook. Experiments on long-context benchmarks and GSM8K show that our method reduces FP16 KV cache size by 87.5% with 2-bit quantization, while outperforming state-of-the-art KV cache quantization methods. Notably, it enables 1-bit KV cache quantization with minimal accuracy loss, allowing a LLaMA-3.1 8B model to run with a 128K context length on a single RTX 4090 GPU. The source code is available at: https://github.com/UMass-Embodied-AGI/CommVQ.', 'score': 3, 'issue_id': 4448, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '1d442a58c0e72d5c', 'authors': ['Junyan Li', 'Yang Zhang', 'Muhammad Yusuf Hassan', 'Talha Chafekar', 'Tianle Cai', 'Zhile Ren', 'Pengsheng Guo', 'Foroozan Karimzadeh', 'Colorado Reed', 'Chong Wang', 'Chuang Gan'], 'affiliations': ['Apple Inc.', 'Massachusetts Institute of Technology', 'Princeton University', 'University of Massachusetts Amherst'], 'pdf_title_img': 'assets/pdf/title_img/2506.18879.jpg', 'data': {'categories': ['#long_context', '#training', '#open_source', '#inference', '#optimization'], 'emoji': '🧠', 'ru': {'title': 'Эффективное сжатие памяти для длинноконтекстных языковых моделей', 'desc': 'Статья представляет метод Commutative Vector Quantization (CommVQ) для сжатия кэша ключ-значение в больших языковых моделях. CommVQ использует аддитивное квантование и интеграцию с Rotary Position Embedding для значительного уменьшения использования памяти. Этот подход позволяет сократить размер кэша на 87.5% при 2-битном квантовании, сохраняя высокую точность. Метод также делает возможным 1-битное квантование с минимальной потерей точности, что позволяет запускать модель LLaMA-3.1 8B с контекстом 128K на одном GPU RTX 4090.'}, 'en': {'title': 'Efficient Memory Management for Long-Context LLMs with CommVQ', 'desc': 'This paper introduces Commutative Vector Quantization (CommVQ), a method designed to reduce memory usage in long-context inference for Large Language Models (LLMs). By employing additive quantization and a commutative codebook integrated with Rotary Position Embedding (RoPE), the method compresses the key-value (KV) cache effectively. The approach allows for efficient decoding through simple matrix multiplication, significantly lowering computational costs. Experiments demonstrate that CommVQ can reduce the KV cache size by 87.5% while maintaining high accuracy, enabling LLMs to handle longer contexts on standard GPUs.'}, 'zh': {'title': '可交换向量量化：优化长上下文推理的内存使用', 'desc': '本文提出了一种称为可交换向量量化（CommVQ）的方法，旨在减少长上下文大语言模型（LLM）推理中的内存使用。通过引入加法量化和轻量级编码器，CommVQ能够有效压缩键值（KV）缓存，并通过简单的矩阵乘法进行解码。我们还设计了与旋转位置嵌入（RoPE）兼容的代码本，并使用期望最大化（EM）算法进行训练，从而在自注意力机制中实现高效解码。实验结果表明，该方法在保持高准确率的同时，能够将FP16 KV缓存大小减少87.5%，并在1位量化下实现最小的准确性损失。'}}}, {'id': 'https://huggingface.co/papers/2506.16507', 'title': 'Robust Reward Modeling via Causal Rubrics', 'url': 'https://huggingface.co/papers/2506.16507', 'abstract': 'Crome, a novel reward modeling framework using causal and neutral augmentations, significantly improves the robustness and accuracy of reward models against reward hacking.  \t\t\t\t\tAI-generated summary \t\t\t\t Reward models (RMs) are fundamental to aligning Large Language Models (LLMs) via human feedback, yet they often suffer from reward hacking. They tend to latch on to superficial or spurious attributes, such as response length or formatting, mistaking these cues learned from correlations in training data for the true causal drivers of quality (e.g., factuality, relevance). This occurs because standard training objectives struggle to disentangle these factors, leading to brittle RMs and misaligned policies. We introduce Crome (Causally Robust Reward Modeling), a novel framework grounded in an explicit causal model designed to mitigate reward hacking. Crome employs the following synthetic targeted augmentations during training: (1) Causal Augmentations, which are pairs that differ along specific causal attributes, to enforce sensitivity along each causal attribute individually, and (2) Neutral Augmentations, which are tie-label pairs varying primarily in spurious attributes, to enforce invariance along spurious attributes. Notably, our augmentations are produced without any knowledge of spurious factors, via answer interventions only along causal rubrics, that are identified by querying an oracle LLM. Empirically, Crome significantly outperforms standard baselines on RewardBench, improving average accuracy by up to 5.4% and achieving gains of up to 13.2% and 7.2% in specific categories. The robustness of Crome is further testified by the consistent gains obtained in a Best-of-N inference setting across increasing N, across various benchmarks, including the popular RewardBench (covering chat, chat-hard, safety, and reasoning tasks), the safety-focused WildGuardTest, and the reasoning-specific GSM8k.', 'score': 3, 'issue_id': 4455, 'pub_date': '2025-06-19', 'pub_date_card': {'ru': '19 июня', 'en': 'June 19', 'zh': '6月19日'}, 'hash': 'aca1d330d3067ef5', 'authors': ['Pragya Srivastava', 'Harman Singh', 'Rahul Madhavan', 'Gandharv Patil', 'Sravanti Addepalli', 'Arun Suggala', 'Rengarajan Aravamudhan', 'Soumya Sharma', 'Anirban Laha', 'Aravindan Raghuveer', 'Karthikeyan Shanmugam', 'Doina Precup'], 'affiliations': ['Google DeepMind', 'MILA - Quebec AI Institute', 'McGill University'], 'pdf_title_img': 'assets/pdf/title_img/2506.16507.jpg', 'data': {'categories': ['#optimization', '#alignment', '#benchmark', '#rlhf', '#hallucinations', '#training'], 'emoji': '🎯', 'ru': {'title': 'Устойчивое моделирование вознаграждений через каузальные аугментации', 'desc': 'Crome - это новая система моделирования вознаграждений, использующая каузальные и нейтральные аугментации для улучшения устойчивости и точности моделей вознаграждения против взлома вознаграждений. Она основана на явной каузальной модели и применяет синтетические целевые аугментации во время обучения. Crome значительно превосходит стандартные базовые модели на бенчмарке RewardBench, повышая среднюю точность до 5.4%. Устойчивость Crome подтверждается стабильным улучшением результатов при инференсе с выбором лучшего из N вариантов на различных бенчмарках.'}, 'en': {'title': 'Crome: Enhancing Reward Models with Causal Insights', 'desc': 'Crome is a new framework designed to enhance reward models used in aligning Large Language Models with human feedback. It addresses the issue of reward hacking, where models mistakenly focus on superficial traits instead of genuine quality indicators. By using causal and neutral augmentations during training, Crome helps models learn the true causal factors that contribute to quality while ignoring misleading spurious attributes. The framework has shown significant improvements in accuracy and robustness across various benchmarks, demonstrating its effectiveness in creating more reliable reward models.'}, 'zh': {'title': 'Crome：提升奖励模型鲁棒性的创新框架', 'desc': 'Crome是一种新颖的奖励建模框架，旨在提高奖励模型的鲁棒性和准确性，以防止奖励黑客行为。传统的奖励模型容易受到表面特征的影响，导致误判质量的真正因果驱动因素。Crome通过因果增强和中性增强的合成目标来训练模型，从而分别增强对因果属性的敏感性和对表面属性的不变性。实验结果表明，Crome在多个基准测试中显著优于传统模型，提升了平均准确率。'}}}, {'id': 'https://huggingface.co/papers/2506.18901', 'title': 'From Virtual Games to Real-World Play', 'url': 'https://huggingface.co/papers/2506.18901', 'abstract': 'RealPlay generates photorealistic, temporally consistent video sequences from user control signals through iterative prediction and generalizes to various real-world entities.  \t\t\t\t\tAI-generated summary \t\t\t\t We introduce RealPlay, a neural network-based real-world game engine that enables interactive video generation from user control signals. Unlike prior works focused on game-style visuals, RealPlay aims to produce photorealistic, temporally consistent video sequences that resemble real-world footage. It operates in an interactive loop: users observe a generated scene, issue a control command, and receive a short video chunk in response. To enable such realistic and responsive generation, we address key challenges including iterative chunk-wise prediction for low-latency feedback, temporal consistency across iterations, and accurate control response. RealPlay is trained on a combination of labeled game data and unlabeled real-world videos, without requiring real-world action annotations. Notably, we observe two forms of generalization: (1) control transfer-RealPlay effectively maps control signals from virtual to real-world scenarios; and (2) entity transfer-although training labels originate solely from a car racing game, RealPlay generalizes to control diverse real-world entities, including bicycles and pedestrians, beyond vehicles. Project page can be found: https://wenqsun.github.io/RealPlay/', 'score': 2, 'issue_id': 4457, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': '74497a4801f265ee', 'authors': ['Wenqiang Sun', 'Fangyun Wei', 'Jinjing Zhao', 'Xi Chen', 'Zilong Chen', 'Hongyang Zhang', 'Jun Zhang', 'Yan Lu'], 'affiliations': ['HKUST', 'Microsoft Research', 'Tsinghua University', 'University of Sydney', 'University of Waterloo'], 'pdf_title_img': 'assets/pdf/title_img/2506.18901.jpg', 'data': {'categories': ['#games', '#video', '#multimodal', '#transfer_learning'], 'emoji': '🎮', 'ru': {'title': 'RealPlay: от виртуального управления к реалистичному видео', 'desc': 'RealPlay - это нейросетевой движок для генерации фотореалистичных видеопоследовательностей на основе пользовательских сигналов управления. Система работает итеративно, предсказывая короткие видеофрагменты в ответ на команды пользователя. RealPlay обучается на комбинации размеченных игровых данных и нераз меченных видео реального мира, что позволяет ей обобщать навыки управления с виртуальных на реальные сценарии. Примечательно, что модель способна управлять разнообразными объектами реального мира, включая велосипеды и пешеходов, хотя обучалась только на данных гонок автомобилей.'}, 'en': {'title': 'RealPlay: Interactive, Photorealistic Video Generation from User Commands', 'desc': 'RealPlay is a neural network-based system designed to generate realistic video sequences in response to user commands. It focuses on creating photorealistic visuals that maintain temporal consistency, making the generated videos appear like real-world footage. The system operates interactively, allowing users to issue commands and receive video chunks with low latency. RealPlay demonstrates impressive generalization capabilities, effectively transferring control signals from virtual environments to real-world scenarios and adapting to various entities beyond its initial training data.'}, 'zh': {'title': '实时生成真实感视频的游戏引擎', 'desc': 'RealPlay是一种基于神经网络的游戏引擎，能够根据用户的控制信号生成逼真的视频序列。与以往专注于游戏风格视觉效果的研究不同，RealPlay旨在生成与真实世界视频相似的高质量、时间一致的视频。它通过一个交互循环工作，用户观察生成的场景，发出控制命令，然后收到短视频片段作为反馈。RealPlay在训练过程中结合了标记的游戏数据和未标记的真实世界视频，能够有效地将控制信号从虚拟场景映射到真实场景，并且能够控制多种真实世界实体。'}}}, {'id': 'https://huggingface.co/papers/2506.17673', 'title': 'FaithfulSAE: Towards Capturing Faithful Features with Sparse\n  Autoencoders without External Dataset Dependencies', 'url': 'https://huggingface.co/papers/2506.17673', 'abstract': 'FaithfulSAE improves Sparse Autoencoder stability and interpretability by training on synthetic datasets generated by the model itself, reducing the occurrence of fake features and out-of-distribution data issues.  \t\t\t\t\tAI-generated summary \t\t\t\t Sparse Autoencoders (SAEs) have emerged as a promising solution for decomposing large language model representations into interpretable features. However, Paulo and Belrose (2025) have highlighted instability across different initialization seeds, and Heap et al. (2025) have pointed out that SAEs may not capture model-internal features. These problems likely stem from training SAEs on external datasets - either collected from the Web or generated by another model - which may contain out-of-distribution (OOD) data beyond the model\'s generalisation capabilities. This can result in hallucinated SAE features, which we term "Fake Features", that misrepresent the model\'s internal activations. To address these issues, we propose FaithfulSAE, a method that trains SAEs on the model\'s own synthetic dataset. Using FaithfulSAEs, we demonstrate that training SAEs on less-OOD instruction datasets results in SAEs being more stable across seeds. Notably, FaithfulSAEs outperform SAEs trained on web-based datasets in the SAE probing task and exhibit a lower Fake Feature Ratio in 5 out of 7 models. Overall, our approach eliminates the dependency on external datasets, advancing interpretability by better capturing model-internal features while highlighting the often neglected importance of SAE training datasets.', 'score': 2, 'issue_id': 4453, 'pub_date': '2025-06-21', 'pub_date_card': {'ru': '21 июня', 'en': 'June 21', 'zh': '6月21日'}, 'hash': 'b4d024da8e8afc68', 'authors': ['Seonglae Cho', 'Harryn Oh', 'Donghyun Lee', 'Luis Eduardo Rodrigues Vieira', 'Andrew Bermingham', 'Ziad El Sayed'], 'affiliations': ['University College London'], 'pdf_title_img': 'assets/pdf/title_img/2506.17673.jpg', 'data': {'categories': ['#dataset', '#interpretability', '#data', '#hallucinations', '#synthetic', '#training'], 'emoji': '🧠', 'ru': {'title': 'Верные себе автоэнкодеры: улучшение стабильности и интерпретируемости SAE', 'desc': 'FaithfulSAE - это метод улучшения стабильности и интерпретируемости разреженных автоэнкодеров (SAE) путем обучения на синтетических данных, генерируемых самой моделью. Этот подход снижает появление ложных признаков и проблем с данными вне распределения. FaithfulSAE показывает лучшие результаты в задачах зондирования SAE по сравнению с SAE, обученными на веб-датасетах. Метод устраняет зависимость от внешних наборов данных, улучшая интерпретируемость путем лучшего захвата внутренних особенностей модели.'}, 'en': {'title': 'Enhancing SAE Stability and Interpretability with Synthetic Data', 'desc': "FaithfulSAE is a method designed to enhance the stability and interpretability of Sparse Autoencoders (SAEs) by training them on synthetic datasets generated by the model itself. This approach addresses issues of instability and the presence of 'Fake Features' that arise when SAEs are trained on external datasets, which may include out-of-distribution data. By using less out-of-distribution instruction datasets, FaithfulSAE ensures that the SAEs are more consistent across different initialization seeds. The results show that FaithfulSAE significantly reduces the occurrence of misrepresented features and improves performance in SAE probing tasks compared to traditional web-based training methods."}, 'zh': {'title': 'FaithfulSAE：提升稀疏自编码器的稳定性与可解释性', 'desc': 'FaithfulSAE是一种改进稀疏自编码器（SAE）稳定性和可解释性的方法。它通过使用模型自身生成的合成数据集进行训练，减少了虚假特征和分布外数据的问题。研究表明，使用FaithfulSAE训练的SAE在不同初始化种子下表现更稳定，并且在SAE探测任务中优于基于网络数据集训练的SAE。该方法强调了SAE训练数据集的重要性，推动了对模型内部特征的更好捕捉。'}}}, {'id': 'https://huggingface.co/papers/2506.16929', 'title': 'A deep learning and machine learning approach to predict neonatal death\n  in the context of São Paulo', 'url': 'https://huggingface.co/papers/2506.16929', 'abstract': 'Deep learning, specifically LSTM, outperforms other machine learning techniques in predicting neonatal mortality using historical data.  \t\t\t\t\tAI-generated summary \t\t\t\t Neonatal death is still a concerning reality for underdeveloped and even some developed countries. Worldwide data indicate that 26.693 babies out of 1,000 births die, according to Macro Trades. To reduce this number, early prediction of endangered babies is crucial. Such prediction enables the opportunity to take ample care of the child and mother so that early child death can be avoided. In this context, machine learning was used to determine whether a newborn baby is at risk. To train the predictive model, historical data of 1.4 million newborns was used. Machine learning and deep learning techniques such as logical regression, K-nearest neighbor, random forest classifier, extreme gradient boosting (XGBoost), convolutional neural network, and long short-term memory (LSTM) were implemented using the dataset to identify the most accurate model for predicting neonatal mortality. Among the machine learning algorithms, XGBoost and random forest classifier achieved the best accuracy with 94%, while among the deep learning models, LSTM delivered the highest accuracy with 99%. Therefore, using LSTM appears to be the most suitable approach to predict whether precautionary measures for a child are necessary.', 'score': 2, 'issue_id': 4455, 'pub_date': '2025-06-20', 'pub_date_card': {'ru': '20 июня', 'en': 'June 20', 'zh': '6月20日'}, 'hash': '0bc1d033846c482b', 'authors': ['Mohon Raihan', 'Plabon Kumar Saha', 'Rajan Das Gupta', 'A Z M Tahmidul Kabir', 'Afia Anjum Tamanna', 'Md. Harun-Ur-Rashid', 'Adnan Bin Abdus Salam', 'Md Tanvir Anjum', 'A Z M Ahteshamul Kabir'], 'affiliations': ['Department of Computer Science and Engineering, Faculty of Engineering and Technology, University of Dhaka, Dhaka, Bangladesh', 'Department of Computer Science and Engineering, Faculty of Science & Engineering, United International University-Bangladesh, Dhaka, Bangladesh', 'Department of Computer Science and Engineering, Faculty of Science and Technology, American International University-Bangladesh, Dhaka, Bangladesh', 'Department of Computer Science and Software Engineering, Faculty of Science and Technology, American International University-Bangladesh, Dhaka, Bangladesh', 'Department of Computer Science, Faculty of Mathematical & Physical Sciences, Jahangirnagar University, Dhaka, Bangladesh', 'Department of Electrical and Electronic Engineering, Faculty of Engineering, American International University-Bangladesh, Dhaka, Bangladesh', 'Department of Predictive Analytics, Faculty of Science and Engineering, Curtin University, Perth, Australia'], 'pdf_title_img': 'assets/pdf/title_img/2506.16929.jpg', 'data': {'categories': ['#healthcare', '#dataset', '#training', '#data'], 'emoji': '👶', 'ru': {'title': 'LSTM превосходит другие модели в прогнозировании неонатальной смертности', 'desc': 'Исследование посвящено применению методов машинного обучения для прогнозирования неонатальной смертности. Авторы использовали исторические данные о 1,4 миллионах новорожденных для обучения различных моделей, включая логистическую регрессию, случайный лес, XGBoost и нейронные сети. Среди алгоритмов машинного обучения лучшую точность в 94% показали XGBoost и случайный лес. Наилучший результат продемонстрировала модель LSTM с точностью 99%, что делает ее наиболее подходящей для прогнозирования необходимости превентивных мер.'}, 'en': {'title': 'LSTM: The Key to Predicting Neonatal Survival', 'desc': 'This paper discusses the use of machine learning, particularly Long Short-Term Memory (LSTM) networks, to predict neonatal mortality using historical data from 1.4 million newborns. The study compares various machine learning techniques, including logistic regression, K-nearest neighbors, random forest, and XGBoost, to identify the most effective model for this prediction task. Results show that while XGBoost and random forest achieved 94% accuracy, LSTM outperformed all other models with an impressive 99% accuracy. The findings highlight the importance of early prediction in reducing neonatal deaths by enabling timely interventions for at-risk infants.'}, 'zh': {'title': 'LSTM：新生儿死亡率预测的最佳选择', 'desc': '本研究探讨了深度学习，特别是长短期记忆网络（LSTM）在预测新生儿死亡率方面的优势。通过分析140万名新生儿的历史数据，研究使用了多种机器学习技术，包括逻辑回归、K近邻、随机森林分类器和极端梯度提升（XGBoost）。结果显示，LSTM模型的预测准确率高达99%，远超其他算法。因此，LSTM被认为是预测新生儿是否需要采取预防措施的最佳方法。'}}}, {'id': 'https://huggingface.co/papers/2506.17323', 'title': 'I Know Which LLM Wrote Your Code Last Summer: LLM generated Code\n  Stylometry for Authorship Attribution', 'url': 'https://huggingface.co/papers/2506.17323', 'abstract': "A novel model, CodeT5-Authorship, is introduced to classify the authorship of C programs generated by Large Language Models, achieving high accuracy compared to traditional and transformer-based classifiers.  \t\t\t\t\tAI-generated summary \t\t\t\t Detecting AI-generated code, deepfakes, and other synthetic content is an emerging research challenge. As code generated by Large Language Models (LLMs) becomes more common, identifying the specific model behind each sample is increasingly important. This paper presents the first systematic study of LLM authorship attribution for C programs. We released CodeT5-Authorship, a novel model that uses only the encoder layers from the original CodeT5 encoder-decoder architecture, discarding the decoder to focus on classification. Our model's encoder output (first token) is passed through a two-layer classification head with GELU activation and dropout, producing a probability distribution over possible authors. To evaluate our approach, we introduce LLM-AuthorBench, a benchmark of 32,000 compilable C programs generated by eight state-of-the-art LLMs across diverse tasks. We compare our model to seven traditional ML classifiers and eight fine-tuned transformer models, including BERT, RoBERTa, CodeBERT, ModernBERT, DistilBERT, DeBERTa-V3, Longformer, and LoRA-fine-tuned Qwen2-1.5B. In binary classification, our model achieves 97.56% accuracy in distinguishing C programs generated by closely related models such as GPT-4.1 and GPT-4o, and 95.40% accuracy for multi-class attribution among five leading LLMs (Gemini 2.5 Flash, Claude 3.5 Haiku, GPT-4.1, Llama 3.3, and DeepSeek-V3). To support open science, we release the CodeT5-Authorship architecture, the LLM-AuthorBench benchmark, and all relevant Google Colab scripts on GitHub: https://github.com/LLMauthorbench/.", 'score': 2, 'issue_id': 4455, 'pub_date': '2025-06-18', 'pub_date_card': {'ru': '18 июня', 'en': 'June 18', 'zh': '6月18日'}, 'hash': '51a95259fad4a8ed', 'authors': ['Tamas Bisztray', 'Bilel Cherif', 'Richard A. Dubniczky', 'Nils Gruschka', 'Bertalan Borsos', 'Mohamed Amine Ferrag', 'Attila Kovacs', 'Vasileios Mavroeidis', 'Norbert Tihanyi'], 'affiliations': ['Eötvös Lóránd University, Budapest, Hungary', 'Guelma University, Guelma, Algeria', 'Technology Innovation Institute, Abu Dhabi, United Arab Emirates', 'University of Oslo, Cyentific AS, Oslo, Norway', 'University of Oslo, Oslo, Norway'], 'pdf_title_img': 'assets/pdf/title_img/2506.17323.jpg', 'data': {'categories': ['#synthetic', '#architecture', '#benchmark', '#open_source', '#dataset'], 'emoji': '🤖', 'ru': {'title': 'CodeT5-Authorship: точное определение LLM-авторства кода', 'desc': 'Представлена новая модель CodeT5-Authorship для классификации авторства программ на C, созданных большими языковыми моделями (LLM). Модель использует только энкодер архитектуры CodeT5 и достигает высокой точности по сравнению с традиционными классификаторами и моделями на основе трансформеров. Для оценки подхода авторы создали бенчмарк LLM-AuthorBench из 32 000 компилируемых C-программ, сгенерированных восемью современными LLM. В бинарной классификации модель достигает точности 97.56% при различении программ от близких моделей, а в многоклассовой атрибуции среди пяти ведущих LLM - 95.40%.'}, 'en': {'title': 'Unmasking Code: Identifying LLM Authorship with Precision', 'desc': 'The paper introduces CodeT5-Authorship, a new model designed to classify the authorship of C programs generated by Large Language Models (LLMs). It focuses on using only the encoder part of the CodeT5 architecture to enhance classification accuracy. The model achieves impressive results, with 97.56% accuracy in binary classification and 95.40% in multi-class attribution among various LLMs. Additionally, the authors provide a benchmark dataset, LLM-AuthorBench, to facilitate further research in this area.'}, 'zh': {'title': '识别AI生成代码的作者身份新方法', 'desc': '本文介绍了一种新模型CodeT5-Authorship，用于分类由大型语言模型生成的C程序的作者身份。该模型仅使用原始CodeT5编码器-解码器架构的编码器层，专注于分类任务，取得了比传统和基于变换器的分类器更高的准确率。我们还推出了LLM-AuthorBench，这是一个包含32,000个可编译C程序的基准，涵盖了八种最先进的LLM。通过与多种传统机器学习分类器和微调的变换器模型进行比较，我们的模型在二分类和多分类任务中均表现出色。'}}}, {'id': 'https://huggingface.co/papers/2506.18839', 'title': '4Real-Video-V2: Fused View-Time Attention and Feedforward Reconstruction\n  for 4D Scene Generation', 'url': 'https://huggingface.co/papers/2506.18839', 'abstract': 'A new framework combines 4D video modeling and 3D reconstruction using a unified architecture with sparse attention patterns, achieving superior visual quality and reconstruction.  \t\t\t\t\tAI-generated summary \t\t\t\t We propose the first framework capable of computing a 4D spatio-temporal grid of video frames and 3D Gaussian particles for each time step using a feed-forward architecture. Our architecture has two main components, a 4D video model and a 4D reconstruction model. In the first part, we analyze current 4D video diffusion architectures that perform spatial and temporal attention either sequentially or in parallel within a two-stream design. We highlight the limitations of existing approaches and introduce a novel fused architecture that performs spatial and temporal attention within a single layer. The key to our method is a sparse attention pattern, where tokens attend to others in the same frame, at the same timestamp, or from the same viewpoint. In the second part, we extend existing 3D reconstruction algorithms by introducing a Gaussian head, a camera token replacement algorithm, and additional dynamic layers and training. Overall, we establish a new state of the art for 4D generation, improving both visual quality and reconstruction capability.', 'score': 1, 'issue_id': 4458, 'pub_date': '2025-06-18', 'pub_date_card': {'ru': '18 июня', 'en': 'June 18', 'zh': '6月18日'}, 'hash': 'adf5e4953f4c2a0e', 'authors': ['Chaoyang Wang', 'Ashkan Mirzaei', 'Vidit Goel', 'Willi Menapace', 'Aliaksandr Siarohin', 'Avalon Vinella', 'Michael Vasilkovsky', 'Ivan Skorokhodov', 'Vladislav Shakhrai', 'Sergey Korolev', 'Sergey Tulyakov', 'Peter Wonka'], 'affiliations': ['KAUST', 'Snap Inc.'], 'pdf_title_img': 'assets/pdf/title_img/2506.18839.jpg', 'data': {'categories': ['#3d', '#video', '#diffusion', '#architecture'], 'emoji': '🎥', 'ru': {'title': 'Единая архитектура для 4D видео и 3D реконструкции с разреженным вниманием', 'desc': 'Эта статья представляет новую архитектуру для 4D моделирования видео и 3D реконструкции. Авторы предлагают объединенную модель с разреженными паттернами внимания, которая выполняет пространственное и временное внимание в одном слое. Ключевые компоненты включают 4D модель видео и 4D модель реконструкции с дополнительными динамическими слоями. Результаты демонстрируют улучшенное качество визуализации и возможности реконструкции по сравнению с существующими методами.'}, 'en': {'title': 'Revolutionizing 4D Video and 3D Reconstruction with Sparse Attention', 'desc': 'This paper presents a novel framework that integrates 4D video modeling with 3D reconstruction using a unified architecture. It introduces a feed-forward model that computes a 4D spatio-temporal grid of video frames alongside 3D Gaussian particles for each time step. The framework employs a unique sparse attention pattern, allowing tokens to focus on relevant information within the same frame, timestamp, or viewpoint, enhancing both spatial and temporal attention. As a result, this approach sets a new benchmark in 4D generation, significantly improving visual quality and reconstruction accuracy.'}, 'zh': {'title': '融合4D视频与3D重建的新框架', 'desc': '本文提出了一种新的框架，结合了4D视频建模和3D重建，使用统一的架构和稀疏注意力模式，显著提高了视觉质量和重建效果。该框架能够计算每个时间步的4D时空网格视频帧和3D高斯粒子，采用前馈架构。我们分析了现有的4D视频扩散架构，指出了其在空间和时间注意力处理上的局限性，并引入了一种新型的融合架构，在单层中同时执行空间和时间注意力。通过引入高斯头和动态层等新技术，我们在4D生成领域建立了新的技术标准。'}}}, {'id': 'https://huggingface.co/papers/2506.10597', 'title': 'SoK: Evaluating Jailbreak Guardrails for Large Language Models', 'url': 'https://huggingface.co/papers/2506.10597', 'abstract': 'A systematic analysis and evaluation framework for jailbreak guardrails in Large Language Models is presented, categorizing and assessing their effectiveness and optimization potential.  \t\t\t\t\tAI-generated summary \t\t\t\t Large Language Models (LLMs) have achieved remarkable progress, but their deployment has exposed critical vulnerabilities, particularly to jailbreak attacks that circumvent safety mechanisms. Guardrails--external defense mechanisms that monitor and control LLM interaction--have emerged as a promising solution. However, the current landscape of LLM guardrails is fragmented, lacking a unified taxonomy and comprehensive evaluation framework. In this Systematization of Knowledge (SoK) paper, we present the first holistic analysis of jailbreak guardrails for LLMs. We propose a novel, multi-dimensional taxonomy that categorizes guardrails along six key dimensions, and introduce a Security-Efficiency-Utility evaluation framework to assess their practical effectiveness. Through extensive analysis and experiments, we identify the strengths and limitations of existing guardrail approaches, explore their universality across attack types, and provide insights into optimizing defense combinations. Our work offers a structured foundation for future research and development, aiming to guide the principled advancement and deployment of robust LLM guardrails. The code is available at https://github.com/xunguangwang/SoK4JailbreakGuardrails.', 'score': 1, 'issue_id': 4448, 'pub_date': '2025-06-12', 'pub_date_card': {'ru': '12 июня', 'en': 'June 12', 'zh': '6月12日'}, 'hash': '4122cc84dd4333e8', 'authors': ['Xunguang Wang', 'Zhenlan Ji', 'Wenxuan Wang', 'Zongjie Li', 'Daoyuan Wu', 'Shuai Wang'], 'affiliations': ['Renmin University of China', 'The Hong Kong University of Science and Technology'], 'pdf_title_img': 'assets/pdf/title_img/2506.10597.jpg', 'data': {'categories': ['#data', '#benchmark', '#security', '#optimization'], 'emoji': '🛡️', 'ru': {'title': 'Комплексный анализ защиты LLM от взлома: создание надежных барьеров', 'desc': 'В статье представлен систематический анализ и оценка защитных механизмов (гардрейлов) для больших языковых моделей (LLM) от атак типа jailbreak. Авторы предлагают многомерную таксономию, классифицирующую гардрейлы по шести ключевым параметрам. Вводится система оценки Security-Efficiency-Utility для определения практической эффективности защитных механизмов. Исследование выявляет сильные и слабые стороны существующих подходов к защите LLM, а также предлагает рекомендации по оптимизации комбинаций защитных мер.'}, 'en': {'title': 'Strengthening LLMs: A New Framework for Jailbreak Guardrails', 'desc': 'This paper presents a comprehensive framework for analyzing and evaluating guardrails designed to protect Large Language Models (LLMs) from jailbreak attacks. It introduces a multi-dimensional taxonomy that categorizes these guardrails based on six important aspects, helping to clarify their roles and effectiveness. Additionally, the authors propose a new evaluation framework that balances security, efficiency, and utility, allowing for a thorough assessment of guardrail performance. By identifying the strengths and weaknesses of current approaches, this work aims to enhance the development of more effective defenses for LLMs against potential vulnerabilities.'}, 'zh': {'title': '系统化评估大型语言模型的越狱防护机制', 'desc': '本文提出了一种系统化的分析和评估框架，用于大型语言模型（LLMs）中的越狱防护机制。研究表明，尽管LLMs取得了显著进展，但在实际应用中暴露了关键的安全漏洞，尤其是越狱攻击。我们提出了一种新的多维分类法，将防护机制分为六个关键维度，并引入了安全性、效率和实用性评估框架，以评估其实际效果。通过广泛的分析和实验，我们识别了现有防护方法的优缺点，并为未来的研究和开发提供了结构化的基础。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (2)', '#agents (1)', '#agi (1)', '#alignment (1)', '#architecture (3)', '#audio', '#benchmark (13)', '#cv (2)', '#data (8)', '#dataset (8)', '#diffusion (4)', '#ethics', '#games (2)', '#graphs', '#hallucinations (2)', '#healthcare (2)', '#inference (2)', '#interpretability (3)', '#leakage', '#long_context (3)', '#low_resource', '#machine_translation', '#math', '#multilingual', '#multimodal (5)', '#open_source (6)', '#optimization (10)', '#plp', '#rag', '#reasoning (5)', '#rl (4)', '#rlhf (3)', '#robotics', '#science (1)', '#security (1)', '#small_models (2)', '#story_generation', '#survey', '#synthetic (3)', '#training (14)', '#transfer_learning (2)', '#video (4)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-06-24 13:28',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-06-24 13:28')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-06-24 13:28')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    