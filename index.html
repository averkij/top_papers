
<!DOCTYPE html>
<html>
<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-C1CRWDNJ1J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-C1CRWDNJ1J');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>HF. 18 papers. June 27.</title>
<link rel="icon" href="favicon.svg" sizes="any" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&family=Tiny5&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: cornflowerblue;
            --primary-color-dark: #fffd87cf;
            --secondary-color: #fff;
            --background-color: #eee;
            --text-color: #333333;
            --header-color: cornflowerblue;
            --body-color: #eee;
            --menu-color: #002370;
        }
        .background-digit {
            position: absolute;
            font-family: 'Tiny5';
            bottom: -20px;
            right: -10px;
            font-size: 8em;
            font-weight: 400;
            color: #0989ea22;
            z-index: 2;
            line-height: 1;
        }
        .dark-theme .background-digit {
            color: #e9e78f3d;
        }
        body {
            font-family: 'Roboto Slab', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 1500px;
            margin: 0 auto;
            flex: 1 0 auto;
            width: 100%
        }
        .a-clean {
            color: var(--secondary-color);
            text-decoration: none;
        }
        .a-clean:hover {
            color: #fff;
        }
        header {
            padding: 3.6em 0 2.4em 0;
            text-align: center;
        }
        footer {
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            margin-top: 2em;
            flex-shrink: 0;
            padding: 20px;
        }
        h1 {
            font-size: 2.4em;
            margin: 0;
            font-weight: 700;
        }
        .article-title-cont {
            margin: -21px -21px 0px -21px;
            padding: 10px 20px;
            background: cornflowerblue;
            display: table;
            min-height: 5.9em;
        }
        .dark-theme .article-title-cont {
            background: #444444;
        }
        .article-title {
            color: white;           
        }
        .article-title h2 {
            margin: 0px;
            padding: 0px;
            font-weight: 400;
            text-align:center;
        }
        h2 {
            # color: var(--primary-color);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 0.5em;
        }
        header p {
            font-size: 1.2em;
            margin-top: 0.5em;
            font-weight: 300;
        }
        main {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5em;
            padding: 10px 20px 20px 20px;
        }
        body.dark-tmeme>header {
            background-color: background-color: #333333;
            color: white;
        }
        body.dark-theme>div>main>article>div.article-content>p.meta {
            color: #fff;
        }
        body.light-theme>div>main>article>div.article-content>p.meta {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>p.pub-date {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>p.pub-date {
            color: #555;
        }
        body.dark-theme>div>main>article>div.article-content>div.tags {
            color: #ccc;
        }
        body.light-theme>div>main>article>div.article-content>div.tags {
            color: #fff;
        }
        body.light-theme>header {
            background-color: var(--header-color);
            color: white;
        }
        article {
            display: flex;
            flex-direction: row;
            justify-content: center;
        }
        .article-content {
            border-radius: 5px;
            border: 1px solid #ddd;
            overflow: hidden;
            transition: background-color 0.2s ease;
            padding: 1.3em;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            cursor: pointer;
            max-width: 800px;
            position: relative;
        }
        body.dark-theme>div>main>article>div.article-content {
            background-color: #444;
            border: none;
        }
        body.light-theme>div>main>article>div.article-content {
            background-color: #fff;
        }
        body.dark-theme>div>main>article>div.article-content:hover {
            background-color: #414141;
        }
        body.light-theme>div>main>article>div.article-content:hover {
            background-color: #fafafa;
        }
        .meta {
            font-size: 0.9em;
            margin-bottom: 0em;
            font-weight: 500;
            margin: 20px 0 0px 0;
            padding-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }
        .pub-date {
            font-size: 0.8em;
            margin-bottom: 0.8em;
            font-weight: 400;
            text-align: right;
            font-family: Roboto;
        }
        .tags {
            font-size: 0.9em;
            margin-bottom: 0;
            position: absolute;
            bottom: 0px;
            font-weight: 300;
            font-family: 'Roboto Slab';
            background: #555;
            left: 0;
            width: 100%;
            padding: 10px 20px;
        }
        .abstract {
            position: relative;
            max-height: 170px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }
        .abstract.expanded {
            max-height: 1000px;
        }
        .abstract-toggle {
            position: absolute;
            bottom: 4px;
            right: 0;
            cursor: pointer;
            color: var(--primary-color);
            float: right;
            font-weight: 400;
        }
        .explanation {
            background-color: #e8f5e9;
            border-left: 4px solid var(--secondary-color);
            padding: 1em;
            margin-top: 1.5em;
        }
        .links {
            margin-top: 1.5em;
            margin-bottom: 20px;
        }
        .affiliations {
            margin-bottom: 50px;
            padding:10px;
            font-size: 0.9em;
            text-align: center
        }
        a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }
        .dark-theme a {
            color: var(--primary-color-dark);
        }
        a:hover {
            color: #e73838;
        }
        .light-theme {
            background-color: var(--body-color);
            color: #333333;
        }
        .dark-theme {
            background-color: #333333;
            color: #ffffff;
        }
        .theme-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 30px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 30px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 24px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--primary-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        .switch-label {
            margin-right: 10px;
        }

        .sub-header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 7px;
            padding: 0 20px;
        }
        .sub-header-container-2 {
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin: 0 auto;
            padding: 0 20px;
        }
        .update-info-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: left;
            flex: 1;
        }
        .sort-container {
            margin-top: 15px;
            margin-bottom: 0px;
            text-align: right;
            flex: 2;
        }
        
        .category-toggle-container {
            display: inline-block;
            margin-top: 15px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        .category-option-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            margin-left: auto;
        }
        .category-option-container.expanded {
            display: block;
        }

        .sort-dropdown {
            padding: 5px 10px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: white;
            color: var(--text-color);
            font-family: 'Roboto Slab', sans-serif;
        }
        .sort-label {
            margin-right: 10px;
            font-size: 1.0em !important;
        }        
        .dark-theme .sort-dropdown {
            background-color: #444;
            color: white;
            border-color: var(--text-color);
        }
        .title-sign {
            display: inline-block;
            transition: all 0.5s ease;            
        }
        .rotate {
            transform: rotate(45deg) translateY(-6px);
            transform-origin: center;
        }
        .title-text {
            display: inline;
            padding-left: 10px;
        }
        .summary_title {
            font-size: 1.2em;
            font-weight: bold;
            color: #222;
            margin-bottom: 5px;
        }
        .summary_text {

        }
        .summary_image {
            max-height: 500px;
            max-width: 100%;
            align: center;
            margin-top: 40px;        
            margin-bottom: 60px;        
        }
        .category-filters {
            margin-top: 20px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }
        .category-filters.expanded {
            display: block;
            margin-top: 10px;
        }
        .category-button {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .category-button.active {
            background-color: var(--primary-color);
            color: white;
        }
        .category-button.inactive:not(.active) {
            color: #ccc;
        }
        .dark-theme .category-button {
            background-color: #555;
            color: #fff;
        }
        .dark-theme .category-button.active {
            background-color: var(--primary-color);
        }
        .dark-theme .category-button.inactive:not(.active) {
            color: #888;
        }
        .clear-categories {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border-radius: 15px;
            background-color: #f0f0f0;
            color: #333;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .clear-categories:hover {
            background-color: #bbb;
        }
        .svg-container {
            display: inline-block;
            position: relative;
            overflow: hidden;
        }
        .svg-container span {
            position: relative;
            z-index: 1;
        }
        .svg-container svg {
            position: absolute;
            bottom: 0;
            left: 0;
            z-index: 0;
        }

        .nav-menu {
            background-color: var(--menu-color);
            padding: 2px 0 2px 0;
            display: inline-block;
            position: relative;
            overflow: hidden;
            width: 100%;
        }        
        .nav-container {
            max-width: 1500px;
            margin: 0 auto;
            display: flex;
            justify-content: left;
            gap: 3em;
        }
        .nav-container span a {
            color: white;
        }        
        .nav-item {
            color: white;
            padding: 3px 0px;
            cursor: pointer;
            font-weight: 400;
        }         
        .nav-prev {
            margin-left: 20px;
        }        
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }        
        .language-flags {
            display: flex;
            gap: 7px;
            padding: 5px 20px 0 0;
            margin-left: auto;
        }
        .flag-svg {
            width: 22px;
            height: 22px;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.3s ease;
            border-radius: 2px;
        }
        .flag-svg.active {
            opacity: 1;
        }
        .flag-svg:hover {
            opacity: 0.8;
        }
        
        .dark-theme .nav-menu {
            background-color: #333;
        }
        .dark-theme .nav-item {
            color: white;
        }
        
        .dark-theme .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .pointer { cursor: pointer; }

        .article-pdf-title-img {
            max-width: 100%;
            max-height: 400px;
            display: inline-block;
            margin-top: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .article-pdf-title-img-cont {
            text-align: center;
        }
        .dark-theme .article-pdf-title-img {
            opacity: 0.8;
            filter: grayscale(1);
        }

        @media (max-width: 600px) {
            .nav-container {
                flex-direction: row;
                gap: 1.5em;
            }            
            .nav-item {
                padding: 3px 0px;
            }
        }
        
        @media (max-width: 768px) {
            .category-filters {
                display: none;
            }
            .category-toggle {
                display: inline-block;
                width: 100%;
                text-align: left;
            }
            .category-filters.expanded {
                display: block;
                margin-top: 10px;
            }
        }
        @media (max-width: 600px) {
            .sub-header-container {
                flex-direction: column;
                align-items: flex-start;
            }
            .sort-container {
                width: 100%;
                display: flex;
                justify-content: left;
                margin: 0 auto;
            }
            .sort-dropdown {
                margin-left: auto;
            }
            .sort-label {
                margin-top: 5px;
                float: left;
            }

            .sub-header-container-2 {
                flex-direction: row;
                align-items: flex-start;
            }
            .update-info-container {
                text-align: left;
                width: 100%;
                margin-bottom: 0px;
            }
            .category-toggle-container {
                margin-top: 15px;
                text-align: left;
                margin-bottom: 10px;
            }
            .category-option-container {
                margin-top: 15px;
                text-align: center;
                margin-bottom: 10px;
            }            
            main {
                grid-template-columns: repeat(auto-fit);
                gap: 0em;
                padding: 10px 0 20px 0;
            }
            footer {
                margin-top: -20px;
            }
            article>div.article-content {
                border-radius: 0px;
            }
        }
    </style>
    <script>
    function toggleAbstract(id) {
        var abstract = document.getElementById('abstract-' + id);
        var toggle = document.getElementById('toggle-' + id);
        if (abstract.classList.contains('expanded')) {
            abstract.classList.remove('expanded');
            toggle.textContent = '...';
        } else {
            abstract.classList.add('expanded');
            toggle.textContent = '';
        }
    }
    function getTimeDiff(dateString, lang='ru') {
        const timeUnits = {
            ru: {
                minute: ["минуту", "минуты", "минут"],
                hour: ["час", "часа", "часов"],
                day: ["день", "дня", "дней"],
                justNow: "только что",
                ago: "назад"
            },
            en: {
                minute: ["minute", "minutes", "minutes"],
                hour: ["hour", "hours", "hours"],
                day: ["day", "days", "days"],
                justNow: "just now",
                ago: "ago"
            },
            zh: {
                minute: ["分钟", "分钟", "分钟"],
                hour: ["小时", "小时", "小时"],
                day: ["天", "天", "天"],
                justNow: "刚刚",
                ago: "前"
            }
        };

        function getPlural(number, words, lang) {
            if (lang === 'ru') {
                if (number % 10 === 1 && number % 100 !== 11) {
                    return words[0];
                } else if (number % 10 >= 2 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
                    return words[1];
                } else {
                    return words[2];
                }
            } else if (lang === 'en') {
                return number === 1 ? words[0] : words[1];
            } else {
                // Chinese doesn't need plural forms
                return words[0];
            }
        }

        function formatTimeDiff(number, unit, lang) {
            const unitWord = getPlural(number, timeUnits[lang][unit], lang);
            
            if (lang === 'zh') {
                return `${number}${unitWord}${timeUnits[lang].ago}`;
            } else {
                return `${number} ${unitWord} ${timeUnits[lang].ago}`;
            }
        }

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        const pastDate = new Date(dateString.replace(" ", "T") + ":00Z");
        const currentDate = new Date();
        const diffInSeconds = Math.floor((currentDate - pastDate) / 1000);
        
        const minutes = Math.floor(diffInSeconds / 60);
        const hours = Math.floor(diffInSeconds / 3600);
        const days = Math.floor(diffInSeconds / 86400);

        if (minutes === 0) {
            return timeUnits[lang].justNow;
        } else if (minutes < 60) {
            return formatTimeDiff(minutes, 'minute', lang);
        } else if (hours < 24) {
            return formatTimeDiff(hours, 'hour', lang);
        } else {
            return formatTimeDiff(days, 'day', lang);
        }
    }
    function isToday(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth() &&
            inputDate.getDate() === today.getDate()
        );
    }
    function isCurrentMonth(dateString) {
        const inputDate = new Date(dateString);
        const today = new Date();
        return (
            inputDate.getFullYear() === today.getFullYear() &&
            inputDate.getMonth() === today.getMonth()
        );
    }
    function formatArticlesTitle(number, lang='ru') {
        const lastDigit = number % 10;
        const lastTwoDigits = number % 100;
        let word;

        if (!['ru', 'en', 'zh'].includes(lang)) {
            throw new Error('Unsupported language. Supported languages are: ru, en, zh');
        }

        if (lang === 'ru') {
            if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
                word = "статей";
            } else if (lastDigit === 1) {
                word = "статья";
            } else if (lastDigit >= 2 && lastDigit <= 4) {
                word = "статьи";
            } else {
                word = "статей";
            }
        } else if (lang === 'en') {
            if (number === 1) {
                word = 'paper'
            } else {
                word = 'papers'
            }
        } else if (lang === 'zh') {
            word = "篇论文"
        }

        if (lang === 'zh') {
            return `${number}${word}`;
        } else {
            return `${number} ${word}`;
        }
    }
    </script>
</head>
<body class="light-theme">
    <header>
        <div class="container">            
            <a href="https://hfday.ru" class="a-clean"><h1 class="title-sign" id="doomgrad-icon">🔺</h1><h1 class="title-text" id="doomgrad">hf daily</h1></a>
            <p><span id="title-date">27 июня</span> | <span id="title-articles-count">18 papers</span></p>
        </div>
        <div class="theme-switch">
            <label class="switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </header>
    <div class="nav-menu">
        <div class="nav-container">
            <span class="nav-item nav-prev" id="nav-prev"><a href="/d/2025-06-26.html">⬅️ <span id="prev-date">26.06</span></a></span>
            <span class="nav-item" id="nav-next"><a href="/d/2025-06-30.html">➡️ <span id="next-date">30.06</span></a></span>
            <span class="nav-item" id="nav-monthly"><a href="/m/2025-06.html">📈 <span id='top-month-label'>Месяц</span></a></span>
            <div class="language-flags">
                <svg class="flag-svg" data-lang="ru" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="#1435a1" d="M1 11H31V21H1z"></path><path d="M5,4H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" fill="#fff"></path><path d="M5,20H27c2.208,0,4,1.792,4,4v4H1v-4c0-2.208,1.792-4,4-4Z" transform="rotate(180 16 24)" fill="#c53a28"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="zh" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#db362f"></rect><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path fill="#ff0" d="M7.958 10.152L7.19 7.786 6.421 10.152 3.934 10.152 5.946 11.614 5.177 13.979 7.19 12.517 9.202 13.979 8.433 11.614 10.446 10.152 7.958 10.152z"></path><path fill="#ff0" d="M12.725 8.187L13.152 8.898 13.224 8.072 14.032 7.886 13.269 7.562 13.342 6.736 12.798 7.361 12.035 7.037 12.461 7.748 11.917 8.373 12.725 8.187z"></path><path fill="#ff0" d="M14.865 10.372L14.982 11.193 15.37 10.46 16.187 10.602 15.61 10.007 15.997 9.274 15.253 9.639 14.675 9.044 14.793 9.865 14.048 10.23 14.865 10.372z"></path><path fill="#ff0" d="M15.597 13.612L16.25 13.101 15.421 13.13 15.137 12.352 14.909 13.149 14.081 13.179 14.769 13.642 14.541 14.439 15.194 13.928 15.881 14.391 15.597 13.612z"></path><path fill="#ff0" d="M13.26 15.535L13.298 14.707 12.78 15.354 12.005 15.062 12.46 15.754 11.942 16.402 12.742 16.182 13.198 16.875 13.236 16.047 14.036 15.827 13.26 15.535z"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path></svg>
                <svg class="flag-svg" data-lang="en" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="1" y="4" width="30" height="24" rx="4" ry="4" fill="#fff"></rect><path d="M1.638,5.846H30.362c-.711-1.108-1.947-1.846-3.362-1.846H5c-1.414,0-2.65,.738-3.362,1.846Z" fill="#a62842"></path><path d="M2.03,7.692c-.008,.103-.03,.202-.03,.308v1.539H31v-1.539c0-.105-.022-.204-.03-.308H2.03Z" fill="#a62842"></path><path fill="#a62842" d="M2 11.385H31V13.231H2z"></path><path fill="#a62842" d="M2 15.077H31V16.923000000000002H2z"></path><path fill="#a62842" d="M1 18.769H31V20.615H1z"></path><path d="M1,24c0,.105,.023,.204,.031,.308H30.969c.008-.103,.031-.202,.031-.308v-1.539H1v1.539Z" fill="#a62842"></path><path d="M30.362,26.154H1.638c.711,1.108,1.947,1.846,3.362,1.846H27c1.414,0,2.65-.738,3.362-1.846Z" fill="#a62842"></path><path d="M5,4h11v12.923H1V8c0-2.208,1.792-4,4-4Z" fill="#102d5e"></path><path d="M27,4H5c-2.209,0-4,1.791-4,4V24c0,2.209,1.791,4,4,4H27c2.209,0,4-1.791,4-4V8c0-2.209-1.791-4-4-4Zm3,20c0,1.654-1.346,3-3,3H5c-1.654,0-3-1.346-3-3V8c0-1.654,1.346-3,3-3H27c1.654,0,3,1.346,3,3V24Z" opacity=".15"></path><path d="M27,5H5c-1.657,0-3,1.343-3,3v1c0-1.657,1.343-3,3-3H27c1.657,0,3,1.343,3,3v-1c0-1.657-1.343-3-3-3Z" fill="#fff" opacity=".2"></path><path fill="#fff" d="M4.601 7.463L5.193 7.033 4.462 7.033 4.236 6.338 4.01 7.033 3.279 7.033 3.87 7.463 3.644 8.158 4.236 7.729 4.827 8.158 4.601 7.463z"></path><path fill="#fff" d="M7.58 7.463L8.172 7.033 7.441 7.033 7.215 6.338 6.989 7.033 6.258 7.033 6.849 7.463 6.623 8.158 7.215 7.729 7.806 8.158 7.58 7.463z"></path><path fill="#fff" d="M10.56 7.463L11.151 7.033 10.42 7.033 10.194 6.338 9.968 7.033 9.237 7.033 9.828 7.463 9.603 8.158 10.194 7.729 10.785 8.158 10.56 7.463z"></path><path fill="#fff" d="M6.066 9.283L6.658 8.854 5.927 8.854 5.701 8.158 5.475 8.854 4.744 8.854 5.335 9.283 5.109 9.979 5.701 9.549 6.292 9.979 6.066 9.283z"></path><path fill="#fff" d="M9.046 9.283L9.637 8.854 8.906 8.854 8.68 8.158 8.454 8.854 7.723 8.854 8.314 9.283 8.089 9.979 8.68 9.549 9.271 9.979 9.046 9.283z"></path><path fill="#fff" d="M12.025 9.283L12.616 8.854 11.885 8.854 11.659 8.158 11.433 8.854 10.702 8.854 11.294 9.283 11.068 9.979 11.659 9.549 12.251 9.979 12.025 9.283z"></path><path fill="#fff" d="M6.066 12.924L6.658 12.494 5.927 12.494 5.701 11.799 5.475 12.494 4.744 12.494 5.335 12.924 5.109 13.619 5.701 13.19 6.292 13.619 6.066 12.924z"></path><path fill="#fff" d="M9.046 12.924L9.637 12.494 8.906 12.494 8.68 11.799 8.454 12.494 7.723 12.494 8.314 12.924 8.089 13.619 8.68 13.19 9.271 13.619 9.046 12.924z"></path><path fill="#fff" d="M12.025 12.924L12.616 12.494 11.885 12.494 11.659 11.799 11.433 12.494 10.702 12.494 11.294 12.924 11.068 13.619 11.659 13.19 12.251 13.619 12.025 12.924z"></path><path fill="#fff" d="M13.539 7.463L14.13 7.033 13.399 7.033 13.173 6.338 12.947 7.033 12.216 7.033 12.808 7.463 12.582 8.158 13.173 7.729 13.765 8.158 13.539 7.463z"></path><path fill="#fff" d="M4.601 11.104L5.193 10.674 4.462 10.674 4.236 9.979 4.01 10.674 3.279 10.674 3.87 11.104 3.644 11.799 4.236 11.369 4.827 11.799 4.601 11.104z"></path><path fill="#fff" d="M7.58 11.104L8.172 10.674 7.441 10.674 7.215 9.979 6.989 10.674 6.258 10.674 6.849 11.104 6.623 11.799 7.215 11.369 7.806 11.799 7.58 11.104z"></path><path fill="#fff" d="M10.56 11.104L11.151 10.674 10.42 10.674 10.194 9.979 9.968 10.674 9.237 10.674 9.828 11.104 9.603 11.799 10.194 11.369 10.785 11.799 10.56 11.104z"></path><path fill="#fff" d="M13.539 11.104L14.13 10.674 13.399 10.674 13.173 9.979 12.947 10.674 12.216 10.674 12.808 11.104 12.582 11.799 13.173 11.369 13.765 11.799 13.539 11.104z"></path><path fill="#fff" d="M4.601 14.744L5.193 14.315 4.462 14.315 4.236 13.619 4.01 14.315 3.279 14.315 3.87 14.744 3.644 15.44 4.236 15.01 4.827 15.44 4.601 14.744z"></path><path fill="#fff" d="M7.58 14.744L8.172 14.315 7.441 14.315 7.215 13.619 6.989 14.315 6.258 14.315 6.849 14.744 6.623 15.44 7.215 15.01 7.806 15.44 7.58 14.744z"></path><path fill="#fff" d="M10.56 14.744L11.151 14.315 10.42 14.315 10.194 13.619 9.968 14.315 9.237 14.315 9.828 14.744 9.603 15.44 10.194 15.01 10.785 15.44 10.56 14.744z"></path><path fill="#fff" d="M13.539 14.744L14.13 14.315 13.399 14.315 13.173 13.619 12.947 14.315 12.216 14.315 12.808 14.744 12.582 15.44 13.173 15.01 13.765 15.44 13.539 14.744z"></path></svg>
            </div>
        </div>
    </div>
    <div class="container">
        <div class="sub-header-container">
            <div class="update-info-container">
                <label class="update-info-label" id="timeDiff"></label>
            </div>
            <div class="sort-container">
                <label class="sort-label">🔀 <span id="sort-label-text">Сортировка по</span></label>
                <select id="sort-dropdown" class="sort-dropdown">
                    <option value="default">рейтингу</option>
                    <option value="pub_date">дате публикации</option>
                    <option value="issue_id">добавлению на HF</option>
                </select>
            </div>
        </div>
        <div class="sub-header-container-2">
            <div class="category-toggle-container">
                <div class="svg-container">
                    <span id="category-toggle">🏷️ Фильтр</span>
                    <svg height="3" width="200">
                        <line x1="0" y1="0" x2="200" y2="0" 
                            stroke="black" 
                            stroke-width="2" 
                            stroke-dasharray="3, 3" />
                    </svg>
                </div>
            </div>
            <div class="category-option-container" id="category-options">                
                <label class="pointer" for="filter-logic-or"><input type="radio" id="filter-logic-or" name="filter-logic" value="or"> A∪B</label>
                <label class="pointer" for="filter-logic-and"><input type="radio" id="filter-logic-and" name="filter-logic" value="and"> A∩B</label>
            </div> 
        </div>
        <div class="category-filters" id="category-filters">
            <span class="clear-categories" id="clear-categories">🧹</span>
            <!-- Categories -->
        </div>
        <main id="articles-container">
            <!-- Articles -->
        </main>
    </div>
    <footer>
        <div class="container">
            <p><a style="color:white;" href="https://t.me/doomgrad">doomgrad</a> ✖️ <a style="color:white;" href="https://huggingface.co/papers">hugging face</a></p>
        </div>
    </footer>
    <script>
        // Language handling
        let currentLang = localStorage.getItem('selectedLang') || 'en';
        let feedDate = {'ru': '27 июня', 'en': 'June 27', 'zh': '6月27日'};
        let feedDateNext = {'ru': '30.06', 'en': '06/30', 'zh': '6月30日'};
        let feedDatePrev = {'ru': '26.06', 'en': '06/26', 'zh': '6月26日'};
        let filterLabel = {'ru': 'Фильтр', 'en': 'Topics', 'zh': '主题筛选'}
        let publishedLabel = {'ru': 'статья от ', 'en': 'published on ', 'zh': '发表于'}
        let sortLabel = {'ru': 'Сортировка по', 'en': 'Sort by', 'zh': '排序方式'}
        let paperLabel = {'ru': 'Статья', 'en': 'Paper', 'zh': '论文'}
        let topMonthLabel = {'ru': 'Месяц', 'en': 'Month', 'zh': '月度论文'}
        let topDayLabel = {'ru': 'День', 'en': 'Day', 'zh': '日度论文'}
        
        function initializeLanguageFlags() {
            const flags = document.querySelectorAll('.flag-svg');
            flags.forEach(flag => {
                if (flag.dataset.lang === currentLang) {
                    flag.classList.add('active');
                }
                flag.addEventListener('click', () => {
                    flags.forEach(f => f.classList.remove('active'));
                    flag.classList.add('active');
                    currentLang = flag.dataset.lang;
                    localStorage.setItem('selectedLang', currentLang);
                    updateTimeDiffs();
                    updateLocalization();
                    filterAndRenderArticles();
                });
            });
        }
        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');
            body.classList.toggle('dark-theme');

            const isDarkMode = body.classList.contains('dark-theme');
            localStorage.setItem('darkMode', isDarkMode);
            
            if (isDarkMode) {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }  else {
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf daily";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.remove('rotate');
            }
        }

        const articlesData = [{'id': 'https://huggingface.co/papers/2506.20670', 'title': 'MMSearch-R1: Incentivizing LMMs to Search', 'url': 'https://huggingface.co/papers/2506.20670', 'abstract': 'MMSearch-R1, a reinforcement learning framework, enables large multimodal models to perform efficient, on-demand, multi-turn search in real-world environments, outperforming existing approaches.  \t\t\t\t\tAI-generated summary \t\t\t\t Robust deployment of large multimodal models (LMMs) in real-world scenarios requires access to external knowledge sources, given the complexity and dynamic nature of real-world information. Existing approaches such as retrieval-augmented generation (RAG) and prompt engineered search agents rely on rigid pipelines, often leading to inefficient or excessive search behaviors. We present MMSearch-R1, the first end-to-end reinforcement learning framework that enables LMMs to perform on-demand, multi-turn search in real-world Internet environments. Our framework integrates both image and text search tools, allowing the model to reason about when and how to invoke them guided by an outcome-based reward with a search penalty. To support training, We collect a multimodal search VQA dataset through a semi-automated pipeline that covers diverse visual and textual knowledge needs and curate a search-balanced subset with both search-required and search-free samples, which proves essential for shaping efficient and on-demand search behavior. Extensive experiments on knowledge-intensive and info-seeking VQA tasks show that our model not only outperforms RAG-based baselines of the same model size, but also matches the performance of a larger RAG-based model while reducing search calls by over 30%. We further analyze key empirical findings to offer actionable insights for advancing research in multimodal search.', 'score': 37, 'issue_id': 4516, 'pub_date': '2025-06-25', 'pub_date_card': {'ru': '25 июня', 'en': 'June 25', 'zh': '6月25日'}, 'hash': '15412dc74ea5bed3', 'authors': ['Jinming Wu', 'Zihao Deng', 'Wei Li', 'Yiding Liu', 'Bo You', 'Bo Li', 'Zejun Ma', 'Ziwei Liu'], 'affiliations': ['ByteDance', 'S-Lab, NTU'], 'pdf_title_img': 'assets/pdf/title_img/2506.20670.jpg', 'data': {'categories': ['#optimization', '#dataset', '#reasoning', '#games', '#rl', '#rag', '#multimodal'], 'emoji': '🔍', 'ru': {'title': 'Эффективный мультимодальный поиск с помощью обучения с подкреплением', 'desc': 'MMSearch-R1 - это фреймворк обучения с подкреплением, который позволяет большим мультимодальным моделям выполнять эффективный многоэтапный поиск в реальных средах по запросу. Он интегрирует инструменты поиска изображений и текста, позволяя модели рассуждать о том, когда и как их использовать, руководствуясь наградой, основанной на результатах, с учетом штрафа за поиск. Для обучения авторы собрали мультимодальный набор данных VQA для поиска, охватывающий разнообразные потребности в визуальных и текстовых знаниях. Эксперименты показывают, что модель превосходит базовые модели на основе RAG того же размера и соответствует производительности более крупной модели на основе RAG, уменьшая количество поисковых запросов более чем на 30%.'}, 'en': {'title': 'Efficient Multimodal Search with Reinforcement Learning', 'desc': 'MMSearch-R1 is a novel reinforcement learning framework designed to enhance the performance of large multimodal models (LMMs) in real-world search tasks. It addresses the limitations of traditional methods like retrieval-augmented generation (RAG) by allowing LMMs to conduct efficient, on-demand, multi-turn searches using both text and image data. The framework employs an outcome-based reward system that encourages optimal search strategies while minimizing unnecessary search actions. Through extensive testing, MMSearch-R1 demonstrates superior efficiency and effectiveness compared to existing models, significantly reducing the number of search calls needed to achieve high performance.'}, 'zh': {'title': '高效多模态搜索的强化学习新框架', 'desc': 'MMSearch-R1是一个强化学习框架，旨在提高大型多模态模型在现实环境中的搜索效率。与现有的检索增强生成（RAG）方法不同，MMSearch-R1采用端到端的方式，支持按需的多轮搜索。该框架结合了图像和文本搜索工具，通过基于结果的奖励和搜索惩罚来指导模型的搜索决策。实验结果表明，MMSearch-R1在知识密集型任务中表现优于同等规模的RAG基线，并且在减少搜索调用的同时，性能与更大规模的RAG模型相当。'}}}, {'id': 'https://huggingface.co/papers/2506.21520', 'title': 'MADrive: Memory-Augmented Driving Scene Modeling', 'url': 'https://huggingface.co/papers/2506.21520', 'abstract': 'MADrive enhances scene reconstruction for autonomous driving by integrating visually similar 3D car assets from an external memory bank to achieve photorealistic synthesis of altered scenarios.  \t\t\t\t\tAI-generated summary \t\t\t\t Recent advances in scene reconstruction have pushed toward highly realistic modeling of autonomous driving (AD) environments using 3D Gaussian splatting. However, the resulting reconstructions remain closely tied to the original observations and struggle to support photorealistic synthesis of significantly altered or novel driving scenarios. This work introduces MADrive, a memory-augmented reconstruction framework designed to extend the capabilities of existing scene reconstruction methods by replacing observed vehicles with visually similar 3D assets retrieved from a large-scale external memory bank. Specifically, we release MAD-Cars, a curated dataset of {sim}70K 360{\\deg} car videos captured in the wild and present a retrieval module that finds the most similar car instances in the memory bank, reconstructs the corresponding 3D assets from video, and integrates them into the target scene through orientation alignment and relighting. The resulting replacements provide complete multi-view representations of vehicles in the scene, enabling photorealistic synthesis of substantially altered configurations, as demonstrated in our experiments. Project page: https://yandex-research.github.io/madrive/', 'score': 28, 'issue_id': 4524, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '850d8a345d876231', 'authors': ['Polina Karpikova', 'Daniil Selikhanovych', 'Kirill Struminsky', 'Ruslan Musaev', 'Maria Golitsyna', 'Dmitry Baranchuk'], 'affiliations': ['HSE University', 'Skoltech', 'Yandex', 'Yandex Research'], 'pdf_title_img': 'assets/pdf/title_img/2506.21520.jpg', 'data': {'categories': ['#3d', '#multimodal', '#games', '#synthetic', '#dataset'], 'emoji': '🚗', 'ru': {'title': 'Фотореалистичное изменение сцен автономного вождения с помощью внешней памяти', 'desc': 'MADrive - это новая система для улучшения реконструкции сцен в автономном вождении. Она интегрирует визуально похожие 3D-модели автомобилей из внешней базы данных для создания фотореалистичных измененных сценариев. Система использует набор данных MAD-Cars, содержащий около 70 тысяч 360-градусных видео автомобилей, снятых в реальных условиях. MADrive позволяет заменять наблюдаемые автомобили на похожие 3D-модели, реконструированные из видео, и интегрировать их в целевую сцену с учетом ориентации и освещения.'}, 'en': {'title': 'Enhancing Autonomous Driving with Memory-Augmented Scene Reconstruction', 'desc': 'MADrive is a framework that improves scene reconstruction for autonomous driving by using a memory bank of 3D car models. It allows for the replacement of real vehicles in a scene with visually similar 3D assets, enhancing the realism of altered driving scenarios. The framework utilizes a curated dataset called MAD-Cars, which contains around 70,000 car videos, to retrieve and reconstruct these 3D assets. This approach enables the generation of photorealistic images of driving environments, even when significant changes are made to the scene.'}, 'zh': {'title': 'MADrive：提升自动驾驶场景重建的真实感', 'desc': 'MADrive 是一个增强场景重建的框架，专为自动驾驶设计。它通过从外部记忆库中整合视觉相似的 3D 车辆资产，来实现对改变场景的真实感合成。该框架使用了一个名为 MAD-Cars 的数据集，包含约 70,000 个 360 度的汽车视频，并通过检索模块找到最相似的车辆实例。最终，MADrive 能够生成多视角的车辆表现，支持显著改变的场景合成。'}}}, {'id': 'https://huggingface.co/papers/2506.20911', 'title': 'FaSTA^*: Fast-Slow Toolpath Agent with Subroutine Mining for Efficient\n  Multi-turn Image Editing', 'url': 'https://huggingface.co/papers/2506.20911', 'abstract': 'A neurosymbolic agent combines language models for fast subtask planning with A$^*$ search for detailed toolpaths, creating a cost-efficient multi-turn image editing solution.  \t\t\t\t\tAI-generated summary \t\t\t\t We develop a cost-efficient neurosymbolic agent to address challenging multi-turn image editing tasks such as "Detect the bench in the image while recoloring it to pink. Also, remove the cat for a clearer view and recolor the wall to yellow.\'\' It combines the fast, high-level subtask planning by large language models (LLMs) with the slow, accurate, tool-use, and local A^* search per subtask to find a cost-efficient toolpath -- a sequence of calls to AI tools. To save the cost of A^* on similar subtasks, we perform inductive reasoning on previously successful toolpaths via LLMs to continuously extract/refine frequently used subroutines and reuse them as new tools for future tasks in an adaptive fast-slow planning, where the higher-level subroutines are explored first, and only when they fail, the low-level A^* search is activated. The reusable symbolic subroutines considerably save exploration cost on the same types of subtasks applied to similar images, yielding a human-like fast-slow toolpath agent "FaSTA^*\'\': fast subtask planning followed by rule-based subroutine selection per subtask is attempted by LLMs at first, which is expected to cover most tasks, while slow A^* search is only triggered for novel and challenging subtasks. By comparing with recent image editing approaches, we demonstrate FaSTA^* is significantly more computationally efficient while remaining competitive with the state-of-the-art baseline in terms of success rate.', 'score': 27, 'issue_id': 4519, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': 'f2b4bebdfb3a457f', 'authors': ['Advait Gupta', 'Rishie Raj', 'Dang Nguyen', 'Tianyi Zhou'], 'affiliations': ['University of Maryland, College Park'], 'pdf_title_img': 'assets/pdf/title_img/2506.20911.jpg', 'data': {'categories': ['#cv', '#agents', '#optimization', '#reasoning'], 'emoji': '🎨', 'ru': {'title': 'Эффективное редактирование изображений с помощью нейросимволического ИИ', 'desc': 'Статья представляет нейросимволический агент для эффективного многоэтапного редактирования изображений. Он сочетает быстрое планирование подзадач с помощью больших языковых моделей (LLM) и точный поиск A* для детальных инструментальных путей. Агент FaSTA* использует индуктивное рассуждение для извлечения часто используемых подпрограмм, которые затем применяются как новые инструменты. Это значительно сокращает вычислительные затраты при сохранении высокой успешности выполнения задач.'}, 'en': {'title': 'FaSTA*: Fast and Efficient Multi-Turn Image Editing', 'desc': 'This paper presents a neurosymbolic agent designed for efficient multi-turn image editing tasks. It utilizes large language models (LLMs) for quick planning of high-level subtasks and employs A* search for precise toolpath execution. The agent learns from previous successful toolpaths, allowing it to reuse effective strategies for similar tasks, which reduces computational costs. The proposed method, named FaSTA*, balances fast planning with detailed execution, achieving competitive performance while being more efficient than existing approaches.'}, 'zh': {'title': '高效的多轮图像编辑代理', 'desc': '本文提出了一种高效的神经符号代理，用于解决复杂的多轮图像编辑任务。该代理结合了大型语言模型（LLMs）进行快速的高层次子任务规划，以及A^*搜索算法进行精确的工具路径规划。通过对成功的工具路径进行归纳推理，代理能够提取和重用常用的子程序，从而在相似任务中节省计算成本。实验结果表明，FaSTA^*在计算效率上显著优于现有的图像编辑方法，同时在成功率上与最先进的基线保持竞争力。'}}}, {'id': 'https://huggingface.co/papers/2506.21506', 'title': 'Mind2Web 2: Evaluating Agentic Search with Agent-as-a-Judge', 'url': 'https://huggingface.co/papers/2506.21506', 'abstract': 'Mind2Web 2 benchmark evaluates agentic search systems with a suite of realistic, long-horizon tasks, introducing an Agent-as-a-Judge framework to assess accuracy and source attribution.  \t\t\t\t\tAI-generated summary \t\t\t\t Agentic search such as Deep Research systems, where large language models autonomously browse the web, synthesize information, and return comprehensive citation-backed answers, represents a major shift in how users interact with web-scale information. While promising greater efficiency and cognitive offloading, the growing complexity and open-endedness of agentic search have outpaced existing evaluation benchmarks and methodologies, which largely assume short search horizons and static answers. In this paper, we introduce Mind2Web 2, a benchmark of 130 realistic, high-quality, and long-horizon tasks that require real-time web browsing and extensive information synthesis, constructed with over 1,000 hours of human labor. To address the challenge of evaluating time-varying and complex answers, we propose a novel Agent-as-a-Judge framework. Our method constructs task-specific judge agents based on a tree-structured rubric design to automatically assess both answer correctness and source attribution. We conduct a comprehensive evaluation of nine frontier agentic search systems and human performance, along with a detailed error analysis to draw insights for future development. The best-performing system, OpenAI Deep Research, can already achieve 50-70% of human performance while spending half the time, showing a great potential. Altogether, Mind2Web 2 provides a rigorous foundation for developing and benchmarking the next generation of agentic search systems.', 'score': 26, 'issue_id': 4516, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '00a88b4b0bc63d5b', 'authors': ['Boyu Gou', 'Zanming Huang', 'Yuting Ning', 'Yu Gu', 'Michael Lin', 'Weijian Qi', 'Andrei Kopanev', 'Botao Yu', 'Bernal Jiménez Gutiérrez', 'Yiheng Shu', 'Chan Hee Song', 'Jiaman Wu', 'Shijie Chen', 'Hanane Nour Moussa', 'Tianshu Zhang', 'Jian Xie', 'Yifei Li', 'Tianci Xue', 'Zeyi Liao', 'Kai Zhang', 'Boyuan Zheng', 'Zhaowei Cai', 'Viktor Rozgic', 'Morteza Ziyadi', 'Huan Sun', 'Yu Su'], 'affiliations': ['Amazon AGI', 'The Ohio State University'], 'pdf_title_img': 'assets/pdf/title_img/2506.21506.jpg', 'data': {'categories': ['#interpretability', '#optimization', '#agents', '#agi', '#benchmark'], 'emoji': '🕵️', 'ru': {'title': 'Mind2Web 2: Новый стандарт оценки агентного поиска', 'desc': 'Mind2Web 2 - это новый бенчмарк для оценки систем агентного поиска, включающий 130 реалистичных задач с длительным горизонтом планирования. Он вводит фреймворк Agent-as-a-Judge для автоматической оценки точности ответов и атрибуции источников. Бенчмарк был создан с использованием более 1000 часов человеческого труда и оценивает 9 современных систем агентного поиска. Результаты показывают, что лучшая система (OpenAI Deep Research) достигает 50-70% человеческой производительности за половину времени.'}, 'en': {'title': 'Mind2Web 2: Advancing Evaluation for Agentic Search Systems', 'desc': 'The paper presents Mind2Web 2, a benchmark designed to evaluate agentic search systems through a set of 130 realistic, long-horizon tasks that require extensive web browsing and information synthesis. It introduces the Agent-as-a-Judge framework, which uses task-specific judge agents to automatically assess the accuracy and source attribution of answers generated by these systems. This benchmark addresses the limitations of existing evaluation methods that focus on short search tasks and static responses. The findings indicate that the best-performing system, OpenAI Deep Research, achieves significant performance levels compared to human users, highlighting the potential of agentic search technologies.'}, 'zh': {'title': 'Mind2Web 2：评估自主搜索系统的新基准', 'desc': '本文介绍了Mind2Web 2基准测试，旨在评估自主搜索系统在现实长时间任务中的表现。我们提出了一种新的Agent-as-a-Judge框架，用于自动评估答案的准确性和来源归属。该基准包含130个高质量的任务，要求实时浏览网页并综合信息，构建过程中耗费了超过1000小时的人力。通过对九个前沿自主搜索系统和人类表现的全面评估，展示了这些系统在效率和准确性上的潜力。'}}}, {'id': 'https://huggingface.co/papers/2506.21539', 'title': 'WorldVLA: Towards Autoregressive Action World Model', 'url': 'https://huggingface.co/papers/2506.21539', 'abstract': "WorldVLA, an autoregressive action world model integrating vision-language-action (VLA) and world models, enhances performance through mutual understanding and generation, improving action prediction and sequence generation with an attention mask strategy.  \t\t\t\t\tAI-generated summary \t\t\t\t We present WorldVLA, an autoregressive action world model that unifies action and image understanding and generation. Our WorldVLA intergrates Vision-Language-Action (VLA) model and world model in one single framework. The world model predicts future images by leveraging both action and image understanding, with the purpose of learning the underlying physics of the environment to improve action generation. Meanwhile, the action model generates the subsequent actions based on image observations, aiding in visual understanding and in turn helps visual generation of the world model. We demonstrate that WorldVLA outperforms standalone action and world models, highlighting the mutual enhancement between the world model and the action model. In addition, we find that the performance of the action model deteriorates when generating sequences of actions in an autoregressive manner. This phenomenon can be attributed to the model's limited generalization capability for action prediction, leading to the propagation of errors from earlier actions to subsequent ones. To address this issue, we propose an attention mask strategy that selectively masks prior actions during the generation of the current action, which shows significant performance improvement in the action chunk generation task.", 'score': 24, 'issue_id': 4517, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': 'a293600a80c39e2d', 'authors': ['Jun Cen', 'Chaohui Yu', 'Hangjie Yuan', 'Yuming Jiang', 'Siteng Huang', 'Jiayan Guo', 'Xin Li', 'Yibing Song', 'Hao Luo', 'Fan Wang', 'Deli Zhao', 'Hao Chen'], 'affiliations': ['DAMO Academy, Alibaba Group', 'Hupan Lab', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2506.21539.jpg', 'data': {'categories': ['#optimization', '#rl', '#multimodal', '#games', '#cv'], 'emoji': '🌐', 'ru': {'title': 'Единая модель мира и действий для улучшенного понимания и генерации', 'desc': 'WorldVLA - это авторегрессионная модель мира действий, объединяющая понимание и генерацию изображений и действий. Она интегрирует модель зрения-языка-действия (VLA) и модель мира в единую структуру. WorldVLA превосходит отдельные модели действий и мира, демонстрируя взаимное улучшение между ними. Для решения проблемы ухудшения производительности при генерации последовательностей действий авторы предлагают стратегию маски внимания, которая выборочно маскирует предыдущие действия.'}, 'en': {'title': 'Enhancing Action Prediction with WorldVLA: A Unified Vision-Language-Action Model', 'desc': "WorldVLA is a novel autoregressive action world model that combines vision, language, and action understanding into a single framework. It enhances action prediction and sequence generation by integrating a world model that predicts future images based on actions and visual inputs. The model demonstrates mutual enhancement, where the action model improves visual understanding, which in turn aids the world model's image generation. To tackle the issue of error propagation in action sequences, an attention mask strategy is introduced, leading to significant performance gains in generating action sequences."}, 'zh': {'title': '世界模型与动作模型的相互增强', 'desc': 'WorldVLA是一种自回归的动作世界模型，结合了视觉-语言-动作（VLA）和世界模型。它通过相互理解和生成来增强性能，改善动作预测和序列生成。该模型利用动作和图像理解来预测未来图像，从而学习环境的基本物理特性。我们提出的注意力掩码策略有效解决了自回归生成中动作模型性能下降的问题，显著提高了动作生成的效果。'}}}, {'id': 'https://huggingface.co/papers/2506.21551', 'title': 'Where to find Grokking in LLM Pretraining? Monitor\n  Memorization-to-Generalization without Test', 'url': 'https://huggingface.co/papers/2506.21551', 'abstract': 'Grokking, or continued test performance improvement after training loss convergence, is observed during pretraining of a large language model, showcasing a memorization-to-generalization process.  \t\t\t\t\tAI-generated summary \t\t\t\t Grokking, i.e., test performance keeps improving long after training loss converged, has been recently witnessed in neural network training, making the mechanism of generalization and other emerging capabilities such as reasoning mysterious. While prior studies usually train small models on a few toy or highly-specific tasks for thousands of epochs, we conduct the first study of grokking on checkpoints during one-pass pretraining of a 7B large language model (LLM), i.e., OLMoE. We compute the training loss and evaluate generalization on diverse benchmark tasks, including math reasoning, code generation, and commonsense/domain-specific knowledge retrieval tasks.   Our study, for the first time, verifies that grokking still happens in the pretraining of large-scale foundation models, though different data may enter grokking stages asynchronously. We further demystify grokking\'s "emergence of generalization" by investigating LLM internal dynamics. Specifically, we find that training samples\' pathways (i.e., expert choices across layers) evolve from random, instance-specific to more structured and shareable between samples during grokking. Also, the complexity of a sample\'s pathway reduces despite the converged loss. These indicate a memorization-to-generalization conversion, providing a mechanistic explanation of delayed generalization. In the study, we develop two novel metrics to quantify pathway distance and the complexity of a single pathway. We show their ability to predict the generalization improvement on diverse downstream tasks. They are efficient, simple to compute and solely dependent on training data. Hence, they have practical value for pretraining, enabling us to monitor the generalization performance without finetuning and test. Theoretically, we show that more structured pathways reduce model complexity and improve the generalization bound.', 'score': 21, 'issue_id': 4518, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': 'd78fbac896c81bf5', 'authors': ['Ziyue Li', 'Chenrui Fan', 'Tianyi Zhou'], 'affiliations': ['Department of Computer Science University of Maryland, College Park'], 'pdf_title_img': 'assets/pdf/title_img/2506.21551.jpg', 'data': {'categories': ['#math', '#data', '#optimization', '#reasoning', '#benchmark', '#training'], 'emoji': '🧠', 'ru': {'title': 'От запоминания к обобщению: раскрывая тайны грокинга в больших языковых моделях', 'desc': 'Исследование демонстрирует явление грокинга (grokking) при предобучении большой языковой модели (LLM) с 7 миллиардами параметров. Грокинг проявляется как продолжающееся улучшение производительности на тестовых данных после сходимости функции потерь на обучающих данных. Анализ внутренней динамики модели показывает, что во время грокинга происходит переход от запоминания к обобщению. Авторы предлагают новые метрики для количественной оценки этого процесса, которые могут предсказывать улучшение обобщающей способности модели на различных задачах.'}, 'en': {'title': 'Grokking: From Memorization to Generalization in Large Language Models', 'desc': 'This paper explores the phenomenon of grokking, where a large language model continues to improve its test performance even after the training loss has stabilized. The authors investigate this behavior during the pretraining of a 7 billion parameter model, OLMoE, and find that grokking occurs asynchronously across different data samples. They analyze the internal dynamics of the model, revealing that the pathways through which training samples are processed evolve from random to more structured forms, indicating a shift from memorization to generalization. Additionally, the study introduces new metrics to measure the complexity of these pathways, which can predict improvements in generalization across various tasks without the need for fine-tuning.'}, 'zh': {'title': '揭示大型语言模型的泛化之谜', 'desc': '本文研究了在大型语言模型预训练过程中观察到的“grokking”现象，即在训练损失收敛后，测试性能仍然持续提高。我们首次在一个7B参数的大型语言模型OLMoE的单次预训练检查点上进行研究，验证了grokking在大规模基础模型预训练中的存在。研究发现，训练样本的路径从随机、特定实例逐渐演变为更结构化和可共享的形式，尽管损失已收敛，样本路径的复杂性却在降低。这表明了从记忆到泛化的转变，为延迟泛化提供了机制解释。'}}}, {'id': 'https://huggingface.co/papers/2506.21547', 'title': 'SAM4D: Segment Anything in Camera and LiDAR Streams', 'url': 'https://huggingface.co/papers/2506.21547', 'abstract': 'SAM4D is a multi-modal and temporal foundation model for segmentation in autonomous driving using Unified Multi-modal Positional Encoding and Motion-aware Cross-modal Memory Attention, with a multi-modal automated data engine generating pseudo-labels.  \t\t\t\t\tAI-generated summary \t\t\t\t We present SAM4D, a multi-modal and temporal foundation model designed for promptable segmentation across camera and LiDAR streams. Unified Multi-modal Positional Encoding (UMPE) is introduced to align camera and LiDAR features in a shared 3D space, enabling seamless cross-modal prompting and interaction. Additionally, we propose Motion-aware Cross-modal Memory Attention (MCMA), which leverages ego-motion compensation to enhance temporal consistency and long-horizon feature retrieval, ensuring robust segmentation across dynamically changing autonomous driving scenes. To avoid annotation bottlenecks, we develop a multi-modal automated data engine that synergizes VFM-driven video masklets, spatiotemporal 4D reconstruction, and cross-modal masklet fusion. This framework generates camera-LiDAR aligned pseudo-labels at a speed orders of magnitude faster than human annotation while preserving VFM-derived semantic fidelity in point cloud representations. We conduct extensive experiments on the constructed Waymo-4DSeg, which demonstrate the powerful cross-modal segmentation ability and great potential in data annotation of proposed SAM4D.', 'score': 9, 'issue_id': 4516, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '25172262b153bc59', 'authors': ['Jianyun Xu', 'Song Wang', 'Ziqian Ni', 'Chunyong Hu', 'Sheng Yang', 'Jianke Zhu', 'Qiang Li'], 'affiliations': ['Unmanned Vehicle Dept., CaiNiao Inc., Alibaba Group', 'Zhejiang University'], 'pdf_title_img': 'assets/pdf/title_img/2506.21547.jpg', 'data': {'categories': ['#optimization', '#dataset', '#games', '#multimodal', '#cv'], 'emoji': '🚗', 'ru': {'title': 'SAM4D: Революция в сегментации для беспилотных автомобилей', 'desc': 'SAM4D - это многомодальная и темпоральная фундаментальная модель для сегментации в автономном вождении. Она использует унифицированное многомодальное позиционное кодирование (UMPE) для выравнивания признаков камеры и лидара в общем 3D-пространстве. Модель также применяет учитывающее движение кросс-модальное внимание с памятью (MCMA) для улучшения временной согласованности. SAM4D включает автоматизированный механизм генерации псевдо-разметки для обучения без ручной аннотации.'}, 'en': {'title': 'Revolutionizing Segmentation in Autonomous Driving with SAM4D', 'desc': 'SAM4D is a cutting-edge model that integrates multiple data types, specifically camera and LiDAR, to improve segmentation tasks in autonomous driving. It uses Unified Multi-modal Positional Encoding to align features from both data sources in a shared 3D space, facilitating effective interaction between them. The model also incorporates Motion-aware Cross-modal Memory Attention to maintain consistency over time and retrieve features from long sequences, which is crucial for dynamic driving environments. To streamline the data labeling process, SAM4D employs an automated engine that generates high-quality pseudo-labels quickly, significantly reducing the need for manual annotation.'}, 'zh': {'title': 'SAM4D：自动驾驶分割的多模态基础模型', 'desc': 'SAM4D是一种多模态和时间基础模型，专为自动驾驶中的分割任务设计。它使用统一的多模态位置编码（UMPE）来对齐相机和激光雷达的特征，从而实现无缝的跨模态提示和交互。此外，运动感知跨模态记忆注意力（MCMA）利用自我运动补偿来增强时间一致性和长时间特征检索，确保在动态变化的自动驾驶场景中进行稳健的分割。为了避免标注瓶颈，我们开发了一个多模态自动数据引擎，能够快速生成与相机和激光雷达对齐的伪标签，速度远超人工标注，同时保持点云表示中的语义保真度。'}}}, {'id': 'https://huggingface.co/papers/2506.16655', 'title': 'Arch-Router: Aligning LLM Routing with Human Preferences', 'url': 'https://huggingface.co/papers/2506.16655', 'abstract': 'A preference-aligned routing framework using a compact 1.5B model effectively matches queries to user-defined domains and action types, outperforming proprietary models in subjective evaluation criteria.  \t\t\t\t\tAI-generated summary \t\t\t\t With the rapid proliferation of large language models (LLMs) -- each optimized for different strengths, style, or latency/cost profile -- routing has become an essential technique to operationalize the use of different models. However, existing LLM routing approaches are limited in two key ways: they evaluate performance using benchmarks that often fail to capture human preferences driven by subjective evaluation criteria, and they typically select from a limited pool of models. In this work, we propose a preference-aligned routing framework that guides model selection by matching queries to user-defined domains (e.g., travel) or action types (e.g., image editing) -- offering a practical mechanism to encode preferences in routing decisions. Specifically, we introduce Arch-Router, a compact 1.5B model that learns to map queries to domain-action preferences for model routing decisions. Our approach also supports seamlessly adding new models for routing without requiring retraining or architectural modifications. Experiments on conversational datasets demonstrate that our approach achieves state-of-the-art (SOTA) results in matching queries with human preferences, outperforming top proprietary models. Our approach captures subjective evaluation criteria and makes routing decisions more transparent and flexible. Our model is available at: https://huggingface.co/katanemo/Arch-Router-1.5B.', 'score': 5, 'issue_id': 4519, 'pub_date': '2025-06-19', 'pub_date_card': {'ru': '19 июня', 'en': 'June 19', 'zh': '6月19日'}, 'hash': '09391602d5fce0b2', 'authors': ['Co Tran', 'Salman Paracha', 'Adil Hafeez', 'Shuguang Chen'], 'affiliations': ['Katanemo Labs, Inc.'], 'pdf_title_img': 'assets/pdf/title_img/2506.16655.jpg', 'data': {'categories': ['#training', '#alignment', '#small_models', '#multimodal'], 'emoji': '🔀', 'ru': {'title': 'Умная маршрутизация запросов к ИИ с учетом предпочтений пользователя', 'desc': 'В статье представлен фреймворк для маршрутизации запросов к языковым моделям на основе предпочтений пользователей. Авторы разработали компактную модель Arch-Router объемом 1,5 млрд параметров, которая сопоставляет запросы с предопределенными доменами и типами действий. Эксперименты показали, что подход превосходит проприетарные модели по субъективным критериям оценки. Фреймворк позволяет гибко добавлять новые модели без переобучения.'}, 'en': {'title': 'Aligning Queries with User Preferences for Optimal Model Routing', 'desc': 'This paper presents a new routing framework called Arch-Router, which uses a compact 1.5 billion parameter model to effectively match user queries with specific domains and action types. Unlike traditional models that rely on fixed benchmarks, this framework aligns with human preferences by incorporating subjective evaluation criteria into its routing decisions. Arch-Router allows for the easy addition of new models without the need for retraining, enhancing flexibility in model selection. Experiments show that this approach outperforms existing proprietary models, achieving state-of-the-art results in aligning queries with user preferences.'}, 'zh': {'title': '偏好对齐的智能路由框架', 'desc': '本文提出了一种偏好对齐的路由框架，使用一个紧凑的1.5B模型有效地将查询与用户定义的领域和动作类型匹配。该框架通过将查询与用户的偏好相结合，克服了现有大语言模型路由方法在主观评估标准上的局限性。我们引入的Arch-Router模型能够学习将查询映射到领域-动作偏好，从而优化模型选择。实验结果表明，该方法在与人类偏好的匹配上达到了最先进的水平，超越了许多专有模型。'}}}, {'id': 'https://huggingface.co/papers/2506.21552', 'title': 'Whole-Body Conditioned Egocentric Video Prediction', 'url': 'https://huggingface.co/papers/2506.21552', 'abstract': "A model trained on real-world egocentric video and body pose predicts video from human actions using an auto-regressive conditional diffusion transformer, evaluated with a hierarchical protocol of tasks.  \t\t\t\t\tAI-generated summary \t\t\t\t We train models to Predict Ego-centric Video from human Actions (PEVA), given the past video and an action represented by the relative 3D body pose. By conditioning on kinematic pose trajectories, structured by the joint hierarchy of the body, our model learns to simulate how physical human actions shape the environment from a first-person point of view. We train an auto-regressive conditional diffusion transformer on Nymeria, a large-scale dataset of real-world egocentric video and body pose capture. We further design a hierarchical evaluation protocol with increasingly challenging tasks, enabling a comprehensive analysis of the model's embodied prediction and control abilities. Our work represents an initial attempt to tackle the challenges of modeling complex real-world environments and embodied agent behaviors with video prediction from the perspective of a human.", 'score': 4, 'issue_id': 4519, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '88d888f2aa383886', 'authors': ['Yutong Bai', 'Danny Tran', 'Amir Bar', 'Yann LeCun', 'Trevor Darrell', 'Jitendra Malik'], 'affiliations': ['FAIR, Meta', 'New York University', 'UC Berkeley (BAIR)'], 'pdf_title_img': 'assets/pdf/title_img/2506.21552.jpg', 'data': {'categories': ['#diffusion', '#agents', '#games', '#dataset', '#video'], 'emoji': '🎥', 'ru': {'title': 'Предсказание эгоцентрического видео по действиям человека', 'desc': 'Статья представляет модель PEVA, обученную предсказывать эгоцентрическое видео на основе действий человека. Модель использует авторегрессивный условный диффузионный трансформер, обученный на датасете Nymeria с реальными эгоцентрическими видео и позами тела. Для оценки модели разработан иерархический протокол с усложняющимися задачами. Это первая попытка моделирования сложных реальных сред и поведения агентов с точки зрения человека через предсказание видео.'}, 'en': {'title': 'Predicting Video from Human Actions in First-Person View', 'desc': "This paper presents a model called PEVA, which predicts ego-centric video based on human actions and body poses. It utilizes an auto-regressive conditional diffusion transformer to learn how human actions influence the environment from a first-person perspective. The model is trained on a large dataset, Nymeria, which includes real-world video and body pose data. A hierarchical evaluation protocol is introduced to assess the model's performance on various tasks, highlighting its ability to understand and simulate complex interactions in real-world scenarios."}, 'zh': {'title': '从人类动作预测自我中心视频的创新模型', 'desc': '本研究提出了一种模型，旨在从人类动作预测自我中心视频。该模型利用相对3D身体姿态作为条件，结合运动学轨迹，模拟人类动作如何影响环境。我们使用了一个名为Nymeria的大规模数据集，训练了一个自回归条件扩散变换器。通过设计分层评估协议，我们能够全面分析模型在复杂环境中的预测和控制能力。'}}}, {'id': 'https://huggingface.co/papers/2506.20936', 'title': 'PhysRig: Differentiable Physics-Based Skinning and Rigging Framework for\n  Realistic Articulated Object Modeling', 'url': 'https://huggingface.co/papers/2506.20936', 'abstract': 'A physics-based skinning and rigging framework called PhysRig uses volumetric representation and continuum mechanics for more realistic and physically plausible animations.  \t\t\t\t\tAI-generated summary \t\t\t\t Skinning and rigging are fundamental components in animation, articulated object reconstruction, motion transfer, and 4D generation. Existing approaches predominantly rely on Linear Blend Skinning (LBS), due to its simplicity and differentiability. However, LBS introduces artifacts such as volume loss and unnatural deformations, and it fails to model elastic materials like soft tissues, fur, and flexible appendages (e.g., elephant trunks, ears, and fatty tissues). In this work, we propose PhysRig: a differentiable physics-based skinning and rigging framework that overcomes these limitations by embedding the rigid skeleton into a volumetric representation (e.g., a tetrahedral mesh), which is simulated as a deformable soft-body structure driven by the animated skeleton. Our method leverages continuum mechanics and discretizes the object as particles embedded in an Eulerian background grid to ensure differentiability with respect to both material properties and skeletal motion. Additionally, we introduce material prototypes, significantly reducing the learning space while maintaining high expressiveness. To evaluate our framework, we construct a comprehensive synthetic dataset using meshes from Objaverse, The Amazing Animals Zoo, and MixaMo, covering diverse object categories and motion patterns. Our method consistently outperforms traditional LBS-based approaches, generating more realistic and physically plausible results. Furthermore, we demonstrate the applicability of our framework in the pose transfer task highlighting its versatility for articulated object modeling.', 'score': 3, 'issue_id': 4530, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': 'a4cf66e609fddfae', 'authors': ['Hao Zhang', 'Haolan Xu', 'Chun Feng', 'Varun Jampani', 'Narendra Ahuja'], 'affiliations': ['Stability AI', 'University of Illinois Urbana Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2506.20936.jpg', 'data': {'categories': ['#synthetic', '#dataset', '#games', '#cv', '#3d'], 'emoji': '🦾', 'ru': {'title': 'PhysRig: физически достоверная анимация для нового поколения', 'desc': 'PhysRig - это новая система анимации, использующая объемное представление и механику сплошных сред для более реалистичного моделирования движений. В отличие от традиционного метода Linear Blend Skinning (LBS), PhysRig позволяет избежать артефактов вроде потери объема и неестественных деформаций. Система особенно эффективна для моделирования эластичных материалов, таких как мягкие ткани и гибкие придатки. PhysRig использует дифференцируемую физическую модель, что позволяет оптимизировать как свойства материалов, так и движения скелета.'}, 'en': {'title': 'PhysRig: Realistic Animation through Physics-Based Skinning', 'desc': 'The paper introduces PhysRig, a novel skinning and rigging framework that utilizes physics-based principles for more realistic animations. Unlike traditional Linear Blend Skinning (LBS), which can cause unnatural deformations, PhysRig employs a volumetric representation and continuum mechanics to simulate soft-body dynamics. This approach allows for better modeling of elastic materials and complex shapes, such as soft tissues and flexible appendages. The framework is evaluated using a synthetic dataset and shows superior performance in generating physically plausible animations compared to existing methods.'}, 'zh': {'title': 'PhysRig：更真实的动画皮肤与绑定框架', 'desc': '本文提出了一种基于物理的皮肤和绑定框架，称为PhysRig，旨在实现更真实和物理上合理的动画效果。传统的线性混合皮肤（LBS）方法虽然简单，但会导致体积损失和不自然的变形，无法有效模拟软组织和灵活的附肢。PhysRig通过将刚性骨架嵌入体积表示中，并利用连续介质力学进行模拟，克服了这些局限性。我们的实验表明，PhysRig在生成真实感和物理合理性方面优于传统的LBS方法，且在姿态转移任务中展现了良好的适用性。'}}}, {'id': 'https://huggingface.co/papers/2506.20430', 'title': 'An Agentic System for Rare Disease Diagnosis with Traceable Reasoning', 'url': 'https://huggingface.co/papers/2506.20430', 'abstract': "DeepRare, a large language model-based system, provides accurate rare disease diagnoses using heterogeneous clinical inputs and outperforms other diagnostic methods across various datasets.  \t\t\t\t\tAI-generated summary \t\t\t\t Rare diseases collectively affect over 300 million individuals worldwide, yet timely and accurate diagnosis remains a pervasive challenge. This is largely due to their clinical heterogeneity, low individual prevalence, and the limited familiarity most clinicians have with rare conditions. Here, we introduce DeepRare, the first rare disease diagnosis agentic system powered by a large language model (LLM), capable of processing heterogeneous clinical inputs. The system generates ranked diagnostic hypotheses for rare diseases, each accompanied by a transparent chain of reasoning that links intermediate analytic steps to verifiable medical evidence.   DeepRare comprises three key components: a central host with a long-term memory module; specialized agent servers responsible for domain-specific analytical tasks integrating over 40 specialized tools and web-scale, up-to-date medical knowledge sources, ensuring access to the most current clinical information. This modular and scalable design enables complex diagnostic reasoning while maintaining traceability and adaptability. We evaluate DeepRare on eight datasets. The system demonstrates exceptional diagnostic performance among 2,919 diseases, achieving 100% accuracy for 1013 diseases. In HPO-based evaluations, DeepRare significantly outperforms other 15 methods, like traditional bioinformatics diagnostic tools, LLMs, and other agentic systems, achieving an average Recall@1 score of 57.18% and surpassing the second-best method (Reasoning LLM) by a substantial margin of 23.79 percentage points. For multi-modal input scenarios, DeepRare achieves 70.60% at Recall@1 compared to Exomiser's 53.20% in 109 cases. Manual verification of reasoning chains by clinical experts achieves 95.40% agreements. Furthermore, the DeepRare system has been implemented as a user-friendly web application http://raredx.cn/doctor.", 'score': 3, 'issue_id': 4517, 'pub_date': '2025-06-25', 'pub_date_card': {'ru': '25 июня', 'en': 'June 25', 'zh': '6月25日'}, 'hash': 'f12b8efd117ae9ab', 'authors': ['Weike Zhao', 'Chaoyi Wu', 'Yanjie Fan', 'Xiaoman Zhang', 'Pengcheng Qiu', 'Yuze Sun', 'Xiao Zhou', 'Yanfeng Wang', 'Ya Zhang', 'Yongguo Yu', 'Kun Sun', 'Weidi Xie'], 'affiliations': ['Department of Biomedical Informatics, Harvard Medical School, Boston, MA, USA', 'Shanghai Artificial Intelligence Laboratory, Shanghai, China', 'Shanghai Jiao Tong University, Shanghai, China', 'Xinhua Hospital affiliated to Shanghai Jiao Tong University School of Medicine, Shanghai, China'], 'pdf_title_img': 'assets/pdf/title_img/2506.20430.jpg', 'data': {'categories': ['#agents', '#reasoning', '#benchmark', '#science', '#dataset', '#healthcare'], 'emoji': '🔬', 'ru': {'title': 'DeepRare: Революция в диагностике редких заболеваний с помощью ИИ', 'desc': 'DeepRare - это система на основе большой языковой модели для диагностики редких заболеваний, использующая гетерогенные клинические данные. Система состоит из центрального хоста с модулем долговременной памяти и специализированных агентов для аналитических задач. DeepRare превосходит другие методы диагностики на различных наборах данных, достигая 100% точности для 1013 заболеваний. Система также предоставляет прозрачную цепочку рассуждений, связывающую аналитические шаги с проверяемыми медицинскими доказательствами.'}, 'en': {'title': 'Revolutionizing Rare Disease Diagnosis with DeepRare', 'desc': 'DeepRare is a novel system that utilizes a large language model to diagnose rare diseases by analyzing diverse clinical data. It generates ranked hypotheses for potential diagnoses, providing clear reasoning linked to medical evidence. The system is modular, featuring a long-term memory and specialized agents that integrate over 40 tools and current medical knowledge. DeepRare outperforms traditional diagnostic methods, achieving high accuracy and recall rates across multiple datasets, making it a significant advancement in rare disease diagnosis.'}, 'zh': {'title': 'DeepRare：精准诊断罕见疾病的智能系统', 'desc': 'DeepRare是一个基于大型语言模型的系统，能够利用多种临床输入提供准确的罕见疾病诊断。该系统通过生成排名的诊断假设，并提供透明的推理链，确保每一步分析都与可验证的医学证据相连接。DeepRare的设计模块化且可扩展，集成了超过40种专业工具和最新的医学知识来源，确保获取最新的临床信息。经过评估，DeepRare在2919种疾病中表现出色，1013种疾病的诊断准确率达到100%。'}}}, {'id': 'https://huggingface.co/papers/2506.21272', 'title': 'FairyGen: Storied Cartoon Video from a Single Child-Drawn Character', 'url': 'https://huggingface.co/papers/2506.21272', 'abstract': "FairyGen generates story-driven cartoon videos from a single drawing by disentangling character modeling and background styling, employing MLLM for storyboards, style propagation for consistency, and MMDiT-based diffusion models for motion.  \t\t\t\t\tAI-generated summary \t\t\t\t We propose FairyGen, an automatic system for generating story-driven cartoon videos from a single child's drawing, while faithfully preserving its unique artistic style. Unlike previous storytelling methods that primarily focus on character consistency and basic motion, FairyGen explicitly disentangles character modeling from stylized background generation and incorporates cinematic shot design to support expressive and coherent storytelling. Given a single character sketch, we first employ an MLLM to generate a structured storyboard with shot-level descriptions that specify environment settings, character actions, and camera perspectives. To ensure visual consistency, we introduce a style propagation adapter that captures the character's visual style and applies it to the background, faithfully retaining the character's full visual identity while synthesizing style-consistent scenes. A shot design module further enhances visual diversity and cinematic quality through frame cropping and multi-view synthesis based on the storyboard. To animate the story, we reconstruct a 3D proxy of the character to derive physically plausible motion sequences, which are then used to fine-tune an MMDiT-based image-to-video diffusion model. We further propose a two-stage motion customization adapter: the first stage learns appearance features from temporally unordered frames, disentangling identity from motion; the second stage models temporal dynamics using a timestep-shift strategy with frozen identity weights. Once trained, FairyGen directly renders diverse and coherent video scenes aligned with the storyboard. Extensive experiments demonstrate that our system produces animations that are stylistically faithful, narratively structured natural motion, highlighting its potential for personalized and engaging story animation. The code will be available at https://github.com/GVCLab/FairyGen", 'score': 2, 'issue_id': 4525, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '912ef8f5a86d8a2c', 'authors': ['Jiayi Zheng', 'Xiaodong Cun'], 'affiliations': ['GVC Lab, Great Bay University, China'], 'pdf_title_img': 'assets/pdf/title_img/2506.21272.jpg', 'data': {'categories': ['#multimodal', '#3d', '#video', '#diffusion', '#story_generation'], 'emoji': '🎨', 'ru': {'title': 'От детского рисунка к мультфильму: FairyGen оживляет воображение', 'desc': 'FairyGen - это система для создания мультфильмов по одному детскому рисунку, сохраняющая уникальный художественный стиль. Она использует мультимодальную языковую модель для генерации раскадровки и адаптер распространения стиля для согласованности фона и персонажа. Система применяет 3D-реконструкцию персонажа для создания правдоподобных движений и использует диффузионные модели на основе MMDiT для анимации. FairyGen обеспечивает разнообразие и кинематографическое качество с помощью модуля дизайна кадров.'}, 'en': {'title': 'Transforming Drawings into Animated Stories with FairyGen', 'desc': "FairyGen is an innovative system that creates cartoon videos from a single drawing while maintaining the original artistic style. It separates character modeling from background styling, allowing for more coherent storytelling and visual consistency. The system uses a multi-level language model (MLLM) to generate detailed storyboards and employs a style propagation adapter to ensure that the character's style is preserved in the background. Additionally, it utilizes a two-stage motion customization process to create realistic animations, resulting in engaging and personalized video content."}, 'zh': {'title': '从一幅画生成故事动画的魔法', 'desc': 'FairyGen 是一个自动生成故事驱动卡通视频的系统，只需一幅儿童画即可，同时保留其独特的艺术风格。该系统通过将角色建模与背景风格生成分离，结合 MLLM 生成结构化故事板，确保视觉一致性。它还使用 MMDiT 基于扩散模型来生成物理上合理的运动序列，从而实现动画效果。实验表明，FairyGen 能够生成风格一致、叙事结构清晰的自然运动动画，展示了其在个性化故事动画中的潜力。'}}}, {'id': 'https://huggingface.co/papers/2506.21263', 'title': 'DiLoCoX: A Low-Communication Large-Scale Training Framework for\n  Decentralized Cluster', 'url': 'https://huggingface.co/papers/2506.21263', 'abstract': 'DiLoCoX, a decentralized cluster training framework, enhances the training of large-scale models over slow networks by utilizing pipeline parallelism, dual optimizer policy, and gradient compression, achieving significant speed improvements and effective scalability.  \t\t\t\t\tAI-generated summary \t\t\t\t The distributed training of foundation models, particularly large language models (LLMs), demands a high level of communication. Consequently, it is highly dependent on a centralized cluster with fast and reliable interconnects. Can we conduct training on slow networks and thereby unleash the power of decentralized clusters when dealing with models exceeding 100 billion parameters? In this paper, we propose DiLoCoX, a low-communication large-scale decentralized cluster training framework. It combines Pipeline Parallelism with Dual Optimizer Policy, One-Step-Delay Overlap of Communication and Local Training, and an Adaptive Gradient Compression Scheme. This combination significantly improves the scale of parameters and the speed of model pre-training. We justify the benefits of one-step-delay overlap of communication and local training, as well as the adaptive gradient compression scheme, through a theoretical analysis of convergence. Empirically, we demonstrate that DiLoCoX is capable of pre-training a 107B foundation model over a 1Gbps network. Compared to vanilla AllReduce, DiLoCoX can achieve a 357x speedup in distributed training while maintaining negligible degradation in model convergence. To the best of our knowledge, this is the first decentralized training framework successfully applied to models with over 100 billion parameters.', 'score': 1, 'issue_id': 4527, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '5ee2d59ef586a49c', 'authors': ['Ji Qi', 'WenPeng Zhu', 'Li Li', 'Ming Wu', 'YingJun Wu', 'Wu He', 'Xun Gao', 'Jason Zeng', 'Michael Heinrich'], 'affiliations': ['China Mobile(Suzhou) Software Technology, JiangSu', 'Zero Gravity Labs'], 'pdf_title_img': 'assets/pdf/title_img/2506.21263.jpg', 'data': {'categories': ['#architecture', '#optimization', '#training'], 'emoji': '🚀', 'ru': {'title': 'DiLoCoX: Прорыв в децентрализованном обучении крупномасштабных языковых моделей', 'desc': 'DiLoCoX - это фреймворк для децентрализованного обучения крупномасштабных моделей на медленных сетях. Он использует конвейерный параллелизм, политику двойного оптимизатора и сжатие градиентов. DiLoCoX значительно ускоряет распределенное обучение и обеспечивает эффективную масштабируемость. Фреймворк позволяет обучать модели с более чем 100 миллиардами параметров на сетях со скоростью 1 Гбит/с, достигая 357-кратного ускорения по сравнению с обычным AllReduce.'}, 'en': {'title': 'Revolutionizing Large-Scale Model Training on Slow Networks', 'desc': 'DiLoCoX is a decentralized training framework designed to improve the training of large-scale models, especially those with over 100 billion parameters, over slow networks. It employs techniques like pipeline parallelism and a dual optimizer policy to enhance communication efficiency and speed. The framework also introduces an adaptive gradient compression scheme, which helps in reducing the amount of data that needs to be communicated during training. Empirical results show that DiLoCoX can achieve a remarkable 357x speedup in distributed training compared to traditional methods, while still ensuring effective model convergence.'}, 'zh': {'title': '去中心化集群训练的速度革命', 'desc': 'DiLoCoX是一种去中心化的集群训练框架，旨在提高大规模模型在慢速网络上的训练效率。它结合了管道并行、双优化器策略和梯度压缩等技术，显著提升了训练速度和可扩展性。通过理论分析和实证验证，DiLoCoX能够在1Gbps网络上成功预训练超过107亿参数的基础模型。与传统的AllReduce方法相比，DiLoCoX在分布式训练中实现了357倍的加速，同时模型收敛性几乎没有下降。'}}}, {'id': 'https://huggingface.co/papers/2506.21103', 'title': 'Learning to Skip the Middle Layers of Transformers', 'url': 'https://huggingface.co/papers/2506.21103', 'abstract': "A novel conditional computation architecture for Transformers dynamically skips middle layers based on input and a gating mechanism, but does not outperform dense baselines in reducing computational cost or improving validation performance.  \t\t\t\t\tAI-generated summary \t\t\t\t Conditional computation is a popular strategy to make Transformers more efficient. Existing methods often target individual modules (e.g., mixture-of-experts layers) or skip layers independently of one another. However, interpretability research has demonstrated that the middle layers of Transformers exhibit greater redundancy, and that early layers aggregate information into token positions. Guided by these insights, we propose a novel architecture that dynamically skips a variable number of layers from the middle outward. In particular, a learned gating mechanism determines whether to bypass a symmetric span of central blocks based on the input, and a gated attention mechanism prevents subsequent tokens from attending to skipped token positions. Residual norms are controlled with a 'sandwich' or 'perilayernorm' scheme and gate sparsity with an adaptive regularization loss. We had aimed to reduce compute requirements for 'simpler' tokens and potentially foster an emergent multi-level representational hierarchy but, at the scales investigated, our approach does not achieve improvements in the trade-off between validation cross-entropy and estimated FLOPs compared to dense baselines with fewer layers. We release our code at https://github.com/tim-lawson/skip-middle.", 'score': 1, 'issue_id': 4524, 'pub_date': '2025-06-26', 'pub_date_card': {'ru': '26 июня', 'en': 'June 26', 'zh': '6月26日'}, 'hash': '3c7e7fa3beaf5d4d', 'authors': ['Tim Lawson', 'Laurence Aitchison'], 'affiliations': ['School of Engineering Mathematics and Technology University of Bristol Bristol, UK'], 'pdf_title_img': 'assets/pdf/title_img/2506.21103.jpg', 'data': {'categories': ['#interpretability', '#architecture', '#optimization', '#training'], 'emoji': '⏭️', 'ru': {'title': 'Динамический пропуск средних слоев: новый подход к оптимизации трансформеров', 'desc': 'Статья представляет новую архитектуру условных вычислений для трансформеров, которая динамически пропускает средние слои на основе входных данных и механизма гейтинга. Авторы предлагают использовать обученный механизм гейтинга для определения, следует ли обойти симметричный диапазон центральных блоков, основываясь на входных данных. Несмотря на инновационный подход, предложенная архитектура не превосходит плотные базовые модели в снижении вычислительных затрат или улучшении производительности при валидации. Исследование предоставляет интересные insights о структуре трансформеров, но не достигает значительных улучшений в масштабах, исследованных авторами.'}, 'en': {'title': 'Dynamic Layer Skipping in Transformers: Innovation Meets Limitation', 'desc': 'This paper introduces a new architecture for Transformers that uses conditional computation to skip certain middle layers based on the input data. A gating mechanism is employed to decide which layers to bypass, aiming to enhance efficiency without compromising performance. Despite the innovative approach, the results show that this method does not outperform traditional dense models in terms of reducing computational costs or improving validation accuracy. The findings suggest that while the architecture is theoretically sound, it may not provide practical benefits at the scales tested.'}, 'zh': {'title': '动态跳层，提升Transformer效率的探索', 'desc': '本文提出了一种新颖的条件计算架构，用于Transformer模型，能够根据输入动态跳过中间层。通过学习的门控机制，决定是否跳过一段对称的中央块，以提高计算效率。尽管该方法旨在减少计算需求并促进多层次表示的形成，但在实验中未能在验证性能和计算成本之间取得显著改善。研究结果表明，现有的密集基线在减少计算成本和提高验证性能方面仍然表现更好。'}}}, {'id': 'https://huggingface.co/papers/2506.20703', 'title': 'Generative Blocks World: Moving Things Around in Pictures', 'url': 'https://huggingface.co/papers/2506.20703', 'abstract': 'A generative method that edits 3D scenes using convex primitives and regenerates images with enhanced texture consistency and visual fidelity.  \t\t\t\t\tAI-generated summary \t\t\t\t We describe Generative Blocks World to interact with the scene of a generated image by manipulating simple geometric abstractions. Our method represents scenes as assemblies of convex 3D primitives, and the same scene can be represented by different numbers of primitives, allowing an editor to move either whole structures or small details. Once the scene geometry has been edited, the image is generated by a flow-based method which is conditioned on depth and a texture hint. Our texture hint takes into account the modified 3D primitives, exceeding texture-consistency provided by existing key-value caching techniques. These texture hints (a) allow accurate object and camera moves and (b) largely preserve the identity of objects depicted. Quantitative and qualitative experiments demonstrate that our approach outperforms prior works in visual fidelity, editability, and compositional generalization.', 'score': 1, 'issue_id': 4535, 'pub_date': '2025-06-25', 'pub_date_card': {'ru': '25 июня', 'en': 'June 25', 'zh': '6月25日'}, 'hash': '5f5979ba6e2c9a34', 'authors': ['Vaibhav Vavilala', 'Seemandhar Jain', 'Rahul Vasanth', 'D. A. Forsyth', 'Anand Bhattad'], 'affiliations': ['Toyota Technological Institute at Chicago', 'University of Illinois Urbana-Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2506.20703.jpg', 'data': {'categories': ['#3d', '#cv'], 'emoji': '🧊', 'ru': {'title': 'Генеративные блоки: новый уровень редактирования 3D-сцен', 'desc': 'Статья представляет генеративный метод редактирования 3D-сцен с использованием выпуклых примитивов. Метод позволяет манипулировать геометрическими абстракциями сцены, представляя её как набор 3D-примитивов. После редактирования геометрии изображение генерируется с помощью flow-based метода, учитывающего глубину и текстурные подсказки. Этот подход обеспечивает лучшую согласованность текстур и визуальную точность по сравнению с существующими техниками кэширования.'}, 'en': {'title': 'Edit 3D Scenes with Precision and Visual Fidelity!', 'desc': 'This paper presents a novel generative method called Generative Blocks World, which allows users to edit 3D scenes using simple geometric shapes known as convex primitives. The method enables flexible scene representation, where the same scene can be constructed with varying numbers of these primitives, facilitating both large structural changes and fine detail adjustments. After editing the scene geometry, a flow-based image generation technique is employed, which utilizes depth information and a texture hint to enhance visual quality. The results show that this approach significantly improves texture consistency and visual fidelity compared to existing methods, making it easier to manipulate and generate realistic 3D images.'}, 'zh': {'title': '通过凸体素编辑3D场景，提升图像质量与一致性', 'desc': '本文介绍了一种生成方法，通过使用凸体素编辑3D场景，并生成具有增强纹理一致性和视觉真实感的图像。我们的方法将场景表示为凸3D原语的组合，允许编辑者移动整个结构或小细节。编辑场景几何后，使用基于流的方法生成图像，该方法依赖于深度信息和纹理提示。我们的纹理提示考虑了修改后的3D原语，超越了现有关键值缓存技术提供的纹理一致性。'}}}, {'id': 'https://huggingface.co/papers/2506.18729', 'title': 'MuseControlLite: Multifunctional Music Generation with Lightweight\n  Conditioners', 'url': 'https://huggingface.co/papers/2506.18729', 'abstract': 'Rotary positional embeddings enhance time-varying control in text-to-music generation models with fewer parameters.  \t\t\t\t\tAI-generated summary \t\t\t\t We propose MuseControlLite, a lightweight mechanism designed to fine-tune text-to-music generation models for precise conditioning using various time-varying musical attributes and reference audio signals. The key finding is that positional embeddings, which have been seldom used by text-to-music generation models in the conditioner for text conditions, are critical when the condition of interest is a function of time. Using melody control as an example, our experiments show that simply adding rotary positional embeddings to the decoupled cross-attention layers increases control accuracy from 56.6% to 61.1%, while requiring 6.75 times fewer trainable parameters than state-of-the-art fine-tuning mechanisms, using the same pre-trained diffusion Transformer model of Stable Audio Open. We evaluate various forms of musical attribute control, audio inpainting, and audio outpainting, demonstrating improved controllability over MusicGen-Large and Stable Audio Open ControlNet at a significantly lower fine-tuning cost, with only 85M trainble parameters. Source code, model checkpoints, and demo examples are available at: https://musecontrollite.github.io/web/.', 'score': 1, 'issue_id': 4524, 'pub_date': '2025-06-23', 'pub_date_card': {'ru': '23 июня', 'en': 'June 23', 'zh': '6月23日'}, 'hash': 'b1d008a79f59af7d', 'authors': ['Fang-Duo Tsai', 'Shih-Lun Wu', 'Weijaw Lee', 'Sheng-Ping Yang', 'Bo-Rui Chen', 'Hao-Chung Cheng', 'Yi-Hsuan Yang'], 'affiliations': ['Massachusetts Institute of Technology, Cambridge, MA, United States', 'National Taiwan University, Taipei, Taiwan'], 'pdf_title_img': 'assets/pdf/title_img/2506.18729.jpg', 'data': {'categories': ['#optimization', '#audio', '#diffusion', '#training', '#games', '#data'], 'emoji': '🎵', 'ru': {'title': 'Легкий контроль над генерацией музыки с помощью позиционных вложений', 'desc': 'Исследователи представили MuseControlLite - легковесный механизм для точной настройки моделей генерации музыки по тексту. Ключевым открытием стало использование позиционных вложений в слоях перекрестного внимания, что значительно повысило точность контроля. Эксперименты показали, что добавление вращательных позиционных вложений увеличивает точность контроля с 56.6% до 61.1%, используя в 6.75 раз меньше обучаемых параметров. MuseControlLite продемонстрировал улучшенную управляемость по сравнению с MusicGen-Large и Stable Audio Open ControlNet при значительно меньших затратах на дообучение.'}, 'en': {'title': 'Enhancing Music Generation with Efficient Positional Control', 'desc': 'This paper introduces MuseControlLite, a streamlined approach for enhancing text-to-music generation models by incorporating rotary positional embeddings. These embeddings are crucial for managing time-varying musical attributes, allowing for more precise control over generated music. The study demonstrates that adding these embeddings to cross-attention layers improves control accuracy significantly while reducing the number of trainable parameters needed. Overall, MuseControlLite offers a cost-effective solution for fine-tuning music generation models, achieving better performance with fewer resources.'}, 'zh': {'title': '旋转位置嵌入提升文本到音乐生成的控制能力', 'desc': '本文提出了一种名为MuseControlLite的轻量级机制，旨在通过时间变化的音乐属性和参考音频信号来精细调整文本到音乐生成模型。研究发现，旋转位置嵌入在文本条件的调节器中至关重要，尤其是当条件与时间相关时。通过在解耦的交叉注意力层中添加旋转位置嵌入，控制精度从56.6%提高到61.1%，且所需的可训练参数比最先进的微调机制少6.75倍。我们还评估了多种音乐属性控制形式，展示了在较低的微调成本下，MuseControlLite在可控性方面的显著提升。'}}}, {'id': 'https://huggingface.co/papers/2506.17533', 'title': 'DuaShepherd: Integrating Stepwise Correctness and Potential Rewards for\n  Mathematical Reasoning', 'url': 'https://huggingface.co/papers/2506.17533', 'abstract': "A novel reward modeling framework DuaShepherd integrates correctness and potential signals into a unified multi-head architecture to enhance LLMs' mathematical reasoning capabilities and achieve state-of-the-art performance.  \t\t\t\t\tAI-generated summary \t\t\t\t In this paper, we propose DuaShepherd, a novel reward modeling framework that integrates two complementary reward signals, correctness and potential, to enhance the mathematical reasoning capabilities of Large Language Models (LLMs). While correctness-based signals emphasize identification of stepwise errors, potential-based signals focus on the likelihood of reaching the correct final answer. We developed an automated pipeline for constructing large-scale reward modeling dataset with both signals. A unified, multi-head architecture was explored to train the two reward models in a multi-task setup, demonstrating benefits from learning both correctness and potential in parallel. By combining these two signals into a compound probability, our model achieves consistent performance improvements across multiple benchmarks. Empirical evaluations on MATH500 and ProcessBench confirm that this combined reward significantly outperforms models trained on either reward type alone, achieving state-of-the-art performance under comparable resource constraints.", 'score': 1, 'issue_id': 4533, 'pub_date': '2025-06-21', 'pub_date_card': {'ru': '21 июня', 'en': 'June 21', 'zh': '6月21日'}, 'hash': '4beafb969a7354be', 'authors': ['Yuanhao Wu', 'Juntong Song', 'Hanning Zhang', 'Tong Zhang', 'Cheng Niu'], 'affiliations': ['NewsBreak', 'University of Illinois Urbana-Champaign'], 'pdf_title_img': 'assets/pdf/title_img/2506.17533.jpg', 'data': {'categories': ['#training', '#dataset', '#reasoning', '#optimization', '#data', '#benchmark', '#math'], 'emoji': '🧠', 'ru': {'title': 'Двойной подход к обучению ИИ математике', 'desc': 'DuaShepherd - это новая система моделирования вознаграждений для улучшения математических рассуждений больших языковых моделей (LLM). Она объединяет два типа сигналов - корректность и потенциал - в единую многоголовую архитектуру. Авторы разработали автоматизированный конвейер для создания масштабного набора данных с обоими типами сигналов. Эмпирические оценки показали, что комбинированное вознаграждение значительно превосходит модели, обученные на каждом типе сигналов по отдельности, достигая лучших результатов при сопоставимых вычислительных ресурсах.'}, 'en': {'title': "Enhancing LLMs' Math Skills with DuaShepherd", 'desc': 'The paper introduces DuaShepherd, a new framework for reward modeling that enhances the mathematical reasoning abilities of Large Language Models (LLMs). It combines two types of reward signals: correctness, which focuses on identifying errors in reasoning steps, and potential, which assesses the likelihood of arriving at the correct answer. The authors created an automated system to build a large dataset that incorporates both signals and employed a multi-head architecture to train the models simultaneously. This approach leads to improved performance on various benchmarks, demonstrating that using both signals together yields better results than using either one alone.'}, 'zh': {'title': 'DuaShepherd：提升数学推理的新框架', 'desc': '本文提出了一种新的奖励建模框架DuaShepherd，旨在增强大型语言模型（LLMs）的数学推理能力。该框架整合了正确性和潜力两种互补的奖励信号，以提高模型的表现。我们开发了一个自动化流程，用于构建包含这两种信号的大规模奖励建模数据集。通过在多任务设置中训练这两个奖励模型，我们的模型在多个基准测试中表现出显著的性能提升。'}}}, {'id': 'https://huggingface.co/papers/2506.15196', 'title': 'HeurAgenix: Leveraging LLMs for Solving Complex Combinatorial\n  Optimization Challenges', 'url': 'https://huggingface.co/papers/2506.15196', 'abstract': "HeurAgenix, a two-stage hyper-heuristic framework using large language models, evolves and selects heuristics dynamically for combinatorial optimization problems, achieving performance on par with specialized solvers.  \t\t\t\t\tAI-generated summary \t\t\t\t Heuristic algorithms play a vital role in solving combinatorial optimization (CO) problems, yet traditional designs depend heavily on manual expertise and struggle to generalize across diverse instances. We introduce HeurAgenix, a two-stage hyper-heuristic framework powered by large language models (LLMs) that first evolves heuristics and then selects among them automatically. In the heuristic evolution phase, HeurAgenix leverages an LLM to compare seed heuristic solutions with higher-quality solutions and extract reusable evolution strategies. During problem solving, it dynamically picks the most promising heuristic for each problem state, guided by the LLM's perception ability. For flexibility, this selector can be either a state-of-the-art LLM or a fine-tuned lightweight model with lower inference cost. To mitigate the scarcity of reliable supervision caused by CO complexity, we fine-tune the lightweight heuristic selector with a dual-reward mechanism that jointly exploits singals from selection preferences and state perception, enabling robust selection under noisy annotations. Extensive experiments on canonical benchmarks show that HeurAgenix not only outperforms existing LLM-based hyper-heuristics but also matches or exceeds specialized solvers. Code is available at https://github.com/microsoft/HeurAgenix.", 'score': 1, 'issue_id': 4523, 'pub_date': '2025-06-18', 'pub_date_card': {'ru': '18 июня', 'en': 'June 18', 'zh': '6月18日'}, 'hash': '464747c8cdf8780d', 'authors': ['Xianliang Yang', 'Ling Zhang', 'Haolong Qian', 'Lei Song', 'Jiang Bian'], 'affiliations': ['Microsoft Research Asia, Beijing, China', 'Tsinghua University, Beijing, China'], 'pdf_title_img': 'assets/pdf/title_img/2506.15196.jpg', 'data': {'categories': ['#benchmark', '#training', '#optimization', '#agents', '#architecture'], 'emoji': '🧠', 'ru': {'title': 'Автоматическая эволюция и выбор эвристик с помощью искусственного интеллекта', 'desc': 'HeurAgenix - это двухэтапная гипер-эвристическая система, использующая большие языковые модели (LLM) для решения задач комбинаторной оптимизации. На первом этапе система эволюционирует эвристики, а на втором выбирает наиболее подходящую для конкретной задачи. HeurAgenix использует LLM для сравнения эвристических решений и извлечения стратегий эволюции. Система применяет механизм двойного вознаграждения при обучении легковесного селектора эвристик, что позволяет осуществлять надежный выбор даже при зашумленных аннотациях.'}, 'en': {'title': 'Dynamic Heuristic Evolution and Selection with LLMs', 'desc': "HeurAgenix is a novel two-stage hyper-heuristic framework that utilizes large language models (LLMs) to enhance the solving of combinatorial optimization (CO) problems. The framework first evolves heuristics by comparing initial solutions with better ones, extracting effective strategies for improvement. In the second stage, it dynamically selects the most suitable heuristic for each problem state, leveraging the LLM's ability to perceive and adapt. This approach not only improves performance compared to traditional methods but also rivals specialized solvers, demonstrating the potential of LLMs in optimization tasks."}, 'zh': {'title': '动态演化与选择启发式算法的创新框架', 'desc': 'HeurAgenix 是一个基于大型语言模型的两阶段超启发式框架，旨在动态演化和选择启发式算法以解决组合优化问题。该框架首先通过比较种子启发式解与高质量解，提取可重用的演化策略。然后，在解决问题时，HeurAgenix 根据当前状态动态选择最有前景的启发式算法。实验结果表明，HeurAgenix 的性能与专门的求解器相当，甚至在某些情况下超过了现有的基于 LLM 的超启发式算法。'}}}];
        const articlesContainer = document.getElementById('articles-container');
        const sortDropdown = document.getElementById('sort-dropdown');
        const categoryFiltersContainer = document.getElementById('category-filters');
        const categoryFiltersLogicOptions = document.getElementById('category-options');
        const categoryToggle = document.getElementById('category-toggle');
        const clearCategoriesButton = document.getElementById('clear-categories');
        let selectedCategories = [];
        let selectedArticles = [];
        let sortBy = 'issue_id';     
        let showLimitHint = false; 
        let filterLogicIsAnd = false;

        function getUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const categoriesParam = urlParams.get('cat');
            let categories = categoriesParam ? categoriesParam.split(',') : [];
            categories = categories.map(element => `#${element}`);
            return categories
        }

        function updateUrlWithCategories() {
            let cleanedCategories = selectedCategories.map(element => element.replace(/^#/, ''));
            const newUrl = cleanedCategories.length > 0 
                ? `${window.location.pathname}?cat=${cleanedCategories.join(',')}`
                : window.location.pathname;
            console.log("cleanedCategories", cleanedCategories)
            window.history.pushState({}, '', newUrl);
        }

        function loadSettings() {
            const themeToggle = document.getElementById('theme-toggle');
            const sortDropdown = document.getElementById('sort-dropdown');

            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            let settingSortBy = localStorage.getItem('sort_by');
            filterLogicIsAnd = localStorage.getItem('filter_logic_is_and') === 'true';
            
            if (isDarkMode) {
                document.body.classList.remove('light-theme');
                document.body.classList.add('dark-theme');
                themeToggle.checked = true;
                const title = document.getElementById('doomgrad');
                title.innerHTML = "hf nightly";
                const titleSign = document.getElementById('doomgrad-icon');
                titleSign.classList.add('rotate');
            }

            if ((!settingSortBy) || (settingSortBy === 'null')) {
                settingSortBy = 'issue_id';
            }

            if (filterLogicIsAnd) {
                document.getElementById('filter-logic-and').checked = true;
            } else {
                document.getElementById('filter-logic-or').checked = true;
            }

            sortDropdown.value = settingSortBy;
            sortBy = settingSortBy;
        }

        document.getElementById('theme-toggle').addEventListener('change', toggleTheme);
        document.getElementById('filter-logic-and').addEventListener('change', () => {
            filterLogicIsAnd = true;
            localStorage.setItem('filter_logic_is_and', 'true');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });
        document.getElementById('filter-logic-or').addEventListener('change', () => {
            filterLogicIsAnd = false;
            localStorage.setItem('filter_logic_is_and', 'false');
            filterAndRenderArticles();
            updateSelectedArticlesTitle();
        });

        function getUniqueCategories(articles) {
            const categories = new Set();
            articles.forEach(article => {
                if (article.data && article.data.categories) {
                    article.data.categories.forEach(cat => categories.add(cat));
                }
            });
            let res = Array.from(categories);
            res.sort();
            return res;
        }

        function createCategoryButtons() {
            //const categories = getUniqueCategories(articlesData);
            const categories = ['#3d (4)', '#agents (5)', '#agi (1)', '#alignment (1)', '#architecture (3)', '#audio (1)', '#benchmark (5)', '#cv (5)', '#data (3)', '#dataset (7)', '#diffusion (3)', '#ethics', '#games (7)', '#graphs', '#hallucinations', '#healthcare (1)', '#inference', '#interpretability (2)', '#leakage', '#long_context', '#low_resource', '#machine_translation', '#math (2)', '#multilingual', '#multimodal (6)', '#open_source', '#optimization (11)', '#plp', '#rag (1)', '#reasoning (5)', '#rl (2)', '#rlhf', '#robotics', '#science (1)', '#security', '#small_models (1)', '#story_generation (1)', '#survey', '#synthetic (2)', '#training (7)', '#transfer_learning', '#video (2)'];

            categories.forEach(category => {
                let catNameSplitted = category.split(/(\s+)/);
                let catName = catNameSplitted[0];
                const button = document.createElement('span');
                button.textContent = catName;
                button.className = 'category-button';
                if (catNameSplitted.length < 2) {
                    button.classList.add('inactive');
                };
                button.onclick = () => toggleCategory(catName, button);
                categoryFiltersContainer.appendChild(button);
            });
        }

        function toggleCategory(category, button) {
            const index = selectedCategories.indexOf(category);
            if (index === -1) {
                selectedCategories.push(category);
                button.classList.add('active');
            } else {
                selectedCategories.splice(index, 1);
                button.classList.remove('active');
            }         
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
            setFilterOptionsVisibility();
        }

        function saveCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify(selectedCategories));
        }

        function updateSelectedArticlesTitle() {
            if ((selectedArticles.length === articlesData.length) & (selectedCategories.length === 0)) {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]}`;
            } else {
                categoryToggle.textContent = `🏷️ ${filterLabel[currentLang]} (${formatArticlesTitle(selectedArticles.length, currentLang)})`;
            }
        }

        function cleanCategorySelection() {
            localStorage.setItem('selectedCategories', JSON.stringify('[]'));
        }

        function loadCategorySelection() {
            const urlCategories = getUrlParameters();
            if (urlCategories.length > 0) {
                selectedCategories = urlCategories;
                saveCategorySelection();
            } else {
                const savedCategories = localStorage.getItem('selectedCategories');
                if (savedCategories && savedCategories !== '"[]"') {
                    selectedCategories = JSON.parse(savedCategories);                    
                }
            }
            updateCategoryButtonStates();
        }

        function updateCategoryButtonStates() {
            const buttons = categoryFiltersContainer.getElementsByClassName('category-button');
            Array.from(buttons).forEach(button => {
                if (selectedCategories.includes(button.textContent)) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
        }

        function filterAndRenderArticles() {
            console.log(selectedCategories);
            let filteredArticles; 

            if (filterLogicIsAnd) {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        selectedCategories.every(cat => article.data.categories.includes(cat))
                );
            } else {
                filteredArticles = selectedCategories.length === 0
                    ? articlesData
                    : articlesData.filter(article => 
                        article.data && article.data.categories && 
                        article.data.categories.some(cat => selectedCategories.includes(cat))
                    );            
            }

            console.log('filteredArticles', filteredArticles)

            selectedArticles = filteredArticles;
            sortArticles(selectedArticles);
        }

        function clearAllCategories() {
            selectedCategories = [];
            updateCategoryButtonStates();
            filterAndRenderArticles();
            saveCategorySelection();
            updateSelectedArticlesTitle();
            updateUrlWithCategories();
        }

        function renderArticles(articles) {
            if (articles.length > 50) {
                articles = articles.slice(0, 50);
                showLimitHint = true;
            } else {
                showLimitHint = false;
            }
            console.log(articles);
            articlesContainer.innerHTML = '';
            articles.forEach((item, index) => {
                if ("error" in item) {
                    console.log(`Omitting JSON. ${item["raw_data"]}`);
                    return;
                }
                
                let explanation = item["data"][currentLang]["desc"];
                let title = item["data"][currentLang]["title"];

                const cats = item["data"]["categories"].slice(0, 5).join(" ");
                
                let affiliations = ""
                if ('affiliations' in item) {
                    affiliations = item["affiliations"].slice(0, 10).join(", ");
                }

                let pdfImg = "https://hfday.ru/img/title_stub.png"
                if ('pdf_title_img' in item) {
                    pdfImg = 'https://hfday.ru/' + item['pdf_title_img']
                    
                }                

                const articleHTML = `
                    <article class='x${item["hash"]}'>
                        <div class="article-content" onclick="toggleAbstract(${index})">
                            <div class="background-digit">${index + 1}</div>
                            <div class="article-title-cont">
                                <div style="display:table-cell; vertical-align: middle;">
                                    <div class="article-title"><h2>${item['data']['emoji']} ${title}</h2></div>
                                </div>
                            </div>
                            <p class="meta">
                            🔺 ${item['score']}. ${item['title']}</p>
                            <p class="pub-date">${publishedLabel[currentLang]}${item['pub_date_card'][currentLang]}</p>
                            
                            <div class="article-pdf-title-img-cont"><img class="article-pdf-title-img" src="${pdfImg}"/></div>
                            
                            <div id="abstract-${index}" class="abstract">
                                <p>${explanation}</p>
                                <div id="toggle-${index}" class="abstract-toggle">...</div>
                            </div>

                            

                            <div class="links">
                                <a href="${item['url']}" target="_blank">${paperLabel[currentLang]}</a>
                            </div>

                            <div class="affiliations">${affiliations}</div>

                            <div class="tags">${cats}</div>
                        </div>
                    </article>
                `;
                articlesContainer.innerHTML += articleHTML;
            });
        }
        
        function sortArticles() {
            let sortedArticles = [...selectedArticles];
            if (sortBy === 'issue_id') {
                sortedArticles.sort((a, b) => b.issue_id - a.issue_id);
            } else if (sortBy === 'pub_date') {
                sortedArticles.sort((a, b) => b.pub_date.localeCompare(a.pub_date));
            } else {
                sortedArticles.sort((a, b) => b.score - a.score);
            }
            renderArticles(sortedArticles);
            localStorage.setItem('sort_by', sortBy);
        }
        
        sortDropdown.addEventListener('change', (event) => {
            sortBy = event.target.value;
            sortArticles(event.target.value);
        });

        categoryToggle.addEventListener('click', () => {
            categoryFiltersContainer.classList.toggle('expanded');
            setFilterOptionsVisibility();
        });

        clearCategoriesButton.addEventListener('click', () => {
            clearAllCategories();
            setFilterOptionsVisibility();
        });

        function setFilterOptionsVisibility() {
            if (selectedCategories.length > 0) {
                categoryFiltersLogicOptions.style.display = 'inline-block';
            } else {
                categoryFiltersLogicOptions.style.display = 'none';
            }
        } 
        
        function updateTimeDiffs() {
            const timeDiff = document.getElementById('timeDiff');
            timeDiff.innerHTML = '🔄 ' + getTimeDiff('2025-06-27 21:10',lang=currentLang);
        }
        function updateSortingOptions() {
            const sortingLabels = {
                ru: {
                    default: "рейтингу",
                    pub_date: "дате публикации",
                    issue_id: "добавлению на HF"
                },
                en: {
                    default: "rating",
                    pub_date: "publication date",
                    issue_id: "HF addition date"
                },
                zh: {
                    default: "评分",
                    pub_date: "发布日期",
                    issue_id: "HF上传日期"
                }
            };

            const dropdown = document.getElementById('sort-dropdown');
            const options = dropdown.options;

            for (let i = 0; i < options.length; i++) {
                const optionValue = options[i].value;
                console.log(sortingLabels)
                options[i].text = sortingLabels[currentLang][optionValue];
            }
        }
        function updateLocalization() {
            const titleDate = document.getElementById('title-date');
            const prevDate = document.getElementById('prev-date');
            const nextDate = document.getElementById('next-date');
            const topMonth = document.getElementById('top-month-label');
            const topDay = document.getElementById('top-day-label');
            const papersCount = document.getElementById('title-articles-count');
            const sortLabelText = document.getElementById('sort-label-text');
            titleDate.innerHTML = feedDate[currentLang];
            prevDate.innerHTML = feedDatePrev[currentLang];
            nextDate.innerHTML = feedDateNext[currentLang];
            papersCount.innerHTML = formatArticlesTitle(articlesData.length, currentLang);
            sortLabelText.innerHTML = sortLabel[currentLang];
            if (topMonth) {
                topMonth.innerHTML = topMonthLabel[currentLang];
            }  
            if (topDay) {
                topDay.innerHTML = topDayLabel[currentLang];
            }             
            updateSelectedArticlesTitle();
            updateSortingOptions();
        } 
        function hideNextLink(format) {
            if (format === 'monthly') {
                if (isCurrentMonth('2025-06-27 21:10')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            } else {            
                if (isToday('2025-06-27 21:10')) {
                    const element = document.getElementById('nav-next');
                    if (element) {    
                        element.style.display = 'none';
                    }
                }
            }
        }

        loadSettings();
        createCategoryButtons();
        loadCategorySelection();
        filterAndRenderArticles();
        updateSelectedArticlesTitle();
        updateTimeDiffs();
        hideNextLink('daily'); 
        initializeLanguageFlags();
        updateLocalization();
        setFilterOptionsVisibility();
    </script>
</body>
</html>
    